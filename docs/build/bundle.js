
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35730/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
	'use strict';

	// generated during release, do not modify

	const PUBLIC_VERSION = '5';

	if (typeof window !== 'undefined')
		// @ts-ignore
		(window.__svelte ||= { v: new Set() }).v.add(PUBLIC_VERSION);

	const EACH_ITEM_REACTIVE = 1;
	const EACH_INDEX_REACTIVE = 1 << 1;
	/** See EachBlock interface metadata.is_controlled for an explanation what this is */
	const EACH_IS_CONTROLLED = 1 << 2;
	const EACH_IS_ANIMATED = 1 << 3;
	const EACH_ITEM_IMMUTABLE = 1 << 4;

	const PROPS_IS_IMMUTABLE = 1;
	const PROPS_IS_RUNES = 1 << 1;
	const PROPS_IS_UPDATED = 1 << 2;
	const PROPS_IS_BINDABLE = 1 << 3;
	const PROPS_IS_LAZY_INITIAL = 1 << 4;

	const TRANSITION_IN = 1;
	const TRANSITION_OUT = 1 << 1;
	const TRANSITION_GLOBAL = 1 << 2;

	const TEMPLATE_FRAGMENT = 1;
	const TEMPLATE_USE_IMPORT_NODE = 1 << 1;

	const UNINITIALIZED = Symbol();

	// Dev-time component properties
	const FILENAME = Symbol('filename');

	const DEV = false;

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * %handler% should be a function. Did you mean to %suggestion%?
	 * @param {string} handler
	 * @param {string} suggestion
	 */
	function event_handler_invalid(handler, suggestion) {
		{
			// TODO print a link to the documentation
			console.warn("event_handler_invalid");
		}
	}

	/**
	 * Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results
	 * @param {string} operator
	 */
	function state_proxy_equality_mismatch(operator) {
		{
			// TODO print a link to the documentation
			console.warn("state_proxy_equality_mismatch");
		}
	}

	// Store the references to globals in case someone tries to monkey patch these, causing the below
	// to de-opt (this occurs often when using popular extensions).
	var is_array = Array.isArray;
	var array_from = Array.from;
	var define_property = Object.defineProperty;
	var get_descriptor = Object.getOwnPropertyDescriptor;
	var get_descriptors = Object.getOwnPropertyDescriptors;
	var object_prototype = Object.prototype;
	var array_prototype = Array.prototype;
	var get_prototype_of = Object.getPrototypeOf;

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
		return typeof thing === 'function';
	}

	const noop = () => {};

	/** @param {Function} fn */
	function run(fn) {
		return fn();
	}

	/** @param {Array<() => void>} arr */
	function run_all(arr) {
		for (var i = 0; i < arr.length; i++) {
			arr[i]();
		}
	}

	const DERIVED = 1 << 1;
	const EFFECT = 1 << 2;
	const RENDER_EFFECT = 1 << 3;
	const BLOCK_EFFECT = 1 << 4;
	const BRANCH_EFFECT = 1 << 5;
	const ROOT_EFFECT = 1 << 6;
	const UNOWNED = 1 << 7;
	const DISCONNECTED = 1 << 8;
	const CLEAN = 1 << 9;
	const DIRTY = 1 << 10;
	const MAYBE_DIRTY = 1 << 11;
	const INERT = 1 << 12;
	const DESTROYED = 1 << 13;
	const EFFECT_RAN = 1 << 14;
	/** 'Transparent' effects do not create a transition boundary */
	const EFFECT_TRANSPARENT = 1 << 15;
	/** Svelte 4 legacy mode props need to be handled with deriveds and be recognized elsewhere, hence the dedicated flag */
	const LEGACY_DERIVED_PROP = 1 << 16;
	const HEAD_EFFECT = 1 << 18;
	const EFFECT_HAS_DERIVED = 1 << 19;

	const STATE_SYMBOL = Symbol('$state');
	const LOADING_ATTR_SYMBOL = Symbol('');

	/** @import { Equals } from '#client' */
	/** @type {Equals} */
	function equals(value) {
		return value === this.v;
	}

	/**
	 * @param {unknown} a
	 * @param {unknown} b
	 * @returns {boolean}
	 */
	function safe_not_equal(a, b) {
		return a != a
			? b == b
			: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';
	}

	/** @type {Equals} */
	function safe_equals(value) {
		return !safe_not_equal(value, this.v);
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * Component %component% has an export named `%key%` that a consumer component is trying to access using `bind:%key%`, which is disallowed. Instead, use `bind:this` (e.g. `<%name% bind:this={component} />`) and then access the property on the bound component instance (e.g. `component.%key%`)
	 * @param {string} component
	 * @param {string} key
	 * @param {string} name
	 * @returns {never}
	 */
	function bind_invalid_export(component, key, name) {
		{
			// TODO print a link to the documentation
			throw new Error("bind_invalid_export");
		}
	}

	/**
	 * A component is attempting to bind to a non-bindable property `%key%` belonging to %component% (i.e. `<%name% bind:%key%={...}>`). To mark a property as bindable: `let { %key% = $bindable() } = $props()`
	 * @param {string} key
	 * @param {string} component
	 * @param {string} name
	 * @returns {never}
	 */
	function bind_not_bindable(key, component, name) {
		{
			// TODO print a link to the documentation
			throw new Error("bind_not_bindable");
		}
	}

	/**
	 * %parent% called `%method%` on an instance of %component%, which is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information
	 * @param {string} parent
	 * @param {string} method
	 * @param {string} component
	 * @returns {never}
	 */
	function component_api_changed(parent, method, component) {
		{
			// TODO print a link to the documentation
			throw new Error("component_api_changed");
		}
	}

	/**
	 * Attempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `compatibility.componentApi` compiler option to `4` to keep it working. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information
	 * @param {string} component
	 * @param {string} name
	 * @returns {never}
	 */
	function component_api_invalid_new(component, name) {
		{
			// TODO print a link to the documentation
			throw new Error("component_api_invalid_new");
		}
	}

	/**
	 * `%rune%` cannot be used inside an effect cleanup function
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_in_teardown(rune) {
		{
			// TODO print a link to the documentation
			throw new Error("effect_in_teardown");
		}
	}

	/**
	 * Effect cannot be created inside a `$derived` value that was not itself created inside an effect
	 * @returns {never}
	 */
	function effect_in_unowned_derived() {
		{
			// TODO print a link to the documentation
			throw new Error("effect_in_unowned_derived");
		}
	}

	/**
	 * `%rune%` can only be used inside an effect (e.g. during component initialisation)
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_orphan(rune) {
		{
			// TODO print a link to the documentation
			throw new Error("effect_orphan");
		}
	}

	/**
	 * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops
	 * @returns {never}
	 */
	function effect_update_depth_exceeded() {
		{
			// TODO print a link to the documentation
			throw new Error("effect_update_depth_exceeded");
		}
	}

	/**
	 * `%name%(...)` cannot be used in runes mode
	 * @param {string} name
	 * @returns {never}
	 */
	function lifecycle_legacy_only(name) {
		{
			// TODO print a link to the documentation
			throw new Error("lifecycle_legacy_only");
		}
	}

	/**
	 * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value
	 * @param {string} key
	 * @returns {never}
	 */
	function props_invalid_value(key) {
		{
			// TODO print a link to the documentation
			throw new Error("props_invalid_value");
		}
	}

	/**
	 * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.
	 * @returns {never}
	 */
	function state_descriptors_fixed() {
		{
			// TODO print a link to the documentation
			throw new Error("state_descriptors_fixed");
		}
	}

	/**
	 * Cannot set prototype of `$state` object
	 * @returns {never}
	 */
	function state_prototype_fixed() {
		{
			// TODO print a link to the documentation
			throw new Error("state_prototype_fixed");
		}
	}

	/**
	 * Reading state that was created inside the same derived is forbidden. Consider using `untrack` to read locally created state
	 * @returns {never}
	 */
	function state_unsafe_local_read() {
		{
			// TODO print a link to the documentation
			throw new Error("state_unsafe_local_read");
		}
	}

	/**
	 * Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without `$state`
	 * @returns {never}
	 */
	function state_unsafe_mutation() {
		{
			// TODO print a link to the documentation
			throw new Error("state_unsafe_mutation");
		}
	}

	/** @import { Derived, Effect, Reaction, Source, Value } from '#client' */

	/**
	 * @template V
	 * @param {V} v
	 * @returns {Source<V>}
	 */
	function source(v) {
		return {
			f: 0, // TODO ideally we could skip this altogether, but it causes type errors
			v,
			reactions: null,
			equals,
			version: 0
		};
	}

	/**
	 * @template V
	 * @param {V} v
	 */
	function state(v) {
		return push_derived_source(source(v));
	}

	/**
	 * @template V
	 * @param {V} initial_value
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function mutable_source(initial_value, immutable = false) {
		const s = source(initial_value);
		if (!immutable) {
			s.equals = safe_equals;
		}

		// bind the signal to the component context, in case we need to
		// track updates to trigger beforeUpdate/afterUpdate callbacks
		if (component_context !== null && component_context.l !== null) {
			(component_context.l.s ??= []).push(s);
		}

		return s;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	function mutable_state(v, immutable = false) {
		return push_derived_source(mutable_source(v, immutable));
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function push_derived_source(source) {
		if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
			if (derived_sources === null) {
				set_derived_sources([source]);
			} else {
				derived_sources.push(source);
			}
		}

		return source;
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function set(source, value) {
		if (
			active_reaction !== null &&
			is_runes() &&
			(active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 &&
			// If the source was created locally within the current derived, then
			// we allow the mutation.
			(derived_sources === null || !derived_sources.includes(source))
		) {
			state_unsafe_mutation();
		}

		return internal_set(source, value);
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function internal_set(source, value) {
		if (!source.equals(value)) {
			source.v = value;
			source.version = increment_version();

			mark_reactions(source, DIRTY);

			// If the current signal is running for the first time, it won't have any
			// reactions as we only allocate and assign the reactions after the signal
			// has fully executed. So in the case of ensuring it registers the reaction
			// properly for itself, we need to ensure the current effect actually gets
			// scheduled. i.e: `$effect(() => x++)`
			if (
				is_runes() &&
				active_effect !== null &&
				(active_effect.f & CLEAN) !== 0 &&
				(active_effect.f & BRANCH_EFFECT) === 0
			) {
				if (new_deps !== null && new_deps.includes(source)) {
					set_signal_status(active_effect, DIRTY);
					schedule_effect(active_effect);
				} else {
					if (untracked_writes === null) {
						set_untracked_writes([source]);
					} else {
						untracked_writes.push(source);
					}
				}
			}
		}

		return value;
	}

	/**
	 * @param {Value} signal
	 * @param {number} status should be DIRTY or MAYBE_DIRTY
	 * @returns {void}
	 */
	function mark_reactions(signal, status) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		var runes = is_runes();
		var length = reactions.length;

		for (var i = 0; i < length; i++) {
			var reaction = reactions[i];
			var flags = reaction.f;

			// Skip any effects that are already dirty
			if ((flags & DIRTY) !== 0) continue;

			// In legacy mode, skip the current effect to prevent infinite loops
			if (!runes && reaction === active_effect) continue;

			set_signal_status(reaction, status);

			// If the signal a) was previously clean or b) is an unowned derived, then mark it
			if ((flags & (CLEAN | UNOWNED)) !== 0) {
				if ((flags & DERIVED) !== 0) {
					mark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);
				} else {
					schedule_effect(/** @type {Effect} */ (reaction));
				}
			}
		}
	}

	/** @import { Derived, Effect } from '#client' */

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived(fn) {
		var flags = DERIVED | DIRTY;

		if (active_effect === null) {
			flags |= UNOWNED;
		} else {
			// Since deriveds are evaluated lazily, any effects created inside them are
			// created too late to ensure that the parent effect is added to the tree
			active_effect.f |= EFFECT_HAS_DERIVED;
		}

		/** @type {Derived<V>} */
		const signal = {
			children: null,
			ctx: component_context,
			deps: null,
			equals,
			f: flags,
			fn,
			reactions: null,
			v: /** @type {V} */ (null),
			version: 0,
			parent: active_effect
		};

		if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
			var derived = /** @type {Derived} */ (active_reaction);
			(derived.children ??= []).push(signal);
		}

		return signal;
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived_safe_equal(fn) {
		const signal = derived(fn);
		signal.equals = safe_equals;
		return signal;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function destroy_derived_children(derived) {
		var children = derived.children;

		if (children !== null) {
			derived.children = null;

			for (var i = 0; i < children.length; i += 1) {
				var child = children[i];
				if ((child.f & DERIVED) !== 0) {
					destroy_derived(/** @type {Derived} */ (child));
				} else {
					destroy_effect(/** @type {Effect} */ (child));
				}
			}
		}
	}

	/**
	 * @template T
	 * @param {Derived} derived
	 * @returns {T}
	 */
	function execute_derived(derived) {
		var value;
		var prev_active_effect = active_effect;

		set_active_effect(derived.parent);

		{
			try {
				destroy_derived_children(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
			}
		}

		return value;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function update_derived(derived) {
		var value = execute_derived(derived);
		var status =
			(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;

		set_signal_status(derived, status);

		if (!derived.equals(value)) {
			derived.v = value;
			derived.version = increment_version();
		}
	}

	/**
	 * @param {Derived} signal
	 * @returns {void}
	 */
	function destroy_derived(signal) {
		destroy_derived_children(signal);
		remove_reactions(signal, 0);
		set_signal_status(signal, DESTROYED);

		// TODO we need to ensure we remove the derived from any parent derives
		signal.v = signal.children = signal.deps = signal.ctx = signal.reactions = null;
	}

	/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, Reaction, TemplateNode, TransitionManager } from '#client' */

	/**
	 * @param {'$effect' | '$effect.pre' | '$inspect'} rune
	 */
	function validate_effect(rune) {
		if (active_effect === null && active_reaction === null) {
			effect_orphan();
		}

		if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0) {
			effect_in_unowned_derived();
		}

		if (is_destroying_effect) {
			effect_in_teardown();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {Effect} parent_effect
	 */
	function push_effect(effect, parent_effect) {
		var parent_last = parent_effect.last;
		if (parent_last === null) {
			parent_effect.last = parent_effect.first = effect;
		} else {
			parent_last.next = effect;
			effect.prev = parent_last;
			parent_effect.last = effect;
		}
	}

	/**
	 * @param {number} type
	 * @param {null | (() => void | (() => void))} fn
	 * @param {boolean} sync
	 * @param {boolean} push
	 * @returns {Effect}
	 */
	function create_effect(type, fn, sync, push = true) {
		var is_root = (type & ROOT_EFFECT) !== 0;
		var parent_effect = active_effect;

		/** @type {Effect} */
		var effect = {
			ctx: component_context,
			deps: null,
			deriveds: null,
			nodes_start: null,
			nodes_end: null,
			f: type | DIRTY,
			first: null,
			fn,
			last: null,
			next: null,
			parent: is_root ? null : parent_effect,
			prev: null,
			teardown: null,
			transitions: null,
			version: 0
		};

		if (sync) {
			var previously_flushing_effect = is_flushing_effect;

			try {
				set_is_flushing_effect(true);
				update_effect(effect);
				effect.f |= EFFECT_RAN;
			} catch (e) {
				destroy_effect(effect);
				throw e;
			} finally {
				set_is_flushing_effect(previously_flushing_effect);
			}
		} else if (fn !== null) {
			schedule_effect(effect);
		}

		// if an effect has no dependencies, no DOM and no teardown function,
		// don't bother adding it to the effect tree
		var inert =
			sync &&
			effect.deps === null &&
			effect.first === null &&
			effect.nodes_start === null &&
			effect.teardown === null &&
			(effect.f & EFFECT_HAS_DERIVED) === 0;

		if (!inert && !is_root && push) {
			if (parent_effect !== null) {
				push_effect(effect, parent_effect);
			}

			// if we're in a derived, add the effect there too
			if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
				var derived = /** @type {Derived} */ (active_reaction);
				(derived.children ??= []).push(effect);
			}
		}

		return effect;
	}

	/**
	 * @param {() => void} fn
	 */
	function teardown(fn) {
		const effect = create_effect(RENDER_EFFECT, null, false);
		set_signal_status(effect, CLEAN);
		effect.teardown = fn;
		return effect;
	}

	/**
	 * Internal representation of `$effect(...)`
	 * @param {() => void | (() => void)} fn
	 */
	function user_effect(fn) {
		validate_effect();

		// Non-nested `$effect(...)` in a component should be deferred
		// until the component is mounted
		var defer =
			active_effect !== null &&
			(active_effect.f & BRANCH_EFFECT) !== 0 &&
			component_context !== null &&
			!component_context.m;

		if (defer) {
			var context = /** @type {ComponentContext} */ (component_context);
			(context.e ??= []).push({
				fn,
				effect: active_effect,
				reaction: active_reaction
			});
		} else {
			var signal = effect$3(fn);
			return signal;
		}
	}

	/**
	 * Internal representation of `$effect.pre(...)`
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function user_pre_effect(fn) {
		validate_effect();
		return render_effect(fn);
	}

	/**
	 * Internal representation of `$effect.root(...)`
	 * @param {() => void | (() => void)} fn
	 * @returns {() => void}
	 */
	function effect_root(fn) {
		const effect = create_effect(ROOT_EFFECT, fn, true);
		return () => {
			destroy_effect(effect);
		};
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function effect$3(fn) {
		return create_effect(EFFECT, fn, false);
	}

	/**
	 * Internal representation of `$: ..`
	 * @param {() => any} deps
	 * @param {() => void | (() => void)} fn
	 */
	function legacy_pre_effect(deps, fn) {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		/** @type {{ effect: null | Effect, ran: boolean }} */
		var token = { effect: null, ran: false };
		context.l.r1.push(token);

		token.effect = render_effect(() => {
			deps();

			// If this legacy pre effect has already run before the end of the reset, then
			// bail out to emulate the same behavior.
			if (token.ran) return;

			token.ran = true;
			set(context.l.r2, true);
			untrack(fn);
		});
	}

	function legacy_pre_effect_reset() {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		render_effect(() => {
			if (!get(context.l.r2)) return;

			// Run dirty `$:` statements
			for (var token of context.l.r1) {
				var effect = token.effect;

				// If the effect is CLEAN, then make it MAYBE_DIRTY. This ensures we traverse through
				// the effects dependencies and correctly ensure each dependency is up-to-date.
				if ((effect.f & CLEAN) !== 0) {
					set_signal_status(effect, MAYBE_DIRTY);
				}

				if (check_dirtiness(effect)) {
					update_effect(effect);
				}

				token.ran = false;
			}

			context.l.r2.v = false; // set directly to avoid rerunning this effect
		});
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function render_effect(fn) {
		return create_effect(RENDER_EFFECT, fn, true);
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function template_effect(fn) {
		return block(fn);
	}

	/**
	 * @param {(() => void)} fn
	 * @param {number} flags
	 */
	function block(fn, flags = 0) {
		return create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);
	}

	/**
	 * @param {(() => void)} fn
	 * @param {boolean} [push]
	 */
	function branch(fn, push = true) {
		return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push);
	}

	/**
	 * @param {Effect} effect
	 */
	function execute_effect_teardown(effect) {
		var teardown = effect.teardown;
		if (teardown !== null) {
			const previously_destroying_effect = is_destroying_effect;
			const previous_reaction = active_reaction;
			set_is_destroying_effect(true);
			set_active_reaction(null);
			try {
				teardown.call(null);
			} finally {
				set_is_destroying_effect(previously_destroying_effect);
				set_active_reaction(previous_reaction);
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function destroy_effect_deriveds(signal) {
		var deriveds = signal.deriveds;

		if (deriveds !== null) {
			signal.deriveds = null;

			for (var i = 0; i < deriveds.length; i += 1) {
				destroy_derived(deriveds[i]);
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @param {boolean} remove_dom
	 * @returns {void}
	 */
	function destroy_effect_children(signal, remove_dom = false) {
		var effect = signal.first;
		signal.first = signal.last = null;

		while (effect !== null) {
			var next = effect.next;
			destroy_effect(effect, remove_dom);
			effect = next;
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function destroy_block_effect_children(signal) {
		var effect = signal.first;

		while (effect !== null) {
			var next = effect.next;
			if ((effect.f & BRANCH_EFFECT) === 0) {
				destroy_effect(effect);
			}
			effect = next;
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} [remove_dom]
	 * @returns {void}
	 */
	function destroy_effect(effect, remove_dom = true) {
		var removed = false;

		if ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes_start !== null) {
			/** @type {TemplateNode | null} */
			var node = effect.nodes_start;
			var end = effect.nodes_end;

			while (node !== null) {
				/** @type {TemplateNode | null} */
				var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));

				node.remove();
				node = next;
			}

			removed = true;
		}

		destroy_effect_children(effect, remove_dom && !removed);
		destroy_effect_deriveds(effect);
		remove_reactions(effect, 0);
		set_signal_status(effect, DESTROYED);

		var transitions = effect.transitions;

		if (transitions !== null) {
			for (const transition of transitions) {
				transition.stop();
			}
		}

		execute_effect_teardown(effect);

		var parent = effect.parent;

		// If the parent doesn't have any children, then skip this work altogether
		if (parent !== null && parent.first !== null) {
			unlink_effect(effect);
		}

		// `first` and `child` are nulled out in destroy_effect_children
		effect.next =
			effect.prev =
			effect.teardown =
			effect.ctx =
			effect.deps =
			effect.parent =
			effect.fn =
			effect.nodes_start =
			effect.nodes_end =
				null;
	}

	/**
	 * Detach an effect from the effect tree, freeing up memory and
	 * reducing the amount of work that happens on subsequent traversals
	 * @param {Effect} effect
	 */
	function unlink_effect(effect) {
		var parent = effect.parent;
		var prev = effect.prev;
		var next = effect.next;

		if (prev !== null) prev.next = next;
		if (next !== null) next.prev = prev;

		if (parent !== null) {
			if (parent.first === effect) parent.first = next;
			if (parent.last === effect) parent.last = prev;
		}
	}

	/**
	 * When a block effect is removed, we don't immediately destroy it or yank it
	 * out of the DOM, because it might have transitions. Instead, we 'pause' it.
	 * It stays around (in memory, and in the DOM) until outro transitions have
	 * completed, and if the state change is reversed then we _resume_ it.
	 * A paused effect does not update, and the DOM subtree becomes inert.
	 * @param {Effect} effect
	 * @param {() => void} [callback]
	 */
	function pause_effect(effect, callback) {
		/** @type {TransitionManager[]} */
		var transitions = [];

		pause_children(effect, transitions, true);

		run_out_transitions(transitions, () => {
			destroy_effect(effect);
			if (callback) callback();
		});
	}

	/**
	 * @param {TransitionManager[]} transitions
	 * @param {() => void} fn
	 */
	function run_out_transitions(transitions, fn) {
		var remaining = transitions.length;
		if (remaining > 0) {
			var check = () => --remaining || fn();
			for (var transition of transitions) {
				transition.out(check);
			}
		} else {
			fn();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {TransitionManager[]} transitions
	 * @param {boolean} local
	 */
	function pause_children(effect, transitions, local) {
		if ((effect.f & INERT) !== 0) return;
		effect.f ^= INERT;

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transitions.push(transition);
				}
			}
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call pause_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			pause_children(child, transitions, transparent ? local : false);
			child = sibling;
		}
	}

	/**
	 * The opposite of `pause_effect`. We call this if (for example)
	 * `x` becomes falsy then truthy: `{#if x}...{/if}`
	 * @param {Effect} effect
	 */
	function resume_effect(effect) {
		resume_children(effect, true);
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} local
	 */
	function resume_children(effect, local) {
		if ((effect.f & INERT) === 0) return;

		// If a dependency of this effect changed while it was paused,
		// apply the change now
		if (check_dirtiness(effect)) {
			update_effect(effect);
		}

		// Ensure we toggle the flag after possibly updating the effect so that
		// each block logic can correctly operate on inert items
		effect.f ^= INERT;

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call resume_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			resume_children(child, transparent ? local : false);
			child = sibling;
		}

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transition.in();
				}
			}
		}
	}

	let is_micro_task_queued$1 = false;

	/** @type {Array<() => void>} */
	let current_queued_micro_tasks = [];

	function process_micro_tasks() {
		is_micro_task_queued$1 = false;
		const tasks = current_queued_micro_tasks.slice();
		current_queued_micro_tasks = [];
		run_all(tasks);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_micro_task(fn) {
		if (!is_micro_task_queued$1) {
			is_micro_task_queued$1 = true;
			queueMicrotask(process_micro_tasks);
		}
		current_queued_micro_tasks.push(fn);
	}

	/** @import { ProxyMetadata } from '#client' */
	/** @typedef {{ file: string, line: number, column: number }} Location */


	/** @type {Record<string, Array<{ start: Location, end: Location, component: Function }>>} */
	const boundaries = {};

	const chrome_pattern = /at (?:.+ \()?(.+):(\d+):(\d+)\)?$/;
	const firefox_pattern = /@(.+):(\d+):(\d+)$/;

	function get_stack() {
		const stack = new Error().stack;
		if (!stack) return null;

		const entries = [];

		for (const line of stack.split('\n')) {
			let match = chrome_pattern.exec(line) ?? firefox_pattern.exec(line);

			if (match) {
				entries.push({
					file: match[1],
					line: +match[2],
					column: +match[3]
				});
			}
		}

		return entries;
	}

	/**
	 * Determines which `.svelte` component is responsible for a given state change
	 * @returns {Function | null}
	 */
	function get_component() {
		// first 4 lines are svelte internals; adjust this number if we change the internal call stack
		const stack = get_stack()?.slice(4);
		if (!stack) return null;

		for (let i = 0; i < stack.length; i++) {
			const entry = stack[i];
			const modules = boundaries[entry.file];
			if (!modules) {
				// If the first entry is not a component, that means the modification very likely happened
				// within a .svelte.js file, possibly triggered by a component. Since these files are not part
				// of the bondaries/component context heuristic, we need to bail in this case, else we would
				// have false positives when the .svelte.ts file provides a state creator function, encapsulating
				// the state and its mutations, and is being called from a component other than the one who
				// called the state creator function.
				if (i === 0) return null;
				continue;
			}

			for (const module of modules) {
				if (module.start.line < entry.line && module.end.line > entry.line) {
					return module.component;
				}
			}
		}

		return null;
	}

	/**
	 * Together with `mark_module_end`, this function establishes the boundaries of a `.svelte` file,
	 * such that subsequent calls to `get_component` can tell us which component is responsible
	 * for a given state change
	 */
	function mark_module_start() {
		const start = get_stack()?.[2];

		if (start) {
			(boundaries[start.file] ??= []).push({
				start,
				// @ts-expect-error
				end: null,
				// @ts-expect-error we add the component at the end, since HMR will overwrite the function
				component: null
			});
		}
	}

	/**
	 * @param {Function} component
	 */
	function mark_module_end(component) {
		const end = get_stack()?.[2];

		if (end) {
			const boundaries_file = boundaries[end.file];
			const boundary = boundaries_file[boundaries_file.length - 1];

			boundary.end = end;
			boundary.component = component;
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * `%name%(...)` can only be used during component initialisation
	 * @param {string} name
	 * @returns {never}
	 */
	function lifecycle_outside_component(name) {
		{
			// TODO print a link to the documentation
			throw new Error("lifecycle_outside_component");
		}
	}

	/**
	 * `%name%` is not a store with a `subscribe` method
	 * @param {string} name
	 * @returns {never}
	 */
	function store_invalid_shape(name) {
		{
			// TODO print a link to the documentation
			throw new Error("store_invalid_shape");
		}
	}

	/** @import { ComponentContext, Derived, Effect, Reaction, Signal, Source, Value } from '#client' */
	// Used for handling scheduling
	let is_micro_task_queued = false;

	let is_flushing_effect = false;
	let is_destroying_effect = false;

	/** @param {boolean} value */
	function set_is_flushing_effect(value) {
		is_flushing_effect = value;
	}

	/** @param {boolean} value */
	function set_is_destroying_effect(value) {
		is_destroying_effect = value;
	}

	// Handle effect queues

	/** @type {Effect[]} */
	let queued_root_effects = [];

	let flush_count = 0;
	/** @type {Effect[]} Stack of effects, dev only */
	let dev_effect_stack = [];
	// Handle signal reactivity tree dependencies and reactions

	/** @type {null | Reaction} */
	let active_reaction = null;

	/** @param {null | Reaction} reaction */
	function set_active_reaction(reaction) {
		active_reaction = reaction;
	}

	/** @type {null | Effect} */
	let active_effect = null;

	/** @param {null | Effect} effect */
	function set_active_effect(effect) {
		active_effect = effect;
	}

	/**
	 * When sources are created within a derived, we record them so that we can safely allow
	 * local mutations to these sources without the side-effect error being invoked unnecessarily.
	 * @type {null | Source[]}
	 */
	let derived_sources = null;

	/**
	 * @param {Source[] | null} sources
	 */
	function set_derived_sources(sources) {
		derived_sources = sources;
	}

	/**
	 * The dependencies of the reaction that is currently being executed. In many cases,
	 * the dependencies are unchanged between runs, and so this will be `null` unless
	 * and until a new dependency is accessed — we track this via `skipped_deps`
	 * @type {null | Value[]}
	 */
	let new_deps = null;

	let skipped_deps = 0;

	/**
	 * Tracks writes that the effect it's executed in doesn't listen to yet,
	 * so that the dependency can be added to the effect later on if it then reads it
	 * @type {null | Source[]}
	 */
	let untracked_writes = null;

	/** @param {null | Source[]} value */
	function set_untracked_writes(value) {
		untracked_writes = value;
	}

	/** @type {number} Used by sources and deriveds for handling updates to unowned deriveds */
	let current_version = 0;

	// If we are working with a get() chain that has no active container,
	// to prevent memory leaks, we skip adding the reaction.
	let skip_reaction = false;

	// Handling runtime component context
	/** @type {ComponentContext | null} */
	let component_context = null;

	function increment_version() {
		return ++current_version;
	}

	/** @returns {boolean} */
	function is_runes() {
		return component_context !== null && component_context.l === null;
	}

	/**
	 * Determines whether a derived or effect is dirty.
	 * If it is MAYBE_DIRTY, will set the status to CLEAN
	 * @param {Reaction} reaction
	 * @returns {boolean}
	 */
	function check_dirtiness(reaction) {
		var flags = reaction.f;

		if ((flags & DIRTY) !== 0) {
			return true;
		}

		if ((flags & MAYBE_DIRTY) !== 0) {
			var dependencies = reaction.deps;
			var is_unowned = (flags & UNOWNED) !== 0;

			if (dependencies !== null) {
				var i;

				if ((flags & DISCONNECTED) !== 0) {
					for (i = 0; i < dependencies.length; i++) {
						(dependencies[i].reactions ??= []).push(reaction);
					}

					reaction.f ^= DISCONNECTED;
				}

				for (i = 0; i < dependencies.length; i++) {
					var dependency = dependencies[i];

					if (check_dirtiness(/** @type {Derived} */ (dependency))) {
						update_derived(/** @type {Derived} */ (dependency));
					}

					// If we are working with an unowned signal as part of an effect (due to !skip_reaction)
					// and the version hasn't changed, we still need to check that this reaction
					// is linked to the dependency source – otherwise future updates will not be caught.
					if (
						is_unowned &&
						active_effect !== null &&
						!skip_reaction &&
						!dependency?.reactions?.includes(reaction)
					) {
						(dependency.reactions ??= []).push(reaction);
					}

					if (dependency.version > reaction.version) {
						return true;
					}
				}
			}

			// Unowned signals should never be marked as clean.
			if (!is_unowned) {
				set_signal_status(reaction, CLEAN);
			}
		}

		return false;
	}

	/**
	 * @param {Error} error
	 * @param {Effect} effect
	 * @param {ComponentContext | null} component_context
	 */
	function handle_error(error, effect, component_context) {
		// Given we don't yet have error boundaries, we will just always throw.
		{
			throw error;
		}
	}

	/**
	 * @template V
	 * @param {Reaction} reaction
	 * @returns {V}
	 */
	function update_reaction(reaction) {
		var previous_deps = new_deps;
		var previous_skipped_deps = skipped_deps;
		var previous_untracked_writes = untracked_writes;
		var previous_reaction = active_reaction;
		var previous_skip_reaction = skip_reaction;
		var prev_derived_sources = derived_sources;
		var previous_component_context = component_context;
		var flags = reaction.f;

		new_deps = /** @type {null | Value[]} */ (null);
		skipped_deps = 0;
		untracked_writes = null;
		active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
		skip_reaction = !is_flushing_effect && (flags & UNOWNED) !== 0;
		derived_sources = null;
		component_context = reaction.ctx;

		try {
			var result = /** @type {Function} */ (0, reaction.fn)();
			var deps = reaction.deps;

			if (new_deps !== null) {
				var i;

				remove_reactions(reaction, skipped_deps);

				if (deps !== null && skipped_deps > 0) {
					deps.length = skipped_deps + new_deps.length;
					for (i = 0; i < new_deps.length; i++) {
						deps[skipped_deps + i] = new_deps[i];
					}
				} else {
					reaction.deps = deps = new_deps;
				}

				if (!skip_reaction) {
					for (i = skipped_deps; i < deps.length; i++) {
						(deps[i].reactions ??= []).push(reaction);
					}
				}
			} else if (deps !== null && skipped_deps < deps.length) {
				remove_reactions(reaction, skipped_deps);
				deps.length = skipped_deps;
			}

			return result;
		} finally {
			new_deps = previous_deps;
			skipped_deps = previous_skipped_deps;
			untracked_writes = previous_untracked_writes;
			active_reaction = previous_reaction;
			skip_reaction = previous_skip_reaction;
			derived_sources = prev_derived_sources;
			component_context = previous_component_context;
		}
	}

	/**
	 * @template V
	 * @param {Reaction} signal
	 * @param {Value<V>} dependency
	 * @returns {void}
	 */
	function remove_reaction(signal, dependency) {
		let reactions = dependency.reactions;
		if (reactions !== null) {
			var index = reactions.indexOf(signal);
			if (index !== -1) {
				var new_length = reactions.length - 1;
				if (new_length === 0) {
					reactions = dependency.reactions = null;
				} else {
					// Swap with last element and then remove.
					reactions[index] = reactions[new_length];
					reactions.pop();
				}
			}
		}
		// If the derived has no reactions, then we can disconnect it from the graph,
		// allowing it to either reconnect in the future, or be GC'd by the VM.
		if (
			reactions === null &&
			(dependency.f & DERIVED) !== 0 &&
			// Destroying a child effect while updating a parent effect can cause a dependency to appear
			// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
			// allows us to skip the expensive work of disconnecting and immediately reconnecting it
			(new_deps === null || !new_deps.includes(dependency))
		) {
			set_signal_status(dependency, MAYBE_DIRTY);
			// If we are working with a derived that is owned by an effect, then mark it as being
			// disconnected.
			if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
				dependency.f ^= DISCONNECTED;
			}
			remove_reactions(/** @type {Derived} **/ (dependency), 0);
		}
	}

	/**
	 * @param {Reaction} signal
	 * @param {number} start_index
	 * @returns {void}
	 */
	function remove_reactions(signal, start_index) {
		var dependencies = signal.deps;
		if (dependencies === null) return;

		for (var i = start_index; i < dependencies.length; i++) {
			remove_reaction(signal, dependencies[i]);
		}
	}

	/**
	 * @param {Effect} effect
	 * @returns {void}
	 */
	function update_effect(effect) {
		var flags = effect.f;

		if ((flags & DESTROYED) !== 0) {
			return;
		}

		set_signal_status(effect, CLEAN);

		var previous_effect = active_effect;

		active_effect = effect;

		try {
			if ((flags & BLOCK_EFFECT) !== 0) {
				destroy_block_effect_children(effect);
			} else {
				destroy_effect_children(effect);
			}
			destroy_effect_deriveds(effect);

			execute_effect_teardown(effect);
			var teardown = update_reaction(effect);
			effect.teardown = typeof teardown === 'function' ? teardown : null;
			effect.version = current_version;

			if (DEV) ;
		} catch (error) {
			handle_error(/** @type {Error} */ (error));
		} finally {
			active_effect = previous_effect;
		}
	}

	function infinite_loop_guard() {
		if (flush_count > 1000) {
			flush_count = 0;
			{
				effect_update_depth_exceeded();
			}
		}
		flush_count++;
	}

	/**
	 * @param {Array<Effect>} root_effects
	 * @returns {void}
	 */
	function flush_queued_root_effects(root_effects) {
		var length = root_effects.length;
		if (length === 0) {
			return;
		}
		infinite_loop_guard();

		var previously_flushing_effect = is_flushing_effect;
		is_flushing_effect = true;

		try {
			for (var i = 0; i < length; i++) {
				var effect = root_effects[i];

				if ((effect.f & CLEAN) === 0) {
					effect.f ^= CLEAN;
				}

				/** @type {Effect[]} */
				var collected_effects = [];

				process_effects(effect, collected_effects);
				flush_queued_effects(collected_effects);
			}
		} finally {
			is_flushing_effect = previously_flushing_effect;
		}
	}

	/**
	 * @param {Array<Effect>} effects
	 * @returns {void}
	 */
	function flush_queued_effects(effects) {
		var length = effects.length;
		if (length === 0) return;

		for (var i = 0; i < length; i++) {
			var effect = effects[i];

			if ((effect.f & (DESTROYED | INERT)) === 0 && check_dirtiness(effect)) {
				update_effect(effect);

				// Effects with no dependencies or teardown do not get added to the effect tree.
				// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we
				// don't know if we need to keep them until they are executed. Doing the check
				// here (rather than in `update_effect`) allows us to skip the work for
				// immediate effects.
				if (effect.deps === null && effect.first === null && effect.nodes_start === null) {
					if (effect.teardown === null) {
						// remove this effect from the graph
						unlink_effect(effect);
					} else {
						// keep the effect in the graph, but free up some memory
						effect.fn = null;
					}
				}
			}
		}
	}

	function process_deferred() {
		is_micro_task_queued = false;
		if (flush_count > 1001) {
			return;
		}
		const previous_queued_root_effects = queued_root_effects;
		queued_root_effects = [];
		flush_queued_root_effects(previous_queued_root_effects);
		if (!is_micro_task_queued) {
			flush_count = 0;
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function schedule_effect(signal) {
		{
			if (!is_micro_task_queued) {
				is_micro_task_queued = true;
				queueMicrotask(process_deferred);
			}
		}

		var effect = signal;

		while (effect.parent !== null) {
			effect = effect.parent;
			var flags = effect.f;

			if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
				if ((flags & CLEAN) === 0) return;
				effect.f ^= CLEAN;
			}
		}

		queued_root_effects.push(effect);
	}

	/**
	 *
	 * This function both runs render effects and collects user effects in topological order
	 * from the starting effect passed in. Effects will be collected when they match the filtered
	 * bitwise flag passed in only. The collected effects array will be populated with all the user
	 * effects to be flushed.
	 *
	 * @param {Effect} effect
	 * @param {Effect[]} collected_effects
	 * @returns {void}
	 */
	function process_effects(effect, collected_effects) {
		var current_effect = effect.first;
		var effects = [];

		main_loop: while (current_effect !== null) {
			var flags = current_effect.f;
			var is_branch = (flags & BRANCH_EFFECT) !== 0;
			var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;

			if (!is_skippable_branch && (flags & INERT) === 0) {
				if ((flags & RENDER_EFFECT) !== 0) {
					if (is_branch) {
						current_effect.f ^= CLEAN;
					} else if (check_dirtiness(current_effect)) {
						update_effect(current_effect);
					}

					var child = current_effect.first;

					if (child !== null) {
						current_effect = child;
						continue;
					}
				} else if ((flags & EFFECT) !== 0) {
					effects.push(current_effect);
				}
			}

			var sibling = current_effect.next;

			if (sibling === null) {
				let parent = current_effect.parent;

				while (parent !== null) {
					if (effect === parent) {
						break main_loop;
					}
					var parent_sibling = parent.next;
					if (parent_sibling !== null) {
						current_effect = parent_sibling;
						continue main_loop;
					}
					parent = parent.parent;
				}
			}

			current_effect = sibling;
		}

		// We might be dealing with many effects here, far more than can be spread into
		// an array push call (callstack overflow). So let's deal with each effect in a loop.
		for (var i = 0; i < effects.length; i++) {
			child = effects[i];
			collected_effects.push(child);
			process_effects(child, collected_effects);
		}
	}

	/**
	 * @template V
	 * @param {Value<V>} signal
	 * @returns {V}
	 */
	function get(signal) {
		var flags = signal.f;
		var is_derived = (flags & DERIVED) !== 0;

		// If the derived is destroyed, just execute it again without retaining
		// its memoisation properties as the derived is stale
		if (is_derived && (flags & DESTROYED) !== 0) {
			var value = execute_derived(/** @type {Derived} */ (signal));
			// Ensure the derived remains destroyed
			destroy_derived(/** @type {Derived} */ (signal));
			return value;
		}

		// Register the dependency on the current reaction signal.
		if (active_reaction !== null) {
			if (derived_sources !== null && derived_sources.includes(signal)) {
				state_unsafe_local_read();
			}
			var deps = active_reaction.deps;

			// If the signal is accessing the same dependencies in the same
			// order as it did last time, increment `skipped_deps`
			// rather than updating `new_deps`, which creates GC cost
			if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
				skipped_deps++;
			} else if (new_deps === null) {
				new_deps = [signal];
			} else {
				new_deps.push(signal);
			}

			if (
				untracked_writes !== null &&
				active_effect !== null &&
				(active_effect.f & CLEAN) !== 0 &&
				(active_effect.f & BRANCH_EFFECT) === 0 &&
				untracked_writes.includes(signal)
			) {
				set_signal_status(active_effect, DIRTY);
				schedule_effect(active_effect);
			}
		} else if (is_derived && /** @type {Derived} */ (signal).deps === null) {
			var derived = /** @type {Derived} */ (signal);
			var parent = derived.parent;

			if (parent !== null && !parent.deriveds?.includes(derived)) {
				(parent.deriveds ??= []).push(derived);
			}
		}

		if (is_derived) {
			derived = /** @type {Derived} */ (signal);

			if (check_dirtiness(derived)) {
				update_derived(derived);
			}
		}

		return signal.v;
	}

	/**
	 * Use `untrack` to prevent something from being treated as an `$effect`/`$derived` dependency.
	 * @template T
	 * @param {() => T} fn
	 * @returns {T}
	 */
	function untrack(fn) {
		const previous_reaction = active_reaction;
		try {
			active_reaction = null;
			return fn();
		} finally {
			active_reaction = previous_reaction;
		}
	}

	const STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);

	/**
	 * @param {Signal} signal
	 * @param {number} status
	 * @returns {void}
	 */
	function set_signal_status(signal, status) {
		signal.f = (signal.f & STATUS_MASK) | status;
	}

	/**
	 * Retrieves the context that belongs to the closest parent component with the specified `key`.
	 * Must be called during component initialisation.
	 *
	 * @template T
	 * @param {any} key
	 * @returns {T}
	 */
	function getContext(key) {
		const context_map = get_or_init_context_map();
		const result = /** @type {T} */ (context_map.get(key));

		return result;
	}

	/**
	 * Associates an arbitrary `context` object with the current component and the specified `key`
	 * and returns that object. The context is then available to children of the component
	 * (including slotted content) with `getContext`.
	 *
	 * Like lifecycle functions, this must be called during component initialisation.
	 *
	 * @template T
	 * @param {any} key
	 * @param {T} context
	 * @returns {T}
	 */
	function setContext(key, context) {
		const context_map = get_or_init_context_map();
		context_map.set(key, context);
		return context;
	}

	/**
	 * @param {string} name
	 * @returns {Map<unknown, unknown>}
	 */
	function get_or_init_context_map(name) {
		if (component_context === null) {
			lifecycle_outside_component();
		}

		return (component_context.c ??= new Map(get_parent_context(component_context) || undefined));
	}

	/**
	 * @param {ComponentContext} component_context
	 * @returns {Map<unknown, unknown> | null}
	 */
	function get_parent_context(component_context) {
		let parent = component_context.p;
		while (parent !== null) {
			const context_map = parent.c;
			if (context_map !== null) {
				return context_map;
			}
			parent = parent.p;
		}
		return null;
	}

	/**
	 * @param {Value<number>} signal
	 * @param {1 | -1} [d]
	 * @returns {number}
	 */
	function update(signal, d = 1) {
		var value = +get(signal);
		set(signal, value + d);
		return value;
	}

	/**
	 * @param {Value<number>} signal
	 * @param {1 | -1} [d]
	 * @returns {number}
	 */
	function update_pre(signal, d = 1) {
		return set(signal, +get(signal) + d);
	}

	/**
	 * @param {Record<string, unknown>} props
	 * @param {any} runes
	 * @param {Function} [fn]
	 * @returns {void}
	 */
	function push(props, runes = false, fn) {
		component_context = {
			p: component_context,
			c: null,
			e: null,
			m: false,
			s: props,
			x: null,
			l: null
		};

		if (!runes) {
			component_context.l = {
				s: null,
				u: null,
				r1: [],
				r2: source(false)
			};
		}
	}

	/**
	 * @template {Record<string, any>} T
	 * @param {T} [component]
	 * @returns {T}
	 */
	function pop(component) {
		const context_stack_item = component_context;
		if (context_stack_item !== null) {
			if (component !== undefined) {
				context_stack_item.x = component;
			}
			const component_effects = context_stack_item.e;
			if (component_effects !== null) {
				var previous_effect = active_effect;
				var previous_reaction = active_reaction;
				context_stack_item.e = null;
				try {
					for (var i = 0; i < component_effects.length; i++) {
						var component_effect = component_effects[i];
						set_active_effect(component_effect.effect);
						set_active_reaction(component_effect.reaction);
						effect$3(component_effect.fn);
					}
				} finally {
					set_active_effect(previous_effect);
					set_active_reaction(previous_reaction);
				}
			}
			component_context = context_stack_item.p;
			context_stack_item.m = true;
		}
		// Micro-optimization: Don't set .a above to the empty object
		// so it can be garbage-collected when the return here is unused
		return component || /** @type {T} */ ({});
	}

	/**
	 * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.
	 * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).
	 * @param {any} value
	 * @returns {void}
	 */
	function deep_read_state(value) {
		if (typeof value !== 'object' || !value || value instanceof EventTarget) {
			return;
		}

		if (STATE_SYMBOL in value) {
			deep_read(value);
		} else if (!Array.isArray(value)) {
			for (let key in value) {
				const prop = value[key];
				if (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {
					deep_read(prop);
				}
			}
		}
	}

	/**
	 * Deeply traverse an object and read all its properties
	 * so that they're all reactive in case this is `$state`
	 * @param {any} value
	 * @param {Set<any>} visited
	 * @returns {void}
	 */
	function deep_read(value, visited = new Set()) {
		if (
			typeof value === 'object' &&
			value !== null &&
			// We don't want to traverse DOM elements
			!(value instanceof EventTarget) &&
			!visited.has(value)
		) {
			visited.add(value);
			// When working with a possible SvelteDate, this
			// will ensure we capture changes to it.
			if (value instanceof Date) {
				value.getTime();
			}
			for (let key in value) {
				try {
					deep_read(value[key], visited);
				} catch (e) {
					// continue
				}
			}
			const proto = get_prototype_of(value);
			if (
				proto !== Object.prototype &&
				proto !== Array.prototype &&
				proto !== Map.prototype &&
				proto !== Set.prototype &&
				proto !== Date.prototype
			) {
				const descriptors = get_descriptors(proto);
				for (let key in descriptors) {
					const get = descriptors[key].get;
					if (get) {
						try {
							get.call(value);
						} catch (e) {
							// continue
						}
					}
				}
			}
		}
	}

	/** @import { ProxyMetadata, ProxyStateObject, Source } from '#client' */

	/**
	 * @template T
	 * @param {T} value
	 * @param {ProxyMetadata | null} [parent]
	 * @param {Source<T>} [prev] dev mode only
	 * @returns {T}
	 */
	function proxy(value, parent = null, prev) {
		// if non-proxyable, or is already a proxy, return `value`
		if (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {
			return value;
		}

		const prototype = get_prototype_of(value);

		if (prototype !== object_prototype && prototype !== array_prototype) {
			return value;
		}

		/** @type {Map<any, Source<any>>} */
		var sources = new Map();
		var is_proxied_array = is_array(value);
		var version = source(0);

		if (is_proxied_array) {
			// We need to create the length source eagerly to ensure that
			// mutations to the array are properly synced with our proxy
			sources.set('length', source(/** @type {any[]} */ (value).length));
		}

		/** @type {ProxyMetadata} */
		var metadata;

		return new Proxy(/** @type {any} */ (value), {
			defineProperty(_, prop, descriptor) {
				if (
					!('value' in descriptor) ||
					descriptor.configurable === false ||
					descriptor.enumerable === false ||
					descriptor.writable === false
				) {
					// we disallow non-basic descriptors, because unless they are applied to the
					// target object — which we avoid, so that state can be forked — we will run
					// afoul of the various invariants
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants
					state_descriptors_fixed();
				}

				var s = sources.get(prop);

				if (s === undefined) {
					s = source(descriptor.value);
					sources.set(prop, s);
				} else {
					set(s, proxy(descriptor.value, metadata));
				}

				return true;
			},

			deleteProperty(target, prop) {
				var s = sources.get(prop);

				if (s === undefined) {
					if (prop in target) {
						sources.set(prop, source(UNINITIALIZED));
					}
				} else {
					// When working with arrays, we need to also ensure we update the length when removing
					// an indexed property
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n < ls.v) {
							set(ls, n);
						}
					}
					set(s, UNINITIALIZED);
					update_version(version);
				}

				return true;
			},

			get(target, prop, receiver) {

				if (prop === STATE_SYMBOL) {
					return value;
				}

				var s = sources.get(prop);
				var exists = prop in target;

				// create a source, but only if it's an own property and not a prototype property
				if (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {
					s = source(proxy(exists ? target[prop] : UNINITIALIZED, metadata));
					sources.set(prop, s);
				}

				if (s !== undefined) {
					var v = get(s);

					return v === UNINITIALIZED ? undefined : v;
				}

				return Reflect.get(target, prop, receiver);
			},

			getOwnPropertyDescriptor(target, prop) {
				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				if (descriptor && 'value' in descriptor) {
					var s = sources.get(prop);
					if (s) descriptor.value = get(s);
				} else if (descriptor === undefined) {
					var source = sources.get(prop);
					var value = source?.v;

					if (source !== undefined && value !== UNINITIALIZED) {
						return {
							enumerable: true,
							configurable: true,
							value,
							writable: true
						};
					}
				}

				return descriptor;
			},

			has(target, prop) {

				if (prop === STATE_SYMBOL) {
					return true;
				}

				var s = sources.get(prop);
				var has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);

				if (
					s !== undefined ||
					(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))
				) {
					if (s === undefined) {
						s = source(has ? proxy(target[prop], metadata) : UNINITIALIZED);
						sources.set(prop, s);
					}

					var value = get(s);
					if (value === UNINITIALIZED) {
						return false;
					}
				}

				return has;
			},

			set(target, prop, value, receiver) {
				var s = sources.get(prop);
				var has = prop in target;

				// variable.length = value -> clear all signals with index >= value
				if (is_proxied_array && prop === 'length') {
					for (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {
						var other_s = sources.get(i + '');
						if (other_s !== undefined) {
							set(other_s, UNINITIALIZED);
						} else if (i in target) {
							// If the item exists in the original, we need to create a uninitialized source,
							// else a later read of the property would result in a source being created with
							// the value of the original item at that index.
							other_s = source(UNINITIALIZED);
							sources.set(i + '', other_s);
						}
					}
				}

				// If we haven't yet created a source for this property, we need to ensure
				// we do so otherwise if we read it later, then the write won't be tracked and
				// the heuristics of effects will be different vs if we had read the proxied
				// object property before writing to that property.
				if (s === undefined) {
					if (!has || get_descriptor(target, prop)?.writable) {
						s = source(undefined);
						set(s, proxy(value, metadata));
						sources.set(prop, s);
					}
				} else {
					has = s.v !== UNINITIALIZED;
					set(s, proxy(value, metadata));
				}

				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				// Set the new value before updating any signals so that any listeners get the new value
				if (descriptor?.set) {
					descriptor.set.call(receiver, value);
				}

				if (!has) {
					// If we have mutated an array directly, we might need to
					// signal that length has also changed. Do it before updating metadata
					// to ensure that iterating over the array as a result of a metadata update
					// will not cause the length to be out of sync.
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n >= ls.v) {
							set(ls, n + 1);
						}
					}

					update_version(version);
				}

				return true;
			},

			ownKeys(target) {
				get(version);

				var own_keys = Reflect.ownKeys(target).filter((key) => {
					var source = sources.get(key);
					return source === undefined || source.v !== UNINITIALIZED;
				});

				for (var [key, source] of sources) {
					if (source.v !== UNINITIALIZED && !(key in target)) {
						own_keys.push(key);
					}
				}

				return own_keys;
			},

			setPrototypeOf() {
				state_prototype_fixed();
			}
		});
	}

	/**
	 * @param {Source<number>} signal
	 * @param {1 | -1} [d]
	 */
	function update_version(signal, d = 1) {
		set(signal, signal.v + d);
	}

	/**
	 * @param {any} value
	 */
	function get_proxied_value(value) {
		if (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {
			return value[STATE_SYMBOL];
		}

		return value;
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 */
	function is(a, b) {
		return Object.is(get_proxied_value(a), get_proxied_value(b));
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 * @param {boolean} equal
	 * @returns {boolean}
	 */
	function strict_equals(a, b, equal = true) {
		// try-catch needed because this tries to read properties of `a` and `b`,
		// which could be disallowed for example in a secure context
		try {
			if ((a === b) !== (get_proxied_value(a) === get_proxied_value(b))) {
				state_proxy_equality_mismatch(equal ? '===' : '!==');
			}
		} catch {}

		return (a === b) === equal;
	}

	/** @import { TemplateNode } from '#client' */

	// export these for reference in the compiled code, making global name deduplication unnecessary
	/** @type {Window} */
	var $window;

	/** @type {() => Node | null} */
	var first_child_getter;
	/** @type {() => Node | null} */
	var next_sibling_getter;

	/**
	 * Initialize these lazily to avoid issues when using the runtime in a server context
	 * where these globals are not available while avoiding a separate server entry point
	 */
	function init_operations() {
		if ($window !== undefined) {
			return;
		}

		$window = window;

		var element_prototype = Element.prototype;
		var node_prototype = Node.prototype;

		// @ts-ignore
		first_child_getter = get_descriptor(node_prototype, 'firstChild').get;
		// @ts-ignore
		next_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;

		// the following assignments improve perf of lookups on DOM nodes
		// @ts-expect-error
		element_prototype.__click = undefined;
		// @ts-expect-error
		element_prototype.__className = '';
		// @ts-expect-error
		element_prototype.__attributes = null;
		// @ts-expect-error
		element_prototype.__styles = null;
		// @ts-expect-error
		element_prototype.__e = undefined;

		// @ts-expect-error
		Text.prototype.__t = undefined;
	}

	/**
	 * @param {string} value
	 * @returns {Text}
	 */
	function create_text(value = '') {
		return document.createTextNode(value);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_first_child(node) {
		return first_child_getter.call(node);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_next_sibling(node) {
		return next_sibling_getter.call(node);
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @template {Node} N
	 * @param {N} node
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function child(node, is_text) {
		{
			return get_first_child(node);
		}
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {DocumentFragment | TemplateNode[]} fragment
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function first_child(fragment, is_text) {
		{
			// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)
			var first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));

			// TODO prevent user comments with the empty string when preserveComments is true
			if (first instanceof Comment && first.data === '') return get_next_sibling(first);

			return first;
		}
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {TemplateNode} node
	 * @param {number} count
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function sibling(node, count = 1, is_text = false) {
		let next_sibling = node;

		while (count--) {
			next_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));
		}

		{
			return next_sibling;
		}
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {void}
	 */
	function clear_text_content(node) {
		node.textContent = '';
	}

	/** @import { TemplateNode } from '#client' */


	/**
	 * Use this variable to guard everything related to hydration code so it can be treeshaken out
	 * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.
	 */
	let hydrating = false;

	/** @param {TemplateNode} node */
	function reset(node) {
		return;
	}

	function next(count = 1) {
	}

	/** @import { SourceLocation } from '#shared' */

	/**
	 * @param {any} fn
	 * @param {string} filename
	 * @param {SourceLocation[]} locations
	 * @returns {any}
	 */
	function add_locations(fn, filename, locations) {
		return (/** @type {any[]} */ ...args) => {
			const dom = fn(...args);

			var node = dom.nodeType === 11 ? dom.firstChild : dom;
			assign_locations(node, filename, locations);

			return dom;
		};
	}

	/**
	 * @param {Element} element
	 * @param {string} filename
	 * @param {SourceLocation} location
	 */
	function assign_location(element, filename, location) {
		// @ts-expect-error
		element.__svelte_meta = {
			loc: { file: filename, line: location[0], column: location[1] }
		};

		if (location[2]) {
			assign_locations(element.firstChild, filename, location[2]);
		}
	}

	/**
	 * @param {Node | null} node
	 * @param {string} filename
	 * @param {SourceLocation[]} locations
	 */
	function assign_locations(node, filename, locations) {
		var i = 0;

		while (node && i < locations.length) {

			if (node.nodeType === 1) {
				assign_location(/** @type {Element} */ (node), filename, locations[i++]);
			}

			node = node.nextSibling;
		}
	}

	/** @import { Location } from 'locate-character' */

	/** @type {Set<string>} */
	const all_registered_events = new Set();

	/** @type {Set<(events: Array<string>) => void>} */
	const root_event_handles = new Set();

	/**
	 * @param {string} event_name
	 * @param {EventTarget} dom
	 * @param {EventListener} handler
	 * @param {AddEventListenerOptions} options
	 */
	function create_event(event_name, dom, handler, options) {
		/**
		 * @this {EventTarget}
		 */
		function target_handler(/** @type {Event} */ event) {
			if (!options.capture) {
				// Only call in the bubble phase, else delegated events would be called before the capturing events
				handle_event_propagation.call(dom, event);
			}
			if (!event.cancelBubble) {
				var previous_reaction = active_reaction;
				var previous_effect = active_effect;

				set_active_reaction(null);
				set_active_effect(null);
				try {
					return handler.call(this, event);
				} finally {
					set_active_reaction(previous_reaction);
					set_active_effect(previous_effect);
				}
			}
		}

		// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned
		// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we
		// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes
		// this bug. The same applies to wheel events and touch events.
		if (
			event_name.startsWith('pointer') ||
			event_name.startsWith('touch') ||
			event_name === 'wheel'
		) {
			queue_micro_task(() => {
				dom.addEventListener(event_name, target_handler, options);
			});
		} else {
			dom.addEventListener(event_name, target_handler, options);
		}

		return target_handler;
	}

	/**
	 * @param {string} event_name
	 * @param {Element} dom
	 * @param {EventListener} handler
	 * @param {boolean} capture
	 * @param {boolean} [passive]
	 * @returns {void}
	 */
	function event(event_name, dom, handler, capture, passive) {
		var options = { capture, passive };
		var target_handler = create_event(event_name, dom, handler, options);

		// @ts-ignore
		if (dom === document.body || dom === window || dom === document) {
			teardown(() => {
				dom.removeEventListener(event_name, target_handler, options);
			});
		}
	}

	/**
	 * @param {Array<string>} events
	 * @returns {void}
	 */
	function delegate(events) {
		for (var i = 0; i < events.length; i++) {
			all_registered_events.add(events[i]);
		}

		for (var fn of root_event_handles) {
			fn(events);
		}
	}

	/**
	 * @this {EventTarget}
	 * @param {Event} event
	 * @returns {void}
	 */
	function handle_event_propagation(event) {
		var handler_element = this;
		var owner_document = /** @type {Node} */ (handler_element).ownerDocument;
		var event_name = event.type;
		var path = event.composedPath?.() || [];
		var current_target = /** @type {null | Element} */ (path[0] || event.target);

		// composedPath contains list of nodes the event has propagated through.
		// We check __root to skip all nodes below it in case this is a
		// parent of the __root node, which indicates that there's nested
		// mounted apps. In this case we don't want to trigger events multiple times.
		var path_idx = 0;

		// @ts-expect-error is added below
		var handled_at = event.__root;

		if (handled_at) {
			var at_idx = path.indexOf(handled_at);
			if (
				at_idx !== -1 &&
				(handler_element === document || handler_element === /** @type {any} */ (window))
			) {
				// This is the fallback document listener or a window listener, but the event was already handled
				// -> ignore, but set handle_at to document/window so that we're resetting the event
				// chain in case someone manually dispatches the same event object again.
				// @ts-expect-error
				event.__root = handler_element;
				return;
			}

			// We're deliberately not skipping if the index is higher, because
			// someone could create an event programmatically and emit it multiple times,
			// in which case we want to handle the whole propagation chain properly each time.
			// (this will only be a false negative if the event is dispatched multiple times and
			// the fallback document listener isn't reached in between, but that's super rare)
			var handler_idx = path.indexOf(handler_element);
			if (handler_idx === -1) {
				// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)
				// so guard against that, too, and assume that everything was handled at this point.
				return;
			}

			if (at_idx <= handler_idx) {
				path_idx = at_idx;
			}
		}

		current_target = /** @type {Element} */ (path[path_idx] || event.target);
		// there can only be one delegated event per element, and we either already handled the current target,
		// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe
		// to handle a possible delegated event on it later (through the root delegation listener for example).
		if (current_target === handler_element) return;

		// Proxy currentTarget to correct target
		define_property(event, 'currentTarget', {
			configurable: true,
			get() {
				return current_target || owner_document;
			}
		});

		// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,
		// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic
		// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,
		// it's probably best that all event handled by Svelte have this behaviour, as we don't really want
		// an event handler to run in the context of another reaction or effect.
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);

		try {
			/**
			 * @type {unknown}
			 */
			var throw_error;
			/**
			 * @type {unknown[]}
			 */
			var other_errors = [];

			while (current_target !== null) {
				/** @type {null | Element} */
				var parent_element =
					current_target.assignedSlot ||
					current_target.parentNode ||
					/** @type {any} */ (current_target).host ||
					null;

				try {
					// @ts-expect-error
					var delegated = current_target['__' + event_name];

					if (delegated !== undefined && !(/** @type {any} */ (current_target).disabled)) {
						if (is_array(delegated)) {
							var [fn, ...data] = delegated;
							fn.apply(current_target, [event, ...data]);
						} else {
							delegated.call(current_target, event);
						}
					}
				} catch (error) {
					if (throw_error) {
						other_errors.push(error);
					} else {
						throw_error = error;
					}
				}
				if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
					break;
				}
				current_target = parent_element;
			}

			if (throw_error) {
				for (let error of other_errors) {
					// Throw the rest of the errors, one-by-one on a microtask
					queueMicrotask(() => {
						throw error;
					});
				}
				throw throw_error;
			}
		} finally {
			// @ts-expect-error is used above
			event.__root = handler_element;
			// @ts-ignore remove proxy on currentTarget
			delete event.currentTarget;
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/**
	 * In dev, warn if an event handler is not a function, as it means the
	 * user probably called the handler or forgot to add a `() =>`
	 * @param {() => (event: Event, ...args: any) => void} thunk
	 * @param {EventTarget} element
	 * @param {[Event, ...any]} args
	 * @param {any} component
	 * @param {[number, number]} [loc]
	 * @param {boolean} [remove_parens]
	 */
	function apply(
		thunk,
		element,
		args,
		component,
		loc,
		has_side_effects = false,
		remove_parens = false
	) {
		let handler;
		let error;

		try {
			handler = thunk();
		} catch (e) {
			error = e;
		}

		if (typeof handler === 'function') {
			handler.apply(element, args);
		} else if (has_side_effects || handler != null || error) {
			component?.[FILENAME];

			args[0].type;

			event_handler_invalid();

			if (error) {
				throw error;
			}
		}
	}

	/** @param {string} html */
	function create_fragment_from_html(html) {
		var elem = document.createElement('template');
		elem.innerHTML = html;
		return elem.content;
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {TemplateNode} start
	 * @param {TemplateNode | null} end
	 */
	function assign_nodes(start, end) {
		var effect = /** @type {Effect} */ (active_effect);
		if (effect.nodes_start === null) {
			effect.nodes_start = start;
			effect.nodes_end = end;
		}
	}

	/**
	 * @param {string} content
	 * @param {number} flags
	 * @returns {() => Node | Node[]}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function template(content, flags) {
		var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
		var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;

		/** @type {Node} */
		var node;

		/**
		 * Whether or not the first item is a text/element node. If not, we need to
		 * create an additional comment node to act as `effect.nodes.start`
		 */
		var has_start = !content.startsWith('<!>');

		return () => {

			if (node === undefined) {
				node = create_fragment_from_html(has_start ? content : '<!>' + content);
				if (!is_fragment) node = /** @type {Node} */ (get_first_child(node));
			}

			var clone = /** @type {TemplateNode} */ (
				use_import_node ? document.importNode(node, true) : node.cloneNode(true)
			);

			if (is_fragment) {
				var start = /** @type {TemplateNode} */ (get_first_child(clone));
				var end = /** @type {TemplateNode} */ (clone.lastChild);

				assign_nodes(start, end);
			} else {
				assign_nodes(clone, clone);
			}

			return clone;
		};
	}

	/**
	 * @param {string} content
	 * @param {number} flags
	 * @param {'svg' | 'math'} ns
	 * @returns {() => Node | Node[]}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function ns_template(content, flags, ns = 'svg') {
		/**
		 * Whether or not the first item is a text/element node. If not, we need to
		 * create an additional comment node to act as `effect.nodes.start`
		 */
		var has_start = !content.startsWith('<!>');
		var wrapped = `<${ns}>${has_start ? content : '<!>' + content}</${ns}>`;

		/** @type {Element | DocumentFragment} */
		var node;

		return () => {

			if (!node) {
				var fragment = /** @type {DocumentFragment} */ (create_fragment_from_html(wrapped));
				var root = /** @type {Element} */ (get_first_child(fragment));

				{
					node = /** @type {Element} */ (get_first_child(root));
				}
			}

			var clone = /** @type {TemplateNode} */ (node.cloneNode(true));

			{
				assign_nodes(clone, clone);
			}

			return clone;
		};
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {any} value
	 */
	function text(value = '') {
		{
			var t = create_text(value + '');
			assign_nodes(t, t);
			return t;
		}
	}

	function comment() {

		var frag = document.createDocumentFragment();
		var start = document.createComment('');
		var anchor = create_text();
		frag.append(start, anchor);

		assign_nodes(start, anchor);

		return frag;
	}

	/**
	 * Assign the created (or in hydration mode, traversed) dom elements to the current block
	 * and insert the elements into the dom (in client mode).
	 * @param {Text | Comment | Element} anchor
	 * @param {DocumentFragment | Element} dom
	 */
	function append(anchor, dom) {

		if (anchor === null) {
			// edge case — void `<svelte:element>` with content
			return;
		}

		anchor.before(/** @type {Node} */ (dom));
	}

	/**
	 * @param {string} name
	 */
	function is_capture_event(name) {
		return name.endsWith('capture') && name !== 'gotpointercapture' && name !== 'lostpointercapture';
	}

	/** List of Element events that will be delegated */
	const DELEGATED_EVENTS = [
		'beforeinput',
		'click',
		'change',
		'dblclick',
		'contextmenu',
		'focusin',
		'focusout',
		'input',
		'keydown',
		'keyup',
		'mousedown',
		'mousemove',
		'mouseout',
		'mouseover',
		'mouseup',
		'pointerdown',
		'pointermove',
		'pointerout',
		'pointerover',
		'pointerup',
		'touchend',
		'touchmove',
		'touchstart'
	];

	/**
	 * Returns `true` if `event_name` is a delegated event
	 * @param {string} event_name
	 */
	function is_delegated(event_name) {
		return DELEGATED_EVENTS.includes(event_name);
	}

	/**
	 * @type {Record<string, string>}
	 * List of attribute names that should be aliased to their property names
	 * because they behave differently between setting them as an attribute and
	 * setting them as a property.
	 */
	const ATTRIBUTE_ALIASES = {
		// no `class: 'className'` because we handle that separately
		formnovalidate: 'formNoValidate',
		ismap: 'isMap',
		nomodule: 'noModule',
		playsinline: 'playsInline',
		readonly: 'readOnly'
	};

	/**
	 * @param {string} name
	 */
	function normalize_attribute(name) {
		name = name.toLowerCase();
		return ATTRIBUTE_ALIASES[name] ?? name;
	}

	/**
	 * Subset of delegated events which should be passive by default.
	 * These two are already passive via browser defaults on window, document and body.
	 * But since
	 * - we're delegating them
	 * - they happen often
	 * - they apply to mobile which is generally less performant
	 * we're marking them as passive by default for other elements, too.
	 */
	const PASSIVE_EVENTS = ['touchstart', 'touchmove'];

	/**
	 * Returns `true` if `name` is a passive event
	 * @param {string} name
	 */
	function is_passive_event(name) {
		return PASSIVE_EVENTS.includes(name);
	}

	/** @import { ComponentContext, Effect, TemplateNode } from '#client' */
	/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */

	/**
	 * This is normally true — block effects should run their intro transitions —
	 * but is false during hydration (unless `options.intro` is `true`) and
	 * when creating the children of a `<svelte:element>` that just changed tag
	 */
	let should_intro = true;

	/**
	 * @param {Element} text
	 * @param {string} value
	 * @returns {void}
	 */
	function set_text(text, value) {
		// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing
		var str = value == null ? '' : typeof value === 'object' ? value + '' : value;
		// @ts-expect-error
		if (str !== (text.__t ??= text.nodeValue)) {
			// @ts-expect-error
			text.__t = str;
			text.nodeValue = str == null ? '' : str + '';
		}
	}

	/**
	 * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.
	 * Transitions will play during the initial render unless the `intro` option is set to `false`.
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {MountOptions<Props>} options
	 * @returns {Exports}
	 */
	function mount(component, options) {
		return _mount(component, options);
	}

	/** @type {Map<string, number>} */
	const document_listeners = new Map();

	/**
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component
	 * @param {MountOptions} options
	 * @returns {Exports}
	 */
	function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
		init_operations();

		var registered_events = new Set();

		/** @param {Array<string>} events */
		var event_handle = (events) => {
			for (var i = 0; i < events.length; i++) {
				var event_name = events[i];

				if (registered_events.has(event_name)) continue;
				registered_events.add(event_name);

				var passive = is_passive_event(event_name);

				// Add the event listener to both the container and the document.
				// The container listener ensures we catch events from within in case
				// the outer content stops propagation of the event.
				target.addEventListener(event_name, handle_event_propagation, { passive });

				var n = document_listeners.get(event_name);

				if (n === undefined) {
					// The document listener ensures we catch events that originate from elements that were
					// manually moved outside of the container (e.g. via manual portals).
					document.addEventListener(event_name, handle_event_propagation, { passive });
					document_listeners.set(event_name, 1);
				} else {
					document_listeners.set(event_name, n + 1);
				}
			}
		};

		event_handle(array_from(all_registered_events));
		root_event_handles.add(event_handle);

		/** @type {Exports} */
		// @ts-expect-error will be defined because the render effect runs synchronously
		var component = undefined;

		var unmount = effect_root(() => {
			var anchor_node = anchor ?? target.appendChild(create_text());

			branch(() => {
				if (context) {
					push({});
					var ctx = /** @type {ComponentContext} */ (component_context);
					ctx.c = context;
				}

				if (events) {
					// We can't spread the object or else we'd lose the state proxy stuff, if it is one
					/** @type {any} */ (props).$$events = events;
				}

				should_intro = intro;
				// @ts-expect-error the public typings are not what the actual function looks like
				component = Component(anchor_node, props) || {};
				should_intro = true;

				if (context) {
					pop();
				}
			});

			return () => {
				for (var event_name of registered_events) {
					target.removeEventListener(event_name, handle_event_propagation);

					var n = /** @type {number} */ (document_listeners.get(event_name));

					if (--n === 0) {
						document.removeEventListener(event_name, handle_event_propagation);
						document_listeners.delete(event_name);
					} else {
						document_listeners.set(event_name, n);
					}
				}

				root_event_handles.delete(event_handle);
				mounted_components.delete(component);
				if (anchor_node !== anchor) {
					anchor_node.parentNode?.removeChild(anchor_node);
				}
			};
		});

		mounted_components.set(component, unmount);
		return component;
	}

	/**
	 * References of the components that were mounted or hydrated.
	 * Uses a `WeakMap` to avoid memory leaks.
	 */
	let mounted_components = new WeakMap();

	/**
	 * Unmounts a component that was previously mounted using `mount` or `hydrate`.
	 * @param {Record<string, any>} component
	 */
	function unmount(component) {
		const fn = mounted_components.get(component);

		if (fn) {
			fn();
		}
	}

	/** @param {Function & { [FILENAME]: string }} target */
	function check_target(target) {
		if (target) {
			component_api_invalid_new(target[FILENAME] ?? 'a component', target.name);
		}
	}

	function legacy_api() {
		const component = component_context?.function;

		/** @param {string} method */
		function error(method) {
			// @ts-expect-error
			const parent = get_component()?.[FILENAME] ?? 'Something';
			component_api_changed(parent, method, component[FILENAME]);
		}

		return {
			$destroy: () => error('$destroy()'),
			$on: () => error('$on(...)'),
			$set: () => error('$set(...)')
		};
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {TemplateNode} node
	 * @param {() => boolean} get_condition
	 * @param {(anchor: Node) => void} consequent_fn
	 * @param {null | ((anchor: Node) => void)} [alternate_fn]
	 * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'
	 * @returns {void}
	 */
	function if_block(node, get_condition, consequent_fn, alternate_fn = null, elseif = false) {

		var anchor = node;

		/** @type {Effect | null} */
		var consequent_effect = null;

		/** @type {Effect | null} */
		var alternate_effect = null;

		/** @type {boolean | null} */
		var condition = null;

		var flags = elseif ? EFFECT_TRANSPARENT : 0;

		block(() => {
			if (condition === (condition = !!get_condition())) return;

			if (condition) {
				if (consequent_effect) {
					resume_effect(consequent_effect);
				} else {
					consequent_effect = branch(() => consequent_fn(anchor));
				}

				if (alternate_effect) {
					pause_effect(alternate_effect, () => {
						alternate_effect = null;
					});
				}
			} else {
				if (alternate_effect) {
					resume_effect(alternate_effect);
				} else if (alternate_fn) {
					alternate_effect = branch(() => alternate_fn(anchor));
				}

				if (consequent_effect) {
					pause_effect(consequent_effect, () => {
						consequent_effect = null;
					});
				}
			}
		}, flags);
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @template V
	 * @param {TemplateNode} node
	 * @param {() => V} get_key
	 * @param {(anchor: Node) => TemplateNode | void} render_fn
	 * @returns {void}
	 */
	function key_block(node, get_key, render_fn) {

		var anchor = node;

		/** @type {V | typeof UNINITIALIZED} */
		var key = UNINITIALIZED;

		/** @type {Effect} */
		var effect;

		block(() => {
			if (safe_not_equal(key, (key = get_key()))) {
				if (effect) {
					pause_effect(effect);
				}

				effect = branch(() => render_fn(anchor));
			}
		});
	}

	/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */

	/**
	 * The row of a keyed each block that is currently updating. We track this
	 * so that `animate:` directives have something to attach themselves to
	 * @type {EachItem | null}
	 */
	let current_each_item = null;

	/**
	 * @param {any} _
	 * @param {number} i
	 */
	function index(_, i) {
		return i;
	}

	/**
	 * Pause multiple effects simultaneously, and coordinate their
	 * subsequent destruction. Used in each blocks
	 * @param {EachState} state
	 * @param {EachItem[]} items
	 * @param {null | Node} controlled_anchor
	 * @param {Map<any, EachItem>} items_map
	 */
	function pause_effects(state, items, controlled_anchor, items_map) {
		/** @type {TransitionManager[]} */
		var transitions = [];
		var length = items.length;

		for (var i = 0; i < length; i++) {
			pause_children(items[i].e, transitions, true);
		}

		var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;
		// If we have a controlled anchor, it means that the each block is inside a single
		// DOM element, so we can apply a fast-path for clearing the contents of the element.
		if (is_controlled) {
			var parent_node = /** @type {Element} */ (
				/** @type {Element} */ (controlled_anchor).parentNode
			);
			clear_text_content(parent_node);
			parent_node.append(/** @type {Element} */ (controlled_anchor));
			items_map.clear();
			link$1(state, items[0].prev, items[length - 1].next);
		}

		run_out_transitions(transitions, () => {
			for (var i = 0; i < length; i++) {
				var item = items[i];
				if (!is_controlled) {
					items_map.delete(item.k);
					link$1(state, item.prev, item.next);
				}
				destroy_effect(item.e, !is_controlled);
			}
		});
	}

	/**
	 * @template V
	 * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @param {(value: V, index: number) => any} get_key
	 * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn
	 * @param {null | ((anchor: Node) => void)} fallback_fn
	 * @returns {void}
	 */
	function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {
		var anchor = node;

		/** @type {EachState} */
		var state = { flags, items: new Map(), first: null };

		var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;

		if (is_controlled) {
			var parent_node = /** @type {Element} */ (node);

			anchor = parent_node.appendChild(create_text());
		}

		/** @type {Effect | null} */
		var fallback = null;

		var was_empty = false;

		block(() => {
			var collection = get_collection();

			var array = is_array(collection)
				? collection
				: collection == null
					? []
					: array_from(collection);

			var length = array.length;

			if (was_empty && length === 0) {
				// ignore updates if the array is empty,
				// and it already was empty on previous run
				return;
			}
			was_empty = length === 0;

			{
				var effect = /** @type {Effect} */ (active_reaction);
				reconcile(array, state, anchor, render_fn, flags, (effect.f & INERT) !== 0, get_key);
			}

			if (fallback_fn !== null) {
				if (length === 0) {
					if (fallback) {
						resume_effect(fallback);
					} else {
						fallback = branch(() => fallback_fn(anchor));
					}
				} else if (fallback !== null) {
					pause_effect(fallback, () => {
						fallback = null;
					});
				}
			}

			// When we mount the each block for the first time, the collection won't be
			// connected to this effect as the effect hasn't finished running yet and its deps
			// won't be assigned. However, it's possible that when reconciling the each block
			// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the
			// collection again can provide consistency to the reactive graph again as the deriveds
			// will now be `CLEAN`.
			get_collection();
		});
	}

	/**
	 * Add, remove, or reorder items output by an each block as its input changes
	 * @template V
	 * @param {Array<V>} array
	 * @param {EachState} state
	 * @param {Element | Comment | Text} anchor
	 * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>) => void} render_fn
	 * @param {number} flags
	 * @param {boolean} is_inert
	 * @param {(value: V, index: number) => any} get_key
	 * @returns {void}
	 */
	function reconcile(array, state, anchor, render_fn, flags, is_inert, get_key) {
		var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
		var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;

		var length = array.length;
		var items = state.items;
		var first = state.first;
		var current = first;

		/** @type {undefined | Set<EachItem>} */
		var seen;

		/** @type {EachItem | null} */
		var prev = null;

		/** @type {undefined | Set<EachItem>} */
		var to_animate;

		/** @type {EachItem[]} */
		var matched = [];

		/** @type {EachItem[]} */
		var stashed = [];

		/** @type {V} */
		var value;

		/** @type {any} */
		var key;

		/** @type {EachItem | undefined} */
		var item;

		/** @type {number} */
		var i;

		if (is_animated) {
			for (i = 0; i < length; i += 1) {
				value = array[i];
				key = get_key(value, i);
				item = items.get(key);

				if (item !== undefined) {
					item.a?.measure();
					(to_animate ??= new Set()).add(item);
				}
			}
		}

		for (i = 0; i < length; i += 1) {
			value = array[i];
			key = get_key(value, i);
			item = items.get(key);

			if (item === undefined) {
				var child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;

				prev = create_item(
					child_anchor,
					state,
					prev,
					prev === null ? state.first : prev.next,
					value,
					key,
					i,
					render_fn,
					flags
				);

				items.set(key, prev);

				matched = [];
				stashed = [];

				current = prev.next;
				continue;
			}

			if (should_update) {
				update_item(item, value, i, flags);
			}

			if ((item.e.f & INERT) !== 0) {
				resume_effect(item.e);
				if (is_animated) {
					item.a?.unfix();
					(to_animate ??= new Set()).delete(item);
				}
			}

			if (item !== current) {
				if (seen !== undefined && seen.has(item)) {
					if (matched.length < stashed.length) {
						// more efficient to move later items to the front
						var start = stashed[0];
						var j;

						prev = start.prev;

						var a = matched[0];
						var b = matched[matched.length - 1];

						for (j = 0; j < matched.length; j += 1) {
							move(matched[j], start, anchor);
						}

						for (j = 0; j < stashed.length; j += 1) {
							seen.delete(stashed[j]);
						}

						link$1(state, a.prev, b.next);
						link$1(state, prev, a);
						link$1(state, b, start);

						current = start;
						prev = b;
						i -= 1;

						matched = [];
						stashed = [];
					} else {
						// more efficient to move earlier items to the back
						seen.delete(item);
						move(item, current, anchor);

						link$1(state, item.prev, item.next);
						link$1(state, item, prev === null ? state.first : prev.next);
						link$1(state, prev, item);

						prev = item;
					}

					continue;
				}

				matched = [];
				stashed = [];

				while (current !== null && current.k !== key) {
					// If the each block isn't inert and an item has an effect that is already inert,
					// skip over adding it to our seen Set as the item is already being handled
					if (is_inert || (current.e.f & INERT) === 0) {
						(seen ??= new Set()).add(current);
					}
					stashed.push(current);
					current = current.next;
				}

				if (current === null) {
					continue;
				}

				item = current;
			}

			matched.push(item);
			prev = item;
			current = item.next;
		}

		if (current !== null || seen !== undefined) {
			var to_destroy = seen === undefined ? [] : array_from(seen);

			while (current !== null) {
				// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished
				if (is_inert || (current.e.f & INERT) === 0) {
					to_destroy.push(current);
				}
				current = current.next;
			}

			var destroy_length = to_destroy.length;

			if (destroy_length > 0) {
				var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;

				if (is_animated) {
					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.measure();
					}

					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.fix();
					}
				}

				pause_effects(state, to_destroy, controlled_anchor, items);
			}
		}

		if (is_animated) {
			queue_micro_task(() => {
				if (to_animate === undefined) return;
				for (item of to_animate) {
					item.a?.apply();
				}
			});
		}

		/** @type {Effect} */ (active_effect).first = state.first && state.first.e;
		/** @type {Effect} */ (active_effect).last = prev && prev.e;
	}

	/**
	 * @param {EachItem} item
	 * @param {any} value
	 * @param {number} index
	 * @param {number} type
	 * @returns {void}
	 */
	function update_item(item, value, index, type) {
		if ((type & EACH_ITEM_REACTIVE) !== 0) {
			internal_set(item.v, value);
		}

		if ((type & EACH_INDEX_REACTIVE) !== 0) {
			internal_set(/** @type {Value<number>} */ (item.i), index);
		} else {
			item.i = index;
		}
	}

	/**
	 * @template V
	 * @param {Node} anchor
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 * @param {V} value
	 * @param {unknown} key
	 * @param {number} index
	 * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>) => void} render_fn
	 * @param {number} flags
	 * @returns {EachItem}
	 */
	function create_item(anchor, state, prev, next, value, key, index, render_fn, flags) {
		var previous_each_item = current_each_item;

		try {
			var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
			var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;

			var v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;
			var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);

			/** @type {EachItem} */
			var item = {
				i,
				v,
				k: key,
				a: null,
				// @ts-expect-error
				e: null,
				prev,
				next
			};

			current_each_item = item;
			item.e = branch(() => render_fn(anchor, v, i), hydrating);

			item.e.prev = prev && prev.e;
			item.e.next = next && next.e;

			if (prev === null) {
				state.first = item;
			} else {
				prev.next = item;
				prev.e.next = item.e;
			}

			if (next !== null) {
				next.prev = item;
				next.e.prev = item.e;
			}

			return item;
		} finally {
			current_each_item = previous_each_item;
		}
	}

	/**
	 * @param {EachItem} item
	 * @param {EachItem | null} next
	 * @param {Text | Element | Comment} anchor
	 */
	function move(item, next, anchor) {
		var end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;

		var dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;
		var node = /** @type {TemplateNode} */ (item.e.nodes_start);

		while (node !== end) {
			var next_node = /** @type {TemplateNode} */ (get_next_sibling(node));
			dest.before(node);
			node = next_node;
		}
	}

	/**
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 */
	function link$1(state, prev, next) {
		if (prev === null) {
			state.first = next;
		} else {
			prev.next = next;
			prev.e.next = next && next.e;
		}

		if (next !== null) {
			next.prev = prev;
			next.e.prev = prev && prev.e;
		}
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {Element | Text | Comment} node
	 * @param {() => string} get_value
	 * @param {boolean} svg
	 * @param {boolean} mathml
	 * @param {boolean} [skip_warning]
	 * @returns {void}
	 */
	function html(node, get_value, svg, mathml, skip_warning) {
		var anchor = node;

		var value = '';

		/** @type {Effect | undefined} */
		var effect;

		block(() => {
			if (value === (value = get_value() ?? '')) {
				return;
			}

			if (effect !== undefined) {
				destroy_effect(effect);
				effect = undefined;
			}

			if (value === '') return;

			effect = branch(() => {

				var html = value + '';

				// Don't use create_fragment_with_script_from_html here because that would mean script tags are executed.
				// @html is basically `.innerHTML = ...` and that doesn't execute scripts either due to security reasons.
				/** @type {DocumentFragment | Element} */
				var node = create_fragment_from_html(html);

				assign_nodes(
					/** @type {TemplateNode} */ (get_first_child(node)),
					/** @type {TemplateNode} */ (node.lastChild)
				);

				{
					anchor.before(node);
				}
			});
		});
	}

	/**
	 * @param {Comment} anchor
	 * @param {Record<string, any>} $$props
	 * @param {string} name
	 * @param {Record<string, unknown>} slot_props
	 * @param {null | ((anchor: Comment) => void)} fallback_fn
	 */
	function slot(anchor, $$props, name, slot_props, fallback_fn) {

		var slot_fn = $$props.$$slots?.[name];
		// Interop: Can use snippets to fill slots
		var is_interop = false;
		if (slot_fn === true) {
			slot_fn = $$props['children' ];
			is_interop = true;
		}

		if (slot_fn === undefined) ; else {
			slot_fn(anchor, is_interop ? () => slot_props : slot_props);
		}
	}

	/** @import { Snippet } from 'svelte' */
	/** @import { Effect, TemplateNode } from '#client' */
	/** @import { Getters } from '#shared' */

	/**
	 * @template {(node: TemplateNode, ...args: any[]) => void} SnippetFn
	 * @param {TemplateNode} node
	 * @param {() => SnippetFn | null | undefined} get_snippet
	 * @param {(() => any)[]} args
	 * @returns {void}
	 */
	function snippet(node, get_snippet, ...args) {
		var anchor = node;

		/** @type {SnippetFn | null | undefined} */
		// @ts-ignore
		var snippet = noop;

		/** @type {Effect | null} */
		var snippet_effect;

		block(() => {
			if (snippet === (snippet = get_snippet())) return;

			if (snippet_effect) {
				destroy_effect(snippet_effect);
				snippet_effect = null;
			}

			snippet_effect = branch(() => /** @type {SnippetFn} */ (snippet)(anchor, ...args));
		}, EFFECT_TRANSPARENT);
	}

	/**
	 * In development, wrap the snippet function so that it passes validation, and so that the
	 * correct component context is set for ownership checks
	 * @param {any} component
	 * @param {(node: TemplateNode, ...args: any[]) => void} fn
	 */
	function wrap_snippet(component, fn) {
		return (/** @type {TemplateNode} */ node, /** @type {any[]} */ ...args) => {

			try {
				return fn(node, ...args);
			} finally {
			}
		};
	}

	/** @import { TemplateNode, Dom, Effect } from '#client' */

	/**
	 * @template P
	 * @template {(props: P) => void} C
	 * @param {TemplateNode} node
	 * @param {() => C} get_component
	 * @param {(anchor: TemplateNode, component: C) => Dom | void} render_fn
	 * @returns {void}
	 */
	function component(node, get_component, render_fn) {

		var anchor = node;

		/** @type {C} */
		var component;

		/** @type {Effect | null} */
		var effect;

		block(() => {
			if (component === (component = get_component())) return;

			if (effect) {
				pause_effect(effect);
				effect = null;
			}

			if (component) {
				effect = branch(() => render_fn(anchor, component));
			}
		}, EFFECT_TRANSPARENT);
	}

	/** @import { ActionPayload } from '#client' */

	/**
	 * @template P
	 * @param {Element} dom
	 * @param {(dom: Element, value?: P) => ActionPayload<P>} action
	 * @param {() => P} [get_value]
	 * @returns {void}
	 */
	function action(dom, action, get_value) {
		effect$3(() => {
			var payload = untrack(() => action(dom, get_value?.()) || {});

			if (get_value && payload?.update) {
				var inited = false;
				/** @type {P} */
				var prev = /** @type {any} */ ({}); // initialize with something so it's never equal on first run

				render_effect(() => {
					var value = get_value();

					// Action's update method is coarse-grained, i.e. when anything in the passed value changes, update.
					// This works in legacy mode because of mutable_source being updated as a whole, but when using $state
					// together with actions and mutation, it wouldn't notice the change without a deep read.
					deep_read_state(value);

					if (inited && safe_not_equal(prev, value)) {
						prev = value;
						/** @type {Function} */ (payload.update)(value);
					}
				});

				inited = true;
			}

			if (payload?.destroy) {
				return () => /** @type {Function} */ (payload.destroy)();
			}
		});
	}

	/**
	 * @param {HTMLElement} dom
	 * @param {boolean} value
	 * @returns {void}
	 */
	function autofocus(dom, value) {
		if (value) {
			const body = document.body;
			dom.autofocus = true;

			queue_micro_task(() => {
				if (document.activeElement === body) {
					dom.focus();
				}
			});
		}
	}

	let listening_to_form_reset = false;

	function add_form_reset_listener() {
		if (!listening_to_form_reset) {
			listening_to_form_reset = true;
			document.addEventListener(
				'reset',
				(evt) => {
					// Needs to happen one tick later or else the dom properties of the form
					// elements have not updated to their reset values yet
					Promise.resolve().then(() => {
						if (!evt.defaultPrevented) {
							for (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {
								// @ts-expect-error
								e.__on_r?.();
							}
						}
					});
				},
				// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
				{ capture: true }
			);
		}
	}

	/**
	 * @param {Element} element
	 * @param {string} attribute
	 * @param {string | null} value
	 * @param {boolean} [skip_warning]
	 */
	function set_attribute(element, attribute, value, skip_warning) {
		// @ts-expect-error
		var attributes = (element.__attributes ??= {});

		if (attributes[attribute] === (attributes[attribute] = value)) return;

		if (attribute === 'style' && '__styles' in element) {
			// reset styles to force style: directive to update
			element.__styles = {};
		}

		if (attribute === 'loading') {
			// @ts-expect-error
			element[LOADING_ATTR_SYMBOL] = value;
		}

		if (value == null) {
			element.removeAttribute(attribute);
		} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {
			// @ts-ignore
			element[attribute] = value;
		} else {
			element.setAttribute(attribute, value);
		}
	}

	/**
	 * @param {Element} dom
	 * @param {string} attribute
	 * @param {string} value
	 */
	function set_xlink_attribute(dom, attribute, value) {
		dom.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
	}

	/**
	 * Spreads attributes onto a DOM element, taking into account the currently set attributes
	 * @param {Element & ElementCSSInlineStyle} element
	 * @param {Record<string, any> | undefined} prev
	 * @param {Record<string, any>} next New attributes - this function mutates this object
	 * @param {string} [css_hash]
	 * @param {boolean} [preserve_attribute_case]
	 * @param {boolean} [is_custom_element]
	 * @param {boolean} [skip_warning]
	 * @returns {Record<string, any>}
	 */
	function set_attributes(
		element,
		prev,
		next,
		css_hash,
		preserve_attribute_case = false,
		is_custom_element = false,
		skip_warning = false
	) {
		var current = prev || {};
		var is_option_element = element.tagName === 'OPTION';

		for (var key in prev) {
			if (!(key in next)) {
				next[key] = null;
			}
		}

		{
			next.class = next.class ? next.class + ' ' + css_hash : css_hash;
		}

		var setters = get_setters(element);

		// @ts-expect-error
		var attributes = /** @type {Record<string, unknown>} **/ (element.__attributes ??= {});
		/** @type {Array<[string, any, () => void]>} */
		var events = [];

		// since key is captured we use const
		for (const key in next) {
			// let instead of var because referenced in a closure
			let value = next[key];

			// Up here because we want to do this for the initial value, too, even if it's undefined,
			// and this wouldn't be reached in case of undefined because of the equality check below
			if (is_option_element && key === 'value' && value == null) {
				// The <option> element is a special case because removing the value attribute means
				// the value is set to the text content of the option element, and setting the value
				// to null or undefined means the value is set to the string "null" or "undefined".
				// To align with how we handle this case in non-spread-scenarios, this logic is needed.
				// There's a super-edge-case bug here that is left in in favor of smaller code size:
				// Because of the "set missing props to null" logic above, we can't differentiate
				// between a missing value and an explicitly set value of null or undefined. That means
				// that once set, the value attribute of an <option> element can't be removed. This is
				// a very rare edge case, and removing the attribute altogether isn't possible either
				// for the <option value={undefined}> case, so we're not losing any functionality here.
				// @ts-ignore
				element.value = element.__value = '';
				current[key] = value;
				continue;
			}

			var prev_value = current[key];
			if (value === prev_value) continue;

			current[key] = value;

			var prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)
			if (prefix === '$$') continue;

			if (prefix === 'on') {
				/** @type {{ capture?: true }} */
				const opts = {};
				const event_handle_key = '$$' + key;
				let event_name = key.slice(2);
				var delegated = is_delegated(event_name);

				if (is_capture_event(event_name)) {
					event_name = event_name.slice(0, -7);
					opts.capture = true;
				}

				if (!delegated && prev_value) {
					// Listening to same event but different handler -> our handle function below takes care of this
					// If we were to remove and add listeners in this case, it could happen that the event is "swallowed"
					// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler
					// https://github.com/sveltejs/svelte/issues/11903
					if (value != null) continue;

					element.removeEventListener(event_name, current[event_handle_key], opts);
					current[event_handle_key] = null;
				}

				if (value != null) {
					if (!delegated) {
						/**
						 * @this {any}
						 * @param {Event} evt
						 */
						function handle(evt) {
							current[key].call(this, evt);
						}

						if (!prev) {
							events.push([
								key,
								value,
								() => (current[event_handle_key] = create_event(event_name, element, handle, opts))
							]);
						} else {
							current[event_handle_key] = create_event(event_name, element, handle, opts);
						}
					} else {
						// @ts-ignore
						element[`__${event_name}`] = value;
						delegate([event_name]);
					}
				}
			} else if (key === 'style' && value != null) {
				element.style.cssText = value + '';
			} else if (key === 'autofocus') {
				autofocus(/** @type {HTMLElement} */ (element), Boolean(value));
			} else if (key === '__value' || (key === 'value' && value != null)) {
				// @ts-ignore
				element.value = element[key] = element.__value = value;
			} else {
				var name = key;
				if (!preserve_attribute_case) {
					name = normalize_attribute(name);
				}

				if (value == null && !is_custom_element) {
					attributes[key] = null;
					element.removeAttribute(key);
				} else if (setters.includes(name) && (is_custom_element || typeof value !== 'string')) {
					// @ts-ignore
					element[name] = value;
				} else if (typeof value !== 'function') {
					{
						set_attribute(element, name, value);
					}
				}
			}
			if (key === 'style' && '__styles' in element) {
				// reset styles to force style: directive to update
				element.__styles = {};
			}
		}

		// On the first run, ensure that events are added after bindings so
		// that their listeners fire after the binding listeners
		if (!prev) {
			queue_micro_task(() => {
				if (!element.isConnected) return;
				for (const [key, value, evt] of events) {
					if (current[key] === value) {
						evt();
					}
				}
			});
		}

		return current;
	}

	/** @type {Map<string, string[]>} */
	var setters_cache = new Map();

	/** @param {Element} element */
	function get_setters(element) {
		var setters = setters_cache.get(element.nodeName);
		if (setters) return setters;
		setters_cache.set(element.nodeName, (setters = []));
		var descriptors;
		var proto = get_prototype_of(element);
		var element_proto = Element.prototype;

		// Stop at Element, from there on there's only unnecessary setters we're not interested in
		// Do not use contructor.name here as that's unreliable in some browser environments
		while (element_proto !== proto) {
			descriptors = get_descriptors(proto);

			for (var key in descriptors) {
				if (descriptors[key].set) {
					setters.push(key);
				}
			}

			proto = get_prototype_of(proto);
		}

		return setters;
	}

	/**
	 * @param {SVGElement} dom
	 * @param {string} value
	 * @returns {void}
	 */
	function set_svg_class(dom, value) {
		// @ts-expect-error need to add __className to patched prototype
		var prev_class_name = dom.__className;
		var next_class_name = to_class(value);

		if (
			prev_class_name !== next_class_name ||
			(hydrating)
		) {
			if (next_class_name === '') {
				dom.removeAttribute('class');
			} else {
				dom.setAttribute('class', next_class_name);
			}

			// @ts-expect-error need to add __className to patched prototype
			dom.__className = next_class_name;
		}
	}

	/**
	 * @param {HTMLElement} dom
	 * @param {string} value
	 * @returns {void}
	 */
	function set_class(dom, value) {
		// @ts-expect-error need to add __className to patched prototype
		var prev_class_name = dom.__className;
		var next_class_name = to_class(value);

		if (
			prev_class_name !== next_class_name ||
			(hydrating)
		) {
			// Removing the attribute when the value is only an empty string causes
			// peformance issues vs simply making the className an empty string. So
			// we should only remove the class if the the value is nullish.
			if (value == null) {
				dom.removeAttribute('class');
			} else {
				dom.className = next_class_name;
			}

			// @ts-expect-error need to add __className to patched prototype
			dom.__className = next_class_name;
		}
	}

	/**
	 * @template V
	 * @param {V} value
	 * @returns {string | V}
	 */
	function to_class(value) {
		return value == null ? '' : value;
	}

	/**
	 * @param {Element} dom
	 * @param {string} class_name
	 * @param {boolean} value
	 * @returns {void}
	 */
	function toggle_class(dom, class_name, value) {
		if (value) {
			if (dom.classList.contains(class_name)) return;
			dom.classList.add(class_name);
		} else {
			if (!dom.classList.contains(class_name)) return;
			dom.classList.remove(class_name);
		}
	}

	/** @import { Raf } from '#client' */

	const now = () => performance.now() ;

	/** @type {Raf} */
	const raf = {
		// don't access requestAnimationFrame eagerly outside method
		// this allows basic testing of user code without JSDOM
		// bunder will eval and remove ternary when the user's app is built
		tick: /** @param {any} _ */ (_) => (requestAnimationFrame )(_),
		now: () => now(),
		tasks: new Set()
	};

	/** @import { TaskCallback, Task, TaskEntry } from '#client' */

	// TODO move this into timing.js where it probably belongs

	/**
	 * @param {number} now
	 * @returns {void}
	 */
	function run_tasks(now) {
		raf.tasks.forEach((task) => {
			if (!task.c(now)) {
				raf.tasks.delete(task);
				task.f();
			}
		});

		if (raf.tasks.size !== 0) {
			raf.tick(run_tasks);
		}
	}

	/**
	 * Creates a new task that runs on each raf frame
	 * until it returns a falsy value or is aborted
	 * @param {TaskCallback} callback
	 * @returns {Task}
	 */
	function loop(callback) {
		/** @type {TaskEntry} */
		let task;

		if (raf.tasks.size === 0) {
			raf.tick(run_tasks);
		}

		return {
			promise: new Promise((fulfill) => {
				raf.tasks.add((task = { c: callback, f: fulfill }));
			}),
			abort() {
				raf.tasks.delete(task);
			}
		};
	}

	/** @import { AnimateFn, Animation, AnimationConfig, EachItem, Effect, TransitionFn, TransitionManager } from '#client' */

	/**
	 * @param {Element} element
	 * @param {'introstart' | 'introend' | 'outrostart' | 'outroend'} type
	 * @returns {void}
	 */
	function dispatch_event(element, type) {
		element.dispatchEvent(new CustomEvent(type));
	}

	/**
	 * Converts a property to the camel-case format expected by Element.animate(), KeyframeEffect(), and KeyframeEffect.setKeyframes().
	 * @param {string} style
	 * @returns {string}
	 */
	function css_property_to_camelcase(style) {
		// in compliance with spec
		if (style === 'float') return 'cssFloat';
		if (style === 'offset') return 'cssOffset';

		// do not rename custom @properties
		if (style.startsWith('--')) return style;

		const parts = style.split('-');
		if (parts.length === 1) return parts[0];
		return (
			parts[0] +
			parts
				.slice(1)
				.map(/** @param {any} word */ (word) => word[0].toUpperCase() + word.slice(1))
				.join('')
		);
	}

	/**
	 * @param {string} css
	 * @returns {Keyframe}
	 */
	function css_to_keyframe(css) {
		/** @type {Keyframe} */
		const keyframe = {};
		const parts = css.split(';');
		for (const part of parts) {
			const [property, value] = part.split(':');
			if (!property || value === undefined) break;

			const formatted_property = css_property_to_camelcase(property.trim());
			keyframe[formatted_property] = value.trim();
		}
		return keyframe;
	}

	/** @param {number} t */
	const linear = (t) => t;

	/**
	 * Called inside block effects as `$.transition(...)`. This creates a transition manager and
	 * attaches it to the current effect — later, inside `pause_effect` and `resume_effect`, we
	 * use this to create `intro` and `outro` transitions.
	 * @template P
	 * @param {number} flags
	 * @param {HTMLElement} element
	 * @param {() => TransitionFn<P | undefined>} get_fn
	 * @param {(() => P) | null} get_params
	 * @returns {void}
	 */
	function transition(flags, element, get_fn, get_params) {
		var is_intro = (flags & TRANSITION_IN) !== 0;
		var is_outro = (flags & TRANSITION_OUT) !== 0;
		var is_both = is_intro && is_outro;
		var is_global = (flags & TRANSITION_GLOBAL) !== 0;

		/** @type {'in' | 'out' | 'both'} */
		var direction = is_both ? 'both' : is_intro ? 'in' : 'out';

		/** @type {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig) | undefined} */
		var current_options;

		var inert = element.inert;

		/** @type {Animation | undefined} */
		var intro;

		/** @type {Animation | undefined} */
		var outro;

		function get_options() {
			var previous_reaction = active_reaction;
			var previous_effect = active_effect;
			set_active_reaction(null);
			set_active_effect(null);
			try {
				// If a transition is still ongoing, we use the existing options rather than generating
				// new ones. This ensures that reversible transitions reverse smoothly, rather than
				// jumping to a new spot because (for example) a different `duration` was used
				return (current_options ??= get_fn()(element, get_params?.() ?? /** @type {P} */ ({}), {
					direction
				}));
			} finally {
				set_active_reaction(previous_reaction);
				set_active_effect(previous_effect);
			}
		}

		/** @type {TransitionManager} */
		var transition = {
			is_global,
			in() {
				element.inert = inert;

				if (!is_intro) {
					outro?.abort();
					outro?.reset?.();
					return;
				}

				if (!is_outro) {
					// if we intro then outro then intro again, we want to abort the first intro,
					// if it's not a bidirectional transition
					intro?.abort();
				}

				dispatch_event(element, 'introstart');

				intro = animate(element, get_options(), outro, 1, () => {
					dispatch_event(element, 'introend');

					// Ensure we cancel the animation to prevent leaking
					intro?.abort();
					intro = current_options = undefined;
				});
			},
			out(fn) {
				if (!is_outro) {
					fn?.();
					current_options = undefined;
					return;
				}

				element.inert = true;

				dispatch_event(element, 'outrostart');

				outro = animate(element, get_options(), intro, 0, () => {
					dispatch_event(element, 'outroend');
					fn?.();
				});
			},
			stop: () => {
				intro?.abort();
				outro?.abort();
			}
		};

		var e = /** @type {Effect} */ (active_effect);

		(e.transitions ??= []).push(transition);

		// if this is a local transition, we only want to run it if the parent (branch) effect's
		// parent (block) effect is where the state change happened. we can determine that by
		// looking at whether the block effect is currently initializing
		if (is_intro && should_intro) {
			var run = is_global;

			if (!run) {
				var block = /** @type {Effect | null} */ (e.parent);

				// skip over transparent blocks (e.g. snippets, else-if blocks)
				while (block && (block.f & EFFECT_TRANSPARENT) !== 0) {
					while ((block = block.parent)) {
						if ((block.f & BLOCK_EFFECT) !== 0) break;
					}
				}

				run = !block || (block.f & EFFECT_RAN) !== 0;
			}

			if (run) {
				effect$3(() => {
					untrack(() => transition.in());
				});
			}
		}
	}

	/**
	 * Animates an element, according to the provided configuration
	 * @param {Element} element
	 * @param {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig)} options
	 * @param {Animation | undefined} counterpart The corresponding intro/outro to this outro/intro
	 * @param {number} t2 The target `t` value — `1` for intro, `0` for outro
	 * @param {(() => void)} on_finish Called after successfully completing the animation
	 * @returns {Animation}
	 */
	function animate(element, options, counterpart, t2, on_finish) {
		var is_intro = t2 === 1;

		if (is_function(options)) {
			// In the case of a deferred transition (such as `crossfade`), `option` will be
			// a function rather than an `AnimationConfig`. We need to call this function
			// once the DOM has been updated...
			/** @type {Animation} */
			var a;
			var aborted = false;

			queue_micro_task(() => {
				if (aborted) return;
				var o = options({ direction: is_intro ? 'in' : 'out' });
				a = animate(element, o, counterpart, t2, on_finish);
			});

			// ...but we want to do so without using `async`/`await` everywhere, so
			// we return a facade that allows everything to remain synchronous
			return {
				abort: () => {
					aborted = true;
					a?.abort();
				},
				deactivate: () => a.deactivate(),
				reset: () => a.reset(),
				t: () => a.t()
			};
		}

		counterpart?.deactivate();

		if (!options?.duration) {
			on_finish();

			return {
				abort: noop,
				deactivate: noop,
				reset: noop,
				t: () => t2
			};
		}

		const { delay = 0, css, tick, easing = linear } = options;

		var keyframes = [];

		if (is_intro && counterpart === undefined) {
			if (tick) {
				tick(0, 1); // TODO put in nested effect, to avoid interleaved reads/writes?
			}

			if (css) {
				var styles = css_to_keyframe(css(0, 1));
				keyframes.push(styles, styles);
			}
		}

		var get_t = () => 1 - t2;

		// create a dummy animation that lasts as long as the delay (but with whatever devtools
		// multiplier is in effect). in the common case that it is `0`, we keep it anyway so that
		// the CSS keyframes aren't created until the DOM is updated
		var animation = element.animate(keyframes, { duration: delay });

		animation.onfinish = () => {
			// for bidirectional transitions, we start from the current position,
			// rather than doing a full intro/outro
			var t1 = counterpart?.t() ?? 1 - t2;
			counterpart?.abort();

			var delta = t2 - t1;
			var duration = /** @type {number} */ (options.duration) * Math.abs(delta);
			var keyframes = [];

			if (duration > 0) {
				if (css) {
					var n = Math.ceil(duration / (1000 / 60)); // `n` must be an integer, or we risk missing the `t2` value

					for (var i = 0; i <= n; i += 1) {
						var t = t1 + delta * easing(i / n);
						var styles = css(t, 1 - t);
						keyframes.push(css_to_keyframe(styles));
					}
				}

				get_t = () => {
					var time = /** @type {number} */ (
						/** @type {globalThis.Animation} */ (animation).currentTime
					);

					return t1 + delta * easing(time / duration);
				};

				if (tick) {
					loop(() => {
						if (animation.playState !== 'running') return false;

						var t = get_t();
						tick(t, 1 - t);

						return true;
					});
				}
			}

			animation = element.animate(keyframes, { duration, fill: 'forwards' });

			animation.onfinish = () => {
				get_t = () => t2;
				tick?.(t2, 1 - t2);
				on_finish();
			};
		};

		return {
			abort: () => {
				if (animation) {
					animation.cancel();
					// This prevents memory leaks in Chromium
					animation.effect = null;
					// This prevents onfinish to be launched after cancel(),
					// which can happen in some rare cases
					// see https://github.com/sveltejs/svelte/issues/13681
					animation.onfinish = noop;
				}
			},
			deactivate: () => {
				on_finish = noop;
			},
			reset: () => {
				if (t2 === 0) {
					tick?.(1, 0);
				}
			},
			t: () => get_t()
		};
	}

	/**
	 * Listen to the given event, and then instantiate a global form reset listener if not already done,
	 * to notify all bindings when the form is reset
	 * @param {HTMLElement} element
	 * @param {string} event
	 * @param {() => void} handler
	 * @param {() => void} [on_reset]
	 */
	function listen_to_event_and_reset_event(element, event, handler, on_reset = handler) {
		element.addEventListener(event, handler);
		// @ts-expect-error
		const prev = element.__on_r;
		if (prev) {
			// special case for checkbox that can have multiple binds (group & checked)
			// @ts-expect-error
			element.__on_r = () => {
				prev();
				on_reset();
			};
		} else {
			// @ts-expect-error
			element.__on_r = on_reset;
		}

		add_form_reset_listener();
	}

	/**
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_value(input, get, set = get) {
		var runes = is_runes();

		listen_to_event_and_reset_event(input, 'input', () => {

			/** @type {unknown} */
			var value = is_numberlike_input(input) ? to_number(input.value) : input.value;
			set(value);

			// In runes mode, respect any validation in accessors (doesn't apply in legacy mode,
			// because we use mutable state which ensures the render effect always runs)
			if (runes && value !== (value = get())) {
				// @ts-expect-error the value is coerced on assignment
				input.value = value ?? '';
			}
		});

		render_effect(() => {

			var value = get();

			if (is_numberlike_input(input) && value === to_number(input.value)) {
				// handles 0 vs 00 case (see https://github.com/sveltejs/svelte/issues/9959)
				return;
			}

			if (input.type === 'date' && !value && !input.value) {
				// Handles the case where a temporarily invalid date is set (while typing, for example with a leading 0 for the day)
				// and prevents this state from clearing the other parts of the date input (see https://github.com/sveltejs/svelte/issues/7897)
				return;
			}

			// don't set the value of the input if it's the same to allow
			// minlength to work properly
			if (value !== input.value) {
				// @ts-expect-error the value is coerced on assignment
				input.value = value ?? '';
			}
		});
	}

	/**
	 * @param {HTMLInputElement} input
	 */
	function is_numberlike_input(input) {
		var type = input.type;
		return type === 'number' || type === 'range';
	}

	/**
	 * @param {string} value
	 */
	function to_number(value) {
		return value === '' ? null : +value;
	}

	/**
	 * Selects the correct option(s) (depending on whether this is a multiple select)
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {V} value
	 * @param {boolean} [mounting]
	 */
	function select_option(select, value, mounting) {
		if (select.multiple) {
			return select_options(select, value);
		}

		for (var option of select.options) {
			var option_value = get_option_value(option);
			if (is(option_value, value)) {
				option.selected = true;
				return;
			}
		}

		if (!mounting || value !== undefined) {
			select.selectedIndex = -1; // no option should be selected
		}
	}

	/**
	 * Selects the correct option(s) if `value` is given,
	 * and then sets up a mutation observer to sync the
	 * current selection to the dom when it changes. Such
	 * changes could for example occur when options are
	 * inside an `#each` block.
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {() => V} [get_value]
	 */
	function init_select(select, get_value) {
		effect$3(() => {

			var observer = new MutationObserver(() => {
				// @ts-ignore
				var value = select.__value;
				select_option(select, value);
				// Deliberately don't update the potential binding value,
				// the model should be preserved unless explicitly changed
			});

			observer.observe(select, {
				// Listen to option element changes
				childList: true,
				subtree: true, // because of <optgroup>
				// Listen to option element value attribute changes
				// (doesn't get notified of select value changes,
				// because that property is not reflected as an attribute)
				attributes: true,
				attributeFilter: ['value']
			});

			return () => {
				observer.disconnect();
			};
		});
	}

	/**
	 * @param {HTMLSelectElement} select
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_select_value(select, get, set = get) {
		var mounting = true;

		listen_to_event_and_reset_event(select, 'change', () => {
			/** @type {unknown} */
			var value;

			if (select.multiple) {
				value = [].map.call(select.querySelectorAll(':checked'), get_option_value);
			} else {
				/** @type {HTMLOptionElement | null} */
				var selected_option = select.querySelector(':checked');
				value = selected_option && get_option_value(selected_option);
			}

			set(value);
		});

		// Needs to be an effect, not a render_effect, so that in case of each loops the logic runs after the each block has updated
		effect$3(() => {
			var value = get();
			select_option(select, value, mounting);

			// Mounting and value undefined -> take selection from dom
			if (mounting && value === undefined) {
				/** @type {HTMLOptionElement | null} */
				var selected_option = select.querySelector(':checked');
				if (selected_option !== null) {
					value = get_option_value(selected_option);
					set(value);
				}
			}

			// @ts-ignore
			select.__value = value;
			mounting = false;
		});

		// don't pass get_value, we already initialize it in the effect above
		init_select(select);
	}

	/**
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {V} value
	 */
	function select_options(select, value) {
		for (var option of select.options) {
			// @ts-ignore
			option.selected = ~value.indexOf(get_option_value(option));
		}
	}

	/** @param {HTMLOptionElement} option */
	function get_option_value(option) {
		// __value only exists if the <option> has a value attribute
		if ('__value' in option) {
			return option.__value;
		} else {
			return option.value;
		}
	}

	/**
	 * @param {any} bound_value
	 * @param {Element} element_or_component
	 * @returns {boolean}
	 */
	function is_bound_this(bound_value, element_or_component) {
		return (
			bound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component
		);
	}

	/**
	 * @param {any} element_or_component
	 * @param {(value: unknown, ...parts: unknown[]) => void} update
	 * @param {(...parts: unknown[]) => unknown} get_value
	 * @param {() => unknown[]} [get_parts] Set if the this binding is used inside an each block,
	 * 										returns all the parts of the each block context that are used in the expression
	 * @returns {void}
	 */
	function bind_this(element_or_component = {}, update, get_value, get_parts) {
		effect$3(() => {
			/** @type {unknown[]} */
			var old_parts;

			/** @type {unknown[]} */
			var parts;

			render_effect(() => {
				old_parts = parts;
				// We only track changes to the parts, not the value itself to avoid unnecessary reruns.
				parts = [];

				untrack(() => {
					if (element_or_component !== get_value(...parts)) {
						update(element_or_component, ...parts);
						// If this is an effect rerun (cause: each block context changes), then nullfiy the binding at
						// the previous position if it isn't already taken over by a different effect.
						if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
							update(null, ...old_parts);
						}
					}
				});
			});

			return () => {
				// We cannot use effects in the teardown phase, we we use a microtask instead.
				queue_micro_task(() => {
					if (parts && is_bound_this(get_value(...parts), element_or_component)) {
						update(null, ...parts);
					}
				});
			};
		});

		return element_or_component;
	}

	/** @import { ComponentContextLegacy } from '#client' */

	/**
	 * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects
	 * @param {boolean} [immutable]
	 */
	function init(immutable = false) {
		const context = /** @type {ComponentContextLegacy} */ (component_context);

		const callbacks = context.l.u;
		if (!callbacks) return;

		let props = () => deep_read_state(context.s);

		if (immutable) {
			let version = 0;
			let prev = /** @type {Record<string, any>} */ ({});

			// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes
			const d = derived(() => {
				let changed = false;
				const props = context.s;
				for (const key in props) {
					if (props[key] !== prev[key]) {
						prev[key] = props[key];
						changed = true;
					}
				}
				if (changed) version++;
				return version;
			});

			props = () => get(d);
		}

		// beforeUpdate
		if (callbacks.b.length) {
			user_pre_effect(() => {
				observe_all(context, props);
				run_all(callbacks.b);
			});
		}

		// onMount (must run before afterUpdate)
		user_effect(() => {
			const fns = untrack(() => callbacks.m.map(run));
			return () => {
				for (const fn of fns) {
					if (typeof fn === 'function') {
						fn();
					}
				}
			};
		});

		// afterUpdate
		if (callbacks.a.length) {
			user_effect(() => {
				observe_all(context, props);
				run_all(callbacks.a);
			});
		}
	}

	/**
	 * Invoke the getter of all signals associated with a component
	 * so they can be registered to the effect this function is called in.
	 * @param {ComponentContextLegacy} context
	 * @param {(() => void)} props
	 */
	function observe_all(context, props) {
		if (context.l.s) {
			for (const signal of context.l.s) get(signal);
		}

		props();
	}

	/** @import { ComponentContext, ComponentContextLegacy } from '#client' */
	/** @import { EventDispatcher } from './index.js' */
	/** @import { NotFunction } from './internal/types.js' */

	/**
	 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
	 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
	 * it can be called from an external module).
	 *
	 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
	 *
	 * `onMount` does not run inside [server-side components](https://svelte.dev/docs/svelte/svelte-server#render).
	 *
	 * @template T
	 * @param {() => NotFunction<T> | Promise<NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
		if (component_context === null) {
			lifecycle_outside_component();
		}

		if (component_context.l !== null) {
			init_update_callbacks(component_context).m.push(fn);
		} else {
			user_effect(() => {
				const cleanup = untrack(fn);
				if (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup);
			});
		}
	}

	/**
	 * Schedules a callback to run immediately before the component is unmounted.
	 *
	 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
	 * only one that runs inside a server-side component.
	 *
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function onDestroy(fn) {
		if (component_context === null) {
			lifecycle_outside_component();
		}

		onMount(() => () => untrack(fn));
	}

	/**
	 * @template [T=any]
	 * @param {string} type
	 * @param {T} [detail]
	 * @param {any}params_0
	 * @returns {CustomEvent<T>}
	 */
	function create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
		return new CustomEvent(type, { detail, bubbles, cancelable });
	}

	/**
	 * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs/svelte/legacy-on#Component-events).
	 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
	 *
	 * Component events created with `createEventDispatcher` create a
	 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
	 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
	 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
	 * property and can contain any type of data.
	 *
	 * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
	 * ```ts
	 * const dispatch = createEventDispatcher<{
	 *  loaded: never; // does not take a detail argument
	 *  change: string; // takes a detail argument of type string, which is required
	 *  optional: number | null; // takes an optional detail argument of type number
	 * }>();
	 * ```
	 *
	 * @deprecated Use callback props and/or the `$host()` rune instead — see https://svelte.dev/docs/svelte/v5-migration-guide#Event-changes-Component-events
	 * @template {Record<string, any>} [EventMap = any]
	 * @returns {EventDispatcher<EventMap>}
	 */
	function createEventDispatcher() {
		const active_component_context = component_context;
		if (active_component_context === null) {
			lifecycle_outside_component();
		}

		return (type, detail, options) => {
			const events = /** @type {Record<string, Function | Function[]>} */ (
				active_component_context.s.$$events
			)?.[/** @type {any} */ (type)];

			if (events) {
				const callbacks = is_array(events) ? events.slice() : [events];
				// TODO are there situations where events could be dispatched
				// in a server (non-DOM) environment?
				const event = create_custom_event(/** @type {string} */ (type), detail, options);
				for (const fn of callbacks) {
					fn.call(active_component_context.x, event);
				}
				return !event.defaultPrevented;
			}

			return true;
		};
	}

	/**
	 * Schedules a callback to run immediately after the component has been updated.
	 *
	 * The first time the callback runs will be after the initial `onMount`.
	 *
	 * In runes mode use `$effect` instead.
	 *
	 * @deprecated Use `$effect` instead — see https://svelte.dev/docs/svelte/$effect
	 * @param {() => void} fn
	 * @returns {void}
	 */
	function afterUpdate(fn) {
		if (component_context === null) {
			lifecycle_outside_component();
		}

		if (component_context.l === null) {
			lifecycle_legacy_only();
		}

		init_update_callbacks(component_context).a.push(fn);
	}

	/**
	 * Legacy-mode: Init callbacks object for onMount/beforeUpdate/afterUpdate
	 * @param {ComponentContext} context
	 */
	function init_update_callbacks(context) {
		var l = /** @type {ComponentContextLegacy} */ (context).l;
		return (l.u ??= { a: [], b: [], m: [] });
	}

	/** @import { Readable } from './public' */

	/**
	 * @template T
	 * @param {Readable<T> | null | undefined} store
	 * @param {(value: T) => void} run
	 * @param {(value: T) => void} [invalidate]
	 * @returns {() => void}
	 */
	function subscribe_to_store(store, run, invalidate) {
		if (store == null) {
			// @ts-expect-error
			run(undefined);

			return noop;
		}

		// Svelte store takes a private second argument
		// StartStopNotifier could mutate state, and we want to silence the corresponding validation error
		const unsub = untrack(() =>
			store.subscribe(
				run,
				// @ts-expect-error
				invalidate
			)
		);

		// Also support RxJS
		// @ts-expect-error TODO fix this in the types?
		return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
	}

	/** @import { StoreReferencesContainer } from '#client' */
	/** @import { Store } from '#shared' */

	/**
	 * Whether or not the prop currently being read is a store binding, as in
	 * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in
	 * runes mode, and skip `binding_property_non_reactive` validation
	 */
	let is_store_binding = false;

	/**
	 * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy
	 * signal that will be updated when the store is. The store references container is needed to
	 * track reassignments to stores and to track the correct component context.
	 * @template V
	 * @param {Store<V> | null | undefined} store
	 * @param {string} store_name
	 * @param {StoreReferencesContainer} stores
	 * @returns {V}
	 */
	function store_get(store, store_name, stores) {
		const entry = (stores[store_name] ??= {
			store: null,
			source: mutable_source(undefined),
			unsubscribe: noop
		});

		if (entry.store !== store) {
			entry.unsubscribe();
			entry.store = store ?? null;

			if (store == null) {
				entry.source.v = undefined; // see synchronous callback comment below
				entry.unsubscribe = noop;
			} else {
				var is_synchronous_callback = true;

				entry.unsubscribe = subscribe_to_store(store, (v) => {
					if (is_synchronous_callback) {
						// If the first updates to the store value (possibly multiple of them) are synchronously
						// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value
						entry.source.v = v;
					} else {
						set(entry.source, v);
					}
				});

				is_synchronous_callback = false;
			}
		}

		return get(entry.source);
	}

	/**
	 * Unsubscribes from all auto-subscribed stores on destroy
	 * @returns {StoreReferencesContainer}
	 */
	function setup_stores() {
		/** @type {StoreReferencesContainer} */
		const stores = {};

		teardown(() => {
			for (var store_name in stores) {
				const ref = stores[store_name];
				ref.unsubscribe();
			}
		});

		return stores;
	}

	/**
	 * Updates a store with a new value.
	 * @param {Store<V>} store  the store to update
	 * @param {any} expression  the expression that mutates the store
	 * @param {V} new_value  the new store value
	 * @template V
	 */
	function store_mutate(store, expression, new_value) {
		store.set(new_value);
		return expression;
	}

	/**
	 * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.
	 * Used to prevent `binding_property_non_reactive` validation false positives and
	 * ensure that these props are treated as mutable even in runes mode
	 * @template T
	 * @param {() => T} fn
	 * @returns {[T, boolean]}
	 */
	function capture_store_binding(fn) {
		var previous_is_store_binding = is_store_binding;

		try {
			is_store_binding = false;
			return [fn(), is_store_binding];
		} finally {
			is_store_binding = previous_is_store_binding;
		}
	}

	/** @import { Source } from './types.js' */

	/**
	 * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).
	 * Is passed the full `$$props` object and excludes the named props.
	 * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}
	 */
	const rest_props_handler = {
		get(target, key) {
			if (target.exclude.includes(key)) return;
			return target.props[key];
		},
		set(target, key) {

			return false;
		},
		getOwnPropertyDescriptor(target, key) {
			if (target.exclude.includes(key)) return;
			if (key in target.props) {
				return {
					enumerable: true,
					configurable: true,
					value: target.props[key]
				};
			}
		},
		has(target, key) {
			if (target.exclude.includes(key)) return false;
			return key in target.props;
		},
		ownKeys(target) {
			return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));
		}
	};

	/**
	 * @param {Record<string, unknown>} props
	 * @param {string[]} exclude
	 * @param {string} [name]
	 * @returns {Record<string, unknown>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function rest_props(props, exclude, name) {
		return new Proxy(
			{ props, exclude },
			rest_props_handler
		);
	}

	/**
	 * The proxy handler for legacy $$restProps and $$props
	 * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}
	 */
	const legacy_rest_props_handler = {
		get(target, key) {
			if (target.exclude.includes(key)) return;
			get(target.version);
			return key in target.special ? target.special[key]() : target.props[key];
		},
		set(target, key, value) {
			if (!(key in target.special)) {
				// Handle props that can temporarily get out of sync with the parent
				/** @type {Record<string, (v?: unknown) => unknown>} */
				target.special[key] = prop(
					{
						get [key]() {
							return target.props[key];
						}
					},
					/** @type {string} */ (key),
					PROPS_IS_UPDATED
				);
			}

			target.special[key](value);
			update(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun
			return true;
		},
		getOwnPropertyDescriptor(target, key) {
			if (target.exclude.includes(key)) return;
			if (key in target.props) {
				return {
					enumerable: true,
					configurable: true,
					value: target.props[key]
				};
			}
		},
		deleteProperty(target, key) {
			// Svelte 4 allowed for deletions on $$restProps
			if (target.exclude.includes(key)) return true;
			target.exclude.push(key);
			update(target.version);
			return true;
		},
		has(target, key) {
			if (target.exclude.includes(key)) return false;
			return key in target.props;
		},
		ownKeys(target) {
			return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));
		}
	};

	/**
	 * @param {Record<string, unknown>} props
	 * @param {string[]} exclude
	 * @returns {Record<string, unknown>}
	 */
	function legacy_rest_props(props, exclude) {
		return new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);
	}

	/**
	 * The proxy handler for spread props. Handles the incoming array of props
	 * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps
	 * them so that the whole thing is passed to the component as the `$$props` argument.
	 * @template {Record<string | symbol, unknown>} T
	 * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}
	 */
	const spread_props_handler = {
		get(target, key) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				if (typeof p === 'object' && p !== null && key in p) return p[key];
			}
		},
		set(target, key, value) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				const desc = get_descriptor(p, key);
				if (desc && desc.set) {
					desc.set(value);
					return true;
				}
			}
			return false;
		},
		getOwnPropertyDescriptor(target, key) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				if (typeof p === 'object' && p !== null && key in p) {
					const descriptor = get_descriptor(p, key);
					if (descriptor && !descriptor.configurable) {
						// Prevent a "Non-configurability Report Error": The target is an array, it does
						// not actually contain this property. If it is now described as non-configurable,
						// the proxy throws a validation error. Setting it to true avoids that.
						descriptor.configurable = true;
					}
					return descriptor;
				}
			}
		},
		has(target, key) {
			for (let p of target.props) {
				if (is_function(p)) p = p();
				if (p != null && key in p) return true;
			}

			return false;
		},
		ownKeys(target) {
			/** @type {Array<string | symbol>} */
			const keys = [];

			for (let p of target.props) {
				if (is_function(p)) p = p();
				for (const key in p) {
					if (!keys.includes(key)) keys.push(key);
				}
			}

			return keys;
		}
	};

	/**
	 * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props
	 * @returns {any}
	 */
	function spread_props(...props) {
		return new Proxy({ props }, spread_props_handler);
	}

	/**
	 * @template T
	 * @param {() => T} fn
	 * @returns {T}
	 */
	function with_parent_branch(fn) {
		var effect = active_effect;
		var previous_effect = active_effect;

		while (effect !== null && (effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
			effect = effect.parent;
		}
		try {
			set_active_effect(effect);
			return fn();
		} finally {
			set_active_effect(previous_effect);
		}
	}

	/**
	 * This function is responsible for synchronizing a possibly bound prop with the inner component state.
	 * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.
	 * @template V
	 * @param {Record<string, unknown>} props
	 * @param {string} key
	 * @param {number} flags
	 * @param {V | (() => V)} [fallback]
	 * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}
	 */
	function prop(props, key, flags, fallback) {
		var immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;
		var runes = (flags & PROPS_IS_RUNES) !== 0;
		var bindable = (flags & PROPS_IS_BINDABLE) !== 0;
		var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;
		var is_store_sub = false;
		var prop_value;

		if (bindable) {
			[prop_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));
		} else {
			prop_value = /** @type {V} */ (props[key]);
		}
		var setter = get_descriptor(props, key)?.set;

		var fallback_value = /** @type {V} */ (fallback);
		var fallback_dirty = true;
		var fallback_used = false;

		var get_fallback = () => {
			fallback_used = true;
			if (fallback_dirty) {
				fallback_dirty = false;
				if (lazy) {
					fallback_value = untrack(/** @type {() => V} */ (fallback));
				} else {
					fallback_value = /** @type {V} */ (fallback);
				}
			}

			return fallback_value;
		};

		if (prop_value === undefined && fallback !== undefined) {
			if (setter && runes) {
				props_invalid_value();
			}

			prop_value = get_fallback();
			if (setter) setter(prop_value);
		}

		/** @type {() => V} */
		var getter;
		if (runes) {
			getter = () => {
				var value = /** @type {V} */ (props[key]);
				if (value === undefined) return get_fallback();
				fallback_dirty = true;
				fallback_used = false;
				return value;
			};
		} else {
			// Svelte 4 did not trigger updates when a primitive value was updated to the same value.
			// Replicate that behavior through using a derived
			var derived_getter = with_parent_branch(() =>
				(immutable ? derived : derived_safe_equal)(() => /** @type {V} */ (props[key]))
			);
			derived_getter.f |= LEGACY_DERIVED_PROP;
			getter = () => {
				var value = get(derived_getter);
				if (value !== undefined) fallback_value = /** @type {V} */ (undefined);
				return value === undefined ? fallback_value : value;
			};
		}

		// easy mode — prop is never written to
		if ((flags & PROPS_IS_UPDATED) === 0) {
			return getter;
		}

		// intermediate mode — prop is written to, but the parent component had
		// `bind:foo` which means we can just call `$$props.foo = value` directly
		if (setter) {
			var legacy_parent = props.$$legacy;
			return function (/** @type {any} */ value, /** @type {boolean} */ mutation) {
				if (arguments.length > 0) {
					// We don't want to notify if the value was mutated and the parent is in runes mode.
					// In that case the state proxy (if it exists) should take care of the notification.
					// If the parent is not in runes mode, we need to notify on mutation, too, that the prop
					// has changed because the parent will not be able to detect the change otherwise.
					if (!runes || !mutation || legacy_parent || is_store_sub) {
						/** @type {Function} */ (setter)(mutation ? getter() : value);
					}
					return value;
				} else {
					return getter();
				}
			};
		}

		// hard mode. this is where it gets ugly — the value in the child should
		// synchronize with the parent, but it should also be possible to temporarily
		// set the value to something else locally.
		var from_child = false;
		var was_from_child = false;

		// The derived returns the current value. The underlying mutable
		// source is written to from various places to persist this value.
		var inner_current_value = mutable_source(prop_value);
		var current_value = with_parent_branch(() =>
			derived(() => {
				var parent_value = getter();
				var child_value = get(inner_current_value);

				if (from_child) {
					from_child = false;
					was_from_child = true;
					return child_value;
				}

				was_from_child = false;
				return (inner_current_value.v = parent_value);
			})
		);

		if (!immutable) current_value.equals = safe_equals;

		return function (/** @type {any} */ value, /** @type {boolean} */ mutation) {

			if (arguments.length > 0) {
				const new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;

				if (!current_value.equals(new_value)) {
					from_child = true;
					set(inner_current_value, new_value);
					// To ensure the fallback value is consistent when used with proxies, we
					// update the local fallback_value, but only if the fallback is actively used
					if (fallback_used && fallback_value !== undefined) {
						fallback_value = new_value;
					}
					untrack(() => get(current_value)); // force a synchronisation immediately
				}

				return value;
			}
			return get(current_value);
		};
	}

	/**
	 * @param {Record<string, any>} $$props
	 * @param {string[]} bindable
	 * @param {string[]} exports
	 * @param {Function & { [FILENAME]: string }} component
	 */
	function validate_prop_bindings($$props, bindable, exports, component) {
		for (const key in $$props) {
			var setter = get_descriptor($$props, key)?.set;
			component.name;

			if (setter) {
				if (exports.includes(key)) {
					bind_invalid_export(component[FILENAME]);
				}

				if (!bindable.includes(key)) {
					bind_not_bindable(key, component[FILENAME]);
				}
			}
		}
	}

	/** @import { TemplateNode } from '#client' */
	/** @import { Getters } from '#shared' */

	/**
	 * @param {any} store
	 * @param {string} name
	 */
	function validate_store(store, name) {
		if (store != null && typeof store.subscribe !== 'function') {
			store_invalid_shape();
		}
	}

	// lib/common/utils/object.utils.ts
	function shallowClone(obj, depth = 1, omit = []) {
	  if (!obj || depth <= 0 || typeof obj !== "object") {
	    return obj;
	  }
	  if (Array.isArray(obj)) {
	    return obj.map((item) => omit.includes(item) ? item : shallowClone(item, depth - 1, omit));
	  }
	  return Object.keys(obj).reduce((acc, key) => {
	    const value = obj[key];
	    if (!omit.includes(key)) {
	      acc[key] = shallowClone(value, depth - 1, omit);
	    } else {
	      acc[key] = value;
	    }
	    return acc;
	  }, {});
	}
	var isShallowEqual = (a, b, depth = 1) => {
	  if (depth <= 0) return a === b;
	  if (a === b) return true;
	  if (typeof a !== "object" || typeof b !== "object") return a === b;
	  if (a instanceof URL && b instanceof URL) return a.href === b.href;
	  if (a && !b || !a && b) return false;
	  const keys = [...Object.keys(a), ...Object.keys(b)];
	  if (keys.every((key) => a[key] === b[key])) return true;
	  return keys.every((key) => isShallowEqual(a[key], b[key], depth - 1));
	};

	const cloneRoute = (route) => shallowClone(route, 2, ['parent', 'component', 'components', 'loading', 'loadings', 'error', 'errors']);
	const isRouteEqual = (a, b) => isShallowEqual(a, b, 2);
	const toBaseRoute = (route) => {
	    if (!route)
	        return route;
	    return {
	        path: route.path,
	        name: route.name,
	        title: route.title,
	        meta: { ...route.meta },
	        query: { ...route.query },
	        params: { ...route.params },
	    };
	};

	/// <reference types="navigation-api-types" />
	const isLocationEqual = (a, b) => isShallowEqual(a, b, 2);
	const toBasicRouterLocation = (loc) => {
	    if (!loc)
	        return loc;
	    return {
	        origin: loc.origin,
	        base: loc.base,
	        name: loc.name,
	        path: loc.path,
	        href: loc.href.toString(),
	        query: { ...loc.query },
	        params: { ...loc.params },
	        wildcards: { ...loc.wildcards },
	    };
	};
	const isResolvedLocationEqual = (a, b) => isRouteEqual(a?.route, b?.route) && isLocationEqual(a?.location, b?.location);
	const RouterStateConstant = '__SVELTE_SIMPLE_ROUTER_STATE__';
	const RouterScrollConstant = '__SVELTE_SIMPLE_ROUTER_SCROLL__';
	const RouterDebuggerConstant = '__SVELTE_SIMPLE_ROUTER_DEBUGGER__';
	const RouterPathPriority = (a, b) => (b.path?.length || 0) - (a.path?.length || 0) || (b.path || '').localeCompare(a.path || '');
	/**
	 * Default options to initialize a {@link Router} instance.
	 */
	const defaultOptions = {
	    history: globalThis?.history,
	    location: globalThis?.location,
	    navigation: typeof window !== 'undefined' ? window.navigation : undefined,
	    listen: 'history',
	    syncUpdate: 'replace',
	    syncDebounce: 0,
	    priority: RouterPathPriority,
	    caseSensitive: false,
	    hash: false,
	    strict: false,
	    failOnNotFound: false,
	    metaAsState: false,
	    nameAsTitle: false,
	    stripQuery: false,
	    stripHash: false,
	    stripTrailingHash: false,
	    followGuardRedirects: true,
	};

	/* context.svelte.js generated by Svelte v5.1.9 */

	const RouterContextSymbol = Symbol('SvelteSimpleRouterContext');
	const RouterViewSymbol = Symbol('SvelteSimpleRouterView');

	const getRouter = () => {
		return getContext(RouterContextSymbol);
	};

	const setRouter = (router) => {
		return setContext(RouterContextSymbol, router);
	};

	const getView = () => {
		return getContext(RouterViewSymbol);
	};

	const setView = (view) => {
		return setContext(RouterViewSymbol, view);
	};

	// lib/common/models/error.model.ts
	var ParsingError$1 = class ParsingError extends Error {
	  type;
	  error;
	  constructor(type, error, message = `Parsing error: ${type}`) {
	    super(message);
	    this.type = type;
	    this.error = error;
	  }
	};
	var ParsingRelativePathError = class extends ParsingError$1 {
	  constructor({ parent, relative }, message = `Error parsing relative path "${relative}" from parent path "${parent}"`) {
	    super("PARSING_RELATIVE_PATH_ERROR" /* PARSING_RELATIVE_PATH_ERROR */, { parent, relative }, message);
	  }
	};

	var toPathSegment = (str, trailing = false) => {
	  let _str = str?.trim();
	  if (!_str?.length) return "";
	  if (!_str.startsWith("/")) _str = `/${_str}`;
	  if (trailing && !_str.endsWith("/")) _str = `${_str}/`;
	  if (!trailing && _str.endsWith("/")) _str = _str.slice(0, -1);
	  return _str;
	};
	var computeAbsolutePath = (parent, relative) => {
	  const relativeSegments = relative.split("/").filter(Boolean);
	  const parentSegments = parent.split("/").filter(Boolean);
	  relativeSegments.forEach((segment) => {
	    if (segment === ".." && parentSegments.length < 1) throw new ParsingRelativePathError({ parent, relative });
	    else if (segment === "..") parentSegments.pop();
	    else if (segment !== ".") parentSegments.push(segment);
	  });
	  return `/${parentSegments.join("/")}`;
	};

	// lib/common/utils/promise.utils.ts
	function raceUntil(promises, cb = (r) => r !== void 0) {
	  const { promise: outer, resolve, reject } = Promise.withResolvers();
	  const _promises = promises.map(
	    (p) => p.then((result) => {
	      if (cb(result)) resolve(result);
	      return result;
	    })
	  );
	  const inner = Promise.all(_promises).catch(reject).then((result) => {
	    resolve(null);
	    return result;
	  });
	  return { inner, outer };
	}

	// lib/common/utils/logger.utils.ts
	var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
	  LogLevel2[LogLevel2["Silent"] = -1] = "Silent";
	  LogLevel2[LogLevel2["Error"] = 0] = "Error";
	  LogLevel2[LogLevel2["Warn"] = 1] = "Warn";
	  LogLevel2[LogLevel2["Info"] = 2] = "Info";
	  LogLevel2[LogLevel2["Debug"] = 3] = "Debug";
	  LogLevel2[LogLevel2["Trace"] = 4] = "Trace";
	  return LogLevel2;
	})(LogLevel || {});
	var toLogLevel = (logLevel) => {
	  const _logLevel = logLevel.charAt(0).toUpperCase() + logLevel.slice(1).toLowerCase();
	  return LogLevel[_logLevel];
	};
	var TimeStampFormat = {
	  ISO: "ISO",
	  Date: "Date",
	  Time: "Time",
	  Local: "Local"
	};
	var getTimestamp = (scope, format = TimeStampFormat.Time) => {
	  let date;
	  if (format === TimeStampFormat.ISO) date = (/* @__PURE__ */ new Date()).toISOString();
	  else if (format === TimeStampFormat.Date) date = (/* @__PURE__ */ new Date()).toLocaleDateString().split("T").at(0);
	  else if (format === TimeStampFormat.Local) date = (/* @__PURE__ */ new Date()).toLocaleString();
	  else date = (/* @__PURE__ */ new Date()).toLocaleTimeString("en", { hour12: false, timeZone: "UTC" });
	  return scope ? `[${date} - ${scope}]` : `[${date}]`;
	};
	var LoggerColor = {
	  Debug: "#9e9e9e",
	  Info: "#5bd4f9",
	  Warn: "#f2c61a",
	  Error: "#ff5549",
	  Success: "#00ff00"
	};
	var ConsoleFormat = {
	  /**
	   * Formats the value as a string
	   * @see ConsoleFormat
	   */
	  String: "%s",
	  /**
	   * Formats the value as an integer
	   * @see ConsoleFormat
	   */
	  Integer: "%i",
	  /**
	   * Formats the value as a floating point value
	   * @see ConsoleFormat
	   */
	  Float: "%f",
	  /**
	   * Formats the value as an expandable DOM element
	   * @see ConsoleFormat
	   */
	  DOM: "%o",
	  /**
	   * Formats the value as an expandable JavaScript object
	   * @see ConsoleFormat
	   */
	  Object: "%O",
	  /**
	   * Applies CSS style rules to the output string as specified by the second parameter
	   * @see ConsoleFormat
	   */
	  Style: "%c"
	};
	var colorize = (color, ...args) => {
	  if (!args?.some((arg) => typeof arg === "string")) return args;
	  let prefix = "%c";
	  const _args = [`color: ${color}`];
	  args.forEach((arg, i) => {
	    const space = i ? " " : "";
	    if (arg instanceof Element) {
	      if (i < args.length - 1) prefix += `${space}${ConsoleFormat.DOM}`;
	    } else if (typeof arg === "object") {
	      if (i < args.length - 1) prefix += `${space}${ConsoleFormat.Object}`;
	    } else if (typeof arg === "string") {
	      prefix += `${space}${ConsoleFormat.String}`;
	    } else if (typeof arg === "number") {
	      prefix += `${space}${ConsoleFormat.Float}`;
	    }
	    _args.push(arg);
	  });
	  _args.unshift(prefix);
	  return _args;
	};
	var proxyLoggerFilter = {
	  trace: (logLevel) => logLevel >= 4 /* Trace */,
	  debug: (logLevel) => logLevel >= 3 /* Debug */,
	  info: (logLevel) => logLevel >= 2 /* Info */,
	  warn: (logLevel) => logLevel >= 1 /* Warn */,
	  error: (logLevel) => logLevel >= 0 /* Error */
	};
	var ProxyLogger = class _ProxyLogger {
	  _logger;
	  _proxy;
	  _timeFormat;
	  _debug;
	  _logLevel;
	  constructor({
	    logger = console,
	    debug = false,
	    proxy = proxyLoggerFilter,
	    logLevel = 1 /* Warn */,
	    timeFormat = TimeStampFormat.Time
	  } = {}) {
	    this._logger = logger;
	    this._proxy = proxy;
	    this._debug = debug;
	    this._logLevel = logLevel;
	    this._timeFormat = timeFormat;
	  }
	  get timeFormat() {
	    return typeof this._timeFormat === "function" ? this._timeFormat() : this._timeFormat;
	  }
	  get isDebug() {
	    return typeof this._debug === "function" ? this._debug() : this._debug;
	  }
	  get logLevel() {
	    return typeof this._logLevel === "function" ? this._logLevel() : this._logLevel;
	  }
	  set logLevel(level) {
	    if (this._debug) console.debug("[ProxyLogger] - Log level changed:", LogLevel[level]);
	    if (typeof this._logLevel === "function") throw new Error("Cannot set log level when logLevel is a function");
	    this._logLevel = level;
	  }
	  null = (...args) => {
	    if (this.isDebug) console.debug("[ProxyLogger] - Log suppressed:", ...args);
	  };
	  get trace() {
	    if (!this._proxy?.trace?.(this.logLevel)) return this.null;
	    return this._logger.trace.bind(this._logger);
	  }
	  get debug() {
	    if (!this._proxy?.debug?.(this.logLevel)) return this.null;
	    return this._logger.debug.bind(this._logger);
	  }
	  get info() {
	    if (!this._proxy?.info?.(this.logLevel)) return this.null;
	    return this._logger.info.bind(this._logger);
	  }
	  get warn() {
	    if (!this._proxy?.warn?.(this.logLevel)) return this.null;
	    return this._logger.warn.bind(this._logger);
	  }
	  get error() {
	    if (!this._proxy?.error?.(this.logLevel)) return this.null;
	    return this._logger.error.bind(this._logger);
	  }
	  static logger = new _ProxyLogger();
	  static timestamp = getTimestamp;
	  static colorize = colorize;
	  color = {
	    debug: (...args) => this.debug(..._ProxyLogger.colorize(LoggerColor.Debug, ...args)),
	    info: (...args) => this.info(..._ProxyLogger.colorize(LoggerColor.Info, ...args)),
	    warn: (...args) => this.warn(..._ProxyLogger.colorize(LoggerColor.Warn, ...args)),
	    error: (...args) => this.error(..._ProxyLogger.colorize(LoggerColor.Error, ...args)),
	    success: (...args) => this.info(..._ProxyLogger.colorize(LoggerColor.Success, ...args))
	  };
	  /**
	   * Logger with timestamp but looses stack trace origin
	   */
	  time = {
	    debug: (...args) => this.debug(_ProxyLogger.timestamp(void 0, this.timeFormat), ...args),
	    info: (...args) => this.info(_ProxyLogger.timestamp(void 0, this.timeFormat), ...args),
	    warn: (...args) => this.warn(_ProxyLogger.timestamp(void 0, this.timeFormat), ...args),
	    error: (...args) => this.error(_ProxyLogger.timestamp(void 0, this.timeFormat), ...args),
	    color: {
	      debug: (...args) => this.color.debug(_ProxyLogger.timestamp(void 0, this.timeFormat), ...args),
	      info: (...args) => this.color.info(_ProxyLogger.timestamp(void 0, this.timeFormat), ...args),
	      warn: (...args) => this.color.warn(_ProxyLogger.timestamp(void 0, this.timeFormat), ...args),
	      error: (...args) => this.color.error(_ProxyLogger.timestamp(void 0, this.timeFormat), ...args),
	      success: (...args) => this.color.success(_ProxyLogger.timestamp(void 0, this.timeFormat), ...args)
	    }
	  };
	  scope = (_scope) => ({
	    debug: (...args) => this.debug(_ProxyLogger.timestamp(_scope, this.timeFormat), ...args),
	    info: (...args) => this.info(_ProxyLogger.timestamp(_scope, this.timeFormat), ...args),
	    warn: (...args) => this.warn(_ProxyLogger.timestamp(_scope, this.timeFormat), ...args),
	    error: (...args) => this.error(_ProxyLogger.timestamp(_scope, this.timeFormat), ...args),
	    color: {
	      debug: (...args) => this.color.debug(_ProxyLogger.timestamp(_scope, this.timeFormat), ...args),
	      info: (...args) => this.color.info(_ProxyLogger.timestamp(_scope, this.timeFormat), ...args),
	      warn: (...args) => this.color.warn(_ProxyLogger.timestamp(_scope, this.timeFormat), ...args),
	      error: (...args) => this.color.error(_ProxyLogger.timestamp(_scope, this.timeFormat), ...args),
	      success: (...args) => this.color.success(_ProxyLogger.timestamp(_scope, this.timeFormat), ...args)
	    }
	  });
	  colored = {};
	};

	// lib/common/utils/crypto.utils.ts
	var randomHex = (n = 8) => {
	  const bytes = new Uint8Array(n);
	  crypto.getRandomValues(bytes);
	  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
	};

	// lib/common/utils/debounce.utils.ts
	function debounce$2(func, delay = 250, timout = { value: void 0 }) {
	  const timeoutId = timout;
	  return async (...args) => {
	    return new Promise((resolve, reject) => {
	      if (timeoutId.value) clearTimeout(timeoutId.value);
	      timeoutId.value = setTimeout(async () => {
	        try {
	          resolve(await func(...args));
	        } catch (error) {
	          reject(error);
	        }
	      }, delay);
	    });
	  };
	}

	/** @import { Source } from '#client' */

	/** @param {Source<number>} source */
	function increment$1(source) {
		set(source, source.v + 1);
	}

	/** @import { Source } from '#client' */

	var read_methods = ['forEach', 'isDisjointFrom', 'isSubsetOf', 'isSupersetOf'];
	var set_like_methods = ['difference', 'intersection', 'symmetricDifference', 'union'];

	var inited = false;

	/**
	 * @template T
	 * @extends {Set<T>}
	 */
	class SvelteSet extends Set {
		/** @type {Map<T, Source<boolean>>} */
		#sources = new Map();
		#version = source(0);
		#size = source(0);

		/**
		 * @param {Iterable<T> | null | undefined} [value]
		 */
		constructor(value) {
			super();

			if (value) {
				for (var element of value) {
					super.add(element);
				}
				this.#size.v = super.size;
			}

			if (!inited) this.#init();
		}

		// We init as part of the first instance so that we can treeshake this class
		#init() {
			inited = true;

			var proto = SvelteSet.prototype;
			var set_proto = Set.prototype;

			for (const method of read_methods) {
				// @ts-ignore
				proto[method] = function (...v) {
					get(this.#version);
					// @ts-ignore
					return set_proto[method].apply(this, v);
				};
			}

			for (const method of set_like_methods) {
				// @ts-ignore
				proto[method] = function (...v) {
					get(this.#version);
					// @ts-ignore
					var set = /** @type {Set<T>} */ (set_proto[method].apply(this, v));
					return new SvelteSet(set);
				};
			}
		}

		/** @param {T} value */
		has(value) {
			var has = super.has(value);
			var sources = this.#sources;
			var s = sources.get(value);

			if (s === undefined) {
				if (!has) {
					// If the value doesn't exist, track the version in case it's added later
					// but don't create sources willy-nilly to track all possible values
					get(this.#version);
					return false;
				}

				s = source(true);
				sources.set(value, s);
			}

			get(s);
			return has;
		}

		/** @param {T} value */
		add(value) {
			if (!super.has(value)) {
				super.add(value);
				set(this.#size, super.size);
				increment$1(this.#version);
			}

			return this;
		}

		/** @param {T} value */
		delete(value) {
			var deleted = super.delete(value);
			var sources = this.#sources;
			var s = sources.get(value);

			if (s !== undefined) {
				sources.delete(value);
				set(s, false);
			}

			if (deleted) {
				set(this.#size, super.size);
				increment$1(this.#version);
			}

			return deleted;
		}

		clear() {
			if (super.size === 0) {
				return;
			}
			// Clear first, so we get nice console.log outputs with $inspect
			super.clear();
			var sources = this.#sources;

			for (var s of sources.values()) {
				set(s, false);
			}

			sources.clear();
			set(this.#size, 0);
			increment$1(this.#version);
		}

		keys() {
			return this.values();
		}

		values() {
			get(this.#version);
			return super.values();
		}

		entries() {
			get(this.#version);
			return super.entries();
		}

		[Symbol.iterator]() {
			return this.keys();
		}

		get size() {
			return get(this.#size);
		}
	}

	/** @import { Source } from '#client' */

	/**
	 * @template K
	 * @template V
	 * @extends {Map<K, V>}
	 */
	class SvelteMap extends Map {
		/** @type {Map<K, Source<number>>} */
		#sources = new Map();
		#version = source(0);
		#size = source(0);

		/**
		 * @param {Iterable<readonly [K, V]> | null | undefined} [value]
		 */
		constructor(value) {
			super();

			if (value) {
				for (var [key, v] of value) {
					super.set(key, v);
				}
				this.#size.v = super.size;
			}
		}

		/** @param {K} key */
		has(key) {
			var sources = this.#sources;
			var s = sources.get(key);

			if (s === undefined) {
				var ret = super.get(key);
				if (ret !== undefined) {
					s = source(0);
					sources.set(key, s);
				} else {
					// We should always track the version in case
					// the Set ever gets this value in the future.
					get(this.#version);
					return false;
				}
			}

			get(s);
			return true;
		}

		/**
		 * @param {(value: V, key: K, map: Map<K, V>) => void} callbackfn
		 * @param {any} [this_arg]
		 */
		forEach(callbackfn, this_arg) {
			this.#read_all();
			super.forEach(callbackfn, this_arg);
		}

		/** @param {K} key */
		get(key) {
			var sources = this.#sources;
			var s = sources.get(key);

			if (s === undefined) {
				var ret = super.get(key);
				if (ret !== undefined) {
					s = source(0);
					sources.set(key, s);
				} else {
					// We should always track the version in case
					// the Set ever gets this value in the future.
					get(this.#version);
					return undefined;
				}
			}

			get(s);
			return super.get(key);
		}

		/**
		 * @param {K} key
		 * @param {V} value
		 * */
		set(key, value) {
			var sources = this.#sources;
			var s = sources.get(key);
			var prev_res = super.get(key);
			var res = super.set(key, value);
			var version = this.#version;

			if (s === undefined) {
				sources.set(key, source(0));
				set(this.#size, super.size);
				increment$1(version);
			} else if (prev_res !== value) {
				increment$1(s);

				// if not every reaction of s is a reaction of version we need to also include version
				var v_reactions = version.reactions === null ? null : new Set(version.reactions);
				var needs_version_increase =
					v_reactions === null ||
					!s.reactions?.every((r) =>
						/** @type {NonNullable<typeof v_reactions>} */ (v_reactions).has(r)
					);
				if (needs_version_increase) {
					increment$1(version);
				}
			}

			return res;
		}

		/** @param {K} key */
		delete(key) {
			var sources = this.#sources;
			var s = sources.get(key);
			var res = super.delete(key);

			if (s !== undefined) {
				sources.delete(key);
				set(this.#size, super.size);
				set(s, -1);
				increment$1(this.#version);
			}

			return res;
		}

		clear() {
			if (super.size === 0) {
				return;
			}
			// Clear first, so we get nice console.log outputs with $inspect
			super.clear();
			var sources = this.#sources;
			set(this.#size, 0);
			for (var s of sources.values()) {
				set(s, -1);
			}
			increment$1(this.#version);
			sources.clear();
		}

		#read_all() {
			get(this.#version);

			var sources = this.#sources;
			if (this.#size.v !== sources.size) {
				for (var key of super.keys()) {
					if (!sources.has(key)) {
						sources.set(key, source(0));
					}
				}
			}

			for (var [, s] of this.#sources) {
				get(s);
			}
		}

		keys() {
			get(this.#version);
			return super.keys();
		}

		values() {
			this.#read_all();
			return super.values();
		}

		entries() {
			this.#read_all();
			return super.entries();
		}

		[Symbol.iterator]() {
			return this.entries();
		}

		get size() {
			get(this.#size);
			return super.size;
		}
	}

	/**
	 * Flags so we can combine them when checking for multiple errors. This is the internal version of
	 * {@link NavigationFailureType}.
	 *
	 * @internal
	 */
	var ErrorTypes;
	(function (ErrorTypes) {
	    /**
	     * An aborted navigation is a navigation that failed because a navigation guard returned `false` or threw an error
	     */
	    ErrorTypes["NAVIGATION_ABORTED"] = "NAVIGATION_ABORTED";
	    /**
	     * A cancelled navigation is a navigation that failed because a more recent navigation finished started (not necessarily finished).
	     */
	    ErrorTypes["NAVIGATION_CANCELLED"] = "NAVIGATION_CANCELLED";
	    /**
	     * No route was found for the navigation location or name.
	     */
	    ErrorTypes["NAVIGATION_NOT_FOUND"] = "NAVIGATION_NOT_FOUND";
	    /**
	     * The router already has a route with the same name.
	     */
	    ErrorTypes["ROUTER_CONFIG_NAME_CONFLICT"] = "ROUTER_CONFIG_NAME_CONFLICT";
	    /**
	     * The router already has a route with the same path.
	     */
	    ErrorTypes["ROUTER_CONFIG_PATH_CONFLICT"] = "ROUTER_CONFIG_PATH_CONFLICT";
	    /**
	     * The route path and name do not match.
	     */
	    ErrorTypes["ROUTER_CONFIG_NAME_PATH_MISMATCH"] = "ROUTER_CONFIG_NAME_PATH_MISMATCH";
	    /**
	     * The provided path for a route is invalid and cannot be compiled into a valid regex.
	     */
	    ErrorTypes["MATCHER_INVALID_PATH"] = "MATCHER_INVALID_PATH";
	    /**
	     * A required parameter is missing when parsing a path.
	     */
	    ErrorTypes["PARSING_MISSING_REQUIRED_PARAM"] = "PARSING_MISSING_REQUIRED_PARAM";
	    /**
	     * Could not find a required router context.
	     */
	    ErrorTypes["MISSING_ROUTER_CONTEXT"] = "MISSING_ROUTER_CONTEXT";
	    /**
	     * Could not find a required view context.
	     */
	    ErrorTypes["MISSING_VIEW_CONTEXT"] = "MISSING_VIEW_CONTEXT";
	    /**
	     * No active event could be found when starting a view change.
	     */
	    ErrorTypes["VIEW_CHANGE_STATUS_ERROR"] = "VIEW_CHANGE_STATUS_ERROR";
	})(ErrorTypes || (ErrorTypes = {}));
	/**
	 * Extended Error that contains extra information regarding a failed navigation.
	 */
	class NavigationFailure extends Error {
	    type;
	    to;
	    from;
	    error;
	    constructor({ type, from, to }, { message = `Navigation failed: ${type}`, error } = {}) {
	        super(message);
	        this.error = error;
	        this.type = type;
	        this.from = from;
	        this.to = to;
	    }
	}
	/**
	 * Error when a navigation is aborted (a navigation guard returned `false` or threw an error)
	 */
	class NavigationAbortedError extends NavigationFailure {
	    constructor(failure, payload = {}) {
	        super({ ...failure, type: ErrorTypes.NAVIGATION_ABORTED }, payload);
	    }
	}
	/**
	 * Error when a navigation is cancelled (a more recent navigation happened before the current one)
	 */
	class NavigationCancelledError extends NavigationFailure {
	    constructor(failure, payload = {}) {
	        super({ ...failure, type: ErrorTypes.NAVIGATION_CANCELLED }, payload);
	    }
	}
	/**
	 * Error when a navigation is not found (no matching route)
	 */
	class NavigationNotFoundError extends NavigationFailure {
	    constructor(failure, payload = {}) {
	        super({ ...failure, type: ErrorTypes.NAVIGATION_NOT_FOUND }, payload);
	    }
	}
	class RouterConfigurationError extends Error {
	    type;
	    error;
	    constructor(type, { message = `Router Configuration error: ${type}`, error }) {
	        super(message);
	        this.error = error;
	        this.type = type;
	    }
	}
	/**
	 * Error when a route with the same name already exists
	 */
	class RouterNameConflictError extends RouterConfigurationError {
	    constructor(name, message = `A route with the name "${String(name)}" already exists`) {
	        super(ErrorTypes.ROUTER_CONFIG_NAME_CONFLICT, { message, error: name });
	    }
	}
	/**
	 * Error when a route with the same path already exists
	 */
	class RouterPathConflictError extends RouterConfigurationError {
	    constructor(path, message = `A route with the path "${path}" already exists`) {
	        super(ErrorTypes.ROUTER_CONFIG_PATH_CONFLICT, { message, error: path });
	    }
	}
	class RouterNamePathMismatchError extends RouterConfigurationError {
	    constructor({ name, path, registeredName, registeredPath }, message = `Route path "${path}" with name "${String(name)}" does not match registered${registeredName ? ` name "${String(registeredName)}"` : ''}${registeredPath ? ` path "${registeredPath}"` : ''}`) {
	        super(ErrorTypes.ROUTER_CONFIG_NAME_PATH_MISMATCH, { message, error: { name, path, registeredName, registeredPath } });
	    }
	}
	class MatcherError extends Error {
	    type;
	    error;
	    constructor(type, error, message = `Matcher error: ${type}`) {
	        super(message);
	        this.type = type;
	        this.error = error;
	    }
	}
	class MatcherInvalidPathError extends MatcherError {
	    constructor(path, message = `Invalid path "${path}"`) {
	        super(ErrorTypes.MATCHER_INVALID_PATH, path, message);
	    }
	}
	class ParsingError extends Error {
	    type;
	    error;
	    constructor(type, error, message = `Parsing error: ${type}`) {
	        super(message);
	        this.type = type;
	        this.error = error;
	    }
	}
	class ParsingMissingRequiredParamError extends ParsingError {
	    constructor({ template, missing, params }, message = `Missing required param "${missing}" while parsing path "${template}" .`) {
	        super(ErrorTypes.PARSING_MISSING_REQUIRED_PARAM, { template, missing, params }, message);
	    }
	}
	class MissingRouterContextError extends Error {
	    type;
	    constructor(message = 'Router context is missing. Make sure you are calling useRoutes inside a RouterContext or RouterView component tree.') {
	        super(message);
	        this.type = ErrorTypes.MISSING_ROUTER_CONTEXT;
	    }
	}
	class MissingViewContextError extends Error {
	    type;
	    constructor(message = 'View context is missing. Make sure you are calling useView inside a RouterView component tree.') {
	        super(message);
	        this.type = ErrorTypes.MISSING_VIEW_CONTEXT;
	    }
	}
	class ViewChangeStatusError extends Error {
	    type;
	    constructor(message = 'No active event could be found.') {
	        super(message);
	        this.type = ErrorTypes.VIEW_CHANGE_STATUS_ERROR;
	    }
	}

	const templateParamRegex = /\/:[^/]+/g;
	const templateParamReplace = '/([^/]+)';
	const templateParamRegexNumber = /\/:{number}:[^/]+/g;
	const templateParamReplaceNumber = '/(\\d+)';
	const templateParamRegexString = /\/:{string}:[^/]+/g;
	const templateParamReplaceString = '/(\\w+)';
	const optionalTemplateParamRegex = /\/:[^/]+:\?/g;
	const optionalTemplateParamReplace = '/?([^/]+)?';
	const optionalTemplateParamRegexNumber = /\/:{number}:[^/]+:\?/g;
	const optionalTemplateParamReplaceNumber = '/?(\\d+)?';
	const optionalTemplateParamRegexString = /\/:{string}:[^/]+:\?/g;
	const optionalTemplateParamReplaceString = '/?(\\w+)?';
	const relativePathRegex = /^\.+\//;
	const hashPathRegex = /^\/?#/;
	const templateParamRegexPrefix = /\/:{(number|string)}:/g;
	const templateParamReplacePrefix = '/:';
	const templateParamRegexSuffix = /:\?(\/|$)/g;
	const templateParamReplaceSuffix = '/';
	const templateWildcardRegex = /\/\*$/g;
	const templateWildcardReplace = '/(.*)';
	const templateWildcardSegment = /\/\*\//g;
	const templateWildcardSegmentReplace = '/([^/]+)/';
	const templateWildcardOrParamRegex = /\/((\*)|(:[^/]+))/g;
	const templateWildcardOrParamPrefixRegex = /^\/:?/g;
	const titleParamRegexPrefix = /:{number|string}:/g;
	const titleParamReplacePrefix = ':';
	const titleParamRegex = /:(\w|[:?{}])+/g;
	const replacer = (match, params, slice = 2) => {
	    let paramName = match.slice(slice);
	    const optional = paramName.endsWith(':?');
	    if (optional)
	        paramName = paramName.slice(0, -2);
	    return { param: paramName, value: params[paramName], optional };
	};
	const replaceTitleParams = (title, params = {}) => title
	    ?.replace(titleParamRegexPrefix, titleParamReplacePrefix)
	    .replace(titleParamRegex, match => {
	    const { value, optional } = replacer(match, params, 1);
	    return String(value ?? (optional ? '' : match));
	})
	    .trim();
	/**
	 * Replaces template params with their values
	 * @param template
	 * @param params
	 * @throws {ParsingMissingRequiredParamError} when a required param is missing
	 */
	const replaceTemplateParams = (template, params = {}) => template?.replace(templateParamRegexPrefix, templateParamReplacePrefix).replace(templateParamRegex, match => {
	    const { param, value, optional } = replacer(match, params);
	    if (value === undefined) {
	        if (optional)
	            return '';
	        throw new ParsingMissingRequiredParamError({ template, missing: param, params });
	    }
	    return `/${value}`;
	});
	/**
	 * Converts a template path to a regex
	 * @param template
	 * @throws {MatcherInvalidPathError} when the template is invalid (empty or relative)
	 */
	const templateToRegex = (template) => {
	    let _template = template?.trim();
	    if (!_template?.length)
	        throw new MatcherInvalidPathError(template);
	    if (relativePathRegex.test(_template))
	        throw new MatcherInvalidPathError(template, `Path should be absolute, but "${_template}" seems to be relative.`);
	    if (!_template.startsWith('/'))
	        _template = `/${_template}`;
	    const strRegex = _template
	        .replace(optionalTemplateParamRegexString, optionalTemplateParamReplaceString)
	        .replace(optionalTemplateParamRegexNumber, optionalTemplateParamReplaceNumber)
	        .replace(optionalTemplateParamRegex, optionalTemplateParamReplace)
	        .replace(templateParamRegexString, templateParamReplaceString)
	        .replace(templateParamRegexNumber, templateParamReplaceNumber)
	        .replace(templateParamRegex, templateParamReplace)
	        .replace(templateWildcardSegment, templateWildcardSegmentReplace)
	        .replace(templateWildcardRegex, templateWildcardReplace);
	    return {
	        regex: new RegExp(`^${strRegex}`),
	        strictRegex: new RegExp(`^${strRegex}$`),
	    };
	};
	/**
	 * Extracts params from a template path
	 * @param template
	 * @throws {MatcherInvalidPathError} when the template is invalid (empty)
	 */
	const templateToParams = (template) => {
	    const _template = template?.trim();
	    if (!_template?.length)
	        throw new MatcherInvalidPathError(template);
	    return (_template
	        .replace(templateParamRegexPrefix, templateParamReplacePrefix)
	        .replace(templateParamRegexSuffix, templateParamReplaceSuffix)
	        .match(templateWildcardOrParamRegex)
	        ?.map(r => r.replace(templateWildcardOrParamPrefixRegex, '')) ?? []);
	};
	class Matcher {
	    #regex;
	    #strictRegex;
	    #template;
	    #params;
	    /**
	     * Creates a new matcher
	     * @param routeOrPath
	     * @throws {MatcherInvalidPathError} when the path is invalid (empty or relative)
	     */
	    constructor(routeOrPath) {
	        const path = typeof routeOrPath === 'string' ? routeOrPath : routeOrPath.path;
	        if (!path)
	            throw new MatcherInvalidPathError(path);
	        const { regex, strictRegex } = templateToRegex(path);
	        this.#regex = regex;
	        this.#strictRegex = strictRegex;
	        this.#template = path;
	        this.#params = templateToParams(path);
	    }
	    match(path, strict) {
	        const _path = path?.trim()?.split('?')?.at(0)?.replace(hashPathRegex, '');
	        if (!_path)
	            return false;
	        if (strict)
	            return this.#strictRegex.test(_path);
	        return this.#regex.test(_path);
	    }
	    extract(path) {
	        const _path = path?.trim()?.split('?')?.at(0)?.replace(hashPathRegex, '');
	        const result = { params: {}, wildcards: {} };
	        if (!_path)
	            return result;
	        this.#regex.exec(path)?.forEach((match, index) => {
	            if (index === 0)
	                return;
	            if (index > this.#params.length)
	                return;
	            const paramName = this.#params[index - 1];
	            if (paramName === '*')
	                result.wildcards[index] = match;
	            else
	                result.params[paramName] = match;
	        });
	        return result;
	    }
	}

	const LoggerKey = 'SR Router';
	class Logger {
	    static logger = new ProxyLogger({ logLevel: LogLevel.Warn });
	    static colorize = ProxyLogger.colorize;
	    static setLogLevel(logLevel) {
	        if (typeof logLevel === 'string')
	            this.logger.logLevel = toLogLevel(logLevel);
	        else
	            this.logger.logLevel = logLevel;
	    }
	    static get timestamp() {
	        return ProxyLogger.timestamp();
	    }
	    static get trace() {
	        return this.logger.trace;
	    }
	    static get debug() {
	        return this.logger.debug;
	    }
	    static get info() {
	        return this.logger.info;
	    }
	    static get warn() {
	        return this.logger.warn;
	    }
	    static get error() {
	        return this.logger.error;
	    }
	}

	/* event.svelte.js generated by Svelte v5.1.9 */

	class NavigationEvent {
		uuid;
		to;
		from;
		#result;
		#resolve;
		#reject;
		#status = state('active');
		#error;
		#redirect;

		/**
		 * The error that caused the navigation to fail if any.
		 */
		get error() {
			return this.#error;
		}

		/**
		 * The current status of the navigation event.
		 */
		get status() {
			return get(this.#status);
		}

		/**
		 * The navigation event is still pending.
		 * @pending
		 */
		get active() {
			return strict_equals(get(this.#status), 'active');
		}

		/**
		 * The navigation has been completed successfully.
		 * @success
		 */
		get completed() {
			return strict_equals(get(this.#status), 'completed');
		}

		/**
		 * The navigation has been cancelled.
		 * @error
		 */
		get cancelled() {
			return strict_equals(get(this.#status), 'cancelled');
		}

		/**
		 * The navigation has failed.
		 * @error
		 */
		get failed() {
			return this.#error ?? strict_equals(get(this.#status), 'failed');
		}

		/**
		 * The navigation has been redirected.
		 * @success
		 */
		get redirected() {
			return this.#redirect ?? strict_equals(get(this.#status), 'redirected');
		}

		/**
		 * Promise that resolves when the navigation event is completed.
		 */
		get result() {
			if (!this.active) return this.completed || this.redirected ? Promise.resolve(get(this.#status)) : Promise.reject(get(this.#status));

			if (!this.#result) {
				const { promise, resolve, reject } = Promise.withResolvers();

				this.#result = promise;
				this.#resolve = resolve;
				this.#reject = reject;
			}

			return this.#result;
		}

		constructor(to, from) {
			this.uuid = crypto.randomUUID();
			this.to = { ...to, route: toBaseRoute(to.route) };
			this.from = from;
		}

		/**
		 * Complete the current navigation event and mark it as redirected.
		 * @param to
		 */
		redirect(to) {
			if (!this.active) return Logger.error('Cannot redirect a navigation event that is not active', this);
			set(this.#status, 'redirected');
			this.#redirect = to;
			this.#resolve?.(get(this.#status));
		}

		/**
		 * Complete the current navigation event and mark it as completed.
		 */
		complete() {
			if (!this.active) return Logger.error('Cannot complete a navigation event that is not active', this);
			set(this.#status, 'completed');
			this.#resolve?.(get(this.#status));
		}

		/**
		 * Cancel the current navigation event.
		 * @throws {@link NavigationCancelledError}
		 */
		cancel(error) {
			if (!this.active) return Logger.error('Cannot cancel a navigation event that is not active', this);
			set(this.#status, 'cancelled');
			this.#error = error ?? new NavigationCancelledError(this);
			this.#reject?.(get(this.#status));
			if (this.#error instanceof NavigationCancelledError) throw this.#error;
			throw new NavigationCancelledError(this, { error });
		}

		/**
		 * Fail the current navigation event.
		 * @param error - Error to throw
		 * @throws {@link NavigationAbortedError}
		 */
		fail(error) {
			if (!this.active) return Logger.error('Cannot fail a navigation event that is not active', this);
			set(this.#status, 'failed');
			this.#error = error ?? new NavigationAbortedError(this);
			this.#reject?.(get(this.#status));
			if (this.#error instanceof NavigationAbortedError) throw this.#error;
			throw new NavigationAbortedError(this, { error });
		}
	}

	class ViewChangeEvent {
		uuid;
		view;
		route;
		#result;
		#resolve;
		#reject;
		#status = state('pending');
		#error;

		get error() {
			return this.#error;
		}

		get status() {
			return get(this.#status);
		}

		get loading() {
			return strict_equals(get(this.#status), 'loading');
		}

		get pending() {
			return this.loading || strict_equals(get(this.#status), 'pending');
		}

		get loaded() {
			return strict_equals(get(this.#status), 'loaded');
		}

		get failed() {
			return strict_equals(get(this.#status), 'error');
		}

		/**
		 * Promise that resolves when the navigation event is completed.
		 */
		get result() {
			if (!this.pending) return this.failed ? Promise.reject(get(this.#status)) : Promise.resolve(get(this.#status));

			if (!this.#result) {
				const { promise, resolve, reject } = Promise.withResolvers();

				this.#result = promise;
				this.#resolve = resolve;
				this.#reject = reject;
			}

			return this.#result;
		}

		constructor({ view, route }) {
			this.uuid = crypto.randomUUID();
			this.view = view;
			this.route = route;
		}

		load() {
			if (!this.pending) return Logger.error('Cannot load a change event that is not pending', this);
			set(this.#status, 'loading');
			return this;
		}

		complete() {
			if (!this.pending) return Logger.error('Cannot complete a change event that is not pending', this);
			set(this.#status, 'loaded');
			this.#resolve?.(get(this.#status));
			return this;
		}

		fail(error) {
			if (!this.pending) return Logger.error('Cannot fail a change event that is not pending', this);
			set(this.#status, 'error');
			this.#error = error;
			this.#reject?.(error);
			return this;
		}
	}

	const routeToHistoryState = ({ route, location }, { metaAsState, nameAsTitle, state, scrollState = { x: globalThis?.scrollX, y: globalThis?.scrollY }, } = {}) => {
	    const { href, query, params, name, path } = location ?? {};
	    const _name = name ?? route?.name;
	    const _path = path ?? route?.path;
	    const title = route?.title ?? (nameAsTitle ? _name?.toString() : undefined);
	    const routerState = {};
	    if (metaAsState && route?.meta)
	        routerState.meta = JSON.parse(JSON.stringify(route.meta));
	    if (name)
	        routerState.name = _name;
	    if (path)
	        routerState.path = _path;
	    if (href)
	        routerState.href = href.toString();
	    if (query)
	        routerState.query = query;
	    if (params)
	        routerState.params = params;
	    return {
	        state: {
	            ...state,
	            [RouterStateConstant]: routerState,
	            [RouterScrollConstant]: scrollState,
	        },
	        title: title?.length ? replaceTitleParams(title, params) : title,
	    };
	};
	const resolveNewHref = (target, { base, hash, query, stripQuery, stripHash, stripTrailingHash, current = globalThis?.location.href, } = {}) => {
	    const href = new URL(current);
	    // In hash mode, we extract the query from the hash, else we use the search params
	    let search;
	    if (stripQuery)
	        search = new URLSearchParams();
	    else if (hash)
	        search = new URLSearchParams(href.hash?.split('?')?.at(1)?.split('#').at(0));
	    else
	        search = href.searchParams;
	    // If we have a query params, we override the current query params
	    if (query)
	        Object.entries(query).forEach(([key, value]) => search.set(key, String(value)));
	    const [_target, _query] = target.split('?');
	    // If the target includes query params, we parse them and merge them with the current query params
	    if (_query?.length)
	        new URLSearchParams(_query).forEach((value, key) => value && search.set(key, value));
	    // if we have a hash, we override the current hash
	    if (hash) {
	        const trailingHash = href.hash.split('#')?.slice(2).join('#') ?? '';
	        href.hash = `#${_target}`;
	        const strSearch = search.toString();
	        if (strSearch)
	            href.hash += `?${strSearch}`;
	        if (trailingHash?.length && !stripTrailingHash)
	            href.hash += `#${trailingHash}`;
	        if (base)
	            href.pathname = toPathSegment(base, true);
	        if (href.search && !href.search?.endsWith('/'))
	            href.search += '/';
	        if (!href.search?.length && !href.pathname?.endsWith('/'))
	            href.pathname += '/';
	    }
	    else {
	        href.pathname = [base, _target]
	            .filter(Boolean)
	            .map(s => toPathSegment(s))
	            .join('');
	        if (stripHash)
	            href.hash = '';
	        if (stripQuery)
	            href.search = search.toString();
	    }
	    return { href, search };
	};
	const isRouteNavigation = (navigation) => {
	    if (!navigation)
	        return false;
	    if (typeof navigation !== 'object')
	        return false;
	    return !!(('name' in navigation && navigation?.name) || ('path' in navigation && navigation?.path));
	};
	const preventNavigation = (result, failure) => {
	    if (result instanceof Error)
	        throw new NavigationAbortedError(failure, { error: result });
	    if (result === false)
	        throw new NavigationAbortedError(failure);
	    if (isRouteNavigation(result))
	        return result;
	    return false;
	};

	/* router.svelte.js generated by Svelte v5.1.9 */

	class Router {
		/**
		 * Unique identifier for the router instance.
		 */
		id = `r${randomHex(4)}`;
		/**
		 * Logger prefix for the router instance.
		 * @private
		 */
		#log = `[${LoggerKey} - ${this.id}]`;
		/**
		 * Original options object passed to create the Router
		 * @private
		 */
		#options;
		#routes = state(proxy(new SvelteMap()));
		#sortedRoutes = derived(() => Array.from(get(this.#routes).values()).sort(this.#priority));
		#namedRoutes = state(proxy(new SvelteMap()));
		#location = state();
		#route = state();
		#error = state();
		#routing = state();
		#beforeEachGuards = state(proxy(new SvelteSet()));
		#onStartListeners = state(proxy(new SvelteSet()));
		#onEndListeners = state(proxy(new SvelteSet()));
		#onErrorListeners = state(proxy(new SvelteSet()));
		#listening = state(false);

		/**
		 * Event listener for the `navigate` or `popstate` event.
		 * @private
		 */
		#navigateListener = async () => {
			if (this.#matchState) return;
			Logger.debug(this.#log, 'Navigate listener', this.snapshot);

			try {
				await this.sync();
			} catch(error) {
				if (error instanceof NavigationCancelledError) {
					Logger.warn(this.#log, `Failed to sync, navigation cancelled`, error);
				} else {
					Logger.error(this.#log, `Failed to sync`, error);
				}
			}
		};

		/**
		 * History instance to use.
		 * @private
		 */
		get #history() {
			return this.#options.history;
		}

		/**
		 * State object from the history API.
		 * @private
		 */
		get #state() {
			return this.#history.state?.[RouterStateConstant];
		}

		/**
		 * Check if the current location matches the state in the history.
		 * @private
		 */
		get #matchState() {
			return !!(this.#state?.href?.toString() && get(this.#location)?.href?.toString());
		}

		/**
		 * Navigation instance to use.
		 * @private
		 */
		get #navigation() {
			return this.#options.navigation;
		}

		/**
		 * Browser location instance to use.
		 * @private
		 */
		get #browser() {
			return this.#options.location;
		}

		/**
		 * If the router should use the hash portion of the URL for routing.
		 * @private
		 */
		get #hash() {
			return this.#options.hash;
		}

		/**
		 * Base path for the router.
		 * @private
		 */
		get #base() {
			return this.#options.base;
		}

		/**
		 * Priority function to sort routes.
		 * @private
		 */
		get #priority() {
			return this.#options.priority ?? RouterPathPriority;
		}

		/**
		 * If the router should use the navigation API for listening to navigation events.
		 * @private
		 */
		get #useNavigationApi() {
			if (!this.#navigation) return false;
			return strict_equals(this.#options.listen, true) || strict_equals(this.#options.listen, 'navigation');
		}

		/**
		 * Get the route name map based on the case sensitivity option.
		 * @private
		 */
		get #routeNameMap() {
			if (this.#options.caseSensitive) return get(this.#namedRoutes);

			return {
				has: (name) => get(this.#namedRoutes).has(String(name).toLowerCase()),
				get: (name) => get(this.#namedRoutes).get(String(name).toLowerCase()),
				set: (name, path) => get(this.#namedRoutes).set(String(name).toLowerCase(), path),
				delete: (name) => get(this.#namedRoutes).delete(String(name).toLowerCase())
			};
		}

		/**
		 * The last error that occurred during navigation.
		 * This is reactive and will update when an error occurs.
		 * @reactive
		 */
		get error() {
			return get(this.#error);
		}

		/**
		 * The current routing event.
		 * This is reactive and will update when a navigation event is triggered.
		 * @reactive
		 */
		get routing() {
			return get(this.#routing);
		}

		/**
		 * This is a reactive state of the router.
		 * To get a snapshot of the router state, use {@link snapshot} instead.
		 * Current {@link ResolvedRouterLocation}
		 * @reactive
		 */
		get current() {
			return { route: this.route, location: this.location };
		}

		/**
		 * This is a snapshot of the router state.
		 * To get a reactive state, use {@link current} instead.
		 * Current {@link ResolvedRouterLocation}
		 */
		get snapshot() {
			return {
				route: toBaseRoute(get(this.#route)),
				location: toBasicRouterLocation(get(this.#location))
			};
		}

		/**
		 * Router options snapshot.
		 * This snapshot is not reactive but it's properties might be (e.g. `listen`).
		 */
		get options() {
			return {
				base: this.#base,
				hash: this.#hash,
				strict: this.#options.strict,
				failOnNotFound: this.#options.failOnNotFound,
				metaAsState: this.#options.metaAsState,
				nameAsTitle: this.#options.nameAsTitle,
				followGuardRedirects: this.#options.followGuardRedirects,
				caseSensitive: this.#options.caseSensitive,
				syncUpdate: this.#options.syncUpdate,
				syncDebounce: this.#options.syncDebounce,
				stripHash: this.#options.stripHash,
				stripQuery: this.#options.stripQuery,
				stripTrailingHash: this.#options.stripTrailingHash,
				listen: get(this.#listening)
			};
		}

		/**
		 * Current {@link RouterLocation}
		 * This is reactive and will update when the location changes.
		 * @reactive
		 */
		get location() {
			return get(this.#location);
		}

		/**
		 * Current {@link Route}.
		 * This is reactive and will update when the route changes.
		 * @reactive
		 */
		get route() {
			return get(this.#route);
		}

		/**
		 * Get a full list of all the {@link Route}.
		 * @reactive
		 */
		get routes() {
			return get(this.#sortedRoutes);
		}

		constructor(options = {}) {
			this.#options = {
				...defaultOptions,
				...options,
				base: toPathSegment(options.base)
			};

			if (this.#options.routes) this.addRoutes(this.#options.routes);
			this.sync = debounce$2(this.#sync.bind(this), this.#options.syncDebounce ?? 0);
			this.#init();
			if (strict_equals(this.#options?.logLevel, undefined, false)) Logger.setLogLevel(this.#options.logLevel);
			Logger.debug(this.#log, 'Router created', { options: this.#options });
		}

		async #init() {
			try {
				await this.sync();
			} catch(error) {
				if (error instanceof NavigationCancelledError) {
					Logger.warn(this.#log, `Failed to sync, navigation cancelled`, error);
				} else {
					Logger.error(this.#log, `Failed to sync`, error);
				}
			}

			if (this.#options.beforeEach) get(this.#beforeEachGuards).add(this.#options.beforeEach);
			if (this.#options.onStart) get(this.#onStartListeners).add(this.#options.onStart);
			if (this.#options.onEnd) get(this.#onEndListeners).add(this.#options.onEnd);
			if (this.#options.onError) get(this.#onErrorListeners).add(this.#options.onError);
			if (this.#options.listen) this.listen();
			Logger.info(...Logger.colorize(LoggerColor.Success, this.#log, 'Router initialized'), { options: this.options });
		}

		listen() {
			//  If already listening, exit
			if (get(this.#listening)) return;
			if (strict_equals(typeof window, 'undefined')) return;
			if (this.#useNavigationApi) this.#navigation?.addEventListener('currententrychange', this.#navigateListener); else window.addEventListener('popstate', this.#navigateListener);
			set(this.#listening, proxy(this.#useNavigationApi ? 'navigation' : 'history', null, this.#listening));
			Logger.debug(this.#log, 'Router listening', { listening: get(this.#listening) });
		}

		destroy() {
			if (strict_equals(typeof window, 'undefined')) return;
			window.removeEventListener('popstate', this.#navigateListener);
			this.#navigation?.removeEventListener('currententrychange', this.#navigateListener);
			set(this.#listening, false);
			Logger.info(this.#log, ...Logger.colorize(LoggerColor.Warn, 'Router destroyed'), { listening: get(this.#listening) });
		}

		/**
		 * Checks if a route with a given name exists
		 *
		 * @param name - Name of the route to check
		 */
		hasRouteName(name) {
			return this.#routeNameMap.has(name);
		}

		/**
		 * Checks if a route with a given path exists
		 *
		 * @param path - Path of the route to check
		 */
		hasRoutePath(path) {
			return get(this.#routes).has(path);
		}

		/**
		 * Checks if a route with a given name or path exists
		 *
		 * @param route - Partial route with name or path
		 */
		hasRoute({ path, name }) {
			if (name && this.hasRouteName(name)) return true;
			return !!(path && this.hasRoutePath(path));
		}

		/**
		 * Add a new {@link Route} to the router.
		 *
		 * @param route - Route Record to add
		 *
		 * @throws {@link RouterNameConflictError} if a route with the same name already exists
		 * @throws {@link RouterPathConflictError} if a route with the same path already exists
		 */
		addRoute(route) {
			if (route.name && this.hasRouteName(route.name)) throw new RouterNameConflictError(route.name);
			if (route.path && this.hasRoutePath(route.path)) throw new RouterPathConflictError(route.path);

			const _route = cloneRoute(route);

			if (!_route.matcher) _route.matcher = new Matcher(route);
			get(this.#routes).set(route.path, _route);
			if (route.name) this.#routeNameMap.set(route.name, route.path);

			route.children?.forEach((child) => {
				const _child = {
					...child,
					path: [route.path, child.path].map((p) => toPathSegment(p)).join(''),
					parent: route
				};

				this.addRoute(_child);
			});

			Logger.debug(this.#log, 'Route added', {
				route,
				routes: this.routes,
				names: get(this.#namedRoutes)
			});

			return this;
		}

		/**
		 * Add multiple {@link Route} to the router.
		 *
		 * @param routes - Array of routes to add
		 *
		 * @throws {@link RouterNameConflictError} if a route with the same name already exists
		 * @throws {@link RouterPathConflictError} if a route with the same path already exists
		 */
		addRoutes(routes) {
			routes.forEach(this.addRoute.bind(this));
			return this;
		}

		/**
		 * Remove an existing route by its name.
		 *
		 * @param route - Partial route with name or path
		 */
		removeRoute({ path, name }) {
			//  If no name or path is provided, return false
			if (!name && !path) return false;

			//  Check if the name or path provided matches the registered name or path when both are provided
			const registeredPath = name ? this.#routeNameMap.get(name) : undefined;
			const registeredName = path ? get(this.#routes).get(path)?.name : undefined;

			if (name && path) {
				if (registeredPath && strict_equals(registeredPath, path, false)) throw new RouterNamePathMismatchError({ name, path, registeredPath });
				if (registeredName && strict_equals(registeredName, name, false)) throw new RouterNamePathMismatchError({ name, path, registeredName });
			}

			const _path = path || registeredPath;
			const _name = name || registeredName;
			let result = false;

			if (_name) result = this.#routeNameMap.delete(_name);
			if (_path) result = get(this.#routes).delete(_path) || result;

			if (result) Logger.debug(this.#log, 'Removed route', {
				name: _name,
				path: _path,
				routes: this.routes,
				names: get(this.#namedRoutes)
			});

			return result;
		}

		/**
		 * Remove multiple routes by their name or path.
		 * @param routes - Array of routes to remove
		 *
		 * @returns Array of removed routes
		 */
		removeRoutes(routes) {
			return routes.filter(this.removeRoute.bind(this));
		}

		/**
		 * Add a navigation guard that executes before any navigation.
		 *
		 * @return Returns a function that removes the registered guard.
		 *
		 * @param guard - navigation guard to add
		 */
		beforeEach(guard) {
			get(this.#beforeEachGuards).add(guard);
			return () => get(this.#beforeEachGuards).delete(guard);
		}

		/**
		 * Add a navigation listener that is executed when the navigation is triggered but before the route is resolved.
		 *
		 * @param listener - navigation listener to add
		 *
		 * @returns a function that removes the registered listener
		 */
		onStart(listener) {
			get(this.#onStartListeners).add(listener);
			return () => get(this.#onStartListeners).delete(listener);
		}

		/**
		 * Add a navigation listener that is executed when the navigation is triggered and the route is resolved.
		 *
		 * @param listener - navigation listener to add
		 *
		 * @returns a function that removes the registered listener
		 */
		onEnd(listener) {
			get(this.#onEndListeners).add(listener);
			return () => get(this.#onEndListeners).delete(listener);
		}

		/**
		 * Add a navigation listener that is executed when an error occurs during navigation.
		 *
		 * @param listener - navigation listener to add
		 *
		 * @returns a function that removes the registered listener
		 */
		onError(listener) {
			get(this.#onErrorListeners).add(listener);
			return () => get(this.#onErrorListeners).delete(listener);
		}

		/**
		 * Returns the {@link ResolvedRoute} from a {@link RouteNavigation} and current route {@link Route}.
		 *
		 * By default, the `currentLocation` used is `router.currentRoute` and should only be overridden in advanced use cases.
		 *
		 * @param to - Route name or location to resolve
		 * @param options - Additional options to pass to the resolver
		 * @param options.from - Optional current location to resolve against
		 * @param options.strict - If `true`, will only match exact routes
		 * @param options.failOnNotFound - If `true`, will throw an error if the route is not found
		 *
		 * @throws {@link NavigationNotFoundError} if the navigation is not found.
		 */
		resolve(
			to,
			{
				from = get(this.#route),
				strict = this.options?.strict,
				failOnNotFound = this.options?.failOnNotFound,
				base = this.options?.base,
				hash = this.options?.hash
			} = {}
		) {
			const {
				query,
				params,
				path,
				name,
				stripQuery = this.options.stripQuery,
				stripHash = this.options.stripHash,
				stripTrailingHash = this.options.stripTrailingHash
			} = to;

			let _path = path;

			//  if 'name' is present, use namedRoutes to resolve path
			if (!path && name) _path = this.#routeNameMap.get(name);

			if (!_path) throw new NavigationNotFoundError({ to, from }, {
				message: 'No path could be resolved from the provided location'
			});

			// strip hash from path
			if (hash) {
				if (_path.startsWith('/#')) _path = _path.slice(2);
				if (_path.startsWith('#')) _path = _path.slice(1);
			}

			//  if relative path, use from and compute absolute path
			if (_path?.startsWith('.')) {
				if (!from) throw new NavigationNotFoundError({ to, from }, {
					message: 'Relative path provided but no current location could be found'
				});

				_path = computeAbsolutePath(from?.path ?? '', _path);
			}

			if (!_path.startsWith('/')) _path = `/${_path}`;

			// Attempt to find route by path
			let route = get(this.#routes).get(_path);

			//  inject params into path
			if (_path) _path = replaceTemplateParams(_path, { ...route?.params, ...params });
			//  Find exact match
			if (!route) route = this.routes.find((r) => r.matcher.match(_path, true));
			//  If no route found, find first match (if strict is false)
			if (!route && !strict) route = this.routes.find((r) => r.matcher.match(_path));
			//  if no route found and failOnNotFound is true, throw NavigationNotFoundError
			if (!route && failOnNotFound) throw new NavigationNotFoundError({ to, from });

			const { wildcards, params: _params } = route?.matcher.extract(_path) ?? {};

			//  use hash, path, and query to resolve new href
			const { href, search } = resolveNewHref(_path, {
				base,
				hash,
				stripQuery,
				stripHash,
				stripTrailingHash,
				query: { ...route?.query, ...query },
				current: this.#browser.href
			});

			Logger.debug(this.#log, 'Route resolved', route?.name, {
				to,
				from,
				route,
				path: _path,
				href,
				search,
				wildcards,
				params: _params
			});

			//  return resolved route
			return {
				route,
				path: _path,
				name: route?.name,
				href,
				query: Object.fromEntries(search),
				params: { ...params, ..._params },
				wildcards: { ...wildcards }
			};
		}

		/**
		 * Execute all the navigation guards before navigating to a new route.
		 *
		 * @param to - Route location to navigate to
		 * @param navigation - The current navigation event
		 *
		 * @private
		 */
		async #navigationGuards(to, navigation) {
			let result;

			result = preventNavigation(await get(this.#route)?.beforeLeave?.(navigation), navigation);
			if (!Object.is(get(this.#routing), navigation)) navigation.cancel();
			if (result) return result;
			result = preventNavigation(await to.route?.beforeEnter?.(navigation), navigation);
			if (!Object.is(get(this.#routing), navigation)) navigation.cancel();
			if (result) return result;

			result = await raceUntil(
				Array.from(get(this.#beforeEachGuards)).map(async (guard) => {
					if (!Object.is(get(this.#routing), navigation)) navigation.cancel();
					return preventNavigation(await guard(navigation), navigation);
				}),
				(_result) => !!_result
			).outer;

			return result ?? false;
		}

		/**
		 * Internal method to redirect to a new navigation location.
		 * @param to - Route location to navigate to
		 * @param options - Additional options to pass to the resolver
		 * @private
		 */
		async #redirect(to, options = {}) {
			const resolved = this.resolve(to, options);

			return this.#navigate(resolved, options);
		}

		/**
		 * Navigate to a new URL by updating the current location and route.
		 *
		 * @param to - Route location to navigate to
		 * @param from - Route location to navigate from
		 * @param options - Additional options to pass to the resolver
		 *
		 * @throws {@link NavigationFailure} if the navigation is aborted, cancelled, or not found.
		 */
		async #navigate(to, options = {}, from = this.snapshot) {
			const { route, ...location } = to;
			// Merge the options with the router options
			const _options = { ...this.options, ...options };

			const _location = {
				origin: location.href.origin,
				base: _options.base,
				...location
			};

			// If the route is the same, return the current snapshot
			if (!_options.force && isResolvedLocationEqual(this.current, { route, location: _location })) return this.snapshot;
			// Reset the error state
			set(this.#error, undefined);

			// Update the routing state
			const navigation = new NavigationEvent(to, from);

			// Broadcast the navigation start event
			await Promise.all([...get(this.#onStartListeners)].map((listener) => listener(navigation)));
			// Set the new navigation as the current routing event
			set(this.#routing, proxy(navigation, null, this.#routing));

			try {
				// Execute navigation guards
				const blockOrRedirect = await this.#navigationGuards(to, navigation);

				// If the navigation was cancelled return the new promise
				if (!Object.is(get(this.#routing), navigation)) navigation.cancel();

				// If a guard returns a redirect, navigate to the new location and replace state
				if (strict_equals(typeof blockOrRedirect, 'object') && _options.followGuardRedirects) {
					Logger.info(...Logger.colorize(LoggerColor.Info, this.#log, 'Guard redirect'), { ...navigation, redirect: blockOrRedirect });
					navigation.redirect(blockOrRedirect);
					return this.#redirect(blockOrRedirect, { ..._options, followGuardRedirects: false });
				}

				// If the route is a redirect, navigate to the new location and replace state
				if (route?.redirect) {
					Logger.info(...Logger.colorize(LoggerColor.Info, this.#log, 'Route redirect'), { ...navigation, redirect: route.redirect });
					navigation.redirect(route.redirect);
					return this.#redirect(route.redirect, _options);
				}

				// Update the current route and location
				set(this.#route, proxy(route, null, this.#route));
				set(this.#location, proxy(_location, null, this.#location));
				Logger.info(...Logger.colorize(LoggerColor.Success, this.#log, 'Navigated to', to?.name || to?.path), navigation);
				navigation.complete();
				return this.snapshot;
			} catch(error) {
				// If the navigation was already cancelled, rethrow the error
				if (error instanceof NavigationCancelledError) throw error;
				// If the navigation was cancelled throw cancellation error
				if (!Object.is(get(this.#routing), navigation)) navigation.cancel(error);
				set(this.#error, proxy(error, null, this.#error));
				// Broadcast the navigation error event
				Logger.error(this.#log, 'Navigation error', { ...navigation, error });
				get(this.#onErrorListeners).forEach((listener) => listener(error, navigation));
				navigation.fail(error);
				throw error;
			} finally {
				// Only clear the routing state if the navigation is still active
				if (Object.is(get(this.#routing), navigation)) {
					// Broadcast the navigation end event
					get(this.#onEndListeners).forEach((listener) => listener(navigation, this.snapshot));
				}
			}
		}

		/**
		 * Sync the router with the current location.
		 *
		 * @param update - Whether to push or replace the current location to the history state.
		 * @defaults {@link type RouterOptions.update} or 'replace'
		 * @private
		 */
		async #sync(update = this.#options.syncUpdate ?? 'replace') {
			let path = this.#browser.pathname;

			if (this.#base && !path.startsWith(this.#base)) {
				set(this.#location, undefined);
				set(this.#route, undefined);
				return Logger.debug(this.#log, 'Not on base path, ignoring sync', { path, base: this.#base });
			}

			if (this.#hash) path = this.#browser.hash.slice(1); else if (this.#base) path = path.slice(this.#base.length);
			if (!path) path = '/';
			Logger.debug(this.#log, 'Syncing router ...', { update, path });
			if (strict_equals(update, 'push')) return this.push({ path });
			if (strict_equals(update, 'replace')) return this.replace({ path });

			const resolve = this.resolve({ path });

			return this.#navigate(resolve);
		}

		/**
		 * Sync the router with the current location.
		 * @debounced
		 */
		sync;

		/**
		 * Internal method to update the history state and navigate to a new URL.
		 *
		 * @param method - History method to use (pushState or replaceState)
		 * @param to - Route location to navigate to
		 * @param options - Additional options to pass to the resolver
		 *
		 * @throws {@link NavigationNotFoundError} if the route is not found.
		 * @throws {@link NavigationCancelledError} if the navigation is cancelled before completion.
		 * @throws {@link NavigationAbortedError} if the navigation is aborted by a navigation guard.
		 * @throws {@link ParsingError} if the URL cannot be parsed.
		 *
		 * @private
		 */
		async #historyWrapper(method, to, options) {
			const resolved = this.resolve(to, options);
			const routed = await this.#navigate(resolved, options);
			const { state, title } = routeToHistoryState(routed, { ...options, state: to.state });

			try {
				this.#history[method](state, title ?? '', routed.location?.href);
				if (title) document.title = title;
				Logger.debug(this.#log, 'State changed', { method, resolved, routed, state, title });
				return routed;
			} catch(error) {
				Logger.error(this.#log, 'History error', {
					method,
					error,
					resolved,
					routed,
					state,
					title
				});

				throw error;
			}
		}

		/**
		 * Programmatically navigate to a new URL by pushing an entry in the history stack.
		 *
		 * @param to - Route location to navigate to
		 * @param options - Additional options to pass to the resolver
		 *
		 * @throws {@link NavigationNotFoundError} if the route is not found.
		 * @throws {@link NavigationCancelledError} if the navigation is cancelled before completion.
		 * @throws {@link NavigationAbortedError} if the navigation is aborted by a navigation guard.
		 * @throws {@link ParsingError} if the URL cannot be parsed.
		 */
		async push(to, options = {}) {
			return this.#historyWrapper('pushState', to, { ...this.options, ...options });
		}

		/**
		 * Programmatically navigate to a new URL by replacing the current entry in the history stack.
		 *
		 * @param to - Route location to navigate to
		 * @param options - Additional options to pass to the resolver
		 *
		 * @throws {@link NavigationNotFoundError} if the route is not found.
		 * @throws {@link NavigationCancelledError} if the navigation is cancelled before completion.
		 * @throws {@link NavigationAbortedError} if the navigation is aborted by a navigation guard.
		 * @throws {@link ParsingError} if the URL cannot be parsed.
		 *
		 */
		async replace(to, options = {}) {
			return this.#historyWrapper('replaceState', to, { ...this.options, ...options });
		}

		/**
		 * Go back in history if possible by calling `history.back()`.
		 * Equivalent to `router.go(-1)`.
		 */
		async back() {
			this.#history.back();
			if (!get(this.#listening)) return this.sync();
			return this.snapshot;
		}

		/**
		 * Go forward in history if possible by calling `history.forward()`.
		 * Equivalent to `router.go(1)`.
		 */
		async forward() {
			this.#history.forward();
			if (!get(this.#listening)) return this.sync();
			return this.snapshot;
		}

		/**
		 * Allows you to move forward or backward through the history.
		 * Calls `history.go()`.
		 *
		 * @param delta - The position in the history to which you want to move, relative to the current page
		 */
		async go(delta) {
			this.#history.go(delta);
			if (!get(this.#listening)) return this.sync();
			return this.snapshot;
		}
	}

	mark_module_start();
	RouterContext[FILENAME] = "node_modules/@dvcol/svelte-simple-router/dist/components/RouterContext.svelte";

	var root_2$b = add_locations(template(`<span>Failed to initialize router</span>`), RouterContext[FILENAME], [[32, 2]]);

	function RouterContext($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);
		validate_prop_bindings($$props, [], [], RouterContext);

		const outerRouter = getRouter();

		if (outerRouter && ($$props.router || $$props.options)) {
			Logger.warn(`[${LoggerKey} Context]`, 'Router Context is already defined, router prop will be ignored', {
				context: outerRouter,
				props: $$props.router ?? $$props.options
			});
		}

		const createInnerRouter = (_router = new Router($$props.options)) => {
			setRouter(_router);
			Logger.debug(`[${LoggerKey} Context]`, 'Router Context set:', _router);
			return _router;
		};

		const innerRouter = outerRouter ? undefined : createInnerRouter($$props.router);
		const resolvedRouter = outerRouter ?? innerRouter;

		onDestroy(() => {
			if (!innerRouter) return;
			innerRouter.destroy();
			Logger.debug(`[${LoggerKey} Context]`, 'Router Context destroyed', innerRouter);
		});

		var fragment = comment();
		var node = first_child(fragment);

		if_block(
			node,
			() => resolvedRouter,
			($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				snippet(node_1, () => $$props.children ?? noop, () => resolvedRouter);
				append($$anchor, fragment_1);
			},
			($$anchor) => {
				var span = root_2$b();

				append($$anchor, span);
			}
		);

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(RouterContext);

	mark_module_start();
	RouteTransition[FILENAME] = "node_modules/@dvcol/svelte-simple-router/dist/components/RouteTransition.svelte";

	var root_2$a = add_locations(template(`<div><!></div>`), RouteTransition[FILENAME], [[38, 6]]);
	var root$P = add_locations(template(`<div><!></div>`), RouteTransition[FILENAME], [[35, 0]]);

	function RouteTransition($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);
		validate_prop_bindings($$props, [], [], RouteTransition);

		let firstRender = true;
		const skipFirst = derived(() => $$props.transition?.skipFirst ?? true);

		const skipTransition = (skip = get(skipFirst)) => {
			if (!firstRender || !skip) return false;
			firstRender = false;
			return true;
		};

		const _in = derived(() => (node, props, options) => {
			if (skipTransition()) return;
			return $$props.transition?.in?.(node, props, options);
		});

		const _out = derived(() => (node, props, options) => {
			if (firstRender && get(skipFirst)) return;
			return $$props.transition?.out?.(node, props, options);
		});

		const _inParams = derived(() => $$props.transition?.params?.in ?? {});
		const _outParams = derived(() => $$props.transition?.params?.out ?? {});
		const _containerProps = derived(() => $$props.transition?.props?.container);
		const _wrapperProps = derived(() => $$props.transition?.props?.wrapper);

		const _style = derived(() => {
			if (!$$props.transition?.viewTransitionName) return get(_containerProps)?.style;

			let _name = $$props.transition?.viewTransitionName;

			if (strict_equals(typeof _name, 'boolean')) _name = `sr-container-${$$props.id}`;

			return [
				`--container-transition-name: ${_name}`,
				get(_containerProps)?.style
			].filter(Boolean).join('; ');
		});

		var div = root$P();
		let attributes;
		var node_1 = child(div);

		if_block(
			node_1,
			() => $$props.transition?.in || $$props.transition?.out,
			($$anchor) => {
				var fragment = comment();
				var node_2 = first_child(fragment);

				key_block(node_2, () => $$props.key, ($$anchor) => {
					var div_1 = root_2$a();
					let attributes_1;
					var node_3 = child(div_1);

					snippet(node_3, () => $$props.children ?? noop);

					template_effect(() => attributes_1 = set_attributes(
						div_1,
						attributes_1,
						{
							"data-transition-id": "wrapper",
							...get(_wrapperProps)
						},
						"svelte-17v5qnt"
					));

					transition(1, div_1, () => get(_in), () => get(_inParams));
					transition(2, div_1, () => get(_out), () => get(_outParams));
					append($$anchor, div_1);
				});

				append($$anchor, fragment);
			},
			($$anchor) => {
				var fragment_1 = comment();
				var node_4 = first_child(fragment_1);

				snippet(node_4, () => $$props.children ?? noop);
				append($$anchor, fragment_1);
			}
		);

		template_effect(() => attributes = set_attributes(
			div,
			attributes,
			{
				"data-transition-id": "container",
				...get(_containerProps),
				style: get(_style)
			},
			"svelte-17v5qnt"
		));

		append($$anchor, div);
		return pop({ ...legacy_api() });
	}

	mark_module_end(RouteTransition);

	const isLazyComponent = (component) => !!(component && typeof component === 'function' && (component._isLazyComponent || component.name === 'component'));
	const isSnippet = (componentOrSnippet) => componentOrSnippet?.length === 1;
	const resolveComponent = async (component, { onStart, onLoading, onLoaded, onError, } = {}) => {
	    await onStart?.();
	    if (component && !isSnippet(component) && isLazyComponent(component)) {
	        onLoading?.();
	        try {
	            const awaited = await component();
	            await onLoaded?.(awaited.default);
	            return awaited.default;
	        }
	        catch (error) {
	            await onError?.(error);
	            return undefined;
	        }
	    }
	    onLoaded?.(component);
	    return component;
	};

	mark_module_start();
	RouteComponent[FILENAME] = "node_modules/@dvcol/svelte-simple-router/dist/components/RouteComponent.svelte";

	function RouteComponent($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const routed = wrap_snippet(RouteComponent, ($$anchor) => {
			var fragment = comment();
			var node = first_child(fragment);

			if_block(
				node,
				() => get(ResolvedComponent),
				($$anchor) => {
					var fragment_1 = comment();
					var node_1 = first_child(fragment_1);

					if_block(
						node_1,
						() => isSnippet(get(ResolvedComponent)),
						($$anchor) => {
							var fragment_2 = comment();
							var node_2 = first_child(fragment_2);

							snippet(node_2, () => get(ResolvedComponent), () => $$props.view.error ?? ($$props.view.loading ? $$props.route : get(_properties)));
							append($$anchor, fragment_2);
						},
						($$anchor) => {
							var fragment_3 = comment();
							var node_3 = first_child(fragment_3);

							component(node_3, () => get(ResolvedComponent), ($$anchor, $$component) => {
								$$component($$anchor, spread_props(
									{
										get error() {
											return $$props.view.error;
										}
									},
									() => get(_properties)
								));
							});

							append($$anchor, fragment_3);
						}
					);

					append($$anchor, fragment_1);
				},
				($$anchor) => {
					var fragment_4 = comment();
					var node_4 = first_child(fragment_4);

					if_block(
						node_4,
						() => $$props.view.loading,
						($$anchor) => {
							var fragment_5 = comment();
							var node_5 = first_child(fragment_5);

							snippet(node_5, () => $$props.loadingSnippet ?? noop, () => $$props.route);
							append($$anchor, fragment_5);
						},
						($$anchor) => {
							var fragment_6 = comment();
							var node_6 = first_child(fragment_6);

							if_block(
								node_6,
								() => $$props.view.error,
								($$anchor) => {
									var fragment_7 = comment();
									var node_7 = first_child(fragment_7);

									snippet(node_7, () => $$props.errorSnippet ?? noop, () => $$props.view.error);
									append($$anchor, fragment_7);
								},
								null,
								true
							);

							append($$anchor, fragment_6);
						},
						true
					);

					append($$anchor, fragment_4);
				}
			);

			append($$anchor, fragment);
		});

		const result = wrap_snippet(RouteComponent, ($$anchor) => {
			var fragment_8 = comment();
			var node_8 = first_child(fragment_8);

			if_block(
				node_8,
				() => get(routing) && $$props.routingSnippet,
				($$anchor) => {
					var fragment_9 = comment();
					var node_9 = first_child(fragment_9);

					snippet(node_9, () => $$props.routingSnippet, () => $$props.router.routing);
					append($$anchor, fragment_9);
				},
				($$anchor) => {
					routed($$anchor);
				}
			);

			append($$anchor, fragment_8);
		});

		validate_prop_bindings($$props, [], [], RouteComponent);

		// Resolve route, loading or error component to be rendered
		let ResolvedComponent = state(undefined);

		// Generate a unique identifier for each loading state, to prevent cancelled navigations from updating the view
		const change = derived(() => new ViewChangeEvent({
			view: { id: $$props.view.id, name: $$props.view.name },
			route: $$props.route
		}));

		// Extract routing state
		const routing = derived(() => !!$$props.router?.routing?.active);
		// Delay properties update until component is resolved
		let _properties = state(undefined);

		const listeners = derived(() => {
			const _uuid = get(change).uuid;

			return {
				onStart: () => {
					if (strict_equals(get(change).uuid, _uuid, false)) return;
					return untrack(() => $$props.view.start(get(change)));
				},
				onLoading: () => {
					if (strict_equals(get(change).uuid, _uuid, false)) return;
					set(ResolvedComponent, proxy($$props.loading, null));
					return untrack(() => $$props.view.load());
				},
				onLoaded: (_component) => {
					if (strict_equals(get(change).uuid, _uuid, false)) return;
					set(ResolvedComponent, proxy(_component, null));
					set(_properties, proxy($$props.properties, null));
					return untrack(() => $$props.view.complete());
				},
				onError: (err) => {
					if (strict_equals(get(change).uuid, _uuid, false)) return;
					set(ResolvedComponent, proxy($$props.error, null));
					return untrack(() => $$props.view.fail(err));
				}
			};
		});

		user_effect(() => {
			resolveComponent($$props.component, get(listeners));
		});

		// Trigger transition on route change or component update
		const transitionKey = derived(() => {
			const _keys = [get(ResolvedComponent)];

			if ($$props.transition?.updateOnRouteChange) _keys.push(get(change).uuid);
			if ($$props.transition?.updateOnPropsChange) _keys.push(get(_properties));
			if ($$props.routingSnippet) _keys.push(get(routing));
			return _keys;
		});

		var fragment_11 = comment();
		var node_10 = first_child(fragment_11);

		if_block(
			node_10,
			() => $$props.transition,
			($$anchor) => {
				RouteTransition($$anchor, {
					get id() {
						return $$props.view.id;
					},
					get key() {
						return get(transitionKey);
					},
					get transition() {
						return $$props.transition;
					},
					children: wrap_snippet(RouteComponent, ($$anchor, $$slotProps) => {
						result($$anchor);
					}),
					$$slots: { default: true }
				});
			},
			($$anchor) => {
				result($$anchor);
			}
		);

		append($$anchor, fragment_11);
		return pop({ ...legacy_api() });
	}

	mark_module_end(RouteComponent);

	const ViewDebuggerConstant = '__SVELTE_SIMPLE_VIEW_DEBUGGER__';
	const DefaultView = 'default';

	/* hooks.svelte.js generated by Svelte v5.1.9 */

	/**
	 * Returns the current router instance.
	 * @throws {MissingRouterContextError} when no router is available.
	 */
	const useRouter = () => {
		const router = getRouter();

		if (!router) throw new MissingRouterContextError();
		return router;
	};

	/**
	 * Returns the current view instance.
	 * @throws {MissingViewContextError} when no view is available.
	 */
	const useView = () => {
		const view = getView();

		if (!view) throw new MissingViewContextError();
		return view;
	};

	/* view.svelte.js generated by Svelte v5.1.9 */

	class View {
		/**
		 * Unique identifier for the view instance.
		 */
		uuid = `v${randomHex(4)}`;
		/**
		 * Unique identifier for the router instance.
		 */
		routerId;
		/**
		 * Name of the router view instance this is attached to.
		 */
		name;
		/**
		 * Logger prefix for the router instance.
		 * @private
		 */
		#log;
		#loading = state();
		#error = state();
		#onChangeListeners = state(proxy(new SvelteSet()));
		#onViewChangeListeners = state(proxy(new SvelteSet()));
		#onLoadedListeners = state(proxy(new SvelteSet()));
		#onErrorListeners = state(proxy(new SvelteSet()));

		/**
		 * Unique identifier of the view instance.
		 */
		get id() {
			return `${this.routerId}-${this.uuid}-${String(this.name)}`;
		}

		/**
		 * Indicates if the view is currently loading a component.
		 * @reactive
		 */
		get loading() {
			return !!get(this.#loading)?.pending;
		}

		/**
		 * Indicates if an error occurred during the last component loading.
		 * @reactive
		 */
		get error() {
			return get(this.#error);
		}

		constructor(routerId, name = DefaultView) {
			this.routerId = routerId;
			this.name = name;
			this.#log = `[${LoggerKey} View - ${[this.routerId, this.uuid, this.name].join(' - ')}]`;
		}

		/**
		 * Add a listener that execute when the route changes and before the view change starts.
		 *
		 * @return Returns a function that removes the registered guard.
		 *
		 * @param listener - listener to add
		 */
		onChange(listener) {
			get(this.#onChangeListeners).add(listener);
			return () => get(this.#onChangeListeners).delete(listener);
		}

		/**
		 * Add a listener that is executed when a view start loading a component.
		 *
		 * @param listener - listener to add
		 *
		 * @returns a function that removes the registered listener
		 */
		onLoading(listener) {
			get(this.#onViewChangeListeners).add(listener);
			return () => get(this.#onViewChangeListeners).delete(listener);
		}

		/**
		 * Add a listener that is executed when a view start loading a component.
		 *
		 * @param listener - listener to add
		 *
		 * @returns a function that removes the registered listener
		 */
		onLoaded(listener) {
			get(this.#onLoadedListeners).add(listener);
			return () => get(this.#onLoadedListeners).delete(listener);
		}

		/**
		 * Add a listener that is executed when an error occurs during view loading.
		 *
		 * @param listener - listener to add
		 *
		 * @returns a function that removes the registered listener
		 */
		onError(listener) {
			get(this.#onErrorListeners).add(listener);
			return () => get(this.#onErrorListeners).delete(listener);
		}

		/**
		 * Start the view loading process.
		 * @param event
		 */
		start(event) {
			set(this.#loading, proxy(event, null, this.#loading));
			Logger.debug(this.#log, 'View resolving...', event);
			return Promise.all([...get(this.#onChangeListeners)].map((listener) => listener(event)));
		}

		/**
		 * Mark the view as loading.
		 * @param event
		 */
		load(event = get(this.#loading)) {
			if (!event) throw new ViewChangeStatusError();
			event.load();
			Logger.debug(this.#log, 'View loading...', event);
			return Promise.all([...get(this.#onViewChangeListeners)].map((listener) => listener(event)));
		}

		/**
		 * Mark the view as loaded.
		 * @param event
		 */
		complete(event = get(this.#loading)) {
			if (!event) throw new ViewChangeStatusError();
			set(this.#error, undefined);
			set(this.#loading, undefined);
			event.complete();
			Logger.info(...Logger.colorize(LoggerColor.Success, this.#log, 'View loaded'), event);
			return Promise.all([...get(this.#onLoadedListeners)].map((listener) => listener(event)));
		}

		/**
		 * Mark the view as failed to load.
		 * @param error
		 * @param event
		 */
		fail(error, event = get(this.#loading)) {
			if (!event) throw new ViewChangeStatusError();
			set(this.#error, proxy(error, null, this.#error));
			set(this.#loading, undefined);
			event.fail(error);
			Logger.error(this.#log, 'View failed to load', { error, event });
			return Promise.all([...get(this.#onErrorListeners)].map((listener) => listener(error, event)));
		}
	}

	mark_module_start();
	RouteContainer[FILENAME] = "node_modules/@dvcol/svelte-simple-router/dist/components/RouteContainer.svelte";

	var root_1$n = add_locations(template(`<!> <!>`, 1), RouteContainer[FILENAME], []);
	var root_2$9 = add_locations(template(`<h3 style="color: red">Router not found</h3> <p style="color:red">Make sure you are calling useRoutes inside a RouterContext or RouterView component tree.</p>`, 1), RouteContainer[FILENAME], [[85, 2], [86, 2]]);

	function RouteContainer($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);
		validate_prop_bindings($$props, [], [], RouteContainer);

		// Extract router from context
		const router = useRouter();
		const route = derived(() => router.route);
		// Instantiate view and set it in context
		const view = new View(router.id, $$props.name);

		setView(view);

		// Extract component props from route
		const resolvedProps = derived(() => {
			if ($$props.name) return get(route)?.properties?.[$$props.name];
			return get(route)?.props ?? get(route)?.properties?.default;
		});

		// Extract component from route
		const component = derived(() => get(route)?.component);
		const components = derived(() => get(route)?.components);

		const ResolvedComponent = derived(() => {
			if ($$props.name) return get(components)?.[$$props.name];
			return get(component) ?? get(components)?.default;
		});

		// Extract loading component from route
		const loading = derived(() => get(route)?.loading);
		const loadings = derived(() => get(route)?.loadings);

		const ResolvedLoading = derived(() => {
			if ($$props.name) return get(loadings)?.[$$props.name];
			return get(loading) ?? get(loadings)?.default;
		});

		// Extract error component from route
		const error = derived(() => get(route)?.error);
		const errors = derived(() => get(route)?.errors);

		const ResolvedError = derived(() => {
			if ($$props.name) return get(errors)?.[$$props.name];
			return get(error) ?? get(errors)?.default;
		});

		const subs = [];

		if ($$props.beforeEach) subs.push(router.beforeEach($$props.beforeEach));
		if ($$props.onStart) subs.push(router.onStart($$props.onStart));
		if ($$props.onEnd) subs.push(router.onEnd($$props.onEnd));
		if ($$props.onError) subs.push(router.onError($$props.onError));
		if ($$props.onChange) subs.push(view.onChange($$props.onChange));
		if ($$props.onLoading) subs.push(view.onLoading($$props.onLoading));
		if ($$props.onLoaded) subs.push(view.onLoaded($$props.onLoaded));
		if ($$props.onError) subs.push(view.onError($$props.onError));
		onDestroy(() => subs.forEach((sub) => sub()));

		var fragment = comment();
		var node = first_child(fragment);

		if_block(
			node,
			() => router,
			($$anchor) => {
				var fragment_1 = root_1$n();
				var node_1 = first_child(fragment_1);

				snippet(node_1, () => $$props.children ?? noop, () => router);

				var node_2 = sibling(node_1, 2);

				RouteComponent(node_2, {
					get properties() {
						return get(resolvedProps);
					},
					get component() {
						return get(ResolvedComponent);
					},
					get loading() {
						return get(ResolvedLoading);
					},
					get error() {
						return get(ResolvedError);
					},
					router,
					view,
					get route() {
						return get(route);
					},
					get transition() {
						return $$props.transition;
					},
					get errorSnippet() {
						return $$props.error;
					},
					get loadingSnippet() {
						return $$props.loading;
					},
					get routingSnippet() {
						return $$props.routing;
					}
				});

				append($$anchor, fragment_1);
			},
			($$anchor) => {
				var fragment_2 = root_2$9();
				append($$anchor, fragment_2);
			}
		);

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(RouteContainer);

	mark_module_start();
	RouterView[FILENAME] = "node_modules/@dvcol/svelte-simple-router/dist/components/RouterView.svelte";

	function RouterView($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const container = wrap_snippet(RouterView, ($$anchor, _router = noop) => {
			RouteContainer($$anchor, spread_props(() => _props));
		});

		validate_prop_bindings($$props, [], [], RouterView);

		const _props = rest_props(
			$$props,
			[
				"$$slots",
				"$$events",
				"$$legacy",
				"options",
				"router"
			]);

		const contextRouter = getRouter();
		var fragment_1 = comment();
		var node = first_child(fragment_1);

		if_block(
			node,
			() => contextRouter,
			($$anchor) => {
				container($$anchor, () => contextRouter);
			},
			($$anchor) => {
				RouterContext($$anchor, {
					get options() {
						return $$props.options;
					},
					get router() {
						return $$props.router;
					},
					children: container
				});
			}
		);

		append($$anchor, fragment_1);
		return pop({ ...legacy_api() });
	}

	mark_module_end(RouterView);

	mark_module_start();
	RouteView[FILENAME] = "node_modules/@dvcol/svelte-simple-router/dist/components/RouteView.svelte";

	function RouteView($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);
		validate_prop_bindings($$props, [], [], RouteView);

		const _props = rest_props(
			$$props,
			[
				"$$slots",
				"$$events",
				"$$legacy",
				"children",
				"loading",
				"error",
				"route",
				"name"
			]);

		const router = useRouter();
		const _name = $$props.name ?? getView()?.name;
		let component;
		let components;

		// Extract snippet/component from props
		if (Object.keys(_props).length) {
			components = Object.entries(_props).reduce(
				(acc, [key, value]) => {
					if (strict_equals(typeof value, 'function', false)) return acc;
					acc[key] = value;
					return acc;
				},
				{}
			);

			if (!Object.keys(components).length) components = undefined;
		}

		if (_name && strict_equals(_name, DefaultView, false)) {
			components ?? (components = {});
			if (components[_name]) components.default = $$props.children; else components[_name] = $$props.children;
		} else {
			component = $$props.children;
		}

		const _route = {
			...$$props.route,
			component: $$props.route.component ?? component,
			components: $$props.route.components ?? components,
			error: $$props.route.error ?? $$props.error,
			loading: $$props.route.loading ?? $$props.loading
		};

		const log = `[${LoggerKey} Route - ${router.id}]`;

		if (!_route.redirect && !_route.component && !_route.components?.[_name || DefaultView]) {
			Logger.warn(log, 'Route has no component, redirect or children', _route);
		}

		const handleError = (err) => {
			if (err instanceof NavigationCancelledError) {
				Logger.warn(log, `Failed to sync, navigation cancelled`, err);
			} else {
				Logger.error(log, `Failed to sync`, err);
			}
		};

		router.addRoute(_route);

		Logger.debug(log, 'Route added', {
			route: $$props.route,
			children: $$props.children
		});

		router.sync().catch(handleError);

		onDestroy(() => {
			router.removeRoute(_route);
			Logger.debug(log, 'Route removed', $$props.route);
			router.sync().catch(handleError);
		});

		return pop({ ...legacy_api() });
	}

	mark_module_end(RouteView);

	mark_module_start();
	RouteDebugger[FILENAME] = "node_modules/@dvcol/svelte-simple-router/dist/components/debug/RouteDebugger.svelte";

	var root_2$8 = add_locations(template(`<p class="error svelte-1x3z273"> </p>`), RouteDebugger[FILENAME], [[35, 8]]);

	var root_1$m = add_locations(template(`<div><h1>Navigation Error</h1> <p class="error svelte-1x3z273"> </p> <!></div>`), RouteDebugger[FILENAME], [
		[31, 4, [[32, 6], [33, 6]]]
	]);

	var root$O = add_locations(template(`<div class="debug svelte-1x3z273"><h3 class="svelte-1x3z273"> </h3> <br> <div> </div> <div> </div> <div> </div> <div> </div> <br> <div> </div> <div> </div> <div> </div> <div> </div> <div> </div> <br> <!></div>`), RouteDebugger[FILENAME], [
		[
			9,
			0,
			[
				[10, 2],
				[11, 2],
				[12, 2],
				[13, 2],
				[14, 2],
				[15, 2],
				[16, 2],
				[17, 2],
				[18, 2],
				[19, 2],
				[21, 2],
				[22, 2],
				[29, 2]
			]
		]
	]);

	function RouteDebugger($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);
		validate_prop_bindings($$props, [], [], RouteDebugger);

		const router = useRouter();
		const route = derived(() => router?.route);
		const location = derived(() => router?.location);
		const meta = derived(() => get(route)?.meta);
		const error = derived(() => router?.error);
		var div = root$O();
		var h3 = child(div);
		var text = child(h3);

		var div_1 = sibling(h3, 4);
		var text_1 = child(div_1);

		var div_2 = sibling(div_1, 2);
		var text_2 = child(div_2);

		template_effect(() => set_text(text_2, `Params - ${JSON.stringify(get(location)?.params, undefined, 2) ?? ""}`));

		var div_3 = sibling(div_2, 2);
		var text_3 = child(div_3);

		template_effect(() => set_text(text_3, `Query - ${JSON.stringify(get(location)?.query, undefined, 2) ?? ""}`));

		var div_4 = sibling(div_3, 2);
		var text_4 = child(div_4);

		template_effect(() => set_text(text_4, `Wildcards - ${JSON.stringify(get(location)?.wildcards, undefined, 2) ?? ""}`));

		var div_5 = sibling(div_4, 4);
		var text_5 = child(div_5);

		var div_6 = sibling(div_5, 2);
		var text_6 = child(div_6);

		template_effect(() => set_text(text_6, `Meta - ${JSON.stringify(get(meta), undefined, 2) ?? ""}`));

		var div_7 = sibling(div_6, 2);
		var text_7 = child(div_7);

		template_effect(() => set_text(text_7, `Props - ${JSON.stringify(get(route)?.props, undefined, 2) ?? ""}`));

		var div_8 = sibling(div_7, 2);
		var text_8 = child(div_8);

		var div_9 = sibling(div_8, 2);
		var text_9 = child(div_9);

		template_effect(() => set_text(text_9, `Children - ${JSON.stringify(get(route)?.children?.map((r) => ({ name: r.name, path: r.path })), undefined, 2) ?? ""}`));

		var node = sibling(div_9, 4);

		if_block(node, () => get(error), ($$anchor) => {
			var div_10 = root_1$m();
			var p = sibling(child(div_10), 2);
			var text_10 = child(p);

			var node_1 = sibling(p, 2);

			if_block(node_1, () => get(error)?.stack, ($$anchor) => {
				var p_1 = root_2$8();
				var text_11 = child(p_1);
				template_effect(() => set_text(text_11, get(error).stack));
				append($$anchor, p_1);
			});
			template_effect(() => set_text(text_10, get(error)?.message ?? get(error)));
			append($$anchor, div_10);
		});

		template_effect(() => {
			set_text(text, `Router - ${router?.id ?? ""}`);
			set_text(text_1, `Location - ${get(location)?.path ?? ""}`);
			set_text(text_5, `Route - ${get(route)?.name ?? ""}`);
			set_text(text_8, `Parent - ${get(route)?.parent?.name ?? get(route)?.parent?.path ?? ""}`);
		});

		append($$anchor, div);
		return pop({ ...legacy_api() });
	}

	mark_module_end(RouteDebugger);

	mark_module_start();
	RouterDebugger[FILENAME] = "node_modules/@dvcol/svelte-simple-router/dist/components/debug/RouterDebugger.svelte";

	var root_1$l = add_locations(template(`<p>From <span class="route svelte-1iqdhn8"> </span> to <span class="route svelte-1iqdhn8"> </span></p>`), RouterDebugger[FILENAME], [
		[26, 4, [[27, 11], [28, 6]]]
	]);

	var root_2$7 = add_locations(template(`<p>Navigated to <span class="route svelte-1iqdhn8"> </span></p>`), RouterDebugger[FILENAME], [[31, 4, [[31, 20]]]]);

	var root$N = add_locations(template(`<div class="debug svelte-1iqdhn8"><h3 class="svelte-1iqdhn8"> </h3> <pre> </pre> <h3 class="svelte-1iqdhn8">Routing</h3> <div>Pending - <span class="svelte-1iqdhn8"> </span></div> <!></div>`), RouterDebugger[FILENAME], [
		[
			19,
			0,
			[
				[20, 2],
				[21, 2],
				[23, 2],
				[24, 2, [[24, 17]]]
			]
		]
	]);

	function RouterDebugger($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);
		validate_prop_bindings($$props, [], [], RouterDebugger);

		const router = useRouter();

		Logger.info(`[${LoggerKey} Debugger - ${router.id}]`, `router attached to "window.${RouterDebuggerConstant}"`, router);

		window[RouterDebuggerConstant] = {
			...window[RouterDebuggerConstant],
			[router.id]: router
		};

		const options = derived(() => router.options);
		const routing = derived(() => router.routing);
		const location = derived(() => router.location);

		onDestroy(() => {
			Logger.info(`[${LoggerKey} Debugger - ${router.id}]`, `router detached from "window.${RouterDebuggerConstant}"`, router);
			delete window[RouterDebuggerConstant]?.[router.id];
		});

		var div = root$N();
		var h3 = child(div);
		var text = child(h3);

		var pre = sibling(h3, 2);
		var text_1 = child(pre);

		template_effect(() => set_text(text_1, JSON.stringify(get(options), null, 2)));

		var div_1 = sibling(pre, 4);
		var span = sibling(child(div_1));
		var text_2 = child(span);

		var node = sibling(div_1, 2);

		if_block(
			node,
			() => get(routing),
			($$anchor) => {
				var p = root_1$l();
				var span_1 = sibling(child(p));
				var text_3 = child(span_1);

				var span_2 = sibling(span_1, 2);
				var text_4 = child(span_2);

				template_effect(() => {
					set_text(text_3, get(routing).from?.location?.name ?? get(routing)?.from?.location?.path ?? '-');
					set_text(text_4, get(routing).to?.name ?? get(routing)?.to?.path ?? '-');
				});

				append($$anchor, p);
			},
			($$anchor) => {
				var p_1 = root_2$7();
				var span_3 = sibling(child(p_1));
				var text_5 = child(span_3);
				template_effect(() => set_text(text_5, get(location)?.name ?? get(location)?.path));
				append($$anchor, p_1);
			}
		);

		template_effect(() => {
			set_text(text, `Router options - ${router?.id ?? ""}`);
			toggle_class(span, "route", get(routing)?.active);
			set_text(text_2, !!get(routing)?.active);
		});

		append($$anchor, div);
		return pop({ ...legacy_api() });
	}

	mark_module_end(RouterDebugger);

	mark_module_start();
	ViewDebugger[FILENAME] = "node_modules/@dvcol/svelte-simple-router/dist/components/debug/ViewDebugger.svelte";

	var root_2$6 = add_locations(template(`<p class="error svelte-prsw2g"> </p>`), ViewDebugger[FILENAME], [[30, 8]]);

	var root_1$k = add_locations(template(`<div><h1>Navigation Error</h1> <p class="error svelte-prsw2g"> </p> <!></div>`), ViewDebugger[FILENAME], [
		[26, 4, [[27, 6], [28, 6]]]
	]);

	var root$M = add_locations(template(`<div class="debug svelte-prsw2g"><h3 class="svelte-prsw2g"> </h3> <br> <div> </div> <div>Loading - <span class="svelte-prsw2g"> </span></div> <br> <!></div>`), ViewDebugger[FILENAME], [
		[
			19,
			0,
			[
				[20, 2],
				[21, 2],
				[22, 2],
				[23, 2, [[23, 17]]],
				[24, 2]
			]
		]
	]);

	function ViewDebugger($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);
		validate_prop_bindings($$props, [], [], ViewDebugger);

		const view = useView();

		Logger.info(`[${LoggerKey} Debugger - ${view.id}]`, `view attached to "window.${ViewDebuggerConstant}"`, view);

		window[ViewDebuggerConstant] = {
			...window[ViewDebuggerConstant],
			[view.id]: view
		};

		const name = derived(() => view.name);
		const loading = derived(() => view.loading);
		const error = derived(() => view.error);

		onDestroy(() => {
			Logger.info(`[${LoggerKey} Debugger - ${view.id}]`, `router detached from "window.${ViewDebuggerConstant}"`, view);
			delete window[ViewDebuggerConstant]?.[view.id];
		});

		var div = root$M();
		var h3 = child(div);
		var text = child(h3);

		var div_1 = sibling(h3, 4);
		var text_1 = child(div_1);

		var div_2 = sibling(div_1, 2);
		var span = sibling(child(div_2));
		var text_2 = child(span);

		var node = sibling(div_2, 4);

		if_block(node, () => get(error), ($$anchor) => {
			var div_3 = root_1$k();
			var p = sibling(child(div_3), 2);
			var text_3 = child(p);

			var node_1 = sibling(p, 2);

			if_block(node_1, () => get(error)?.stack, ($$anchor) => {
				var p_1 = root_2$6();
				var text_4 = child(p_1);
				template_effect(() => set_text(text_4, get(error).stack));
				append($$anchor, p_1);
			});
			template_effect(() => set_text(text_3, get(error)?.message ?? get(error)));
			append($$anchor, div_3);
		});

		template_effect(() => {
			set_text(text, `View - ${view?.id ?? ""}`);
			set_text(text_1, `Name - ${get(name) ?? ""}`);
			toggle_class(span, "loading", get(loading));
			set_text(text_2, get(loading));
		});

		append($$anchor, div);
		return pop({ ...legacy_api() });
	}

	mark_module_end(ViewDebugger);

	/* active.svelte.js generated by Svelte v5.1.9 */

	// recursively extract route.parent.name
	const getParentName = (route, names = []) => {
		if (route?.name) names.push(route.name);
		if (!route?.parent) return names;
		return getParentName(route.parent, names);
	};

	/**
	 * A svelte action to add an active state (class, style or attribute) to an element when the route matches.
	 *
	 * Additionally:
	 * - If attached to an anchor element, it will attempt to match the href attribute.
	 * - If path or name options are provided, they will take precedence over the element attributes.
	 * - Name always takes precedence over path.
	 * - When the route un-matches, the original style will be restored.
	 *
	 * Note: The action requires the router context to be present in the component tree.
	 *
	 * @param node - The element to add the active state to
	 * @param options - The options to use for the active state
	 *
	 * @see {@link RouterView}
	 *
	 * @example
	 * ```html
	 * <a href="/path" use:active>simple link</a>
	 * <a href="/path" data-name="route-name" use:active>named link</a>
	 * <button :use:active="{ path: '/path' }">button link</button>
	 * <div :use:active="{ name: 'route-name' }">div link</div>
	 * ```
	 */
	const active = (node, options = {}) => {
		const router = getRouter();

		if (!router) {
			Logger.warn('Router not found. Make sure you are using the active action within a Router context.', { node, options });
			node.setAttribute('data-error', 'Router not found.');
			return {};
		}

		let _options = state(proxy(options));
		let _path = state(proxy(get(_options).path || node.getAttribute('data-path') || node.getAttribute('href')));
		let _name = state(proxy(get(_options).name || node.getAttribute('data-name')));

		if (!get(_path) && !get(_name)) {
			Logger.warn('No path or name found. Make sure you are using the active action with the proper parameters.', { node, options });
			node.setAttribute('data-error', 'No path or name found.');
			return {};
		}

		const route = derived(() => router.route);
		const caseSensitive = derived(() => get(_options)?.caseSensitive ?? router.options?.caseSensitive);

		const matchName = derived(() => {
			if (!get(_name)) return false;
			if (!get(route)?.name) return false;

			const names = get(_options).exact ? [get(route).name] : getParentName(get(route));

			if (get(caseSensitive)) return names.includes(get(_name));
			return names.map((n) => String(n)?.toLowerCase()).includes(String(get(_name))?.toLowerCase());
		});

		const location = derived(() => router.location?.path);
		const matcher = derived(() => get(_path) ? new Matcher(get(_path)) : undefined);

		const matchPath = derived(() => {
			if (get(_name)) return false;
			if (!get(matcher)) return false;
			if (!get(location)) return false;
			if (get(_options).exact) return get(matcher).match(get(location), true);
			return get(matcher).match(get(location));
		});

		const match = derived(() => get(matchName) || get(matchPath));
		const originalStyle = Object.fromEntries(Object.keys(get(_options).style || {}).map((key) => [key, node.style[key]]));

		user_effect(() => {
			if (get(match)) {
				node.setAttribute('data-active', 'true');
				if (get(_options).class) node.classList.add(get(_options).class);

				if (get(_options).style) {
					Object.assign(node.style, get(_options).style);
				}
			} else {
				node.removeAttribute('data-active');
				if (get(_options).class) node.classList.remove(get(_options).class);

				if (get(_options).style) {
					Object.keys(get(_options).style).forEach((key) => node.style.removeProperty(key));
					Object.assign(node.style, originalStyle);
				}
			}
		});

		return {
			update: (newOptions = {}) => {
				set(_options, proxy(newOptions, null));
				set(_path, proxy(newOptions.path || node.getAttribute('data-path') || node.getAttribute('href'), null));
				set(_name, proxy(newOptions.name || node.getAttribute('data-name'), null));

				if (!get(_path) && !get(_name)) {
					Logger.warn('No path or name found. Make sure you are using the active action with the proper parameters.', { node, options });
				}
			}
		};
	};

	/* link.svelte.js generated by Svelte v5.1.9 */

	const isAnchorTarget = (target) => {
		return target instanceof HTMLAnchorElement;
	};

	const isTargetWithin = (element) => {
		return strict_equals(element.target, '') || strict_equals(element.target, '_self');
	};

	const isNavigationEvent = (event) => {
		if (event.defaultPrevented) return false;
		if (event instanceof MouseEvent && strict_equals(event.button, 0, false)) return false;
		if (event instanceof KeyboardEvent && strict_equals(event.key, 'Enter', false)) return false;
		return !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
	};

	const isSameHost = (anchor, host = window.location.host) => {
		return strict_equals(anchor.host, host) || anchor.href.startsWith(`https://${host}`) || strict_equals(anchor.href.indexOf(`http://${host}`), 0);
	};

	const parseJsonAttribute = (element, name) => {
		const value = element.getAttribute(`data-${name}`);

		if (strict_equals(value, undefined) || strict_equals(value, null)) return;

		try {
			return JSON.parse(value);
		} catch(error) {
			Logger.error(`Failed to parse JSON attribute "${name}" on <a> element`, { element, name, error });
			element.setAttribute('data-error', `Failed to parse JSON attribute "${name}"`);
		}
	};

	const parseBooleanAttribute = (element, name) => {
		const value = element.getAttribute(`data-${name}`);

		if (strict_equals(value, undefined) || strict_equals(value, null)) return;
		return strict_equals(value, 'false', false);
	};

	const addIfFound = (obj, key, value) => {
		if (strict_equals(value, undefined, false)) obj[key] = value;
		return obj;
	};

	const isNotValidAnchorNavigation = (event) => {
		const anchor = event.currentTarget;

		// if the event is not a valid navigation event (left click or enter, no modifier keys), we return
		if (!isNavigationEvent(event)) return true;
		// if the target is not an anchor element, we skip target and host checks
		if (!isAnchorTarget(anchor)) return false;
		if (!isTargetWithin(anchor)) return true;
		return !isSameHost(anchor);
	};

	/**
	 * A svelte action to add to an element to navigate to a new location using the router.
	 *
	 * The link action will prevent the default behavior and use the router only if the following conditions are met:
	 * - The element is within a router context
	 * - The event is a left click or enter key
	 * - The event does not have a modifier key
	 * - The target is not an external link (for anchor elements)
	 * - The target is not a new tab or window (for anchor elements)
	 *
	 * Additionally:
	 * - The action merge data-attributes with the options passed as argument.
	 * - Passed options have precedence over data-attributes.
	 * - If attribute expects a JSON object, it will be parsed.
	 * - If a name or path parameter are provided, they will be used to navigate and href will be ignored.
	 * - Name takes precedence over path.
	 * - If the host is not an anchor element, the role and tabindex attributes will be set.
	 *
	 * Note: The action requires the router context to be present in the component tree.
	 *
	 * @param node - The element to add the link action to
	 * @param options - The options to use for the navigation
	 *
	 * @Example
	 * ```html
	 * <a href="/path/:param?query=value" use:link>simple link</a>
	 * <a href='goodbye' name use:link>named link</a>
	 * <a href='/path/:param' data-query='{"query":"value"}' use:link>link with query</a>
	 * <a href='/path/:param' use:link="{ params: { param: 'value' } }">link with params</a>
	 * <div href='/path/:param' use:link="{ params: { param: 'value' } }">div link</div>
	 * <button href='/path/:param' use:link="{ params: { param: 'value' } }">button link</button>
	 * ```
	 */
	const link = (node, options = {}) => {
		if (!isAnchorTarget(node)) {
			if (!node.hasAttribute('role')) node.setAttribute('role', 'link');
			if (!node.hasAttribute('tabindex')) node.setAttribute('tabindex', '0');
		} else if (!node.hasAttribute('href') && options?.path) {
			node.setAttribute('href', options.path);
		}

		const router = getRouter();

		if (!router) {
			Logger.warn('Router not found. Make sure you are using the link action within a Router context.', { node, options });
			node.setAttribute('data-error', 'Router not found.');
			return {};
		}

		let _options = options;

		const navigate = async (event) => {
			// if the target is an anchor element and the event is not a valid navigation event, we return
			if (isNotValidAnchorNavigation(event)) return;
			event.preventDefault();

			const replace = _options?.replace || parseBooleanAttribute(node, 'replace');
			const name = _options?.name || node.getAttribute('data-name');
			const path = (_options?.path || node.getAttribute('data-path') || node.getAttribute('href')) ?? '';
			const navigation = name ? { name } : { path };

			// CommonRouteNavigation
			addIfFound(navigation, 'query', _options.query ?? parseJsonAttribute(node, 'query'));
			addIfFound(navigation, 'params', _options.params ?? parseJsonAttribute(node, 'params'));
			addIfFound(navigation, 'state', _options.state ?? parseJsonAttribute(node, 'state'));
			addIfFound(navigation, 'stripQuery', _options.stripQuery ?? parseBooleanAttribute(node, 'strip-query'));
			addIfFound(navigation, 'stripHash', _options.stripHash ?? parseBooleanAttribute(node, 'strip-hash'));
			addIfFound(navigation, 'stripTrailingHash', _options.stripTrailingHash ?? parseBooleanAttribute(node, 'strip-trailing-hash'));

			const navigationOptions = {};

			// RouterNavigationOptions
			addIfFound(navigationOptions, 'base', _options.base ?? (node.getAttribute('data-base') || undefined));
			addIfFound(navigationOptions, 'hash', _options.hash ?? parseBooleanAttribute(node, 'hash'));
			addIfFound(navigationOptions, 'strict', _options.strict ?? parseBooleanAttribute(node, 'strict'));
			addIfFound(navigationOptions, 'force', _options.force ?? parseBooleanAttribute(node, 'force'));
			addIfFound(navigationOptions, 'failOnNotFound', _options.failOnNotFound ?? parseBooleanAttribute(node, 'fail-on-not-found'));
			addIfFound(navigationOptions, 'metaAsState', _options.metaAsState ?? parseBooleanAttribute(node, 'meta-as-state'));
			addIfFound(navigationOptions, 'nameAsTitle', _options.nameAsTitle ?? parseBooleanAttribute(node, 'name-as-title'));
			addIfFound(navigationOptions, 'followGuardRedirects', _options.followGuardRedirects ?? parseBooleanAttribute(node, 'follow-guard-redirects'));

			try {
				return await router[replace ? 'replace' : 'push'](navigation, navigationOptions);
			} catch(error) {
				if (error instanceof NavigationCancelledError) {
					Logger.warn(`[${LoggerKey} Link - ${router.id}] Navigation cancelled`, { node, error, navigation, navigationOptions });
				} else {
					Logger.error(`[${LoggerKey} Link - ${router.id}] Failed to navigate`, { node, error, navigation, navigationOptions });
				}
			}
		};

		node.addEventListener('click', navigate);
		node.addEventListener('keydown', navigate);

		return {
			update(newOptions = {}) {
				_options = newOptions;
			},
			destroy() {
				node.removeEventListener('click', navigate);
				node.removeEventListener('keydown', navigate);
			}
		};
	};

	if (typeof window !== "undefined") {
		if (window.Prism)
			console.warn(
				"Prism has already been initiated. Please ensure that svelte-prism is imported first."
			);

		window.Prism = window.Prism || {};
		window.Prism.manual = true;
	}

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var prism$2 = {exports: {}};

	var hasRequiredPrism;

	function requirePrism () {
		if (hasRequiredPrism) return prism$2.exports;
		hasRequiredPrism = 1;
		(function (module) {
			/* **********************************************
			     Begin prism-core.js
			********************************************** */

			/// <reference lib="WebWorker"/>

			var _self = (typeof window !== 'undefined')
				? window   // if in browser
				: (
					(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
						? self // if in worker
						: {}   // if in node js
				);

			/**
			 * Prism: Lightweight, robust, elegant syntax highlighting
			 *
			 * @license MIT <https://opensource.org/licenses/MIT>
			 * @author Lea Verou <https://lea.verou.me>
			 * @namespace
			 * @public
			 */
			var Prism = (function (_self) {

				// Private helper vars
				var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
				var uniqueId = 0;

				// The grammar object for plaintext
				var plainTextGrammar = {};


				var _ = {
					/**
					 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
					 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
					 * additional languages or plugins yourself.
					 *
					 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
					 *
					 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
					 * empty Prism object into the global scope before loading the Prism script like this:
					 *
					 * ```js
					 * window.Prism = window.Prism || {};
					 * Prism.manual = true;
					 * // add a new <script> to load Prism's script
					 * ```
					 *
					 * @default false
					 * @type {boolean}
					 * @memberof Prism
					 * @public
					 */
					manual: _self.Prism && _self.Prism.manual,
					/**
					 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
					 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
					 * own worker, you don't want it to do this.
					 *
					 * By setting this value to `true`, Prism will not add its own listeners to the worker.
					 *
					 * You obviously have to change this value before Prism executes. To do this, you can add an
					 * empty Prism object into the global scope before loading the Prism script like this:
					 *
					 * ```js
					 * window.Prism = window.Prism || {};
					 * Prism.disableWorkerMessageHandler = true;
					 * // Load Prism's script
					 * ```
					 *
					 * @default false
					 * @type {boolean}
					 * @memberof Prism
					 * @public
					 */
					disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

					/**
					 * A namespace for utility methods.
					 *
					 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
					 * change or disappear at any time.
					 *
					 * @namespace
					 * @memberof Prism
					 */
					util: {
						encode: function encode(tokens) {
							if (tokens instanceof Token) {
								return new Token(tokens.type, encode(tokens.content), tokens.alias);
							} else if (Array.isArray(tokens)) {
								return tokens.map(encode);
							} else {
								return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
							}
						},

						/**
						 * Returns the name of the type of the given value.
						 *
						 * @param {any} o
						 * @returns {string}
						 * @example
						 * type(null)      === 'Null'
						 * type(undefined) === 'Undefined'
						 * type(123)       === 'Number'
						 * type('foo')     === 'String'
						 * type(true)      === 'Boolean'
						 * type([1, 2])    === 'Array'
						 * type({})        === 'Object'
						 * type(String)    === 'Function'
						 * type(/abc+/)    === 'RegExp'
						 */
						type: function (o) {
							return Object.prototype.toString.call(o).slice(8, -1);
						},

						/**
						 * Returns a unique number for the given object. Later calls will still return the same number.
						 *
						 * @param {Object} obj
						 * @returns {number}
						 */
						objId: function (obj) {
							if (!obj['__id']) {
								Object.defineProperty(obj, '__id', { value: ++uniqueId });
							}
							return obj['__id'];
						},

						/**
						 * Creates a deep clone of the given object.
						 *
						 * The main intended use of this function is to clone language definitions.
						 *
						 * @param {T} o
						 * @param {Record<number, any>} [visited]
						 * @returns {T}
						 * @template T
						 */
						clone: function deepClone(o, visited) {
							visited = visited || {};

							var clone; var id;
							switch (_.util.type(o)) {
								case 'Object':
									id = _.util.objId(o);
									if (visited[id]) {
										return visited[id];
									}
									clone = /** @type {Record<string, any>} */ ({});
									visited[id] = clone;

									for (var key in o) {
										if (o.hasOwnProperty(key)) {
											clone[key] = deepClone(o[key], visited);
										}
									}

									return /** @type {any} */ (clone);

								case 'Array':
									id = _.util.objId(o);
									if (visited[id]) {
										return visited[id];
									}
									clone = [];
									visited[id] = clone;

									(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
										clone[i] = deepClone(v, visited);
									});

									return /** @type {any} */ (clone);

								default:
									return o;
							}
						},

						/**
						 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
						 *
						 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
						 *
						 * @param {Element} element
						 * @returns {string}
						 */
						getLanguage: function (element) {
							while (element) {
								var m = lang.exec(element.className);
								if (m) {
									return m[1].toLowerCase();
								}
								element = element.parentElement;
							}
							return 'none';
						},

						/**
						 * Sets the Prism `language-xxxx` class of the given element.
						 *
						 * @param {Element} element
						 * @param {string} language
						 * @returns {void}
						 */
						setLanguage: function (element, language) {
							// remove all `language-xxxx` classes
							// (this might leave behind a leading space)
							element.className = element.className.replace(RegExp(lang, 'gi'), '');

							// add the new `language-xxxx` class
							// (using `classList` will automatically clean up spaces for us)
							element.classList.add('language-' + language);
						},

						/**
						 * Returns the script element that is currently executing.
						 *
						 * This does __not__ work for line script element.
						 *
						 * @returns {HTMLScriptElement | null}
						 */
						currentScript: function () {
							if (typeof document === 'undefined') {
								return null;
							}
							if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
								return /** @type {any} */ (document.currentScript);
							}

							// IE11 workaround
							// we'll get the src of the current script by parsing IE11's error stack trace
							// this will not work for inline scripts

							try {
								throw new Error();
							} catch (err) {
								// Get file src url from stack. Specifically works with the format of stack traces in IE.
								// A stack will look like this:
								//
								// Error
								//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
								//    at Global code (http://localhost/components/prism-core.js:606:1)

								var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
								if (src) {
									var scripts = document.getElementsByTagName('script');
									for (var i in scripts) {
										if (scripts[i].src == src) {
											return scripts[i];
										}
									}
								}
								return null;
							}
						},

						/**
						 * Returns whether a given class is active for `element`.
						 *
						 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
						 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
						 * given class is just the given class with a `no-` prefix.
						 *
						 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
						 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
						 * ancestors have the given class or the negated version of it, then the default activation will be returned.
						 *
						 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
						 * version of it, the class is considered active.
						 *
						 * @param {Element} element
						 * @param {string} className
						 * @param {boolean} [defaultActivation=false]
						 * @returns {boolean}
						 */
						isActive: function (element, className, defaultActivation) {
							var no = 'no-' + className;

							while (element) {
								var classList = element.classList;
								if (classList.contains(className)) {
									return true;
								}
								if (classList.contains(no)) {
									return false;
								}
								element = element.parentElement;
							}
							return !!defaultActivation;
						}
					},

					/**
					 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
					 *
					 * @namespace
					 * @memberof Prism
					 * @public
					 */
					languages: {
						/**
						 * The grammar for plain, unformatted text.
						 */
						plain: plainTextGrammar,
						plaintext: plainTextGrammar,
						text: plainTextGrammar,
						txt: plainTextGrammar,

						/**
						 * Creates a deep copy of the language with the given id and appends the given tokens.
						 *
						 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
						 * will be overwritten at its original position.
						 *
						 * ## Best practices
						 *
						 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
						 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
						 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
						 *
						 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
						 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
						 *
						 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
						 * @param {Grammar} redef The new tokens to append.
						 * @returns {Grammar} The new language created.
						 * @public
						 * @example
						 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
						 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
						 *     // at its original position
						 *     'comment': { ... },
						 *     // CSS doesn't have a 'color' token, so this token will be appended
						 *     'color': /\b(?:red|green|blue)\b/
						 * });
						 */
						extend: function (id, redef) {
							var lang = _.util.clone(_.languages[id]);

							for (var key in redef) {
								lang[key] = redef[key];
							}

							return lang;
						},

						/**
						 * Inserts tokens _before_ another token in a language definition or any other grammar.
						 *
						 * ## Usage
						 *
						 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
						 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
						 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
						 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
						 * this:
						 *
						 * ```js
						 * Prism.languages.markup.style = {
						 *     // token
						 * };
						 * ```
						 *
						 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
						 * before existing tokens. For the CSS example above, you would use it like this:
						 *
						 * ```js
						 * Prism.languages.insertBefore('markup', 'cdata', {
						 *     'style': {
						 *         // token
						 *     }
						 * });
						 * ```
						 *
						 * ## Special cases
						 *
						 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
						 * will be ignored.
						 *
						 * This behavior can be used to insert tokens after `before`:
						 *
						 * ```js
						 * Prism.languages.insertBefore('markup', 'comment', {
						 *     'comment': Prism.languages.markup.comment,
						 *     // tokens after 'comment'
						 * });
						 * ```
						 *
						 * ## Limitations
						 *
						 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
						 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
						 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
						 * deleting properties which is necessary to insert at arbitrary positions.
						 *
						 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
						 * Instead, it will create a new object and replace all references to the target object with the new one. This
						 * can be done without temporarily deleting properties, so the iteration order is well-defined.
						 *
						 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
						 * you hold the target object in a variable, then the value of the variable will not change.
						 *
						 * ```js
						 * var oldMarkup = Prism.languages.markup;
						 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
						 *
						 * assert(oldMarkup !== Prism.languages.markup);
						 * assert(newMarkup === Prism.languages.markup);
						 * ```
						 *
						 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
						 * object to be modified.
						 * @param {string} before The key to insert before.
						 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
						 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
						 * object to be modified.
						 *
						 * Defaults to `Prism.languages`.
						 * @returns {Grammar} The new grammar object.
						 * @public
						 */
						insertBefore: function (inside, before, insert, root) {
							root = root || /** @type {any} */ (_.languages);
							var grammar = root[inside];
							/** @type {Grammar} */
							var ret = {};

							for (var token in grammar) {
								if (grammar.hasOwnProperty(token)) {

									if (token == before) {
										for (var newToken in insert) {
											if (insert.hasOwnProperty(newToken)) {
												ret[newToken] = insert[newToken];
											}
										}
									}

									// Do not insert token which also occur in insert. See #1525
									if (!insert.hasOwnProperty(token)) {
										ret[token] = grammar[token];
									}
								}
							}

							var old = root[inside];
							root[inside] = ret;

							// Update references in other language definitions
							_.languages.DFS(_.languages, function (key, value) {
								if (value === old && key != inside) {
									this[key] = ret;
								}
							});

							return ret;
						},

						// Traverse a language definition with Depth First Search
						DFS: function DFS(o, callback, type, visited) {
							visited = visited || {};

							var objId = _.util.objId;

							for (var i in o) {
								if (o.hasOwnProperty(i)) {
									callback.call(o, i, o[i], type || i);

									var property = o[i];
									var propertyType = _.util.type(property);

									if (propertyType === 'Object' && !visited[objId(property)]) {
										visited[objId(property)] = true;
										DFS(property, callback, null, visited);
									} else if (propertyType === 'Array' && !visited[objId(property)]) {
										visited[objId(property)] = true;
										DFS(property, callback, i, visited);
									}
								}
							}
						}
					},

					plugins: {},

					/**
					 * This is the most high-level function in Prism’s API.
					 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
					 * each one of them.
					 *
					 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
					 *
					 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
					 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
					 * @memberof Prism
					 * @public
					 */
					highlightAll: function (async, callback) {
						_.highlightAllUnder(document, async, callback);
					},

					/**
					 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
					 * {@link Prism.highlightElement} on each one of them.
					 *
					 * The following hooks will be run:
					 * 1. `before-highlightall`
					 * 2. `before-all-elements-highlight`
					 * 3. All hooks of {@link Prism.highlightElement} for each element.
					 *
					 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
					 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
					 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
					 * @memberof Prism
					 * @public
					 */
					highlightAllUnder: function (container, async, callback) {
						var env = {
							callback: callback,
							container: container,
							selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
						};

						_.hooks.run('before-highlightall', env);

						env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

						_.hooks.run('before-all-elements-highlight', env);

						for (var i = 0, element; (element = env.elements[i++]);) {
							_.highlightElement(element, async === true, env.callback);
						}
					},

					/**
					 * Highlights the code inside a single element.
					 *
					 * The following hooks will be run:
					 * 1. `before-sanity-check`
					 * 2. `before-highlight`
					 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
					 * 4. `before-insert`
					 * 5. `after-highlight`
					 * 6. `complete`
					 *
					 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
					 * the element's language.
					 *
					 * @param {Element} element The element containing the code.
					 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
					 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
					 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
					 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
					 *
					 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
					 * asynchronous highlighting to work. You can build your own bundle on the
					 * [Download page](https://prismjs.com/download.html).
					 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
					 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
					 * @memberof Prism
					 * @public
					 */
					highlightElement: function (element, async, callback) {
						// Find language
						var language = _.util.getLanguage(element);
						var grammar = _.languages[language];

						// Set language on the element, if not present
						_.util.setLanguage(element, language);

						// Set language on the parent, for styling
						var parent = element.parentElement;
						if (parent && parent.nodeName.toLowerCase() === 'pre') {
							_.util.setLanguage(parent, language);
						}

						var code = element.textContent;

						var env = {
							element: element,
							language: language,
							grammar: grammar,
							code: code
						};

						function insertHighlightedCode(highlightedCode) {
							env.highlightedCode = highlightedCode;

							_.hooks.run('before-insert', env);

							env.element.innerHTML = env.highlightedCode;

							_.hooks.run('after-highlight', env);
							_.hooks.run('complete', env);
							callback && callback.call(env.element);
						}

						_.hooks.run('before-sanity-check', env);

						// plugins may change/add the parent/element
						parent = env.element.parentElement;
						if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
							parent.setAttribute('tabindex', '0');
						}

						if (!env.code) {
							_.hooks.run('complete', env);
							callback && callback.call(env.element);
							return;
						}

						_.hooks.run('before-highlight', env);

						if (!env.grammar) {
							insertHighlightedCode(_.util.encode(env.code));
							return;
						}

						if (async && _self.Worker) {
							var worker = new Worker(_.filename);

							worker.onmessage = function (evt) {
								insertHighlightedCode(evt.data);
							};

							worker.postMessage(JSON.stringify({
								language: env.language,
								code: env.code,
								immediateClose: true
							}));
						} else {
							insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
						}
					},

					/**
					 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
					 * and the language definitions to use, and returns a string with the HTML produced.
					 *
					 * The following hooks will be run:
					 * 1. `before-tokenize`
					 * 2. `after-tokenize`
					 * 3. `wrap`: On each {@link Token}.
					 *
					 * @param {string} text A string with the code to be highlighted.
					 * @param {Grammar} grammar An object containing the tokens to use.
					 *
					 * Usually a language definition like `Prism.languages.markup`.
					 * @param {string} language The name of the language definition passed to `grammar`.
					 * @returns {string} The highlighted HTML.
					 * @memberof Prism
					 * @public
					 * @example
					 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
					 */
					highlight: function (text, grammar, language) {
						var env = {
							code: text,
							grammar: grammar,
							language: language
						};
						_.hooks.run('before-tokenize', env);
						if (!env.grammar) {
							throw new Error('The language "' + env.language + '" has no grammar.');
						}
						env.tokens = _.tokenize(env.code, env.grammar);
						_.hooks.run('after-tokenize', env);
						return Token.stringify(_.util.encode(env.tokens), env.language);
					},

					/**
					 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
					 * and the language definitions to use, and returns an array with the tokenized code.
					 *
					 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
					 *
					 * This method could be useful in other contexts as well, as a very crude parser.
					 *
					 * @param {string} text A string with the code to be highlighted.
					 * @param {Grammar} grammar An object containing the tokens to use.
					 *
					 * Usually a language definition like `Prism.languages.markup`.
					 * @returns {TokenStream} An array of strings and tokens, a token stream.
					 * @memberof Prism
					 * @public
					 * @example
					 * let code = `var foo = 0;`;
					 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
					 * tokens.forEach(token => {
					 *     if (token instanceof Prism.Token && token.type === 'number') {
					 *         console.log(`Found numeric literal: ${token.content}`);
					 *     }
					 * });
					 */
					tokenize: function (text, grammar) {
						var rest = grammar.rest;
						if (rest) {
							for (var token in rest) {
								grammar[token] = rest[token];
							}

							delete grammar.rest;
						}

						var tokenList = new LinkedList();
						addAfter(tokenList, tokenList.head, text);

						matchGrammar(text, tokenList, grammar, tokenList.head, 0);

						return toArray(tokenList);
					},

					/**
					 * @namespace
					 * @memberof Prism
					 * @public
					 */
					hooks: {
						all: {},

						/**
						 * Adds the given callback to the list of callbacks for the given hook.
						 *
						 * The callback will be invoked when the hook it is registered for is run.
						 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
						 *
						 * One callback function can be registered to multiple hooks and the same hook multiple times.
						 *
						 * @param {string} name The name of the hook.
						 * @param {HookCallback} callback The callback function which is given environment variables.
						 * @public
						 */
						add: function (name, callback) {
							var hooks = _.hooks.all;

							hooks[name] = hooks[name] || [];

							hooks[name].push(callback);
						},

						/**
						 * Runs a hook invoking all registered callbacks with the given environment variables.
						 *
						 * Callbacks will be invoked synchronously and in the order in which they were registered.
						 *
						 * @param {string} name The name of the hook.
						 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
						 * @public
						 */
						run: function (name, env) {
							var callbacks = _.hooks.all[name];

							if (!callbacks || !callbacks.length) {
								return;
							}

							for (var i = 0, callback; (callback = callbacks[i++]);) {
								callback(env);
							}
						}
					},

					Token: Token
				};
				_self.Prism = _;


				// Typescript note:
				// The following can be used to import the Token type in JSDoc:
				//
				//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

				/**
				 * Creates a new token.
				 *
				 * @param {string} type See {@link Token#type type}
				 * @param {string | TokenStream} content See {@link Token#content content}
				 * @param {string|string[]} [alias] The alias(es) of the token.
				 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
				 * @class
				 * @global
				 * @public
				 */
				function Token(type, content, alias, matchedStr) {
					/**
					 * The type of the token.
					 *
					 * This is usually the key of a pattern in a {@link Grammar}.
					 *
					 * @type {string}
					 * @see GrammarToken
					 * @public
					 */
					this.type = type;
					/**
					 * The strings or tokens contained by this token.
					 *
					 * This will be a token stream if the pattern matched also defined an `inside` grammar.
					 *
					 * @type {string | TokenStream}
					 * @public
					 */
					this.content = content;
					/**
					 * The alias(es) of the token.
					 *
					 * @type {string|string[]}
					 * @see GrammarToken
					 * @public
					 */
					this.alias = alias;
					// Copy of the full string this token was created from
					this.length = (matchedStr || '').length | 0;
				}

				/**
				 * A token stream is an array of strings and {@link Token Token} objects.
				 *
				 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
				 * them.
				 *
				 * 1. No adjacent strings.
				 * 2. No empty strings.
				 *
				 *    The only exception here is the token stream that only contains the empty string and nothing else.
				 *
				 * @typedef {Array<string | Token>} TokenStream
				 * @global
				 * @public
				 */

				/**
				 * Converts the given token or token stream to an HTML representation.
				 *
				 * The following hooks will be run:
				 * 1. `wrap`: On each {@link Token}.
				 *
				 * @param {string | Token | TokenStream} o The token or token stream to be converted.
				 * @param {string} language The name of current language.
				 * @returns {string} The HTML representation of the token or token stream.
				 * @memberof Token
				 * @static
				 */
				Token.stringify = function stringify(o, language) {
					if (typeof o == 'string') {
						return o;
					}
					if (Array.isArray(o)) {
						var s = '';
						o.forEach(function (e) {
							s += stringify(e, language);
						});
						return s;
					}

					var env = {
						type: o.type,
						content: stringify(o.content, language),
						tag: 'span',
						classes: ['token', o.type],
						attributes: {},
						language: language
					};

					var aliases = o.alias;
					if (aliases) {
						if (Array.isArray(aliases)) {
							Array.prototype.push.apply(env.classes, aliases);
						} else {
							env.classes.push(aliases);
						}
					}

					_.hooks.run('wrap', env);

					var attributes = '';
					for (var name in env.attributes) {
						attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
					}

					return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
				};

				/**
				 * @param {RegExp} pattern
				 * @param {number} pos
				 * @param {string} text
				 * @param {boolean} lookbehind
				 * @returns {RegExpExecArray | null}
				 */
				function matchPattern(pattern, pos, text, lookbehind) {
					pattern.lastIndex = pos;
					var match = pattern.exec(text);
					if (match && lookbehind && match[1]) {
						// change the match to remove the text matched by the Prism lookbehind group
						var lookbehindLength = match[1].length;
						match.index += lookbehindLength;
						match[0] = match[0].slice(lookbehindLength);
					}
					return match;
				}

				/**
				 * @param {string} text
				 * @param {LinkedList<string | Token>} tokenList
				 * @param {any} grammar
				 * @param {LinkedListNode<string | Token>} startNode
				 * @param {number} startPos
				 * @param {RematchOptions} [rematch]
				 * @returns {void}
				 * @private
				 *
				 * @typedef RematchOptions
				 * @property {string} cause
				 * @property {number} reach
				 */
				function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
					for (var token in grammar) {
						if (!grammar.hasOwnProperty(token) || !grammar[token]) {
							continue;
						}

						var patterns = grammar[token];
						patterns = Array.isArray(patterns) ? patterns : [patterns];

						for (var j = 0; j < patterns.length; ++j) {
							if (rematch && rematch.cause == token + ',' + j) {
								return;
							}

							var patternObj = patterns[j];
							var inside = patternObj.inside;
							var lookbehind = !!patternObj.lookbehind;
							var greedy = !!patternObj.greedy;
							var alias = patternObj.alias;

							if (greedy && !patternObj.pattern.global) {
								// Without the global flag, lastIndex won't work
								var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
								patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
							}

							/** @type {RegExp} */
							var pattern = patternObj.pattern || patternObj;

							for ( // iterate the token list and keep track of the current token/string position
								var currentNode = startNode.next, pos = startPos;
								currentNode !== tokenList.tail;
								pos += currentNode.value.length, currentNode = currentNode.next
							) {

								if (rematch && pos >= rematch.reach) {
									break;
								}

								var str = currentNode.value;

								if (tokenList.length > text.length) {
									// Something went terribly wrong, ABORT, ABORT!
									return;
								}

								if (str instanceof Token) {
									continue;
								}

								var removeCount = 1; // this is the to parameter of removeBetween
								var match;

								if (greedy) {
									match = matchPattern(pattern, pos, text, lookbehind);
									if (!match || match.index >= text.length) {
										break;
									}

									var from = match.index;
									var to = match.index + match[0].length;
									var p = pos;

									// find the node that contains the match
									p += currentNode.value.length;
									while (from >= p) {
										currentNode = currentNode.next;
										p += currentNode.value.length;
									}
									// adjust pos (and p)
									p -= currentNode.value.length;
									pos = p;

									// the current node is a Token, then the match starts inside another Token, which is invalid
									if (currentNode.value instanceof Token) {
										continue;
									}

									// find the last node which is affected by this match
									for (
										var k = currentNode;
										k !== tokenList.tail && (p < to || typeof k.value === 'string');
										k = k.next
									) {
										removeCount++;
										p += k.value.length;
									}
									removeCount--;

									// replace with the new match
									str = text.slice(pos, p);
									match.index -= pos;
								} else {
									match = matchPattern(pattern, 0, str, lookbehind);
									if (!match) {
										continue;
									}
								}

								// eslint-disable-next-line no-redeclare
								var from = match.index;
								var matchStr = match[0];
								var before = str.slice(0, from);
								var after = str.slice(from + matchStr.length);

								var reach = pos + str.length;
								if (rematch && reach > rematch.reach) {
									rematch.reach = reach;
								}

								var removeFrom = currentNode.prev;

								if (before) {
									removeFrom = addAfter(tokenList, removeFrom, before);
									pos += before.length;
								}

								removeRange(tokenList, removeFrom, removeCount);

								var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
								currentNode = addAfter(tokenList, removeFrom, wrapped);

								if (after) {
									addAfter(tokenList, currentNode, after);
								}

								if (removeCount > 1) {
									// at least one Token object was removed, so we have to do some rematching
									// this can only happen if the current pattern is greedy

									/** @type {RematchOptions} */
									var nestedRematch = {
										cause: token + ',' + j,
										reach: reach
									};
									matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

									// the reach might have been extended because of the rematching
									if (rematch && nestedRematch.reach > rematch.reach) {
										rematch.reach = nestedRematch.reach;
									}
								}
							}
						}
					}
				}

				/**
				 * @typedef LinkedListNode
				 * @property {T} value
				 * @property {LinkedListNode<T> | null} prev The previous node.
				 * @property {LinkedListNode<T> | null} next The next node.
				 * @template T
				 * @private
				 */

				/**
				 * @template T
				 * @private
				 */
				function LinkedList() {
					/** @type {LinkedListNode<T>} */
					var head = { value: null, prev: null, next: null };
					/** @type {LinkedListNode<T>} */
					var tail = { value: null, prev: head, next: null };
					head.next = tail;

					/** @type {LinkedListNode<T>} */
					this.head = head;
					/** @type {LinkedListNode<T>} */
					this.tail = tail;
					this.length = 0;
				}

				/**
				 * Adds a new node with the given value to the list.
				 *
				 * @param {LinkedList<T>} list
				 * @param {LinkedListNode<T>} node
				 * @param {T} value
				 * @returns {LinkedListNode<T>} The added node.
				 * @template T
				 */
				function addAfter(list, node, value) {
					// assumes that node != list.tail && values.length >= 0
					var next = node.next;

					var newNode = { value: value, prev: node, next: next };
					node.next = newNode;
					next.prev = newNode;
					list.length++;

					return newNode;
				}
				/**
				 * Removes `count` nodes after the given node. The given node will not be removed.
				 *
				 * @param {LinkedList<T>} list
				 * @param {LinkedListNode<T>} node
				 * @param {number} count
				 * @template T
				 */
				function removeRange(list, node, count) {
					var next = node.next;
					for (var i = 0; i < count && next !== list.tail; i++) {
						next = next.next;
					}
					node.next = next;
					next.prev = node;
					list.length -= i;
				}
				/**
				 * @param {LinkedList<T>} list
				 * @returns {T[]}
				 * @template T
				 */
				function toArray(list) {
					var array = [];
					var node = list.head.next;
					while (node !== list.tail) {
						array.push(node.value);
						node = node.next;
					}
					return array;
				}


				if (!_self.document) {
					if (!_self.addEventListener) {
						// in Node.js
						return _;
					}

					if (!_.disableWorkerMessageHandler) {
						// In worker
						_self.addEventListener('message', function (evt) {
							var message = JSON.parse(evt.data);
							var lang = message.language;
							var code = message.code;
							var immediateClose = message.immediateClose;

							_self.postMessage(_.highlight(code, _.languages[lang], lang));
							if (immediateClose) {
								_self.close();
							}
						}, false);
					}

					return _;
				}

				// Get current script and highlight
				var script = _.util.currentScript();

				if (script) {
					_.filename = script.src;

					if (script.hasAttribute('data-manual')) {
						_.manual = true;
					}
				}

				function highlightAutomaticallyCallback() {
					if (!_.manual) {
						_.highlightAll();
					}
				}

				if (!_.manual) {
					// If the document state is "loading", then we'll use DOMContentLoaded.
					// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
					// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
					// might take longer one animation frame to execute which can create a race condition where only some plugins have
					// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
					// See https://github.com/PrismJS/prism/issues/2102
					var readyState = document.readyState;
					if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
						document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
					} else {
						if (window.requestAnimationFrame) {
							window.requestAnimationFrame(highlightAutomaticallyCallback);
						} else {
							window.setTimeout(highlightAutomaticallyCallback, 16);
						}
					}
				}

				return _;

			}(_self));

			if (module.exports) {
				module.exports = Prism;
			}

			// hack for components to work correctly in node.js
			if (typeof commonjsGlobal !== 'undefined') {
				commonjsGlobal.Prism = Prism;
			}

			// some additional documentation/types

			/**
			 * The expansion of a simple `RegExp` literal to support additional properties.
			 *
			 * @typedef GrammarToken
			 * @property {RegExp} pattern The regular expression of the token.
			 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
			 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
			 * @property {boolean} [greedy=false] Whether the token is greedy.
			 * @property {string|string[]} [alias] An optional alias or list of aliases.
			 * @property {Grammar} [inside] The nested grammar of this token.
			 *
			 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
			 *
			 * This can be used to make nested and even recursive language definitions.
			 *
			 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
			 * each another.
			 * @global
			 * @public
			 */

			/**
			 * @typedef Grammar
			 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
			 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
			 * @global
			 * @public
			 */

			/**
			 * A function which will invoked after an element was successfully highlighted.
			 *
			 * @callback HighlightCallback
			 * @param {Element} element The element successfully highlighted.
			 * @returns {void}
			 * @global
			 * @public
			 */

			/**
			 * @callback HookCallback
			 * @param {Object<string, any>} env The environment variables of the hook.
			 * @returns {void}
			 * @global
			 * @public
			 */


			/* **********************************************
			     Begin prism-markup.js
			********************************************** */

			Prism.languages.markup = {
				'comment': {
					pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
					greedy: true
				},
				'prolog': {
					pattern: /<\?[\s\S]+?\?>/,
					greedy: true
				},
				'doctype': {
					// https://www.w3.org/TR/xml/#NT-doctypedecl
					pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
					greedy: true,
					inside: {
						'internal-subset': {
							pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
							lookbehind: true,
							greedy: true,
							inside: null // see below
						},
						'string': {
							pattern: /"[^"]*"|'[^']*'/,
							greedy: true
						},
						'punctuation': /^<!|>$|[[\]]/,
						'doctype-tag': /^DOCTYPE/i,
						'name': /[^\s<>'"]+/
					}
				},
				'cdata': {
					pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
					greedy: true
				},
				'tag': {
					pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
					greedy: true,
					inside: {
						'tag': {
							pattern: /^<\/?[^\s>\/]+/,
							inside: {
								'punctuation': /^<\/?/,
								'namespace': /^[^\s>\/:]+:/
							}
						},
						'special-attr': [],
						'attr-value': {
							pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
							inside: {
								'punctuation': [
									{
										pattern: /^=/,
										alias: 'attr-equals'
									},
									{
										pattern: /^(\s*)["']|["']$/,
										lookbehind: true
									}
								]
							}
						},
						'punctuation': /\/?>/,
						'attr-name': {
							pattern: /[^\s>\/]+/,
							inside: {
								'namespace': /^[^\s>\/:]+:/
							}
						}

					}
				},
				'entity': [
					{
						pattern: /&[\da-z]{1,8};/i,
						alias: 'named-entity'
					},
					/&#x?[\da-f]{1,8};/i
				]
			};

			Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
				Prism.languages.markup['entity'];
			Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

			// Plugin to make entity title show the real entity, idea by Roman Komarov
			Prism.hooks.add('wrap', function (env) {

				if (env.type === 'entity') {
					env.attributes['title'] = env.content.replace(/&amp;/, '&');
				}
			});

			Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
				/**
				 * Adds an inlined language to markup.
				 *
				 * An example of an inlined language is CSS with `<style>` tags.
				 *
				 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
				 * case insensitive.
				 * @param {string} lang The language key.
				 * @example
				 * addInlined('style', 'css');
				 */
				value: function addInlined(tagName, lang) {
					var includedCdataInside = {};
					includedCdataInside['language-' + lang] = {
						pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
						lookbehind: true,
						inside: Prism.languages[lang]
					};
					includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

					var inside = {
						'included-cdata': {
							pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
							inside: includedCdataInside
						}
					};
					inside['language-' + lang] = {
						pattern: /[\s\S]+/,
						inside: Prism.languages[lang]
					};

					var def = {};
					def[tagName] = {
						pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
						lookbehind: true,
						greedy: true,
						inside: inside
					};

					Prism.languages.insertBefore('markup', 'cdata', def);
				}
			});
			Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
				/**
				 * Adds an pattern to highlight languages embedded in HTML attributes.
				 *
				 * An example of an inlined language is CSS with `style` attributes.
				 *
				 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
				 * case insensitive.
				 * @param {string} lang The language key.
				 * @example
				 * addAttribute('style', 'css');
				 */
				value: function (attrName, lang) {
					Prism.languages.markup.tag.inside['special-attr'].push({
						pattern: RegExp(
							/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
							'i'
						),
						lookbehind: true,
						inside: {
							'attr-name': /^[^\s=]+/,
							'attr-value': {
								pattern: /=[\s\S]+/,
								inside: {
									'value': {
										pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
										lookbehind: true,
										alias: [lang, 'language-' + lang],
										inside: Prism.languages[lang]
									},
									'punctuation': [
										{
											pattern: /^=/,
											alias: 'attr-equals'
										},
										/"|'/
									]
								}
							}
						}
					});
				}
			});

			Prism.languages.html = Prism.languages.markup;
			Prism.languages.mathml = Prism.languages.markup;
			Prism.languages.svg = Prism.languages.markup;

			Prism.languages.xml = Prism.languages.extend('markup', {});
			Prism.languages.ssml = Prism.languages.xml;
			Prism.languages.atom = Prism.languages.xml;
			Prism.languages.rss = Prism.languages.xml;


			/* **********************************************
			     Begin prism-css.js
			********************************************** */

			(function (Prism) {

				var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;

				Prism.languages.css = {
					'comment': /\/\*[\s\S]*?\*\//,
					'atrule': {
						pattern: RegExp('@[\\w-](?:' + /[^;{\s"']|\s+(?!\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\s*\{))/.source),
						inside: {
							'rule': /^@[\w-]+/,
							'selector-function-argument': {
								pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
								lookbehind: true,
								alias: 'selector'
							},
							'keyword': {
								pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
								lookbehind: true
							}
							// See rest below
						}
					},
					'url': {
						// https://drafts.csswg.org/css-values-3/#urls
						pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
						greedy: true,
						inside: {
							'function': /^url/i,
							'punctuation': /^\(|\)$/,
							'string': {
								pattern: RegExp('^' + string.source + '$'),
								alias: 'url'
							}
						}
					},
					'selector': {
						pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
						lookbehind: true
					},
					'string': {
						pattern: string,
						greedy: true
					},
					'property': {
						pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
						lookbehind: true
					},
					'important': /!important\b/i,
					'function': {
						pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
						lookbehind: true
					},
					'punctuation': /[(){};:,]/
				};

				Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

				var markup = Prism.languages.markup;
				if (markup) {
					markup.tag.addInlined('style', 'css');
					markup.tag.addAttribute('style', 'css');
				}

			}(Prism));


			/* **********************************************
			     Begin prism-clike.js
			********************************************** */

			Prism.languages.clike = {
				'comment': [
					{
						pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
						lookbehind: true,
						greedy: true
					},
					{
						pattern: /(^|[^\\:])\/\/.*/,
						lookbehind: true,
						greedy: true
					}
				],
				'string': {
					pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
					greedy: true
				},
				'class-name': {
					pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
					lookbehind: true,
					inside: {
						'punctuation': /[.\\]/
					}
				},
				'keyword': /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
				'boolean': /\b(?:false|true)\b/,
				'function': /\b\w+(?=\()/,
				'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
				'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
				'punctuation': /[{}[\];(),.:]/
			};


			/* **********************************************
			     Begin prism-javascript.js
			********************************************** */

			Prism.languages.javascript = Prism.languages.extend('clike', {
				'class-name': [
					Prism.languages.clike['class-name'],
					{
						pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
						lookbehind: true
					}
				],
				'keyword': [
					{
						pattern: /((?:^|\})\s*)catch\b/,
						lookbehind: true
					},
					{
						pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
						lookbehind: true
					},
				],
				// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
				'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
				'number': {
					pattern: RegExp(
						/(^|[^\w$])/.source +
						'(?:' +
						(
							// constant
							/NaN|Infinity/.source +
							'|' +
							// binary integer
							/0[bB][01]+(?:_[01]+)*n?/.source +
							'|' +
							// octal integer
							/0[oO][0-7]+(?:_[0-7]+)*n?/.source +
							'|' +
							// hexadecimal integer
							/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
							'|' +
							// decimal bigint
							/\d+(?:_\d+)*n/.source +
							'|' +
							// decimal number (integer or float) but no bigint
							/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source
						) +
						')' +
						/(?![\w$])/.source
					),
					lookbehind: true
				},
				'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
			});

			Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;

			Prism.languages.insertBefore('javascript', 'keyword', {
				'regex': {
					pattern: RegExp(
						// lookbehind
						// eslint-disable-next-line regexp/no-dupe-characters-character-class
						/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
						// Regex pattern:
						// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
						// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
						// with the only syntax, so we have to define 2 different regex patterns.
						/\//.source +
						'(?:' +
						/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
						'|' +
						// `v` flag syntax. This supports 3 levels of nested character classes.
						/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +
						')' +
						// lookahead
						/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
					),
					lookbehind: true,
					greedy: true,
					inside: {
						'regex-source': {
							pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
							lookbehind: true,
							alias: 'language-regex',
							inside: Prism.languages.regex
						},
						'regex-delimiter': /^\/|\/$/,
						'regex-flags': /^[a-z]+$/,
					}
				},
				// This must be declared before keyword because we use "function" inside the look-forward
				'function-variable': {
					pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
					alias: 'function'
				},
				'parameter': [
					{
						pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
						lookbehind: true,
						inside: Prism.languages.javascript
					},
					{
						pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
						lookbehind: true,
						inside: Prism.languages.javascript
					},
					{
						pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
						lookbehind: true,
						inside: Prism.languages.javascript
					},
					{
						pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
						lookbehind: true,
						inside: Prism.languages.javascript
					}
				],
				'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
			});

			Prism.languages.insertBefore('javascript', 'string', {
				'hashbang': {
					pattern: /^#!.*/,
					greedy: true,
					alias: 'comment'
				},
				'template-string': {
					pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
					greedy: true,
					inside: {
						'template-punctuation': {
							pattern: /^`|`$/,
							alias: 'string'
						},
						'interpolation': {
							pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
							lookbehind: true,
							inside: {
								'interpolation-punctuation': {
									pattern: /^\$\{|\}$/,
									alias: 'punctuation'
								},
								rest: Prism.languages.javascript
							}
						},
						'string': /[\s\S]+/
					}
				},
				'string-property': {
					pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
					lookbehind: true,
					greedy: true,
					alias: 'property'
				}
			});

			Prism.languages.insertBefore('javascript', 'operator', {
				'literal-property': {
					pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
					lookbehind: true,
					alias: 'property'
				},
			});

			if (Prism.languages.markup) {
				Prism.languages.markup.tag.addInlined('script', 'javascript');

				// add attribute support for all DOM events.
				// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
				Prism.languages.markup.tag.addAttribute(
					/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
					'javascript'
				);
			}

			Prism.languages.js = Prism.languages.javascript;


			/* **********************************************
			     Begin prism-file-highlight.js
			********************************************** */

			(function () {

				if (typeof Prism === 'undefined' || typeof document === 'undefined') {
					return;
				}

				// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
				if (!Element.prototype.matches) {
					Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
				}

				var LOADING_MESSAGE = 'Loading…';
				var FAILURE_MESSAGE = function (status, message) {
					return '✖ Error ' + status + ' while fetching file: ' + message;
				};
				var FAILURE_EMPTY_MESSAGE = '✖ Error: File does not exist or is empty';

				var EXTENSIONS = {
					'js': 'javascript',
					'py': 'python',
					'rb': 'ruby',
					'ps1': 'powershell',
					'psm1': 'powershell',
					'sh': 'bash',
					'bat': 'batch',
					'h': 'c',
					'tex': 'latex'
				};

				var STATUS_ATTR = 'data-src-status';
				var STATUS_LOADING = 'loading';
				var STATUS_LOADED = 'loaded';
				var STATUS_FAILED = 'failed';

				var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])'
					+ ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';

				/**
				 * Loads the given file.
				 *
				 * @param {string} src The URL or path of the source file to load.
				 * @param {(result: string) => void} success
				 * @param {(reason: string) => void} error
				 */
				function loadFile(src, success, error) {
					var xhr = new XMLHttpRequest();
					xhr.open('GET', src, true);
					xhr.onreadystatechange = function () {
						if (xhr.readyState == 4) {
							if (xhr.status < 400 && xhr.responseText) {
								success(xhr.responseText);
							} else {
								if (xhr.status >= 400) {
									error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
								} else {
									error(FAILURE_EMPTY_MESSAGE);
								}
							}
						}
					};
					xhr.send(null);
				}

				/**
				 * Parses the given range.
				 *
				 * This returns a range with inclusive ends.
				 *
				 * @param {string | null | undefined} range
				 * @returns {[number, number | undefined] | undefined}
				 */
				function parseRange(range) {
					var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || '');
					if (m) {
						var start = Number(m[1]);
						var comma = m[2];
						var end = m[3];

						if (!comma) {
							return [start, start];
						}
						if (!end) {
							return [start, undefined];
						}
						return [start, Number(end)];
					}
					return undefined;
				}

				Prism.hooks.add('before-highlightall', function (env) {
					env.selector += ', ' + SELECTOR;
				});

				Prism.hooks.add('before-sanity-check', function (env) {
					var pre = /** @type {HTMLPreElement} */ (env.element);
					if (pre.matches(SELECTOR)) {
						env.code = ''; // fast-path the whole thing and go to complete

						pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading

						// add code element with loading message
						var code = pre.appendChild(document.createElement('CODE'));
						code.textContent = LOADING_MESSAGE;

						var src = pre.getAttribute('data-src');

						var language = env.language;
						if (language === 'none') {
							// the language might be 'none' because there is no language set;
							// in this case, we want to use the extension as the language
							var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
							language = EXTENSIONS[extension] || extension;
						}

						// set language classes
						Prism.util.setLanguage(code, language);
						Prism.util.setLanguage(pre, language);

						// preload the language
						var autoloader = Prism.plugins.autoloader;
						if (autoloader) {
							autoloader.loadLanguages(language);
						}

						// load file
						loadFile(
							src,
							function (text) {
								// mark as loaded
								pre.setAttribute(STATUS_ATTR, STATUS_LOADED);

								// handle data-range
								var range = parseRange(pre.getAttribute('data-range'));
								if (range) {
									var lines = text.split(/\r\n?|\n/g);

									// the range is one-based and inclusive on both ends
									var start = range[0];
									var end = range[1] == null ? lines.length : range[1];

									if (start < 0) { start += lines.length; }
									start = Math.max(0, Math.min(start - 1, lines.length));
									if (end < 0) { end += lines.length; }
									end = Math.max(0, Math.min(end, lines.length));

									text = lines.slice(start, end).join('\n');

									// add data-start for line numbers
									if (!pre.hasAttribute('data-start')) {
										pre.setAttribute('data-start', String(start + 1));
									}
								}

								// highlight code
								code.textContent = text;
								Prism.highlightElement(code);
							},
							function (error) {
								// mark as failed
								pre.setAttribute(STATUS_ATTR, STATUS_FAILED);

								code.textContent = error;
							}
						);
					}
				});

				Prism.plugins.fileHighlight = {
					/**
					 * Executes the File Highlight plugin for all matching `pre` elements under the given container.
					 *
					 * Note: Elements which are already loaded or currently loading will not be touched by this method.
					 *
					 * @param {ParentNode} [container=document]
					 */
					highlight: function highlight(container) {
						var elements = (container || document).querySelectorAll(SELECTOR);

						for (var i = 0, element; (element = elements[i++]);) {
							Prism.highlightElement(element);
						}
					}
				};

				var logged = false;
				/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */
				Prism.fileHighlight = function () {
					if (!logged) {
						console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
						logged = true;
					}
					Prism.plugins.fileHighlight.highlight.apply(this, arguments);
				};

			}()); 
		} (prism$2));
		return prism$2.exports;
	}

	var prismExports = requirePrism();
	var prism$1 = /*@__PURE__*/getDefaultExportFromCjs(prismExports);

	const blocks = '(if|else if|await|then|catch|each|html|debug)';

	Prism.languages.svelte = Prism.languages.extend('markup', {
		each: {
			pattern: new RegExp(
				'{[#/]each' +
					'(?:(?:\\{(?:(?:\\{(?:[^{}])*\\})|(?:[^{}]))*\\})|(?:[^{}]))*}'
			),
			inside: {
				'language-javascript': [
					{
						pattern: /(as[\s\S]*)\([\s\S]*\)(?=\s*\})/,
						lookbehind: true,
						inside: Prism.languages['javascript'],
					},
					{
						pattern: /(as[\s]*)[\s\S]*(?=\s*)/,
						lookbehind: true,
						inside: Prism.languages['javascript'],
					},
					{
						pattern: /(#each[\s]*)[\s\S]*(?=as)/,
						lookbehind: true,
						inside: Prism.languages['javascript'],
					},
				],
				keyword: /[#/]each|as/,
				punctuation: /{|}/,
			},
		},
		block: {
			pattern: new RegExp(
				'{[#:/@]/s' +
					blocks +
					'(?:(?:\\{(?:(?:\\{(?:[^{}])*\\})|(?:[^{}]))*\\})|(?:[^{}]))*}'
			),
			inside: {
				punctuation: /^{|}$/,
				keyword: [new RegExp('[#:/@]' + blocks + '( )*'), /as/, /then/],
				'language-javascript': {
					pattern: /[\s\S]*/,
					inside: Prism.languages['javascript'],
				},
			},
		},
		tag: {
			pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?:"[^"]*"|'[^']*'|{[\s\S]+?}(?=[\s/>])))|(?=[\s/>])))+)?\s*\/?>/i,
			greedy: true,
			inside: {
				tag: {
					pattern: /^<\/?[^\s>\/]+/i,
					inside: {
						punctuation: /^<\/?/,
						namespace: /^[^\s>\/:]+:/,
					},
				},
				'language-javascript': {
					pattern: /\{(?:(?:\{(?:(?:\{(?:[^{}])*\})|(?:[^{}]))*\})|(?:[^{}]))*\}/,
					inside: Prism.languages['javascript'],
				},
				'attr-value': {
					pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/i,
					inside: {
						punctuation: [
							/^=/,
							{
								pattern: /^(\s*)["']|["']$/,
								lookbehind: true,
							},
						],
						'language-javascript': {
							pattern: /{[\s\S]+}/,
							inside: Prism.languages['javascript'],
						},
					},
				},
				punctuation: /\/?>/,
				'attr-name': {
					pattern: /[^\s>\/]+/,
					inside: {
						namespace: /^[^\s>\/:]+:/,
					},
				},
			},
		},
		'language-javascript': {
			pattern: /\{(?:(?:\{(?:(?:\{(?:[^{}])*\})|(?:[^{}]))*\})|(?:[^{}]))*\}/,
			lookbehind: true,
			inside: Prism.languages['javascript'],
		},
	});

	Prism.languages.svelte['tag'].inside['attr-value'].inside['entity'] =
		Prism.languages.svelte['entity'];

	Prism.hooks.add('wrap', env => {
		if (env.type === 'entity') {
			env.attributes['title'] = env.content.replace(/&amp;/, '&');
		}
	});

	Object.defineProperty(Prism.languages.svelte.tag, 'addInlined', {
		value: function addInlined(tagName, lang) {
			const includedCdataInside = {};
			includedCdataInside['language-' + lang] = {
				pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
				lookbehind: true,
				inside: Prism.languages[lang],
			};
			includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

			const inside = {
				'included-cdata': {
					pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
					inside: includedCdataInside,
				},
			};
			inside['language-' + lang] = {
				pattern: /[\s\S]+/,
				inside: Prism.languages[lang],
			};

			const def = {};
			def[tagName] = {
				pattern: RegExp(
					/(<__[\s\S]*?>)(?:<!\[CDATA\[[\s\S]*?\]\]>\s*|[\s\S])*?(?=<\/__>)/.source.replace(
						/__/g,
						tagName
					),
					'i'
				),
				lookbehind: true,
				greedy: true,
				inside,
			};

			Prism.languages.insertBefore('svelte', 'cdata', def);
		},
	});

	Prism.languages.svelte.tag.addInlined('style', 'css');
	Prism.languages.svelte.tag.addInlined('script', 'javascript');

	mark_module_start();
	Prism$1[FILENAME] = "node_modules/svelte-prism/src/Prism.svelte";

	const prism = prism$1;
	prism$1.highlightElement;
	const globalConfig = { transform: (x) => x };

	var root$L = add_locations(template(`<code style="display:none"><!></code> <pre command-line="" data-output="2-17"><code><!></code></pre>`, 1), Prism$1[FILENAME], [
		[27, 0],
		[31, 0, [[31, 65]]]
	]);

	function Prism$1($$anchor, $$props) {
		check_target(new.target);

		const $$sanitized_props = legacy_rest_props($$props, [
			"children",
			"$$slots",
			"$$events",
			"$$legacy"
		]);

		push($$props, false);

		let language = prop($$props, "language", 8, "javascript");
		let source = prop($$props, "source", 8, "");
		let transform = prop($$props, "transform", 8, (x) => x);

		let element = mutable_state(),
			formattedCode = mutable_state();

		function highlightCode() {
			const grammar = prism.languages[language()];
			let body = source() || get(element).textContent;

			body = globalConfig.transform(body);
			body = transform()(body);
			set(formattedCode, strict_equals(language(), "none") ? body : prism.highlight(body, grammar, language()));
		}

		legacy_pre_effect(
			() => (
				deep_read_state($$sanitized_props),
				deep_read_state(source()),
				get(element)
			),
			() => {
				$$sanitized_props && (source() || get(element)) && highlightCode();
			}
		);

		legacy_pre_effect_reset();
		init();

		var fragment = root$L();
		var code = first_child(fragment);
		var node = child(code);

		slot(node, $$props, "default", {});
		bind_this(code, ($$value) => set(element, $$value), () => get(element));

		var pre = sibling(code, 2);
		var code_1 = child(pre);
		var node_1 = child(code_1);

		if_block(
			node_1,
			() => strict_equals(language(), "none"),
			($$anchor) => {
				var text$1 = text();

				template_effect(() => set_text(text$1, get(formattedCode)));
				append($$anchor, text$1);
			},
			($$anchor) => {
				var fragment_2 = comment();
				var node_2 = first_child(fragment_2);

				html(node_2, () => get(formattedCode));
				append($$anchor, fragment_2);
			}
		);

		template_effect(() => {
			set_class(pre, `language-${language() ?? ""}`);
			set_class(code_1, `language-${language() ?? ""}`);
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Prism$1);

	var ebColors = {};

	var hasRequiredEbColors;

	function requireEbColors () {
		if (hasRequiredEbColors) return ebColors;
		hasRequiredEbColors = 1;
		ebColors.__esModule = true;
		ebColors.greenlightRBG =
		  ebColors.greenlight =
		  ebColors.greenColorClass =
		  ebColors.greenBGClass =
		  ebColors.greenRBG =
		  ebColors.green =
		  ebColors.greendarkColorClass =
		  ebColors.greendarkBGClass =
		  ebColors.greendarkRBG =
		  ebColors.greendark =
		  ebColors.sandColorClass =
		  ebColors.sandBGClass =
		  ebColors.sandRBG =
		  ebColors.sand =
		  ebColors.yellowlightColorClass =
		  ebColors.yellowlightBGClass =
		  ebColors.yellowlightRBG =
		  ebColors.yellowlight =
		  ebColors.yellowColorClass =
		  ebColors.yellowBGClass =
		  ebColors.yellowRBG =
		  ebColors.yellow =
		  ebColors.orangeColorClass =
		  ebColors.orangeBGClass =
		  ebColors.orangeRBG =
		  ebColors.orange =
		  ebColors.orangedarkColorClass =
		  ebColors.orangedarkBGClass =
		  ebColors.orangedarkRBG =
		  ebColors.orangedark =
		  ebColors.roseColorClass =
		  ebColors.roseBGClass =
		  ebColors.roseRBG =
		  ebColors.rose =
		  ebColors.pinkColorClass =
		  ebColors.pinkBGClass =
		  ebColors.pinkRBG =
		  ebColors.pink =
		  ebColors.redColorClass =
		  ebColors.redBGClass =
		  ebColors.redRBG =
		  ebColors.red =
		  ebColors.reddarkColorClass =
		  ebColors.reddarkBGClass =
		  ebColors.reddarkRBG =
		  ebColors.reddark =
		  ebColors.bordeauxColorClass =
		  ebColors.bordeauxBGClass =
		  ebColors.bordeauxRBG =
		  ebColors.bordeaux =
		    void 0;
		ebColors.graa2ColorClass =
		  ebColors.graa2BGClass =
		  ebColors.graa2RBG =
		  ebColors.graa2 =
		  ebColors.graa1ColorClass =
		  ebColors.graa1BGClass =
		  ebColors.graa1RBG =
		  ebColors.graa1 =
		  ebColors.graa0ColorClass =
		  ebColors.graa0BGClass =
		  ebColors.graa0RBG =
		  ebColors.graa0 =
		  ebColors.blackColorClass =
		  ebColors.blackBGClass =
		  ebColors.blackRBG =
		  ebColors.black =
		  ebColors.seaColorClass =
		  ebColors.seaBGClass =
		  ebColors.seaRBG =
		  ebColors.sea =
		  ebColors.cyanColorClass =
		  ebColors.cyanBGClass =
		  ebColors.cyanRBG =
		  ebColors.cyan =
		  ebColors.bluelightColorClass =
		  ebColors.bluelightBGClass =
		  ebColors.bluelightRBG =
		  ebColors.bluelight =
		  ebColors.blueColorClass =
		  ebColors.blueBGClass =
		  ebColors.blueRBG =
		  ebColors.blue =
		  ebColors.bluedarkColorClass =
		  ebColors.bluedarkBGClass =
		  ebColors.bluedarkRBG =
		  ebColors.bluedark =
		  ebColors.bluenavyColorClass =
		  ebColors.bluenavyBGClass =
		  ebColors.bluenavyRBG =
		  ebColors.bluenavy =
		  ebColors.purpledarkColorClass =
		  ebColors.purpledarkBGClass =
		  ebColors.purpledarkRBG =
		  ebColors.purpledark =
		  ebColors.limeColorClass =
		  ebColors.limeBGClass =
		  ebColors.limeRBG =
		  ebColors.lime =
		  ebColors.greenlightColorClass =
		  ebColors.greenlightBGClass =
		    void 0;
		ebColors.ebRBG =
		  ebColors.eb =
		  ebColors.pastelyellowColorClass =
		  ebColors.pastelyellowBGClass =
		  ebColors.pastelyellowRBG =
		  ebColors.pastelyellow =
		  ebColors.pasteldarkgreenColorClass =
		  ebColors.pasteldarkgreenBGClass =
		  ebColors.pasteldarkgreenRBG =
		  ebColors.pasteldarkgreen =
		  ebColors.pastelgreenColorClass =
		  ebColors.pastelgreenBGClass =
		  ebColors.pastelgreenRBG =
		  ebColors.pastelgreen =
		  ebColors.pastellightredColorClass =
		  ebColors.pastellightredBGClass =
		  ebColors.pastellightredRBG =
		  ebColors.pastellightred =
		  ebColors.pasteldarkredColorClass =
		  ebColors.pasteldarkredBGClass =
		  ebColors.pasteldarkredRBG =
		  ebColors.pasteldarkred =
		  ebColors.pastelredColorClass =
		  ebColors.pastelredBGClass =
		  ebColors.pastelredRBG =
		  ebColors.pastelred =
		  ebColors.whiteColorClass =
		  ebColors.whiteBGClass =
		  ebColors.whiteRBG =
		  ebColors.white =
		  ebColors.graa7ColorClass =
		  ebColors.graa7BGClass =
		  ebColors.graa7RBG =
		  ebColors.graa7 =
		  ebColors.graa6ColorClass =
		  ebColors.graa6BGClass =
		  ebColors.graa6RBG =
		  ebColors.graa6 =
		  ebColors.graa5ColorClass =
		  ebColors.graa5BGClass =
		  ebColors.graa5RBG =
		  ebColors.graa5 =
		  ebColors.graa4ColorClass =
		  ebColors.graa4BGClass =
		  ebColors.graa4RBG =
		  ebColors.graa4 =
		  ebColors.graa3ColorClass =
		  ebColors.graa3BGClass =
		  ebColors.graa3RBG =
		  ebColors.graa3 =
		    void 0;
		ebColors.livescoreColorClass =
		  ebColors.livescoreBGClass =
		  ebColors.livescoreRBG =
		  ebColors.livescore =
		  ebColors.lederColorClass =
		  ebColors.lederBGClass =
		  ebColors.lederRBG =
		  ebColors.leder =
		  ebColors.forbrugColorClass =
		  ebColors.forbrugBGClass =
		  ebColors.forbrugRBG =
		  ebColors.forbrug =
		  ebColors.flashColorClass =
		  ebColors.flashBGClass =
		  ebColors.flashRBG =
		  ebColors.flash =
		  ebColors.twitterColorClass =
		  ebColors.twitterBGClass =
		  ebColors.twitterRBG =
		  ebColors.twitter =
		  ebColors.facebookColorClass =
		  ebColors.facebookBGClass =
		  ebColors.facebookRBG =
		  ebColors.facebook =
		  ebColors.native2ColorClass =
		  ebColors.native2BGClass =
		  ebColors.native2RBG =
		  ebColors.native2 =
		  ebColors.nativeColorClass =
		  ebColors.nativeBGClass =
		  ebColors.nativeRBG =
		  ebColors.native =
		  ebColors.liveColorClass =
		  ebColors.liveBGClass =
		  ebColors.liveRBG =
		  ebColors.live =
		  ebColors.brugerColorClass =
		  ebColors.brugerBGClass =
		  ebColors.brugerRBG =
		  ebColors.bruger =
		  ebColors.breakingColorClass =
		  ebColors.breakingBGClass =
		  ebColors.breakingRBG =
		  ebColors.breaking =
		  ebColors.eb2ColorClass =
		  ebColors.eb2BGClass =
		  ebColors.eb2RBG =
		  ebColors.eb2 =
		  ebColors.ebColorClass =
		  ebColors.ebBGClass =
		    void 0;
		ebColors.colorNames =
		  ebColors.Background =
		  ebColors.Colors =
		  ebColors.underholdningColorClass =
		  ebColors.underholdningBGClass =
		  ebColors.underholdningRBG =
		  ebColors.underholdning =
		  ebColors.tvColorClass =
		  ebColors.tvBGClass =
		  ebColors.tvRBG =
		  ebColors.tv =
		  ebColors.sportColorClass =
		  ebColors.sportBGClass =
		  ebColors.sportRBG =
		  ebColors.sport =
		  ebColors.skolefodboldColorClass =
		  ebColors.skolefodboldBGClass =
		  ebColors.skolefodboldRBG =
		  ebColors.skolefodbold =
		  ebColors.sexsamliv2ColorClass =
		  ebColors.sexsamliv2BGClass =
		  ebColors.sexsamliv2RBG =
		  ebColors.sexsamliv2 =
		  ebColors.sexsamlivColorClass =
		  ebColors.sexsamlivBGClass =
		  ebColors.sexsamlivRBG =
		  ebColors.sexsamliv =
		  ebColors.nyheder2ColorClass =
		  ebColors.nyheder2BGClass =
		  ebColors.nyheder2RBG =
		  ebColors.nyheder2 =
		  ebColors.nyhederColorClass =
		  ebColors.nyhederBGClass =
		  ebColors.nyhederRBG =
		  ebColors.nyheder =
		  ebColors.livescore2ColorClass =
		  ebColors.livescore2BGClass =
		  ebColors.livescore2RBG =
		  ebColors.livescore2 =
		    void 0;
		ebColors.bordeaux = '#8a0c36';
		ebColors.bordeauxRBG = '138,12,54';
		ebColors.bordeauxBGClass = 'bg--bordeaux';
		ebColors.bordeauxColorClass = 'color--bordeaux';
		ebColors.reddark = '#900';
		ebColors.reddarkRBG = '153,0,0';
		ebColors.reddarkBGClass = 'bg--reddark';
		ebColors.reddarkColorClass = 'color--reddark';
		ebColors.red = '#bd1118';
		ebColors.redRBG = '189,17,24';
		ebColors.redBGClass = 'bg--red';
		ebColors.redColorClass = 'color--red';
		ebColors.pink = '#b31e61';
		ebColors.pinkRBG = '179,30,97';
		ebColors.pinkBGClass = 'bg--pink';
		ebColors.pinkColorClass = 'color--pink';
		ebColors.rose = '#dc7095';
		ebColors.roseRBG = '220,112,149';
		ebColors.roseBGClass = 'bg--rose';
		ebColors.roseColorClass = 'color--rose';
		ebColors.orangedark = '#e96c0d';
		ebColors.orangedarkRBG = '233,108,13';
		ebColors.orangedarkBGClass = 'bg--orangedark';
		ebColors.orangedarkColorClass = 'color--orangedark';
		ebColors.orange = '#e5ad02';
		ebColors.orangeRBG = '229,173,2';
		ebColors.orangeBGClass = 'bg--orange';
		ebColors.orangeColorClass = 'color--orange';
		ebColors.yellow = '#fae500';
		ebColors.yellowRBG = '250,229,0';
		ebColors.yellowBGClass = 'bg--yellow';
		ebColors.yellowColorClass = 'color--yellow';
		ebColors.yellowlight = '#ff0';
		ebColors.yellowlightRBG = '255,255,0';
		ebColors.yellowlightBGClass = 'bg--yellowlight';
		ebColors.yellowlightColorClass = 'color--yellowlight';
		ebColors.sand = '#cec4a6';
		ebColors.sandRBG = '206,196,166';
		ebColors.sandBGClass = 'bg--sand';
		ebColors.sandColorClass = 'color--sand';
		ebColors.greendark = '#2f7820';
		ebColors.greendarkRBG = '47,120,32';
		ebColors.greendarkBGClass = 'bg--greendark';
		ebColors.greendarkColorClass = 'color--greendark';
		ebColors.green = '#029e5d';
		ebColors.greenRBG = '2,158,93';
		ebColors.greenBGClass = 'bg--green';
		ebColors.greenColorClass = 'color--green';
		ebColors.greenlight = '#93b923';
		ebColors.greenlightRBG = '147,185,35';
		ebColors.greenlightBGClass = 'bg--greenlight';
		ebColors.greenlightColorClass = 'color--greenlight';
		ebColors.lime = '#cbfe33';
		ebColors.limeRBG = '203,254,51';
		ebColors.limeBGClass = 'bg--lime';
		ebColors.limeColorClass = 'color--lime';
		ebColors.purpledark = '#51208c';
		ebColors.purpledarkRBG = '81,32,140';
		ebColors.purpledarkBGClass = 'bg--purpledark';
		ebColors.purpledarkColorClass = 'color--purpledark';
		ebColors.bluenavy = '#1a237e';
		ebColors.bluenavyRBG = '26,35,126';
		ebColors.bluenavyBGClass = 'bg--bluenavy';
		ebColors.bluenavyColorClass = 'color--bluenavy';
		ebColors.bluedark = '#1058c2';
		ebColors.bluedarkRBG = '16,88,194';
		ebColors.bluedarkBGClass = 'bg--bluedark';
		ebColors.bluedarkColorClass = 'color--bluedark';
		ebColors.blue = '#31769b';
		ebColors.blueRBG = '49,118,155';
		ebColors.blueBGClass = 'bg--blue';
		ebColors.blueColorClass = 'color--blue';
		ebColors.bluelight = '#4fa8df';
		ebColors.bluelightRBG = '79,168,223';
		ebColors.bluelightBGClass = 'bg--bluelight';
		ebColors.bluelightColorClass = 'color--bluelight';
		ebColors.cyan = '#00b6d2';
		ebColors.cyanRBG = '0,182,210';
		ebColors.cyanBGClass = 'bg--cyan';
		ebColors.cyanColorClass = 'color--cyan';
		ebColors.sea = '#84a8c4';
		ebColors.seaRBG = '132,168,196';
		ebColors.seaBGClass = 'bg--sea';
		ebColors.seaColorClass = 'color--sea';
		ebColors.black = '#000';
		ebColors.blackRBG = '0,0,0';
		ebColors.blackBGClass = 'bg--black';
		ebColors.blackColorClass = 'color--black';
		ebColors.graa0 = '#1b1b1b';
		ebColors.graa0RBG = '27,27,27';
		ebColors.graa0BGClass = 'bg--graa0';
		ebColors.graa0ColorClass = 'color--graa0';
		ebColors.graa1 = '#3c3c3c';
		ebColors.graa1RBG = '60,60,60';
		ebColors.graa1BGClass = 'bg--graa1';
		ebColors.graa1ColorClass = 'color--graa1';
		ebColors.graa2 = '#484848';
		ebColors.graa2RBG = '72,72,72';
		ebColors.graa2BGClass = 'bg--graa2';
		ebColors.graa2ColorClass = 'color--graa2';
		ebColors.graa3 = '#999';
		ebColors.graa3RBG = '153,153,153';
		ebColors.graa3BGClass = 'bg--graa3';
		ebColors.graa3ColorClass = 'color--graa3';
		ebColors.graa4 = '#c8c8c8';
		ebColors.graa4RBG = '200,200,200';
		ebColors.graa4BGClass = 'bg--graa4';
		ebColors.graa4ColorClass = 'color--graa4';
		ebColors.graa5 = '#ddd';
		ebColors.graa5RBG = '221,221,221';
		ebColors.graa5BGClass = 'bg--graa5';
		ebColors.graa5ColorClass = 'color--graa5';
		ebColors.graa6 = '#e5e5e5';
		ebColors.graa6RBG = '229,229,229';
		ebColors.graa6BGClass = 'bg--graa6';
		ebColors.graa6ColorClass = 'color--graa6';
		ebColors.graa7 = '#efefef';
		ebColors.graa7RBG = '239,239,239';
		ebColors.graa7BGClass = 'bg--graa7';
		ebColors.graa7ColorClass = 'color--graa7';
		ebColors.white = '#fff';
		ebColors.whiteRBG = '255,255,255';
		ebColors.whiteBGClass = 'bg--white';
		ebColors.whiteColorClass = 'color--white';
		ebColors.pastelred = '#db5040';
		ebColors.pastelredRBG = '219,80,64';
		ebColors.pastelredBGClass = 'bg--pastelred';
		ebColors.pastelredColorClass = 'color--pastelred';
		ebColors.pasteldarkred = '#954839';
		ebColors.pasteldarkredRBG = '149,72,57';
		ebColors.pasteldarkredBGClass = 'bg--pasteldarkred';
		ebColors.pasteldarkredColorClass = 'color--pasteldarkred';
		ebColors.pastellightred = '#d67e9b';
		ebColors.pastellightredRBG = '214,126,155';
		ebColors.pastellightredBGClass = 'bg--pastellightred';
		ebColors.pastellightredColorClass = 'color--pastellightred';
		ebColors.pastelgreen = '#9fc29c';
		ebColors.pastelgreenRBG = '159,194,156';
		ebColors.pastelgreenBGClass = 'bg--pastelgreen';
		ebColors.pastelgreenColorClass = 'color--pastelgreen';
		ebColors.pasteldarkgreen = '#91a34f';
		ebColors.pasteldarkgreenRBG = '145,163,79';
		ebColors.pasteldarkgreenBGClass = 'bg--pasteldarkgreen';
		ebColors.pasteldarkgreenColorClass = 'color--pasteldarkgreen';
		ebColors.pastelyellow = '#d4c564';
		ebColors.pastelyellowRBG = '212,197,100';
		ebColors.pastelyellowBGClass = 'bg--pastelyellow';
		ebColors.pastelyellowColorClass = 'color--pastelyellow';
		ebColors.eb = '#bd1118';
		ebColors.ebRBG = '189,17,24';
		ebColors.ebBGClass = 'bg--eb';
		ebColors.ebColorClass = 'color--eb';
		ebColors.eb2 = '#900';
		ebColors.eb2RBG = '153,0,0';
		ebColors.eb2BGClass = 'bg--eb2';
		ebColors.eb2ColorClass = 'color--eb2';
		ebColors.breaking = '#ff0';
		ebColors.breakingRBG = '255,255,0';
		ebColors.breakingBGClass = 'bg--breaking';
		ebColors.breakingColorClass = 'color--breaking';
		ebColors.bruger = '#4fa8df';
		ebColors.brugerRBG = '79,168,223';
		ebColors.brugerBGClass = 'bg--bruger';
		ebColors.brugerColorClass = 'color--bruger';
		ebColors.live = '#000';
		ebColors.liveRBG = '0,0,0';
		ebColors.liveBGClass = 'bg--live';
		ebColors.liveColorClass = 'color--live';
		ebColors.native = '#cec4a6';
		ebColors.nativeRBG = '206,196,166';
		ebColors.nativeBGClass = 'bg--native';
		ebColors.nativeColorClass = 'color--native';
		ebColors.native2 = '#84a8c4';
		ebColors.native2RBG = '132,168,196';
		ebColors.native2BGClass = 'bg--native2';
		ebColors.native2ColorClass = 'color--native2';
		ebColors.facebook = '#31769b';
		ebColors.facebookRBG = '49,118,155';
		ebColors.facebookBGClass = 'bg--facebook';
		ebColors.facebookColorClass = 'color--facebook';
		ebColors.twitter = '#4fa8df';
		ebColors.twitterRBG = '79,168,223';
		ebColors.twitterBGClass = 'bg--twitter';
		ebColors.twitterColorClass = 'color--twitter';
		ebColors.flash = '#e5ad02';
		ebColors.flashRBG = '229,173,2';
		ebColors.flashBGClass = 'bg--flash';
		ebColors.flashColorClass = 'color--flash';
		ebColors.forbrug = '#00b6d2';
		ebColors.forbrugRBG = '0,182,210';
		ebColors.forbrugBGClass = 'bg--forbrug';
		ebColors.forbrugColorClass = 'color--forbrug';
		ebColors.leder = '#1a237e';
		ebColors.lederRBG = '26,35,126';
		ebColors.lederBGClass = 'bg--leder';
		ebColors.lederColorClass = 'color--leder';
		ebColors.livescore = '#029e5d';
		ebColors.livescoreRBG = '2,158,93';
		ebColors.livescoreBGClass = 'bg--livescore';
		ebColors.livescoreColorClass = 'color--livescore';
		ebColors.livescore2 = '#cbfe33';
		ebColors.livescore2RBG = '203,254,51';
		ebColors.livescore2BGClass = 'bg--livescore2';
		ebColors.livescore2ColorClass = 'color--livescore2';
		ebColors.nyheder = '#1058c2';
		ebColors.nyhederRBG = '16,88,194';
		ebColors.nyhederBGClass = 'bg--nyheder';
		ebColors.nyhederColorClass = 'color--nyheder';
		ebColors.nyheder2 = '#000';
		ebColors.nyheder2RBG = '0,0,0';
		ebColors.nyheder2BGClass = 'bg--nyheder2';
		ebColors.nyheder2ColorClass = 'color--nyheder2';
		ebColors.sexsamliv = '#b31e61';
		ebColors.sexsamlivRBG = '179,30,97';
		ebColors.sexsamlivBGClass = 'bg--sexsamliv';
		ebColors.sexsamlivColorClass = 'color--sexsamliv';
		ebColors.sexsamliv2 = '#dc7095';
		ebColors.sexsamliv2RBG = '220,112,149';
		ebColors.sexsamliv2BGClass = 'bg--sexsamliv2';
		ebColors.sexsamliv2ColorClass = 'color--sexsamliv2';
		ebColors.skolefodbold = '#93b923';
		ebColors.skolefodboldRBG = '147,185,35';
		ebColors.skolefodboldBGClass = 'bg--skolefodbold';
		ebColors.skolefodboldColorClass = 'color--skolefodbold';
		ebColors.sport = '#029e5d';
		ebColors.sportRBG = '2,158,93';
		ebColors.sportBGClass = 'bg--sport';
		ebColors.sportColorClass = 'color--sport';
		ebColors.tv = '#bd1118';
		ebColors.tvRBG = '189,17,24';
		ebColors.tvBGClass = 'bg--tv';
		ebColors.tvColorClass = 'color--tv';
		ebColors.underholdning = '#51208c';
		ebColors.underholdningRBG = '81,32,140';
		ebColors.underholdningBGClass = 'bg--underholdning';
		ebColors.underholdningColorClass = 'color--underholdning';
		ebColors.Colors = {
		  hex: {
		    bordeaux: '#8a0c36',
		    reddark: '#900',
		    red: '#bd1118',
		    pink: '#b31e61',
		    rose: '#dc7095',
		    orangedark: '#e96c0d',
		    orange: '#e5ad02',
		    yellow: '#fae500',
		    yellowlight: '#ff0',
		    sand: '#cec4a6',
		    greendark: '#2f7820',
		    green: '#029e5d',
		    greenlight: '#93b923',
		    lime: '#cbfe33',
		    purpledark: '#51208c',
		    bluenavy: '#1a237e',
		    bluedark: '#1058c2',
		    blue: '#31769b',
		    bluelight: '#4fa8df',
		    cyan: '#00b6d2',
		    sea: '#84a8c4',
		    black: '#000',
		    graa0: '#1b1b1b',
		    graa1: '#3c3c3c',
		    graa2: '#484848',
		    graa3: '#999',
		    graa4: '#c8c8c8',
		    graa5: '#ddd',
		    graa6: '#e5e5e5',
		    graa7: '#efefef',
		    white: '#fff',
		    pastelred: '#db5040',
		    pasteldarkred: '#954839',
		    pastellightred: '#d67e9b',
		    pastelgreen: '#9fc29c',
		    pasteldarkgreen: '#91a34f',
		    pastelyellow: '#d4c564',
		    eb: '#bd1118',
		    eb2: '#900',
		    breaking: '#ff0',
		    bruger: '#4fa8df',
		    live: '#000',
		    native: '#cec4a6',
		    native2: '#84a8c4',
		    facebook: '#31769b',
		    twitter: '#4fa8df',
		    flash: '#e5ad02',
		    forbrug: '#00b6d2',
		    leder: '#1a237e',
		    livescore: '#029e5d',
		    livescore2: '#cbfe33',
		    nyheder: '#1058c2',
		    nyheder2: '#000',
		    sexsamliv: '#b31e61',
		    sexsamliv2: '#dc7095',
		    skolefodbold: '#93b923',
		    sport: '#029e5d',
		    tv: '#bd1118',
		    underholdning: '#51208c',
		  },
		  rgb: {
		    bordeaux: '138,12,54',
		    reddark: '153,0,0',
		    red: '189,17,24',
		    pink: '179,30,97',
		    rose: '220,112,149',
		    orangedark: '233,108,13',
		    orange: '229,173,2',
		    yellow: '250,229,0',
		    yellowlight: '255,255,0',
		    sand: '206,196,166',
		    greendark: '47,120,32',
		    green: '2,158,93',
		    greenlight: '147,185,35',
		    lime: '203,254,51',
		    purpledark: '81,32,140',
		    bluenavy: '26,35,126',
		    bluedark: '16,88,194',
		    blue: '49,118,155',
		    bluelight: '79,168,223',
		    cyan: '0,182,210',
		    sea: '132,168,196',
		    black: '0,0,0',
		    graa0: '27,27,27',
		    graa1: '60,60,60',
		    graa2: '72,72,72',
		    graa3: '153,153,153',
		    graa4: '200,200,200',
		    graa5: '221,221,221',
		    graa6: '229,229,229',
		    graa7: '239,239,239',
		    white: '255,255,255',
		    pastelred: '219,80,64',
		    pasteldarkred: '149,72,57',
		    pastellightred: '214,126,155',
		    pastelgreen: '159,194,156',
		    pasteldarkgreen: '145,163,79',
		    pastelyellow: '212,197,100',
		    eb: '189,17,24',
		    eb2: '153,0,0',
		    breaking: '255,255,0',
		    bruger: '79,168,223',
		    live: '0,0,0',
		    native: '206,196,166',
		    native2: '132,168,196',
		    facebook: '49,118,155',
		    twitter: '79,168,223',
		    flash: '229,173,2',
		    forbrug: '0,182,210',
		    leder: '26,35,126',
		    livescore: '2,158,93',
		    livescore2: '203,254,51',
		    nyheder: '16,88,194',
		    nyheder2: '0,0,0',
		    sexsamliv: '179,30,97',
		    sexsamliv2: '220,112,149',
		    skolefodbold: '147,185,35',
		    sport: '2,158,93',
		    tv: '189,17,24',
		    underholdning: '81,32,140',
		  },
		};
		ebColors.Background = {
		  bordeaux: { background: '#8a0c36', color: '#fff' },
		  reddark: { background: '#900', color: '#fff' },
		  red: { background: '#bd1118', color: '#fff' },
		  pink: { background: '#b31e61', color: '#fff' },
		  rose: { background: '#dc7095', color: '#fff' },
		  orangedark: { background: '#e96c0d', color: '#fff' },
		  orange: { background: '#e5ad02', color: '#fff' },
		  yellow: { background: '#fae500', color: '#000' },
		  yellowlight: { background: '#ff0', color: '#000' },
		  sand: { background: '#cec4a6', color: '#fff' },
		  greendark: { background: '#2f7820', color: '#fff' },
		  green: { background: '#029e5d', color: '#fff' },
		  greenlight: { background: '#93b923', color: '#fff' },
		  lime: { background: '#cbfe33', color: '#000' },
		  purpledark: { background: '#51208c', color: '#fff' },
		  bluenavy: { background: '#1a237e', color: '#fff' },
		  bluedark: { background: '#1058c2', color: '#fff' },
		  blue: { background: '#31769b', color: '#fff' },
		  bluelight: { background: '#4fa8df', color: '#fff' },
		  cyan: { background: '#00b6d2', color: '#fff' },
		  sea: { background: '#84a8c4', color: '#fff' },
		  black: { background: '#000', color: '#fff' },
		  graa0: { background: '#1b1b1b', color: '#efefef' },
		  graa1: { background: '#3c3c3c', color: '#fff' },
		  graa2: { background: '#484848', color: '#fff' },
		  graa3: { background: '#999', color: '#fff' },
		  graa4: { background: '#c8c8c8', color: '#000' },
		  graa5: { background: '#ddd', color: '#000' },
		  graa6: { background: '#e5e5e5', color: '#000' },
		  graa7: { background: '#efefef', color: '#000' },
		  white: { background: '#fff', color: '#000' },
		  pastelred: { background: '#db5040', color: '#fff' },
		  pasteldarkred: { background: '#954839', color: '#fff' },
		  pastellightred: { background: '#d67e9b', color: '#fff' },
		  pastelgreen: { background: '#9fc29c', color: '#fff' },
		  pasteldarkgreen: { background: '#91a34f', color: '#fff' },
		  pastelyellow: { background: '#d4c564', color: '#fff' },
		  eb: { background: '#bd1118', color: '#fff' },
		  eb2: { background: '#900', color: '#fff' },
		  breaking: { background: '#ff0', color: '#000' },
		  bruger: { background: '#4fa8df', color: '#fff' },
		  live: { background: '#000', color: '#fff' },
		  native: { background: '#cec4a6', color: '#fff' },
		  native2: { background: '#84a8c4', color: '#fff' },
		  facebook: { background: '#31769b', color: '#fff' },
		  twitter: { background: '#4fa8df', color: '#fff' },
		  flash: { background: '#e5ad02', color: '#fff' },
		  forbrug: { background: '#00b6d2', color: '#fff' },
		  leder: { background: '#1a237e', color: '#fff' },
		  livescore: { background: '#029e5d', color: '#fff' },
		  livescore2: { background: '#cbfe33', color: '#000' },
		  nyheder: { background: '#1058c2', color: '#fff' },
		  nyheder2: { background: '#000', color: '#fff' },
		  sexsamliv: { background: '#b31e61', color: '#fff' },
		  sexsamliv2: { background: '#dc7095', color: '#fff' },
		  skolefodbold: { background: '#93b923', color: '#fff' },
		  sport: { background: '#029e5d', color: '#fff' },
		  tv: { background: '#bd1118', color: '#fff' },
		  underholdning: { background: '#51208c', color: '#fff' },
		};
		ebColors.colorNames = {
		  eb: 'eb',
		  eb2: 'eb2',
		  breaking: 'breaking',
		  bruger: 'bruger',
		  live: 'live',
		  native: 'native',
		  native2: 'native2',
		  facebook: 'facebook',
		  twitter: 'twitter',
		  flash: 'flash',
		  forbrug: 'forbrug',
		  leder: 'leder',
		  livescore: 'livescore',
		  livescore2: 'livescore2',
		  nyheder: 'nyheder',
		  nyheder2: 'nyheder2',
		  sexsamliv: 'sex-samliv',
		  sexsamliv2: 'sex-samliv2',
		  skolefodbold: 'skolefodbold',
		  sport: 'sport',
		  tv: 'tv',
		  underholdning: 'underholdning',
		};
		return ebColors;
	}

	var ebColorsExports = requireEbColors();

	/**
	 * timePassedSince
	 *
	 * @param datetime {string}
	 * @returns {string}
	 */
	function timePassedSince(datetime, todayAsText = false) {
	    const monthNames = ['jan', 'feb', 'mar', 'apr', 'maj', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'];
	    const inputdate = new Date(datetime); // UTC-time from server (Z)
	    const now = new Date();
	    const inputDateLocalTz = new Date(inputdate.getTime() + now.getTimezoneOffset() * 60);
	    const secondsSince = Math.round((now.getTime() - inputDateLocalTz.getTime()) / 1000);
	    const days = Math.floor(secondsSince / 86400);
	    let output = '';
	    if (days) {
	        // More than 24 hours old
	        const yesterday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
	        if (inputDateLocalTz.getTime() > yesterday.getTime()) {
	            output = 'I går';
	        }
	        else {
	            output = `${inputDateLocalTz.getDate()}. ${monthNames[inputDateLocalTz.getMonth()]}.${now.getFullYear() !== inputDateLocalTz.getFullYear() ? ` ${inputDateLocalTz.getFullYear()}` : ''}`;
	        }
	    }
	    else if (todayAsText) {
	        output = 'I dag';
	    }
	    else {
	        // Less than 24 hours old
	        const hours = Math.floor((secondsSince % 86400) / 3600);
	        const minutes = Math.floor(((secondsSince % 86400) % 3600) / 60);
	        const seconds = secondsSince % 60;
	        if (hours) {
	            output = hours === 1 ? `${hours} time` : `${hours} timer`;
	        }
	        else if (minutes) {
	            output = `${minutes} min`;
	        }
	        else if (seconds) {
	            output = `${seconds} sek`;
	        }
	    }
	    return output;
	}

	mark_module_start();
	Icon[FILENAME] = "src/components/icon/Icon.svelte";

	var root_1$j = add_locations(ns_template(`<svg viewBox="0 0 14 14"><use></use></svg>`), Icon[FILENAME], [[9, 2, [[10, 4]]]]);

	function Icon($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);
		validate_prop_bindings($$props, [], [], Icon);

		let className = prop($$props, "className", 3, undefined),
			name = prop($$props, "name", 3, undefined),
			width = prop($$props, "width", 3, undefined),
			style = prop($$props, "style", 3, undefined);

		let cssWidth = derived(() => width() ? `--icon-size: ${width()}px;` : '');
		let styleAttr = derived(() => style() ? `${get(cssWidth)} ${style()}` : get(cssWidth));
		const baseClass = className() ? `icon-svg ${className()}` : 'icon-svg';
		var fragment = comment();
		var node = first_child(fragment);

		if_block(node, name, ($$anchor) => {
			var svg = root_1$j();

			set_svg_class(svg, baseClass);

			var use = child(svg);

			template_effect(() => {
				set_attribute(svg, "style", get(styleAttr));
				set_xlink_attribute(use, "xlink:href", `#${name() ?? ""}`);
			});

			append($$anchor, svg);
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Icon);

	mark_module_start();
	ArticleCard[FILENAME] = "src/components/articlecard/ArticleCard.svelte";

	var root_2$5 = add_locations(template(`<div><!></div>`), ArticleCard[FILENAME], [[37, 8]]);
	var root_3$3 = add_locations(template(`<div class="card-media"><div class="card-image bg--graa4"></div></div>`), ArticleCard[FILENAME], [[42, 8, [[43, 10]]]]);
	var root_5 = add_locations(template(`<span class="badge margin-s position-absolute padding-none padding-s--r card--shadow bg--black fontsize-small" style="bottom: 5px; left: 5px;"><!> UPDATE</span>`), ArticleCard[FILENAME], [[49, 12]]);
	var root_6$1 = add_locations(template(`<div class="video-icon"><!></div>`), ArticleCard[FILENAME], [[63, 12]]);
	var root_4$1 = add_locations(template(`<div><!> <!> <img class="card-image"></div>`), ArticleCard[FILENAME], [[47, 8, [[67, 10]]]]);

	var root_8 = add_locations(template(`<div class="card-meta-item"><span class="flex flex-justify--center"><!> <span class="padding-s--l"> </span></span></div>`), ArticleCard[FILENAME], [
		[
			82,
			16,
			[[83, 18, [[85, 20]]]]
		]
	]);

	var root_9$1 = add_locations(template(`<div class="card-meta-item"><!> <span class="padding-s--l"> </span></div>`), ArticleCard[FILENAME], [[90, 16, [[92, 18]]]]);

	var on_click$2 = (evt, $$props, saved) => {
		evt.preventDefault();
		evt.stopPropagation();
		$$props.save(!saved());
	};

	var root_11 = add_locations(template(`<!> <span class="padding-s--l" style="color: var(--fgcolor--list);">Gemt</span>`, 1), ArticleCard[FILENAME], [[106, 20]]);
	var root_12 = add_locations(template(`<!> <span class="padding-s--l" style="color: var(--fgcolor--list);">Gem</span>`, 1), ArticleCard[FILENAME], [[109, 20]]);
	var root_10 = add_locations(template(`<button class="toggle-button card-meta-item padding-m--r padding-s--b"><!> <!></button>`), ArticleCard[FILENAME], [[96, 16]]);
	var root_7$1 = add_locations(template(`<div class="card-meta flex flex-wrap--wrap fontsize-xxsmall"><!> <!> <!></div>`), ArticleCard[FILENAME], [[80, 12]]);
	var root_13 = add_locations(template(`<div class="video-icon"><!></div>`), ArticleCard[FILENAME], [[117, 12]]);

	var root_1$i = add_locations(template(`<a><div><!> <!> <!> <div class="card-content-wrapper"><div class="card-content"><!> <!> <h2 class="card-title"> </h2></div></div></div></a>`), ArticleCard[FILENAME], [
		[
			34,
			2,
			[
				[
					35,
					4,
					[
						[
							77,
							6,
							[[78, 8, [[121, 10]]]]
						]
					]
				]
			]
		]
	]);

	function ArticleCard($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);
		validate_prop_bindings($$props, [], [], ArticleCard);

		let loading = prop($$props, "loading", 3, false),
			title = prop($$props, "title", 3, ''),
			breaking = prop($$props, "breaking", 3, false),
			cardType = prop($$props, "cardType", 3, undefined),
			className = prop($$props, "className", 3, undefined),
			colorName = prop($$props, "colorName", 3, undefined),
			premiumMarkerSize = prop($$props, "premiumMarkerSize", 3, undefined);
			prop($$props, "id", 3, undefined);
			let update = prop($$props, "update", 3, false),
			maxLines = prop($$props, "maxLines", 3, undefined),
			media = prop($$props, "media", 3, undefined),
			premium = prop($$props, "premium", 3, false),
			published = prop($$props, "published", 3, undefined),
			saved = prop($$props, "saved", 3, undefined),
			section = prop($$props, "section", 3, undefined),
			style = prop($$props, "style", 3, ''),
			truncateTitle = prop($$props, "truncateTitle", 3, false),
			url = prop($$props, "url", 3, undefined),
			videoIcon = prop($$props, "videoIcon", 3, false),
			width = prop($$props, "width", 3, '100%');

		createEventDispatcher();
		let baseClass = state(`card-mode card-mode--article`);
		let loadingStyle = state('padding-top: 56.25%; width: 100%;');

		if (loading()) {
			set(baseClass, `${get(baseClass)} animation-fogwave`);
			switch (cardType()) {
				case 'small-media':

				case 'small-media--reverse':
					set(loadingStyle, 'width: 200px;height: 115px;');
					break;
			}
		}

		let innerClass = state('card-inner');

		switch (cardType()) {
			case 'small-media':
				set(innerClass, `${get(innerClass)} card--small-media`);
				break;

			case 'small-media--reverse':
				set(innerClass, `${get(innerClass)} card--small-media card--small-media--reverse`);
				break;
		}

		const titleStyle = maxLines() ? `--max-lines: ${maxLines()};` : undefined;
		let styleProp = derived(() => `${style()}; --color--list: var(--color--${breaking() ? ebColorsExports.colorNames.breaking : colorName()}); --fgcolor--list: var(--fgcolor--${breaking() ? ebColorsExports.colorNames.breaking : colorName()}); --card-width: ${width()};`);
		let cssClass = derived(() => className() ? `${className()} ${get(baseClass)}` : get(baseClass));
		let mediaCssClass = derived(() => media() && media().className ? `${media().className} card-media` : 'card-media');
		var fragment = comment();
		var node = first_child(fragment);

		if_block(node, () => loading() || !loading() && title(), ($$anchor) => {
			var a = root_1$i();

			a.__click = function (...$$args) {
				apply(() => $$props.click, this, $$args, ArticleCard);
			};

			var div = child(a);
			var node_1 = child(div);

			if_block(node_1, premium, ($$anchor) => {
				var div_1 = root_2$5();
				var node_2 = child(div_1);

				Icon(node_2, {
					className: "color--white",
					name: "ebplus-white"
				});
				template_effect(() => set_class(div_1, `premium-dogear ${(premiumMarkerSize() ? `premium-dogear--${premiumMarkerSize()}` : '') ?? ""}`));
				append($$anchor, div_1);
			});

			var node_3 = sibling(node_1, 2);

			if_block(node_3, loading, ($$anchor) => {
				var div_2 = root_3$3();
				var div_3 = child(div_2);
				template_effect(() => set_attribute(div_3, "style", get(loadingStyle)));
				append($$anchor, div_2);
			});

			var node_4 = sibling(node_3, 2);

			if_block(node_4, media, ($$anchor) => {
				var div_4 = root_4$1();
				var node_5 = child(div_4);

				if_block(node_5, update, ($$anchor) => {
					var span = root_5();
					var node_6 = child(span);

					Icon(node_6, {
						name: "lightning",
						get className() {
							return `bg--white color--${colorName() ?? ""} border-radius-s padding-s margin-s--r`;
						},
						style: "margin-left: -1px;",
						width: "15"
					});
					append($$anchor, span);
				});

				var node_7 = sibling(node_5, 2);

				if_block(node_7, videoIcon, ($$anchor) => {
					var div_5 = root_6$1();
					var node_8 = child(div_5);

					Icon(node_8, {
						className: "color--white",
						name: "video-graphic",
						width: "25"
					});
					append($$anchor, div_5);
				});

				var img = sibling(node_7, 2);

				template_effect(() => {
					set_class(div_4, get(mediaCssClass));
					set_attribute(img, "alt", title());
					set_attribute(img, "src", media().src);
					set_attribute(img, "height", media().height);
					set_attribute(img, "width", media().width);
					set_attribute(img, "style", `width: ${media().width ?? ""}px`);
				});

				append($$anchor, div_4);
			});

			var div_6 = sibling(node_4, 2);
			var div_7 = child(div_6);
			var node_9 = child(div_7);

			if_block(node_9, () => section() || published(), ($$anchor) => {
				var div_8 = root_7$1();
				var node_10 = child(div_8);

				if_block(node_10, () => section() && strict_equals(section(), 'New Articles', false), ($$anchor) => {
					var div_9 = root_8();
					var span_1 = child(div_9);
					var node_11 = child(span_1);

					Icon(node_11, { name: "tag", width: "12" });

					var span_2 = sibling(node_11, 2);
					var text = child(span_2);
					template_effect(() => set_text(text, section()));
					append($$anchor, div_9);
				});

				var node_12 = sibling(node_10, 2);

				if_block(node_12, published, ($$anchor) => {
					var div_10 = root_9$1();
					var node_13 = child(div_10);

					Icon(node_13, { name: "clock", width: "12" });

					var span_3 = sibling(node_13, 2);
					var text_1 = child(span_3);

					template_effect(() => set_text(text_1, timePassedSince(published())));
					append($$anchor, div_10);
				});

				var node_14 = sibling(node_12, 2);

				if_block(node_14, () => strict_equals(saved(), undefined, false) && $$props.save, ($$anchor) => {
					var button = root_10();

					button.__click = [on_click$2, $$props, saved];

					var node_15 = child(button);

					if_block(
						node_15,
						saved,
						($$anchor) => {
							var fragment_1 = root_11();
							var node_16 = first_child(fragment_1);

							Icon(node_16, {
								name: "bookmark-solid",
								style: "color: var(--fgcolor--list);",
								width: 12
							});
							append($$anchor, fragment_1);
						},
						($$anchor) => {
							var fragment_2 = root_12();
							var node_17 = first_child(fragment_2);

							Icon(node_17, {
								name: "bookmark",
								style: "color: var(--fgcolor--list);",
								width: 12
							});
							append($$anchor, fragment_2);
						}
					);

					var node_18 = sibling(node_15, 2);

					snippet(node_18, () => $$props.children ?? noop);
					append($$anchor, button);
				});
				append($$anchor, div_8);
			});

			var node_19 = sibling(node_9, 2);

			if_block(node_19, () => videoIcon() && !media(), ($$anchor) => {
				var div_11 = root_13();
				var node_20 = child(div_11);

				Icon(node_20, {
					className: "color--white",
					name: "video-graphic",
					width: "20"
				});
				append($$anchor, div_11);
			});

			var h2 = sibling(node_19, 2);

			set_attribute(h2, "style", titleStyle);

			var text_2 = child(h2);

			template_effect(() => {
				set_attribute(a, "href", url());
				set_class(a, get(cssClass));
				set_attribute(a, "style", get(styleProp));
				set_attribute(a, "data-breaking", breaking());
				set_class(div, get(innerClass));
				toggle_class(h2, "padding-l--r", videoIcon() && !media());
				toggle_class(h2, "card-title--truncate", truncateTitle());
				set_text(text_2, title());
			});

			append($$anchor, a);
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(ArticleCard);
	delegate(["click"]);

	function throttle(callback, wait) {
	    let inThrottle;
	    return function (...args) {
	        // eslint-disable-next-line @typescript-eslint/no-this-alias
	        const context = this;
	        if (!inThrottle) {
	            callback.apply(context, args);
	            inThrottle = true;
	            setTimeout(() => (inThrottle = false), wait);
	        }
	    };
	}

	var SCROLLDIRECTION;
	(function (SCROLLDIRECTION) {
	    SCROLLDIRECTION[SCROLLDIRECTION["left"] = 0] = "left";
	    SCROLLDIRECTION[SCROLLDIRECTION["right"] = 1] = "right";
	})(SCROLLDIRECTION || (SCROLLDIRECTION = {}));
	var BLOCKING;
	(function (BLOCKING) {
	    BLOCKING[BLOCKING["disabled"] = 0] = "disabled";
	    BLOCKING[BLOCKING["enabled"] = 1] = "enabled";
	})(BLOCKING || (BLOCKING = {}));
	var SCROLLPOS;
	(function (SCROLLPOS) {
	    SCROLLPOS[SCROLLPOS["disabled"] = 0] = "disabled";
	    SCROLLPOS[SCROLLPOS["end"] = 1] = "end";
	    SCROLLPOS[SCROLLPOS["neutral"] = 2] = "neutral";
	    SCROLLPOS[SCROLLPOS["start"] = 3] = "start";
	    SCROLLPOS[SCROLLPOS["unset"] = 4] = "unset";
	})(SCROLLPOS || (SCROLLPOS = {}));
	let HorizontalScrollHandler$1 = class HorizontalScrollHandler {
	    constructor() {
	        this.currentState = SCROLLPOS.unset;
	        this.listLength = 0;
	        this.currentBlock = 0;
	        this.blocks = [0];
	        this.blocking = BLOCKING.enabled;
	    }
	    /**
	     *
	     * @param scrollItemContainer {HTMLDivElement}
	     * @param scrollContainer {HTMLDivElement}
	     * @returns {void}
	     */
	    init(scrollItemContainer, scrollContainer) {
	        this.scrollItemContainer = scrollItemContainer;
	        this.scrollContainer = scrollContainer;
	        this.scrollItemContainer.addEventListener('scroll', throttle(() => {
	            this.blocking = BLOCKING.disabled;
	            this.updateButtons();
	        }, 50));
	        this.wrapLeft = scrollItemContainer.getBoundingClientRect().left;
	        this.wrapRight = scrollItemContainer.getBoundingClientRect().right;
	        this.wrapClientWidth = scrollItemContainer.clientWidth;
	        this.update();
	    }
	    /**
	     *
	     * @param dir {SCROLLDIRECTION}
	     * @returns {void}
	     *
	     * Advance scroll to make next or previous elements visible
	     */
	    scrollWithButton(dir) {
	        let left = this.findPosition(dir);
	        if (dir === SCROLLDIRECTION.right && this.wrapMaxLeft < left) {
	            left = this.wrapMaxLeft;
	            this.updateDataSet(SCROLLPOS.end);
	        }
	        else if (left <= 0) {
	            left = 0;
	            this.updateDataSet(SCROLLPOS.start);
	        }
	        else {
	            this.updateDataSet(SCROLLPOS.neutral);
	        }
	        this.scrollItemContainer.scrollTo({
	            behavior: 'smooth',
	            left,
	            top: 0,
	        });
	    }
	    /**
	     *
	     * @returns {void}
	     */
	    update() {
	        if (this.listLength === this.scrollItemContainer.children.length)
	            return;
	        this.children = this.scrollItemContainer.children;
	        this.listLength = this.children.length;
	        const containerBBox = this.scrollContainer.getBoundingClientRect();
	        /**
	         * Find how many visible elements we have
	         */
	        const visibleChildrenCount = Array.from(this.children).filter((child) => {
	            const childBBox = child.getBoundingClientRect();
	            return childBBox.left >= containerBBox.left && childBBox.right <= containerBBox.right;
	        }).length;
	        const maxLength = this.listLength - visibleChildrenCount;
	        this.wrapMaxLeft = this.scrollItemContainer.scrollWidth - this.wrapClientWidth;
	        if (maxLength) {
	            // Some children not visible - enable scroling
	            this.updateButtons();
	        }
	        else {
	            this.updateDataSet(SCROLLPOS.disabled);
	        }
	    }
	    /**
	     * updateDataSet
	     *
	     * update the visibility of buttons through data attributes
	     *
	     * @param pos {SCROLLPOS}
	     */
	    updateDataSet(pos) {
	        if (this.currentState === pos)
	            return;
	        switch (pos) {
	            case SCROLLPOS.neutral:
	                this.scrollContainer.dataset.atstart = 'false';
	                this.scrollContainer.dataset.atend = 'false';
	                break;
	            case SCROLLPOS.end:
	                this.scrollContainer.dataset.atstart = 'false';
	                this.scrollContainer.dataset.atend = 'true';
	                break;
	            case SCROLLPOS.start:
	                this.scrollContainer.dataset.atstart = 'true';
	                this.scrollContainer.dataset.atend = 'false';
	                break;
	            case SCROLLPOS.disabled:
	                this.scrollContainer.dataset.atstart = 'true';
	                this.scrollContainer.dataset.atend = 'true';
	                break;
	        }
	        this.currentState = pos;
	    }
	    /**
	     * updateButtons
	     *
	     * calculate where in the list we are when the user scrolls
	     */
	    updateButtons() {
	        const buffer = 30;
	        const childLeft = this.children[0].getBoundingClientRect().left;
	        const childRight = this.children[this.listLength - 1].getBoundingClientRect().right;
	        const childrenHiddenLeft = childLeft + buffer < this.wrapLeft;
	        const childrenHiddenRight = childRight - buffer > this.wrapRight;
	        let dir;
	        if (childrenHiddenLeft && childrenHiddenRight) {
	            dir = SCROLLPOS.neutral;
	        }
	        else if (childrenHiddenLeft) {
	            dir = SCROLLPOS.end;
	        }
	        else if (childrenHiddenRight) {
	            dir = SCROLLPOS.start;
	        }
	        else {
	            dir = SCROLLPOS.disabled;
	        }
	        this.updateDataSet(dir);
	    }
	    /**
	     * Go backwards through children to find the first element on the left which
	     * is partially visible/invisible to the user
	     */
	    findPrevChild() {
	        return Array.from(this.children)
	            .reverse()
	            .find((child) => {
	            return child.getBoundingClientRect().left < this.wrapLeft;
	        });
	    }
	    /**
	     * Go through children to find the first element on the right which is
	     * partially visible/invisible to the user
	     */
	    findNextChild() {
	        return Array.from(this.children).find((child) => {
	            return child.getBoundingClientRect().right > this.wrapRight;
	        });
	    }
	    /**
	     * findPosition
	     *
	     * Find the position of the next element we need to show
	     *
	     * @param dir {SCROLLDIRECTION}
	     */
	    findPosition(dir) {
	        try {
	            let position = 0;
	            if (dir === SCROLLDIRECTION.left) {
	                if (this.blocking === BLOCKING.enabled && this.blocks[this.currentBlock - 1]) {
	                    this.currentBlock--;
	                    position = this.blocks[this.currentBlock];
	                }
	                else {
	                    this.blocks = [0];
	                    this.currentBlock = 0;
	                    const el = this.findPrevChild();
	                    if (!el) {
	                        console.warn('No prev child found, assume at start');
	                        return 0;
	                    }
	                    position =
	                        this.scrollItemContainer.scrollLeft -
	                            (this.wrapClientWidth - (el.clientWidth - (this.wrapLeft - el.getBoundingClientRect().left)));
	                }
	            }
	            else if (dir === SCROLLDIRECTION.right) {
	                if (this.blocking === BLOCKING.enabled && this.blocks[this.currentBlock + 1]) {
	                    this.currentBlock++;
	                    position = this.blocks[this.currentBlock];
	                }
	                else {
	                    const el = this.findNextChild();
	                    if (!el) {
	                        console.warn('No next child found, assume at end');
	                        return this.wrapMaxLeft;
	                    }
	                    position = el.offsetLeft;
	                    this.currentBlock++;
	                    this.blocks.push(position);
	                }
	            }
	            return position;
	        }
	        catch (err) {
	            console.error('findPosition', err);
	            return -1;
	        }
	    }
	};

	mark_module_start();
	HorizontalScroll[FILENAME] = "src/components/horizontalScroll/HorizontalScroll.svelte";

	var root$K = add_locations(template(`<div><button class="button button--icon horizontal-scroll-nav button-prev bg--white"><!></button> <button class="button button--icon horizontal-scroll-nav button-next bg--white"><!></button> <div class="horizontal-scroll-items horizontal-scroll-items--gap flex position-relative" data-horizontallist="horizontallist"><!></div></div>`), HorizontalScroll[FILENAME], [
		[
			19,
			0,
			[[20, 2], [26, 2], [32, 2]]
		]
	]);

	function HorizontalScroll($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		const cssClass = mutable_state();
		let className = prop($$props, "className", 8, undefined);
		const baseClass = `horizontal-scroll-container position-relative`;
		let scrollContainer = mutable_state();
		let scrollItemContainer = mutable_state();
		const horizontalScrollHandler = new HorizontalScrollHandler$1();

		onMount(() => {
			horizontalScrollHandler.init(get(scrollItemContainer), get(scrollContainer));
		});

		afterUpdate(() => {
			horizontalScrollHandler.update();
		});

		legacy_pre_effect(() => (deep_read_state(className())), () => {
			set(cssClass, className() ? `${className()} ${baseClass}` : baseClass);
		});

		legacy_pre_effect_reset();
		init();

		var div = root$K();
		var button = child(div);
		var node = child(button);

		Icon(node, { name: "angle-left", width: "14" });

		var button_1 = sibling(button, 2);
		var node_1 = child(button_1);

		Icon(node_1, { name: "angle-right", width: "14" });

		var div_1 = sibling(button_1, 2);
		var node_2 = child(div_1);

		slot(node_2, $$props, "default", {});
		bind_this(div_1, ($$value) => set(scrollItemContainer, $$value), () => get(scrollItemContainer));
		bind_this(div, ($$value) => set(scrollContainer, $$value), () => get(scrollContainer));
		template_effect(() => set_class(div, get(cssClass)));
		event("click", button, () => horizontalScrollHandler.scrollWithButton(SCROLLDIRECTION.left));
		event("click", button_1, () => horizontalScrollHandler.scrollWithButton(SCROLLDIRECTION.right));
		append($$anchor, div);
		return pop({ ...legacy_api() });
	}

	mark_module_end(HorizontalScroll);

	mark_module_start();
	Spinner[FILENAME] = "src/components/spinner/Spinner.svelte";

	var root_1$h = add_locations(template(`<div class="loader flex flex--center"><!> <!> <!></div>`), Spinner[FILENAME], [[11, 2]]);

	function Spinner($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);
		validate_prop_bindings($$props, [], [], Spinner);

		let delay = prop($$props, "delay", 3, 150),
			size = prop($$props, "size", 3, 18);

		let isLoading = state(false);

		setTimeout(
			() => {
				set(isLoading, true);
			},
			delay()
		);

		let style = derived(() => `--icon-size: ${size()}px;`);
		var fragment = comment();
		var node = first_child(fragment);

		if_block(node, () => get(isLoading), ($$anchor) => {
			var div = root_1$h();
			var node_1 = child(div);

			Icon(node_1, {
				className: "bounce bounce1",
				name: "circle-solid"
			});

			var node_2 = sibling(node_1, 2);

			Icon(node_2, {
				className: "bounce bounce2",
				name: "circle-solid"
			});

			var node_3 = sibling(node_2, 2);

			Icon(node_3, {
				className: "bounce bounce3",
				name: "circle-solid"
			});
			template_effect(() => set_attribute(div, "style", get(style)));
			append($$anchor, div);
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Spinner);

	const lipsum = [
	    'Lorem ipsum dolor sit amet, consectetur adipiscing elit.',
	    'Fusce ullamcorper nibh quis dui consequat iaculis.',
	    'Integer pretium dapibus orci quis sagittis.',
	    'Maecenas non diam eu nibh lobortis vulputate.',
	    'Fusce pharetra pretium convallis.',
	    'Donec blandit purus sed orci ornare, a egestas justo sagittis.',
	    'Maecenas in dui lacinia, consectetur lorem quis, semper lacus.',
	    'Aenean ut iaculis neque. Etiam bibendum lacus ut commodo vehicula.',
	    'Integer non venenatis ante. Pellentesque egestas venenatis nisl, quis blandit dui porttitor ut.',
	    'Quisque dictum tortor sit amet ornare fringilla.',
	    'Duis metus lectus, imperdiet consequat libero a, tristique pellentesque dolor.',
	    'Fusce augue arcu, sagittis ut porttitor quis, tempor in velit.',
	    'Integer pulvinar risus vitae tortor accumsan cursus. Integer in metus pulvinar, posuere urna a, scelerisque mi.',
	    'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ultrices placerat auctor.',
	    'Mauris molestie hendrerit libero, vitae ultrices elit efficitur nec.',
	    'Curabitur non lectus sit amet magna eleifend sagittis. Suspendisse ac efficitur elit.',
	    'Sed consectetur laoreet mollis. Quisque pulvinar pretium nisi.',
	    'Mauris interdum eleifend risus, quis dapibus augue congue non.',
	    'Ut quis efficitur urna. Fusce sem sapien, porta ac ultricies eget, ultrices dapibus lacus.',
	    'Fusce vehicula, dui quis faucibus lobortis, mi mauris vestibulum dui, quis tempus mi elit ut orci.',
	    'Vestibulum porta nisi nisi.',
	    'Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Quisque ornare massa tellus, feugiat venenatis diam vehicula ornare.',
	    'Nullam sit amet odio consectetur, egestas lorem eget, pellentesque odio.',
	    'Quisque laoreet enim eros, eget commodo odio imperdiet non.',
	    'Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae.',
	    'Mauris fringilla sollicitudin lobortis. Nam sit amet aliquet sem, eu scelerisque metus.',
	    'Interdum et malesuada fames ac ante ipsum primis in faucibus.',
	    'Pellentesque ut lectus vitae odio interdum congue.',
	    'Pellentesque posuere bibendum interdum.',
	    'Proin quis neque efficitur, sollicitudin risus consectetur, sagittis ante.',
	    'Nunc nulla metus, luctus sit amet fermentum quis, lacinia sed quam.',
	    'Interdum et malesuada fames ac ante ipsum primis in faucibus.',
	    'Lorem ipsum dolor sit amet, consectetur adipiscing elit.',
	    'Duis nec magna metus. Ut hendrerit convallis metus quis dictum.',
	    'Phasellus bibendum, ex a posuere rhoncus, mi velit fermentum mauris, id porttitor odio augue id justo.',
	    'Nulla malesuada justo massa, in luctus diam suscipit at.',
	    'Praesent commodo arcu in nisi eleifend auctor non et dui.',
	    'Duis at tellus ac purus tincidunt condimentum.',
	    'Sed id finibus nulla, sed ullamcorper neque.',
	    'Mauris accumsan magna nec nisi tempor, eu consectetur tortor volutpat.',
	    'Sed eget elementum odio.',
	    'Aliquam luctus lectus at nunc vehicula, in malesuada est fermentum.',
	    'Aliquam eget turpis nec dui luctus pretium.',
	    'Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.',
	    'Integer eu aliquam dolor.',
	    'Maecenas et tellus nisi.',
	    'Integer gravida finibus ex vel pretium.',
	    'Cras ac orci eget magna aliquet cursus.',
	    'Cras placerat, est sit amet sodales fringilla, nunc urna ornare neque, eget pharetra nunc odio vitae nulla.',
	    'Aliquam euismod sodales elit ut sollicitudin.',
	];
	const getSentence = () => lipsum[Math.floor(Math.random() * 50)];
	const getWord = () => lipsum[Math.floor(Math.random() * 50)].split(' ')[0];

	function rdmArticleData(mediaWidth = 640, mediaHeight = 360) {
	    const colorNamesForUse = [
	        ebColorsExports.colorNames.breaking,
	        ebColorsExports.colorNames.bruger,
	        ebColorsExports.colorNames.eb,
	        ebColorsExports.colorNames.flash,
	        ebColorsExports.colorNames.forbrug,
	        ebColorsExports.colorNames.livescore,
	        ebColorsExports.colorNames.native,
	        ebColorsExports.colorNames.nyheder,
	        ebColorsExports.colorNames.sexsamliv,
	        ebColorsExports.colorNames.sport,
	        ebColorsExports.colorNames.underholdning,
	    ];
	    const article = {
	        breaking: Math.random() < 0.1,
	        colorName: colorNamesForUse[Math.floor(Math.random() * colorNamesForUse.length)],
	        media: Math.random() < 0.7
	            ? {
	                src: `https://loremflickr.com/${mediaWidth}/${mediaHeight}/city,people,nature,animal?random=${Math.random()}`,
	            }
	            : {},
	        premium: Math.random() < 0.3,
	        published: randomDate().toString(),
	        saved: Math.random() < 0.5,
	        section: getWord(),
	        title: getSentence(),
	        truncateTitle: false,
	        update: Math.random() < 0.5,
	        url: '',
	    };
	    return article;
	}
	function randomDate() {
	    const start = new Date(2019, 0, 1);
	    const end = new Date();
	    return new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
	}

	/** @import { Readable, StartStopNotifier, Subscriber, Unsubscriber, Updater, Writable } from '../public.js' */
	/** @import { Stores, StoresValues, SubscribeInvalidateTuple } from '../private.js' */

	/**
	 * @type {Array<SubscribeInvalidateTuple<any> | any>}
	 */
	const subscriber_queue = [];

	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 *
	 * @template T
	 * @param {T} [value] initial value
	 * @param {StartStopNotifier<T>} [start]
	 * @returns {Writable<T>}
	 */
	function writable(value, start = noop) {
		/** @type {Unsubscriber | null} */
		let stop = null;

		/** @type {Set<SubscribeInvalidateTuple<T>>} */
		const subscribers = new Set();

		/**
		 * @param {T} new_value
		 * @returns {void}
		 */
		function set(new_value) {
			if (safe_not_equal(value, new_value)) {
				value = new_value;
				if (stop) {
					// store is ready
					const run_queue = !subscriber_queue.length;
					for (const subscriber of subscribers) {
						subscriber[1]();
						subscriber_queue.push(subscriber, value);
					}
					if (run_queue) {
						for (let i = 0; i < subscriber_queue.length; i += 2) {
							subscriber_queue[i][0](subscriber_queue[i + 1]);
						}
						subscriber_queue.length = 0;
					}
				}
			}
		}

		/**
		 * @param {Updater<T>} fn
		 * @returns {void}
		 */
		function update(fn) {
			set(fn(/** @type {T} */ (value)));
		}

		/**
		 * @param {Subscriber<T>} run
		 * @param {() => void} [invalidate]
		 * @returns {Unsubscriber}
		 */
		function subscribe(run, invalidate = noop) {
			/** @type {SubscribeInvalidateTuple<T>} */
			const subscriber = [run, invalidate];
			subscribers.add(subscriber);
			if (subscribers.size === 1) {
				stop = start(set, update) || noop;
			}
			run(/** @type {T} */ (value));
			return () => {
				subscribers.delete(subscriber);
				if (subscribers.size === 0 && stop) {
					stop();
					stop = null;
				}
			};
		}
		return { set, update, subscribe };
	}

	const localeSourceType = localStorage.getItem('sourceType');
	const sourceType = writable(localeSourceType || 'html');
	sourceType.subscribe((value) => {
	    localStorage.setItem('sourceType', value);
	});

	mark_module_start();
	ArticleCard_1[FILENAME] = "docs_src/components/ArticleCard.svelte";

	var root_1$g = add_locations(template(`<!> <table class="table"><thead><tr><th>Prop name</th><th>Type</th><th>Default value</th><th>Description</th></tr></thead><tbody><tr><td>className</td><td>string</td><td></td><td></td></tr><tr><td>colorClass</td><td>string</td><td></td><td>EB color <em>(e.g. sport)</em></td></tr><tr><td>src</td><td>string</td><td></td><td>Converts the ArticleCard into a clickable link</td></tr><tr><td>breaking</td><td>boolean</td><td>false</td><td>Force breaking color</td></tr><tr><td>update</td><td>boolean</td><td>false</td><td>Add update icon to media</td></tr><tr><td>premium</td><td>boolean</td><td>false</td><td></td></tr><tr><td>videoIcon</td><td>boolean</td><td>false</td><td>Shows a videoPlay icon on the articleCard inside the image container</td></tr><tr><td>loading</td><td>boolean</td><td>false</td><td>Converts the ArticleCard into a loading placeholder</td></tr><tr><td>maxLines</td><td>number</td><td>4</td><td>Sets the value of <code>--max-lines</code> if truncate is enabled</td></tr><tr><td>media</td><td>IMediaOptions</td><td></td><td>Adds a image, see <span class="badge badge--small" data-type="secondary">Media</span> props below for details</td></tr><tr><td>section</td><td>string</td><td></td><td>Displays the section meta with a tag icon</td></tr><tr><td>style</td><td>string</td><td></td><td></td></tr><tr><td>published</td><td>date string</td><td></td><td>Displays relative time meta with a icon</td></tr><tr><td>truncateTitle</td><td>boolean</td><td>false</td><td></td></tr><tr><td>cardType</td><td>'mode' | 'small-media' | 'small-media--reverse'</td><td></td><td>Display types. See examples below</td></tr><tr><th colspan="4">Media</th></tr><tr><td>className</td><td>string</td><td></td><td></td></tr><tr><td>height</td><td>string</td><td></td><td></td></tr><tr><td>src <span class="badge badge--small" data-type="primary">required</span></td><td>string</td><td></td><td></td></tr><tr><td>width</td><td>string</td><td></td><td></td></tr></tbody></table> <!> <!> <h3>Small-media</h3> <!> <!> <!> <h3>Loading placeholder</h3> <!> <!> <!> <!>`, 1), ArticleCard_1[FILENAME], [
		[
			14,
			2,
			[
				[
					15,
					4,
					[
						[
							16,
							6,
							[
								[17, 8],
								[18, 8],
								[19, 8],
								[20, 8]
							]
						]
					]
				],
				[
					23,
					4,
					[
						[
							24,
							6,
							[
								[25, 8],
								[26, 8],
								[27, 8],
								[28, 8]
							]
						],
						[
							30,
							6,
							[
								[31, 8],
								[32, 8],
								[33, 8],
								[34, 8, [[34, 21]]]
							]
						],
						[
							36,
							6,
							[
								[37, 8],
								[38, 8],
								[39, 8],
								[40, 8]
							]
						],
						[
							42,
							6,
							[
								[43, 8],
								[44, 8],
								[45, 8],
								[46, 8]
							]
						],
						[
							48,
							6,
							[
								[49, 8],
								[50, 8],
								[51, 8],
								[52, 8]
							]
						],
						[
							54,
							6,
							[
								[55, 8],
								[56, 8],
								[57, 8],
								[58, 8]
							]
						],
						[
							60,
							6,
							[
								[61, 8],
								[62, 8],
								[63, 8],
								[64, 8]
							]
						],
						[
							66,
							6,
							[
								[67, 8],
								[68, 8],
								[69, 8],
								[70, 8]
							]
						],
						[
							72,
							6,
							[
								[73, 8],
								[74, 8],
								[75, 8],
								[76, 8, [[76, 30]]]
							]
						],
						[
							78,
							6,
							[
								[79, 8],
								[80, 8],
								[81, 8],
								[82, 8, [[83, 28]]]
							]
						],
						[
							86,
							6,
							[
								[87, 8],
								[88, 8],
								[89, 8],
								[90, 8]
							]
						],
						[
							92,
							6,
							[
								[93, 8],
								[94, 8],
								[95, 8],
								[96, 8]
							]
						],
						[
							98,
							6,
							[
								[99, 8],
								[100, 8],
								[101, 8],
								[102, 8]
							]
						],
						[
							104,
							6,
							[
								[105, 8],
								[106, 8],
								[107, 8],
								[108, 8]
							]
						],
						[
							110,
							6,
							[
								[111, 8],
								[112, 8],
								[113, 8],
								[114, 8]
							]
						],
						[116, 6, [[117, 8]]],
						[
							119,
							6,
							[
								[120, 8],
								[121, 8],
								[122, 8],
								[123, 8]
							]
						],
						[
							125,
							6,
							[
								[126, 8],
								[127, 8],
								[128, 8],
								[129, 8]
							]
						],
						[
							131,
							6,
							[
								[132, 8, [[132, 16]]],
								[133, 8],
								[134, 8],
								[135, 8]
							]
						],
						[
							137,
							6,
							[
								[138, 8],
								[139, 8],
								[140, 8],
								[141, 8]
							]
						]
					]
				]
			]
		],
		[152, 2],
		[162, 2]
	]);

	var root_6 = add_locations(template(`<p>ArticleCard er en ren Svelte component.</p>`), ArticleCard_1[FILENAME], [[174, 2]]);
	var root$J = add_locations(template(`<h1 class="color--eb">Article Card</h1> <!>`, 1), ArticleCard_1[FILENAME], [[7, 0]]);

	function ArticleCard_1($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		const $$stores = setup_stores();

		const $sourceType = () => (
			validate_store(sourceType),
			store_get(sourceType, "$sourceType", $$stores)
		);

		init();

		var fragment = root$J();
		var node = sibling(first_child(fragment), 2);

		if_block(
			node,
			() => strict_equals($sourceType(), 'svelte'),
			($$anchor) => {
				var fragment_1 = root_1$g();
				var node_1 = first_child(fragment_1);

				Prism$1(node_1, {
					language: "js",
					children: wrap_snippet(ArticleCard_1, ($$anchor, $$slotProps) => {
						next();

						var text$1 = text();

						text$1.nodeValue = `import { ArticleCard } from '@ekstra-bladet/designsystem';`;
						append($$anchor, text$1);
					}),
					$$slots: { default: true }
				});

				var node_2 = sibling(node_1, 4);
				var spread_element = derived(rdmArticleData);

				ArticleCard(node_2, spread_props(() => get(spread_element)));

				var node_3 = sibling(node_2, 2);

				Prism$1(node_3, {
					language: "html",
					children: wrap_snippet(ArticleCard_1, ($$anchor, $$slotProps) => {
						next();

						var text_1 = text();

						text_1.nodeValue = `<ArticleCard {...article} />`;
						append($$anchor, text_1);
					}),
					$$slots: { default: true }
				});

				var node_4 = sibling(node_3, 4);
				var spread_element_1 = derived(() => rdmArticleData(250, 120));

				ArticleCard(node_4, spread_props(
					{
						className: "margin-m--b",
						cardType: "small-media",
						saved: true
					},
					() => get(spread_element_1)
				));

				var node_5 = sibling(node_4, 2);
				var spread_element_2 = derived(() => rdmArticleData(250, 120));

				ArticleCard(node_5, spread_props({ cardType: "small-media--reverse" }, () => get(spread_element_2)));

				var node_6 = sibling(node_5, 2);

				Prism$1(node_6, {
					language: "html",
					children: wrap_snippet(ArticleCard_1, ($$anchor, $$slotProps) => {
						next();

						var text_2 = text();

						text_2.nodeValue = `<ArticleCard className="small-media" {...article} />
<ArticleCard className="small-media--reverse" {...article} />`;

						append($$anchor, text_2);
					}),
					$$slots: { default: true }
				});

				var node_7 = sibling(node_6, 4);

				ArticleCard(node_7, {
					loading: true,
					colorName: "graa7",
					className: "margin-m--b"
				});

				var node_8 = sibling(node_7, 2);

				ArticleCard(node_8, {
					loading: true,
					cardType: "small-media",
					colorName: "graa7",
					className: "margin-m--b"
				});

				var node_9 = sibling(node_8, 2);

				ArticleCard(node_9, {
					loading: true,
					cardType: "small-media--reverse",
					colorName: "graa7",
					className: "margin-m--b"
				});

				var node_10 = sibling(node_9, 2);

				Prism$1(node_10, {
					language: "html",
					children: wrap_snippet(ArticleCard_1, ($$anchor, $$slotProps) => {
						next();

						var text_3 = text();

						text_3.nodeValue = `<ArticleCard loading={true} colorName="graa7" />
<ArticleCard loading={true} cardType="small-media" colorName="graa7" />
<ArticleCard loading={true} cardType="small-media--reverse" colorName="graa7" />`;

						append($$anchor, text_3);
					}),
					$$slots: { default: true }
				});

				append($$anchor, fragment_1);
			},
			($$anchor) => {
				var p = root_6();

				append($$anchor, p);
			}
		);

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(ArticleCard_1);

	mark_module_start();
	Badge[FILENAME] = "docs_src/components/Badge.svelte";

	var root_1$f = add_locations(template(`<p>Only valid as a HTML-standard element</p>`), Badge[FILENAME], [[9, 2]]);

	var root_2$4 = add_locations(template(`<p>Badges are used as tags. The size can be set through font-size.</p> <h3>Default</h3> <div class="flex"><span class="badge">Badge</span></div> <!> <h3>Variations</h3> <div class="flex"><span class="badge margin-s" data-type="primary">Primary</span> <span class="badge margin-s" data-type="secondary">Secondary</span> <span class="badge margin-s" data-type="success">Success</span> <span class="badge margin-s" data-type="danger">Danger</span></div> <!> <h3>Color examples from eb-colors</h3> <div class="flex"><span class="badge bg--bluedark margin-s">bg-bluedark</span> <span class="badge bg--green margin-s">bg-green</span> <span class="badge bg--greendark margin-s">bg-greendark</span></div> <!> <h3>Advanced examples</h3> <div class="flex"><span class="badge margin-s padding-none padding-s--r card--shadow bg--black fontsize-small"><!> UPDATE</span></div> <!>`, 1), Badge[FILENAME], [
		[11, 2],
		[13, 2],
		[15, 2, [[16, 4]]],
		[23, 2],
		[
			25,
			2,
			[
				[26, 4],
				[27, 4],
				[28, 4],
				[29, 4]
			]
		],
		[39, 2],
		[
			41,
			2,
			[[42, 4], [43, 4], [44, 4]]
		],
		[53, 2],
		[55, 2, [[56, 4]]]
	]);

	var root$I = add_locations(template(`<h1 class="color--eb">Badge</h1> <!>`, 1), Badge[FILENAME], [[6, 0]]);

	function Badge($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		const $$stores = setup_stores();

		const $sourceType = () => (
			validate_store(sourceType),
			store_get(sourceType, "$sourceType", $$stores)
		);

		var fragment = root$I();
		var node = sibling(first_child(fragment), 2);

		if_block(
			node,
			() => strict_equals($sourceType(), 'svelte'),
			($$anchor) => {
				var p = root_1$f();

				append($$anchor, p);
			},
			($$anchor) => {
				var fragment_1 = root_2$4();
				var node_1 = sibling(first_child(fragment_1), 6);

				Prism$1(node_1, {
					language: "html",
					children: wrap_snippet(Badge, ($$anchor, $$slotProps) => {
						next();

						var text$1 = text();

						text$1.nodeValue = `<span class="badge"></span>`;
						append($$anchor, text$1);
					}),
					$$slots: { default: true }
				});

				var node_2 = sibling(node_1, 6);

				Prism$1(node_2, {
					language: "html",
					children: wrap_snippet(Badge, ($$anchor, $$slotProps) => {
						next();

						var text_1 = text();

						text_1.nodeValue = `<span class="badge" data-type="primary"></span>
<span class="badge" data-type="secondary"></span>
<span class="badge" data-type="success"></span>
<span class="badge" data-type="danger"></span>`;

						append($$anchor, text_1);
					}),
					$$slots: { default: true }
				});

				var node_3 = sibling(node_2, 6);

				Prism$1(node_3, {
					language: "html",
					children: wrap_snippet(Badge, ($$anchor, $$slotProps) => {
						next();

						var text_2 = text();

						text_2.nodeValue = `<span class="badge bg--bluedark"></span>
<span class="badge bg--green"></span>
<span class="badge bg--greendark"></span>`;

						append($$anchor, text_2);
					}),
					$$slots: { default: true }
				});

				var div = sibling(node_3, 4);
				var span = child(div);
				var node_4 = child(span);

				Icon(node_4, {
					name: "lightning",
					className: "bg--white color--flash border-radius-s padding-s margin-s--r",
					style: "margin-left: -1px;",
					width: "15"
				});

				var node_5 = sibling(div, 2);

				Prism$1(node_5, {
					language: "html",
					children: wrap_snippet(Badge, ($$anchor, $$slotProps) => {
						next();

						var text_3 = text();

						text_3.nodeValue = `<span class="badge margin-s padding-none padding-s--r card--shadow bg--black fontsize-small">
  <svg viewBox="0 0 10 16"
    className="icon-svg bg--white color--flash border-radius-s padding-s margin-s--r"
    style="margin-left: -1px; width: 15px; height: 15px;"/>
    <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#lightning"></use>
  </svg>
  UPDATE
</span>`;

						append($$anchor, text_3);
					}),
					$$slots: { default: true }
				});

				append($$anchor, fragment_1);
			}
		);

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Badge);

	mark_module_start();
	Button[FILENAME] = "docs_src/components/Button.svelte";

	var root_1$e = add_locations(template(`<p>Only valid as a HTML-standard element</p>`), Button[FILENAME], [[9, 2]]);

	var root_2$3 = add_locations(template(`<h3>Default</h3> <div class="flex"><button class="button">Button</button> <button class="button margin-l--l" disabled>Disabled</button></div> <!> <h3>Extension attribute</h3> <div class="flex"><button class="margin-m button button--solid">Solid</button> <button class="margin-m button button--solid" disabled>Disabled</button></div> <div class="flex"><button class="margin-m button button--link">Link</button> <button class="margin-m button button--link" disabled>Disabled</button></div> <div class="flex"><button class="margin-m button button--icon"><span style="font-size: 30px">&times;</span></button> <button class="margin-m button button--icon" disabled><span style="font-size: 30px">&times;</span></button></div> <!> <h3>Size attribute</h3> <p><b>big</b> and <b>small</b> can be combined with the other three extensions</p> <button class="margin-m button button--big">Big</button> <button class="margin-m button button--small">Small</button> <!> <h3>Variations</h3> <button class="margin-m button button--primary">Primary</button> <button class="margin-m button button--secondary">Secondary</button> <button class="margin-m button button--accept">Accept</button> <button class="margin-m button button--cancel">Cancel</button> <!> <h3>With Icon</h3> <button class="margin-m button"><span>Icon to the right</span> <!></button> <button class="margin-m button"><!> <span>Icon to the left</span></button> <!> <h3>Colors</h3> <div class="flex margin-m--b"><button class="button" style="--button-color: var(--color--livescore);">Livescore</button> <button class="button button--solid margin-m--l" style="--button-color: var(--color--livescore);">Livescore</button></div> <div class="flex margin-m--b"><button class="button" style="--button-color: var(--color--eb);">Eb</button> <button class="button button--solid margin-m--l" style="--button-color: var(--color--eb);">Eb</button></div> <div class="flex margin-m--b"><button class="button" style="--button-color: var(--color--blue);">Blue</button> <button class="button button--solid margin-m--l" style="--button-color: var(--color--blue);">Blue</button></div> <div class="flex margin-m--b"><button class="button" style="--button-color: var(--color--underholdning);">Underholdning</button> <button class="button button--solid margin-m--l" style="--button-color: var(--color--underholdning);">Underholdning</button></div> <div class="flex margin-m--b"><button class="button" style="--button-color: var(--color--lime); --button-text-color: var(--color--bluedark);">Lime/bluedark</button> <button class="button button--solid margin-m--l" style="--button-color: var(--color--lime); --button-text-color: var(--color--bluedark);">Lime/bluedark</button></div> <!>`, 1), Button[FILENAME], [
		[11, 2],
		[13, 2, [[14, 4], [15, 4]]],
		[22, 2],
		[23, 2, [[24, 4], [25, 4]]],
		[27, 2, [[28, 4], [29, 4]]],
		[
			31,
			2,
			[
				[32, 4, [[33, 6]]],
				[35, 4, [[36, 6]]]
			]
		],
		[48, 2],
		[49, 2, [[49, 5], [49, 20]]],
		[51, 2],
		[52, 2],
		[59, 2],
		[61, 2],
		[62, 2],
		[63, 2],
		[64, 2],
		[73, 2],
		[75, 2, [[76, 4]]],
		[79, 2, [[81, 4]]],
		[99, 2],
		[101, 2, [[102, 4], [103, 4]]],
		[105, 2, [[106, 4], [107, 4]]],
		[109, 2, [[110, 4], [111, 4]]],
		[113, 2, [[114, 4], [115, 4]]],
		[119, 2, [[120, 4], [123, 4]]]
	]);

	var root$H = add_locations(template(`<h1 class="color--eb">Buttons</h1> <!>`, 1), Button[FILENAME], [[6, 0]]);

	function Button($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		const $$stores = setup_stores();

		const $sourceType = () => (
			validate_store(sourceType),
			store_get(sourceType, "$sourceType", $$stores)
		);

		var fragment = root$H();
		var node = sibling(first_child(fragment), 2);

		if_block(
			node,
			() => strict_equals($sourceType(), 'svelte'),
			($$anchor) => {
				var p = root_1$e();

				append($$anchor, p);
			},
			($$anchor) => {
				var fragment_1 = root_2$3();
				var node_1 = sibling(first_child(fragment_1), 4);

				Prism$1(node_1, {
					language: "html",
					children: wrap_snippet(Button, ($$anchor, $$slotProps) => {
						next();

						var text$1 = text();

						text$1.nodeValue = `<button class="button"></button>`;
						append($$anchor, text$1);
					}),
					$$slots: { default: true }
				});

				var node_2 = sibling(node_1, 10);

				Prism$1(node_2, {
					language: "html",
					children: wrap_snippet(Button, ($$anchor, $$slotProps) => {
						next();

						var text_1 = text();

						text_1.nodeValue = `<button class="button button--solid"></button>
<button class="button button--link"></button>
<button class="button button--icon">
  <span style="font-size: 30px;">&times;</span>
</button>`;

						append($$anchor, text_1);
					}),
					$$slots: { default: true }
				});

				var node_3 = sibling(node_2, 10);

				Prism$1(node_3, {
					language: "html",
					children: wrap_snippet(Button, ($$anchor, $$slotProps) => {
						next();

						var text_2 = text();

						text_2.nodeValue = `<button class="button button--big"></button>
<button class="button button--small"></button>`;

						append($$anchor, text_2);
					}),
					$$slots: { default: true }
				});

				var node_4 = sibling(node_3, 12);

				Prism$1(node_4, {
					language: "html",
					children: wrap_snippet(Button, ($$anchor, $$slotProps) => {
						next();

						var text_3 = text();

						text_3.nodeValue = `<button class="button button--primary"></button>
<button class="button button--secondary"></button>
<button class="button button--accept"></button>
<button class="button button--cancel"></button>`;

						append($$anchor, text_3);
					}),
					$$slots: { default: true }
				});

				var button = sibling(node_4, 4);
				var node_5 = sibling(child(button), 2);

				Icon(node_5, { name: "angle-right", width: "20" });

				var button_1 = sibling(button, 2);
				var node_6 = child(button_1);

				Icon(node_6, { name: "angle-left", width: "20" });

				var node_7 = sibling(button_1, 2);

				Prism$1(node_7, {
					language: "html",
					children: wrap_snippet(Button, ($$anchor, $$slotProps) => {
						next();

						var text_4 = text();

						text_4.nodeValue = `<button class="button">
  <span></span>
  <svg viewBox="0 0 50 50">
    <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#angle_right"></use>
  </svg>
</button>
<button class="button">
  <svg viewBox="0 0 50 50">
    <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#angle_left"></use>
  </svg>
  <span></span>
</button>`;

						append($$anchor, text_4);
					}),
					$$slots: { default: true }
				});

				var node_8 = sibling(node_7, 14);

				Prism$1(node_8, {
					language: "html",
					children: wrap_snippet(Button, ($$anchor, $$slotProps) => {
						next();

						var text_5 = text();

						text_5.nodeValue = `<button class="button" style="--button-color: var(--color--livescore);"></button>
<button class="button" style="--button-color: var(--color--eb);"></button>
<button class="button" style="--button-color: var(--color--blue);"></button>
<button class="button" style="--button-color: var(--color--underholdning);"></button>
<button class="button" style="--button-color: var(--color--lime); --button-text-color: var(--color--bluedark);"></button>`;

						append($$anchor, text_5);
					}),
					$$slots: { default: true }
				});

				append($$anchor, fragment_1);
			}
		);

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Button);

	mark_module_start();
	ButtonGroup[FILENAME] = "docs_src/components/ButtonGroup.svelte";

	var root_1$d = add_locations(template(`<p>Only valid as a HTML-standard element</p>`), ButtonGroup[FILENAME], [[10, 2]]);

	var root_2$2 = add_locations(
		template(
			`<div class="buttongroup"><button class="button" data-selected="true">Button 1</button> <button class="button">Button 2</button> <button class="button">Button 3</button></div> <!> <h3>Variations</h3> <div class="margin-m--b buttongroup buttongroup--primary"><button class="button" data-selected="true">Primary</button> <button class="button">Button 2</button> <button class="button">Button 3</button></div> <div class="margin-m--b buttongroup buttongroup--secondary"><button class="button" data-selected="true">Secondary</button> <button class="button">Button 2</button> <button class="button">Button 3</button></div> <div class="margin-m--b buttongroup buttongroup--accept"><button class="button" data-selected="true">Accept</button> <button class="button">Button 2</button> <button class="button">Button 3</button></div> <div class="margin-l--b buttongroup buttongroup--cancel"><button class="button" data-selected="true">Cancel</button> <button class="button">Button 2</button> <button class="button">Button 3</button></div> <!> <h3>Farve muligheder fra eb-colors</h3> <div class="margin-l--b buttongroup" style="
  --buttongroup-color: #8a0c36;
  --buttongroup-fgcolor: #fff;
  --buttongroup-color--hover: #8a0c36;
  --buttongroup-fgcolor--hover: #fff;
"><button class="button">Button 1</button> <button class="button">Button 2</button> <button class="button">Button 3</button></div> <!> <h3>Solid button group</h3> <div class="buttongroup buttongroup--solid margin-l--b" style="
--buttongroup-color: #000;
--buttongroup-fgcolor: #fff;
--buttongroup-color--hover: #e3141d;
--buttongroup-fgcolor--hover: #fff;"><button class="button">Button 1</button> <button class="button">Button 2</button> <button class="button">Button 3</button></div> <!>`,
			1
		),
		ButtonGroup[FILENAME],
		[
			[
				12,
				2,
				[[13, 4], [14, 4], [15, 4]]
			],
			[26, 2],
			[
				28,
				2,
				[[29, 4], [30, 4], [31, 4]]
			],
			[
				34,
				2,
				[[35, 4], [36, 4], [37, 4]]
			],
			[
				40,
				2,
				[[41, 4], [42, 4], [43, 4]]
			],
			[
				46,
				2,
				[[47, 4], [48, 4], [49, 4]]
			],
			[59, 2],
			[
				61,
				2,
				[[70, 4], [71, 4], [72, 4]]
			],
			[84, 2],
			[
				86,
				2,
				[[94, 4], [95, 4], [96, 4]]
			]
		]
	);

	var root$G = add_locations(template(`<h1 class="color--eb">Button groups</h1> <h3>Default</h3> <!>`, 1), ButtonGroup[FILENAME], [[5, 0], [7, 0]]);

	function ButtonGroup($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		const $$stores = setup_stores();

		const $sourceType = () => (
			validate_store(sourceType),
			store_get(sourceType, "$sourceType", $$stores)
		);

		var fragment = root$G();
		var node = sibling(first_child(fragment), 4);

		if_block(
			node,
			() => strict_equals($sourceType(), 'svelte'),
			($$anchor) => {
				var p = root_1$d();

				append($$anchor, p);
			},
			($$anchor) => {
				var fragment_1 = root_2$2();
				var node_1 = sibling(first_child(fragment_1), 2);

				Prism$1(node_1, {
					language: "html",
					children: wrap_snippet(ButtonGroup, ($$anchor, $$slotProps) => {
						next();

						var text$1 = text();

						text$1.nodeValue = `<div class="buttongroup">
  <button class="button" data-selected="true"></button>
  <button class="button"></button>
  <button class="button"></button>
</div>`;

						append($$anchor, text$1);
					}),
					$$slots: { default: true }
				});

				var node_2 = sibling(node_1, 12);

				Prism$1(node_2, {
					language: "html",
					children: wrap_snippet(ButtonGroup, ($$anchor, $$slotProps) => {
						next();

						var text_1 = text();

						text_1.nodeValue = `<div class="buttongroup buttongroup--primary">...</div>
<div class="buttongroup buttongroup--secondary">...</div>
<div class="buttongroup buttongroup--accept">...</div>
<div class="buttongroup buttongroup--cancel">...</div>`;

						append($$anchor, text_1);
					}),
					$$slots: { default: true }
				});

				var node_3 = sibling(node_2, 6);

				Prism$1(node_3, {
					language: "html",
					children: wrap_snippet(ButtonGroup, ($$anchor, $$slotProps) => {
						next();

						var text_2 = text();

						text_2.nodeValue = `<div class="buttongroup" style="
  --buttongroup-color: #8a0c36;
  --buttongroup-fgcolor: #fff;
  --buttongroup-color--hover: #8a0c36;
  --buttongroup-fgcolor--hover: #fff;
">...</div>`;

						append($$anchor, text_2);
					}),
					$$slots: { default: true }
				});

				var node_4 = sibling(node_3, 6);

				Prism$1(node_4, {
					language: "html",
					children: wrap_snippet(ButtonGroup, ($$anchor, $$slotProps) => {
						next();

						var text_3 = text();

						text_3.nodeValue = `<div class="buttongroup buttongroup--solid" style="
  --buttongroup-color: #000;
  --buttongroup-fgcolor: #fff;
  --buttongroup-color--hover: #e3141d;
  --buttongroup-fgcolor--hover: #fff;
">...</div>`;

						append($$anchor, text_3);
					}),
					$$slots: { default: true }
				});

				append($$anchor, fragment_1);
			}
		);

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(ButtonGroup);

	mark_module_start();
	Card[FILENAME] = "docs_src/components/Card.svelte";

	var root_1$c = add_locations(template(`<p>Only valid as a HTML-standard element</p>`), Card[FILENAME], [[8, 2]]);

	var root_2$1 = add_locations(template(`<h3>Card slots</h3> <div class="card margin-l--b"><div class="card-header">Header</div> <div class="card-media"><img src="https://loremflickr.com/1280/400/cat" alt=""></div> <div class="card-content">Content</div> <div class="card-footer">Footer</div></div> <!> <h3>Small media card</h3> <div class="card card--small-media margin-l--b"><div class="card-media"><img src="https://loremflickr.com/250/120/dog" alt=""></div> <div class="card-content">Content</div></div> <!> <h3>Force landscape image</h3> <p>To force the image in a card to landscape view, use class <em>card-media--landscape</em></p>`, 1), Card[FILENAME], [
		[10, 2],
		[
			11,
			2,
			[
				[12, 4],
				[13, 4, [[14, 6]]],
				[16, 4],
				[17, 4]
			]
		],
		[31, 2],
		[
			33,
			2,
			[
				[34, 4, [[35, 6]]],
				[37, 4]
			]
		],
		[49, 2],
		[50, 2, [[50, 63]]]
	]);

	var root$F = add_locations(template(`<h1 class="color--eb">Card</h1> <!>`, 1), Card[FILENAME], [[5, 0]]);

	function Card($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		const $$stores = setup_stores();

		const $sourceType = () => (
			validate_store(sourceType),
			store_get(sourceType, "$sourceType", $$stores)
		);

		var fragment = root$F();
		var node = sibling(first_child(fragment), 2);

		if_block(
			node,
			() => strict_equals($sourceType(), 'svelte'),
			($$anchor) => {
				var p = root_1$c();

				append($$anchor, p);
			},
			($$anchor) => {
				var fragment_1 = root_2$1();
				var node_1 = sibling(first_child(fragment_1), 4);

				Prism$1(node_1, {
					language: "html",
					children: wrap_snippet(Card, ($$anchor, $$slotProps) => {
						next();

						var text$1 = text();

						text$1.nodeValue = `<div class="card">
  <div class="card-header"></div>
  <div class="card-media">
    <img src="" alt="">
  </div>
   <div class="card-content"></div>
  <div class="card-footer"></div>
</div>`;

						append($$anchor, text$1);
					}),
					$$slots: { default: true }
				});

				var node_2 = sibling(node_1, 6);

				Prism$1(node_2, {
					language: "html",
					children: wrap_snippet(Card, ($$anchor, $$slotProps) => {
						next();

						var text_1 = text();

						text_1.nodeValue = `<div class="card card--small-media">
  <div class="card-media">
    <img src="" alt="" />
  </div>
  <div class="card-content"></div>
</div>`;

						append($$anchor, text_1);
					}),
					$$slots: { default: true }
				});
				append($$anchor, fragment_1);
			}
		);

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Card);

	mark_module_start();
	HorizontalScroll_1[FILENAME] = "docs_src/components/HorizontalScroll.svelte";

	var root_1$b = add_locations(template(`<!> <table class="table"><thead><tr><th>Prop name</th><th>Type</th><th>Default value</th><th>Description</th></tr></thead><tbody><tr><td>className</td><td>string</td><td></td><td></td></tr></tbody></table>`, 1), HorizontalScroll_1[FILENAME], [
		[
			46,
			2,
			[
				[
					47,
					4,
					[
						[
							48,
							6,
							[
								[49, 8],
								[50, 8],
								[51, 8],
								[52, 8]
							]
						]
					]
				],
				[
					55,
					4,
					[
						[
							56,
							6,
							[
								[57, 8],
								[58, 8],
								[59, 8],
								[60, 8]
							]
						]
					]
				]
			]
		]
	]);

	var root_3$2 = add_locations(template(`<p>HorizontalScroll kræver javascript som findes under list-v2 på eb</p> <!>`, 1), HorizontalScroll_1[FILENAME], [[65, 2]]);
	var root$E = add_locations(template(`<h1 class="color--eb">Horizontal Scroll</h1> <!> <!> <!> <!> <!> <!> <!>`, 1), HorizontalScroll_1[FILENAME], [[40, 0]]);

	function HorizontalScroll_1($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		const $$stores = setup_stores();

		const $sourceType = () => (
			validate_store(sourceType),
			store_get(sourceType, "$sourceType", $$stores)
		);

		const $articles = () => (
			validate_store(articles),
			store_get(articles, "$articles", $$stores)
		);

		const articles = writable([
			rdmArticleData(640, 360),
			rdmArticleData(640, 360)
		]);

		const max = 20;
		let count = 2;

		const addingInterval = setInterval(
			() => {
				if (count < max) {
					articles.update((art) => {
						art.push(rdmArticleData(640, 360));
						return art;
					});
				} else {
					clearInterval(addingInterval);
				}

				count += 1;
			},
			3000
		);

		const singleArt = rdmArticleData(640, 360);

		const doubleArt = [
			rdmArticleData(640, 360),
			rdmArticleData(640, 360)
		];

		const threeArt = [
			rdmArticleData(640, 360),
			rdmArticleData(640, 360),
			rdmArticleData(640, 360)
		];

		const multipleArt = [
			rdmArticleData(640, 360),
			rdmArticleData(640, 360),
			rdmArticleData(640, 360),
			rdmArticleData(640, 360),
			rdmArticleData(640, 360),
			rdmArticleData(640, 360),
			rdmArticleData(640, 360),
			rdmArticleData(640, 360),
			rdmArticleData(640, 360),
			rdmArticleData(640, 360),
			rdmArticleData(640, 360),
			rdmArticleData(640, 360)
		];

		init();

		var fragment = root$E();
		var node = sibling(first_child(fragment), 2);

		if_block(
			node,
			() => strict_equals($sourceType(), 'svelte'),
			($$anchor) => {
				var fragment_1 = root_1$b();
				var node_1 = first_child(fragment_1);

				Prism$1(node_1, {
					language: "js",
					children: wrap_snippet(HorizontalScroll_1, ($$anchor, $$slotProps) => {
						next();

						var text$1 = text();

						text$1.nodeValue = `import { HorizontalScroll } from '@ekstra-bladet/designsystem';`;
						append($$anchor, text$1);
					}),
					$$slots: { default: true }
				});
				append($$anchor, fragment_1);
			},
			($$anchor) => {
				var fragment_3 = root_3$2();
				var node_2 = sibling(first_child(fragment_3), 2);

				Prism$1(node_2, {
					language: "html",
					children: wrap_snippet(HorizontalScroll_1, ($$anchor, $$slotProps) => {
						next();

						var text_1 = text();

						text_1.nodeValue = `ekstrabladet/ekstrabladet-publication/src/main/webapp/WEB-INF/jsp/components/list-v2/horizontalscroll.ts`;
						append($$anchor, text_1);
					}),
					$$slots: { default: true }
				});

				append($$anchor, fragment_3);
			}
		);

		var node_3 = sibling(node, 2);

		HorizontalScroll(node_3, {
			className: "margin-m--b",
			children: wrap_snippet(HorizontalScroll_1, ($$anchor, $$slotProps) => {
				var fragment_5 = comment();
				var node_4 = first_child(fragment_5);

				each(node_4, 1, () => multipleArt, index, ($$anchor, article) => {
					ArticleCard($$anchor, spread_props(() => get(article), { width: "350px", style: "flex-shrink:0;" }));
				});

				append($$anchor, fragment_5);
			}),
			$$slots: { default: true }
		});

		var node_5 = sibling(node_3, 2);

		HorizontalScroll(node_5, {
			className: "margin-m--b",
			children: wrap_snippet(HorizontalScroll_1, ($$anchor, $$slotProps) => {
				var fragment_7 = comment();
				var node_6 = first_child(fragment_7);

				each(node_6, 1, () => threeArt, index, ($$anchor, article) => {
					ArticleCard($$anchor, spread_props(() => get(article), { width: "215px" }));
				});

				append($$anchor, fragment_7);
			}),
			$$slots: { default: true }
		});

		var node_7 = sibling(node_5, 2);

		HorizontalScroll(node_7, {
			className: "margin-m--b",
			children: wrap_snippet(HorizontalScroll_1, ($$anchor, $$slotProps) => {
				var fragment_9 = comment();
				var node_8 = first_child(fragment_9);

				each(node_8, 1, () => doubleArt, index, ($$anchor, article) => {
					ArticleCard($$anchor, spread_props(() => get(article), { width: "215px" }));
				});

				append($$anchor, fragment_9);
			}),
			$$slots: { default: true }
		});

		var node_9 = sibling(node_7, 2);

		HorizontalScroll(node_9, {
			className: "margin-m--b",
			children: wrap_snippet(HorizontalScroll_1, ($$anchor, $$slotProps) => {
				ArticleCard($$anchor, spread_props(singleArt, { width: "215px" }));
			}),
			$$slots: { default: true }
		});

		var node_10 = sibling(node_9, 2);

		HorizontalScroll(node_10, {
			className: "margin-m--b",
			children: wrap_snippet(HorizontalScroll_1, ($$anchor, $$slotProps) => {
				var fragment_12 = comment();
				var node_11 = first_child(fragment_12);

				each(node_11, 1, $articles, index, ($$anchor, article) => {
					ArticleCard($$anchor, spread_props(() => get(article), { width: "215px" }));
				});

				append($$anchor, fragment_12);
			}),
			$$slots: { default: true }
		});

		var node_12 = sibling(node_10, 2);

		if_block(
			node_12,
			() => strict_equals($sourceType(), 'svelte'),
			($$anchor) => {
				Prism$1($$anchor, {
					language: "html",
					children: wrap_snippet(HorizontalScroll_1, ($$anchor, $$slotProps) => {
						next();

						var text_2 = text();

						text_2.nodeValue = `<HorizontalScroll>
  ...
</HorizontalScroll>`;

						append($$anchor, text_2);
					}),
					$$slots: { default: true }
				});
			},
			($$anchor) => {
				Prism$1($$anchor, {
					language: "html",
					children: wrap_snippet(HorizontalScroll_1, ($$anchor, $$slotProps) => {
						next();

						var text_3 = text();

						text_3.nodeValue = `<div id="example-id" class="horizontal-scroll-container position-relative">
  <button data-horizontallist="button-prev" class="horizontal-scroll-nav">
    <svg viewBox="0 0 50 50">
      <use xlink:href="#angle-left"></use>
    </svg>
  </button>
  <button data-horizontallist="button-next" class="horizontal-scroll-nav">
    <svg viewBox="0 0 50 50">
      <use xlink:href="#angle-left"></use>
    </svg>
  </button>
  <div data-horizontallist="itemcontainer" class="horizontal-scroll-items flex">
    ...
  </div>
</div>`;

						append($$anchor, text_3);
					}),
					$$slots: { default: true }
				});
			}
		);

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(HorizontalScroll_1);

	mark_module_start();
	DrEditionSVGs[FILENAME] = "docs_src/assets/dredition/DrEditionSVGs.svelte";

	var root$D = add_locations(template(`<div class="grid-width--medium"><div class="flex flex--column margin-l--b"><i class="margin-m--b">Icons on the article card</i> <table class="dredition-table-icons svelte-kntg2d"><thead><tr><th style="width:150px;" class="svelte-kntg2d">Icon</th><th style="width:300px;" class="svelte-kntg2d">Name in DrEdition</th><th style="width:300px;" class="svelte-kntg2d">Filename</th></tr></thead><tbody><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/radar.svg"></td><td class="svelte-kntg2d">radar</td><td class="svelte-kntg2d">radar.svg</td></tr><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/ligenu.svg"></td><td class="svelte-kntg2d">Lige nu</td><td class="svelte-kntg2d">ligenu.svg</td></tr><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/breaking-swipe.svg"></td><td class="svelte-kntg2d">Breaking</td><td class="svelte-kntg2d">breaking-swipe.svg</td></tr><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/afsloering-swipe.svg"></td><td class="svelte-kntg2d">Afsløring</td><td class="svelte-kntg2d">afsloering-swipe.svg</td></tr><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/live.svg"></td><td class="svelte-kntg2d">Live</td><td class="svelte-kntg2d">live.svg</td></tr><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/live-static.svg"></td><td class="svelte-kntg2d">Livestatic <i>(ikke aktiv i Aptoma)</i></td><td class="svelte-kntg2d">live-static.svg</td></tr><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/liveblog.svg"></td><td class="svelte-kntg2d">Liveblog <i>(ikke aktiv i Aptoma)</i></td><td class="svelte-kntg2d">liveblog.svg</td></tr><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/live-video.svg"></td><td class="svelte-kntg2d">live video <i>(ikke aktiv i Aptoma)</i></td><td class="svelte-kntg2d">live-video.svg</td></tr><tr><td style="display: flex; background: grey; padding: 5px;" class="svelte-kntg2d"><span class="video-time ff-primary svelte-kntg2d">1:40</span> <img alt="" src="./svg/dredition/video.svg"></td><td class="svelte-kntg2d">Video <i>(the time is CSS created by Aptoma themselves)</i></td><td class="svelte-kntg2d">video.svg</td></tr><tr><td class="svelte-kntg2d"><div class="premium-dogear" style="height: 61px; position: relative;"><img alt="" src="./svg/dredition/eb-plus-white-onred-anim.svg" height="18"></div></td><td class="svelte-kntg2d">Dogear plus <i>(dogear made with css)</i></td><td class="svelte-kntg2d">eb-plus-white-onred-anim.svg</td></tr><tr><td style="background-color: black" class="svelte-kntg2d"><img alt="" src="./svg/dredition/eb-plus-white-onblack-anim.svg" height="50"></td><td class="svelte-kntg2d">Hvidt plus med sort skygge <i>(Kan bruges på alle baggrunde, der ikke er røde)</i></td><td class="svelte-kntg2d">eb-plus-white-onblack-anim.svg</td></tr><tr><td style="background-color: darkred" class="svelte-kntg2d"><img alt="" src="./svg/dredition/eb-plus-white-onred-anim.svg" height="50"></td><td class="svelte-kntg2d">Hvidt plus med rød skygge <i>(Kan bruges på rød baggrund)</i></td><td class="svelte-kntg2d">eb-plus-white-onred-anim.svg</td></tr><tr><td style="background-color: white" class="svelte-kntg2d"><img alt="" src="./svg/dredition/eb-plus-black-anim.svg" height="50"></td><td class="svelte-kntg2d">Sort plus med hvid skygge <i>(Kan bruges på hvid baggrund)</i></td><td class="svelte-kntg2d">eb-plus-black-anim.svg</td></tr></tbody></table> <i class="margin-m--b margin-l--t">Deprecated icons <b>may be deleted after 3 months</b></i> <table class="dredition-table-icons svelte-kntg2d"><thead><tr><th style="width:300px;" class="svelte-kntg2d">Name in DrEdition</th><th style="width:300px;" class="svelte-kntg2d">Filename</th><th style="width:300px;" class="svelte-kntg2d">Icon</th><th style="width:300px;" class="svelte-kntg2d">Deprecated date</th><th style="width:300px;" class="svelte-kntg2d">Delete date</th></tr></thead><tbody><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/ama-static.svg"></td><td class="svelte-kntg2d">ama</td><td class="svelte-kntg2d">ama-static.svg</td><td class="svelte-kntg2d">28.02.2023</td><td class="svelte-kntg2d">28.05.2023</td></tr><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/audio.svg"></td><td class="svelte-kntg2d">Audio</td><td class="svelte-kntg2d">audio.svg</td><td class="svelte-kntg2d">28.02.2023</td><td class="svelte-kntg2d">28.05.2023</td></tr><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/updating-static.svg"></td><td class="svelte-kntg2d">Updating static</td><td class="svelte-kntg2d">updating-static.svg</td><td class="svelte-kntg2d">28.02.2023</td><td class="svelte-kntg2d">28.05.2023</td></tr><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/live-video-opaque.svg"></td><td class="svelte-kntg2d">live video opaque</td><td class="svelte-kntg2d">live-video-opaque.svg</td><td class="svelte-kntg2d">28.02.2023</td><td class="svelte-kntg2d">28.05.2023</td></tr><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/liveblog-opaque.svg"></td><td class="svelte-kntg2d">Liveblog opaque</td><td class="svelte-kntg2d">liveblog-opaque.svg</td><td class="svelte-kntg2d">28.02.2023</td><td class="svelte-kntg2d">28.05.2023</td></tr><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/ama-live.svg"></td><td class="svelte-kntg2d">AMA live</td><td class="svelte-kntg2d">ama-live.svg</td><td class="svelte-kntg2d">28.02.2023</td><td class="svelte-kntg2d">28.05.2023</td></tr><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/ama-live-opaque.svg"></td><td class="svelte-kntg2d">AMA live opaque</td><td class="svelte-kntg2d">ama-live-opaque.svg</td><td class="svelte-kntg2d">28.02.2023</td><td class="svelte-kntg2d">28.05.2023</td></tr><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/breaking.svg"></td><td class="svelte-kntg2d">Breaking</td><td class="svelte-kntg2d">breaking.svg</td><td class="svelte-kntg2d">28.02.2023</td><td class="svelte-kntg2d">28.05.2023</td></tr><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/soccerball.svg"></td><td class="svelte-kntg2d">Soccerball</td><td class="svelte-kntg2d">soccerball.svg</td><td class="svelte-kntg2d">01.03.2023</td><td class="svelte-kntg2d">01.06.2023</td></tr><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/eb-plus.svg"></td><td class="svelte-kntg2d">Plus</td><td class="svelte-kntg2d">eb-plus.svg</td><td class="svelte-kntg2d">01.03.2023</td><td class="svelte-kntg2d">01.06.2023</td></tr><tr><td class="svelte-kntg2d"><img alt="" src="./svg/dredition/updating.svg"></td><td class="svelte-kntg2d">updating (Er nu som et element i Aptoma - nyt design)</td><td class="svelte-kntg2d">updating.svg</td><td class="svelte-kntg2d">09.03.2023</td><td class="svelte-kntg2d">09.06.2023</td></tr></tbody></table></div></div>`), DrEditionSVGs[FILENAME], [
		[
			6,
			0,
			[
				[
					7,
					2,
					[
						[8, 4],
						[
							9,
							4,
							[
								[
									10,
									6,
									[
										[
											11,
											8,
											[[12, 10], [13, 10], [14, 10]]
										]
									]
								],
								[
									17,
									6,
									[
										[
											18,
											8,
											[
												[19, 10, [[20, 12]]],
												[22, 10],
												[23, 10]
											]
										],
										[
											25,
											8,
											[
												[26, 10, [[27, 12]]],
												[29, 10],
												[30, 10]
											]
										],
										[
											32,
											8,
											[
												[33, 10, [[34, 12]]],
												[36, 10],
												[37, 10]
											]
										],
										[
											39,
											8,
											[
												[40, 10, [[41, 12]]],
												[43, 10],
												[44, 10]
											]
										],
										[
											46,
											8,
											[
												[47, 10, [[48, 12]]],
												[50, 10],
												[51, 10]
											]
										],
										[
											53,
											8,
											[
												[54, 10, [[55, 12]]],
												[57, 10, [[57, 25]]],
												[58, 10]
											]
										],
										[
											60,
											8,
											[
												[61, 10, [[62, 12]]],
												[64, 10, [[64, 23]]],
												[65, 10]
											]
										],
										[
											67,
											8,
											[
												[68, 10, [[69, 12]]],
												[71, 10, [[71, 25]]],
												[72, 10]
											]
										],
										[
											74,
											8,
											[
												[75, 10, [[76, 12], [77, 12]]],
												[79, 10, [[79, 20]]],
												[80, 10]
											]
										],
										[
											82,
											8,
											[
												[
													83,
													10,
													[[84, 12, [[85, 14]]]]
												],
												[88, 10, [[88, 26]]],
												[89, 10]
											]
										],
										[
											91,
											8,
											[
												[92, 10, [[93, 12]]],
												[95, 10, [[95, 41]]],
												[96, 10]
											]
										],
										[
											98,
											8,
											[
												[99, 10, [[100, 12]]],
												[102, 10, [[102, 40]]],
												[103, 10]
											]
										],
										[
											105,
											8,
											[
												[106, 10, [[107, 12]]],
												[109, 10, [[109, 40]]],
												[110, 10]
											]
										]
									]
								]
							]
						],
						[115, 4, [[115, 56]]],
						[
							117,
							4,
							[
								[
									118,
									6,
									[
										[
											119,
											8,
											[
												[120, 10],
												[121, 10],
												[122, 10],
												[123, 10],
												[124, 10]
											]
										]
									]
								],
								[
									127,
									6,
									[
										[
											128,
											8,
											[
												[129, 10, [[130, 12]]],
												[132, 10],
												[133, 10],
												[134, 10],
												[135, 10]
											]
										],
										[
											137,
											8,
											[
												[138, 10, [[139, 12]]],
												[141, 10],
												[142, 10],
												[143, 10],
												[144, 10]
											]
										],
										[
											146,
											8,
											[
												[147, 10, [[148, 12]]],
												[150, 10],
												[151, 10],
												[152, 10],
												[153, 10]
											]
										],
										[
											155,
											8,
											[
												[156, 10, [[157, 12]]],
												[159, 10],
												[160, 10],
												[161, 10],
												[162, 10]
											]
										],
										[
											164,
											8,
											[
												[165, 10, [[166, 12]]],
												[168, 10],
												[169, 10],
												[170, 10],
												[171, 10]
											]
										],
										[
											173,
											8,
											[
												[174, 10, [[175, 12]]],
												[177, 10],
												[178, 10],
												[179, 10],
												[180, 10]
											]
										],
										[
											182,
											8,
											[
												[183, 10, [[184, 12]]],
												[186, 10],
												[187, 10],
												[188, 10],
												[189, 10]
											]
										],
										[
											191,
											8,
											[
												[192, 10, [[193, 12]]],
												[195, 10],
												[196, 10],
												[197, 10],
												[198, 10]
											]
										],
										[
											200,
											8,
											[
												[201, 10, [[202, 12]]],
												[204, 10],
												[205, 10],
												[206, 10],
												[207, 10]
											]
										],
										[
											209,
											8,
											[
												[210, 10, [[211, 12]]],
												[213, 10],
												[214, 10],
												[215, 10],
												[216, 10]
											]
										],
										[
											218,
											8,
											[
												[219, 10, [[220, 12]]],
												[222, 10],
												[223, 10],
												[224, 10],
												[225, 10]
											]
										]
									]
								]
							]
						]
					]
				]
			]
		]
	]);

	function DrEditionSVGs($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var div = root$D();

		append($$anchor, div);
		return pop({ ...legacy_api() });
	}

	mark_module_end(DrEditionSVGs);

	const graphicnameshtml = ['ebplus-black', 'ebplus-white-blackshadow', 'ebplus-white', 'ekstrabladet', 'figcaption-pin', 'video-graphic', 'volume-mute-color'];

	const iconnameshtml = ['angle-down', 'angle-left', 'angle-right', 'angle-up', 'applepodcasts', 'arrow-down', 'arrow-left', 'arrow-right', 'arrow-up', 'article', 'at', 'bell', 'bookmark-solid', 'bookmark', 'calendar', 'camera-solid', 'camera', 'chart-bar', 'check-circle-solid', 'check-circle', 'check-solid', 'check-square-solid', 'check-square', 'check', 'circle-nodes', 'circle-notch', 'circle-solid', 'circle', 'clock', 'cog-solid', 'cog', 'comment-solid', 'comment', 'comments-solid', 'cookie-bite-solid', 'copy', 'creditcard-solid', 'creditcard', 'desktop', 'dot-circle', 'ebplus-circle-solid', 'ebplus', 'edit', 'envelope', 'exclamation-circle-solid', 'exclamation-circle', 'exclamation-triangle-solid', 'exclamation-triangle', 'expand', 'external-link', 'facebook', 'filter-solid', 'futbol', 'gallery', 'gamepad-light', 'glasses', 'headphones-klip', 'headphones', 'headset', 'heart-half-solid', 'heart-solid', 'heart', 'history', 'info-circle-solid', 'info-circle', 'instagram', 'lightning', 'linkedin', 'list-ol', 'lock', 'mappin-solid', 'medielogin', 'menubars-solid', 'menubars', 'miteb-solid', 'miteb', 'newspaper', 'pause-circle', 'pause-solid', 'phone', 'pin-solid', 'play-circle', 'play-solid', 'question-circle', 'rss-symbol', 'rss', 'search', 'share', 'smartphone', 'spotify', 'square', 'star-half-solid', 'star-solid', 'star', 'sync', 'tablet', 'tag-solid', 'tag', 'tags-solid', 'tags', 'times-circle-solid', 'times-circle', 'times', 'toggle-off', 'toggle-on', 'trash-solid', 'trash', 'user-circle-solid', 'user-circle', 'user-solid', 'users', 'video', 'volume-muted-solid', 'volume-off', 'volume-up-solid', 'volume', 'x', 'youtube'];

	mark_module_start();
	Icon_1[FILENAME] = "docs_src/components/Icon.svelte";

	const decrement = (_, size) => {
		return update_pre(size, -1);
	};

	const increment = (__1, size) => {
		return update_pre(size);
	};

	var root_1$a = add_locations(template(`<!> <table class="table"><thead><tr><th>Prop name</th><th>Type</th><th>Default value</th><th>Description</th></tr></thead><tbody><tr><td>className</td><td>string</td><td></td><td>Custom class names</td></tr><tr><td>name <span class="badge badge--small" data-type="primary">required</span></td><td>IconTypes</td><td></td><td>Only names listed beneath are valid</td></tr><tr><td>type</td><td>'svg'</td><td>svg</td><td>Use EB svg icons</td></tr><tr><td>width</td><td>number</td><td>36</td><td>The width of the icon in pixels</td></tr><tr><td>style</td><td>string</td><td></td><td>Custom styling</td></tr></tbody></table>`, 1), Icon_1[FILENAME], [
		[
			25,
			2,
			[
				[
					26,
					4,
					[
						[
							27,
							6,
							[
								[28, 8],
								[29, 8],
								[30, 8],
								[31, 8]
							]
						]
					]
				],
				[
					34,
					4,
					[
						[
							35,
							6,
							[
								[36, 8],
								[37, 8],
								[38, 8],
								[39, 8]
							]
						],
						[
							41,
							6,
							[
								[42, 8, [[42, 17]]],
								[43, 8],
								[44, 8],
								[45, 8]
							]
						],
						[
							47,
							6,
							[
								[48, 8],
								[49, 8],
								[50, 8],
								[51, 8]
							]
						],
						[
							53,
							6,
							[
								[54, 8],
								[55, 8],
								[56, 8],
								[57, 8]
							]
						],
						[
							59,
							6,
							[
								[60, 8],
								[61, 8],
								[62, 8],
								[63, 8]
							]
						]
					]
				]
			]
		]
	]);

	var root_3$1 = add_locations(template(`<option> </option>`), Icon_1[FILENAME], [[87, 8]]);
	var root_4 = add_locations(template(`<div class="card flex-align--center flex-justify--center margin-s padding-m bg--graa6"><!> <small> </small></div>`), Icon_1[FILENAME], [[101, 4, [[103, 6]]]]);
	var root_9 = add_locations(template(`<div class="card flex-align--center flex-justify--center margin-s padding-m bg--graa6"><!> <small> </small></div>`), Icon_1[FILENAME], [[158, 4, [[160, 6]]]]);

	var root$C = add_locations(
		template(
			`<h1 class="color--eb">Icon library</h1> <!> <h3>Icons</h3> <p>Icons are simple and dynamic only made with fill. When using the class <em>icon-svg</em>, fill is set to the css
  variable <em>--icon-fill</em> which defaults to <em>currentColor</em>. This means that the icon will inherit the color
  from the nearest parent where color is defined.</p> <p>But by changing the css variable, the color can be handled separately from any set color.</p> <p>Most icons are derived from <a href="https://fontawesome.com/" target="_blank" rel="noreferrer">FontAwesome</a> using
  only the <b>light</b> or <b>solid</b> library!</p> <div class="flex flex-row flex-justify--center flex-align--center"><div class="margin-m--r">Change icon color <select><option>black</option><!></select></div> <button class="button button--cancel margin-m--r"><!></button> <p>Size: <input type="number" style="width: 45px;">px</p> <button class="button button--cancel margin-m--l"><!></button></div> <div class="flex flex-wrap--wrap"></div> <!> <h3>Filter extension</h3> <p>A (small) subset of icons will respond to the CSS variable --icon-filter, can be used to create a drop-shadow</p> <div class="dropit-example flex svelte-jxk0j5"><div class="flex"><div class="dropit svelte-jxk0j5"><!></div> <!></div> <div class="flex"><div class="dropit svelte-jxk0j5"><!></div> <!></div> <div class="flex"><div class="dropit svelte-jxk0j5"><!></div> <!></div> <div class="flex"><div class="dropit svelte-jxk0j5"><!></div> <!></div></div> <h3>Graphics</h3> <p>Graphics are capable of containing more layers i.e static colors on stroke and fill.</p> <div class="flex flex-wrap--wrap"></div> <!> <h3>* Figcaption pin background</h3> <p>The "background" of figcaption-pin can be changed through the css variable <em>--ebds-figcaption-bg</em></p> <div class="flex flex-wrap--wrap"><div class="card flex-align--center flex-justify--center margin-s padding-m bg--graa6"><!> <small>figcaption-pin</small></div></div> <h3>Frontpage icons (DrEdition)</h3> <p>Icons used in DrEdition Aptoma i.e ekstrabladet.dk frontpage cards</p> <!>`,
			1
		),
		Icon_1[FILENAME],
		[
			[18, 0],
			[69, 0],
			[
				70,
				0,
				[[71, 73], [72, 11], [72, 50]]
			],
			[75, 0],
			[
				76,
				0,
				[[77, 30], [79, 2], [80, 5]]
			],
			[
				82,
				0,
				[
					[
						83,
						2,
						[[84, 22, [[85, 6]]]]
					],
					[91, 2],
					[94, 2, [[94, 11]]],
					[95, 2]
				]
			],
			[99, 0],
			[120, 0],
			[121, 0],
			[
				123,
				0,
				[
					[124, 2, [[125, 4]]],
					[131, 2, [[132, 4]]],
					[138, 2, [[139, 4]]],
					[145, 2, [[146, 4]]]
				]
			],
			[153, 0],
			[154, 0],
			[156, 0],
			[177, 0],
			[179, 0, [[179, 78]]],
			[
				180,
				0,
				[[181, 2, [[183, 4]]]]
			],
			[187, 0],
			[188, 0]
		]
	);

	function Icon_1($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);

		const $$stores = setup_stores();

		const $sourceType = () => (
			validate_store(sourceType),
			store_get(sourceType, "$sourceType", $$stores)
		);

		validate_prop_bindings($$props, [], [], Icon_1);

		let iconColor = state('black');
		let size = state(24);
		var fragment = root$C();
		var node = sibling(first_child(fragment), 2);

		if_block(node, () => strict_equals($sourceType(), 'svelte'), ($$anchor) => {
			var fragment_1 = root_1$a();
			var node_1 = first_child(fragment_1);

			Prism$1(node_1, {
				language: "js",
				children: wrap_snippet(Icon_1, ($$anchor, $$slotProps) => {
					next();

					var text$1 = text();

					text$1.nodeValue = `import { Icon } from '@ekstra-bladet/designsystem';`;
					append($$anchor, text$1);
				}),
				$$slots: { default: true }
			});
			append($$anchor, fragment_1);
		});

		var div = sibling(node, 10);
		var div_1 = child(div);
		var select = sibling(child(div_1));
		var node_2 = sibling(child(select));

		each(node_2, 17, () => Object.keys(ebColorsExports.colorNames), index, ($$anchor, colorName) => {
			var option = root_3$1();
			var option_value = {};
			var text_1 = child(option);

			template_effect(() => {
				if (option_value !== (option_value = get(colorName))) {
					option.value = null == (option.__value = get(colorName)) ? "" : get(colorName);
				}

				set_text(text_1, get(colorName));
			});

			append($$anchor, option);
		});

		var button = sibling(div_1, 2);

		button.__click = [decrement, size];

		var node_3 = child(button);

		Icon(node_3, { name: "angle-left", width: 18 });

		var p = sibling(button, 2);
		var input = sibling(child(p));

		var button_1 = sibling(p, 2);

		button_1.__click = [increment, size];

		var node_4 = child(button_1);

		Icon(node_4, { name: "angle-right", width: 18 });

		var div_2 = sibling(div, 2);

		each(div_2, 21, () => iconnameshtml, index, ($$anchor, name, i) => {
			var div_3 = root_4();
			var node_5 = child(div_3);

			Icon(node_5, {
				get name() {
					return get(name);
				},
				className: "margin-s",
				get width() {
					return get(size);
				}
			});

			var small = sibling(node_5, 2);
			var text_2 = child(small);
			template_effect(() => set_text(text_2, iconnameshtml[i]));
			append($$anchor, div_3);
		});

		var node_6 = sibling(div_2, 2);

		if_block(
			node_6,
			() => strict_equals($sourceType(), 'svelte'),
			($$anchor) => {
				Prism$1($$anchor, {
					language: "html",
					children: wrap_snippet(Icon_1, ($$anchor, $$slotProps) => {
						next();

						var text_3 = text();

						text_3.nodeValue = `<Icon name="iconname" />`;
						append($$anchor, text_3);
					}),
					$$slots: { default: true }
				});
			},
			($$anchor) => {
				Prism$1($$anchor, {
					language: "html",
					children: wrap_snippet(Icon_1, ($$anchor, $$slotProps) => {
						next();

						var text_4 = text();

						text_4.nodeValue = `<svg class="icon-svg" viewBox="0 0 50 50">
  <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#icon-name"></use>
</svg>`;

						append($$anchor, text_4);
					}),
					$$slots: { default: true }
				});
			}
		);

		var div_4 = sibling(node_6, 6);
		var div_5 = child(div_4);
		var div_6 = child(div_5);
		var node_7 = child(div_6);

		Icon(node_7, { name: "share" });

		var node_8 = sibling(div_6, 2);

		Icon(node_8, { name: "share" });

		var div_7 = sibling(div_5, 2);
		var div_8 = child(div_7);
		var node_9 = child(div_8);

		Icon(node_9, { name: "volume" });

		var node_10 = sibling(div_8, 2);

		Icon(node_10, { name: "volume" });

		var div_9 = sibling(div_7, 2);
		var div_10 = child(div_9);
		var node_11 = child(div_10);

		Icon(node_11, { name: "volume-off" });

		var node_12 = sibling(div_10, 2);

		Icon(node_12, { name: "volume-off" });

		var div_11 = sibling(div_9, 2);
		var div_12 = child(div_11);
		var node_13 = child(div_12);

		Icon(node_13, { name: "times-circle" });

		var node_14 = sibling(div_12, 2);

		Icon(node_14, { name: "times-circle" });

		var div_13 = sibling(div_4, 6);

		each(div_13, 21, () => graphicnameshtml, index, ($$anchor, name, i) => {
			var div_14 = root_9();
			var node_15 = child(div_14);

			Icon(node_15, {
				get name() {
					return get(name);
				},
				className: "margin-s",
				width: 86
			});

			var small_1 = sibling(node_15, 2);
			var text_5 = child(small_1);
			template_effect(() => set_text(text_5, graphicnameshtml[i]));
			append($$anchor, div_14);
		});

		var node_16 = sibling(div_13, 2);

		if_block(
			node_16,
			() => strict_equals($sourceType(), 'svelte'),
			($$anchor) => {
				Prism$1($$anchor, {
					language: "html",
					children: wrap_snippet(Icon_1, ($$anchor, $$slotProps) => {
						next();

						var text_6 = text();

						text_6.nodeValue = `<Icon name="iconname" />`;
						append($$anchor, text_6);
					}),
					$$slots: { default: true }
				});
			},
			($$anchor) => {
				Prism$1($$anchor, {
					language: "html",
					children: wrap_snippet(Icon_1, ($$anchor, $$slotProps) => {
						next();

						var text_7 = text();

						text_7.nodeValue = `<svg class="icon-svg" viewBox="0 0 50 50">
  <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#icon-name"></use>
</svg>`;

						append($$anchor, text_7);
					}),
					$$slots: { default: true }
				});
			}
		);

		var div_15 = sibling(node_16, 6);
		var div_16 = child(div_15);
		var node_17 = child(div_16);

		Icon(node_17, {
			name: "figcaption-pin",
			className: "margin-s",
			width: 36
		});

		var node_18 = sibling(div_15, 6);

		DrEditionSVGs(node_18, {});
		template_effect(() => set_attribute(div_2, "style", `--icon-fill: var(--color--${get(iconColor) ?? ""});`));
		bind_select_value(select, () => get(iconColor), ($$value) => set(iconColor, $$value));
		bind_value(input, () => get(size), ($$value) => set(size, $$value));
		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Icon_1);
	delegate(["click"]);

	mark_module_start();
	Spinner_1[FILENAME] = "docs_src/components/Spinner.svelte";

	var root_1$9 = add_locations(template(`<!> <table class="table"><thead><tr><th>Prop name</th><th>Type</th><th>Default value</th><th>Description</th></tr></thead><tbody><tr><td>delay</td><td>number</td><td>150</td><td></td></tr><tr><td>size</td><td>number</td><td>18</td><td>pixel value which translates to <em>--icon-size: [size]px</em></td></tr></tbody></table>`, 1), Spinner_1[FILENAME], [
		[
			13,
			2,
			[
				[
					14,
					4,
					[
						[
							15,
							6,
							[
								[16, 8],
								[17, 8],
								[18, 8],
								[19, 8]
							]
						]
					]
				],
				[
					22,
					4,
					[
						[
							23,
							6,
							[
								[24, 8],
								[25, 8],
								[26, 8],
								[27, 8]
							]
						],
						[
							29,
							6,
							[
								[30, 8],
								[31, 8],
								[32, 8],
								[33, 8, [[33, 44]]]
							]
						]
					]
				]
			]
		]
	]);

	var root$B = add_locations(template(`<h1 class="color--eb">Spinner</h1> <!> <div class="padding-l"><!></div> <!>`, 1), Spinner_1[FILENAME], [[6, 0], [39, 0]]);

	function Spinner_1($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		const $$stores = setup_stores();

		const $sourceType = () => (
			validate_store(sourceType),
			store_get(sourceType, "$sourceType", $$stores)
		);

		var fragment = root$B();
		var node = sibling(first_child(fragment), 2);

		if_block(node, () => strict_equals($sourceType(), 'svelte'), ($$anchor) => {
			var fragment_1 = root_1$9();
			var node_1 = first_child(fragment_1);

			Prism$1(node_1, {
				language: "js",
				children: wrap_snippet(Spinner_1, ($$anchor, $$slotProps) => {
					next();

					var text$1 = text();

					text$1.nodeValue = `import { Spinner } from '@ekstra-bladet/designsystem';`;
					append($$anchor, text$1);
				}),
				$$slots: { default: true }
			});
			append($$anchor, fragment_1);
		});

		var div = sibling(node, 2);
		var node_2 = child(div);

		Spinner(node_2, {});

		var node_3 = sibling(div, 2);

		if_block(
			node_3,
			() => strict_equals($sourceType(), 'svelte'),
			($$anchor) => {
				Prism$1($$anchor, {
					language: "html",
					children: wrap_snippet(Spinner_1, ($$anchor, $$slotProps) => {
						next();

						var text_1 = text();

						text_1.nodeValue = `<Spinner />`;
						append($$anchor, text_1);
					}),
					$$slots: { default: true }
				});
			},
			($$anchor) => {
				Prism$1($$anchor, {
					language: "html",
					children: wrap_snippet(Spinner_1, ($$anchor, $$slotProps) => {
						next();

						var text_2 = text();

						text_2.nodeValue = `<div class="loader flex flex--center">
    <svg viewBox="0 0 18 18" class="bounce bounce1">
      <use xlink:href="#circle-solid"></use>
    </svg>
    <svg viewBox="0 0 18 18" class="bounce bounce2">
      <use xlink:href="#circle-solid"></use>
    </svg>
    <svg viewBox="0 0 18 18" class="bounce bounce3">
      <use xlink:href="#circle-solid"></use>
    </svg>
</div>`;

						append($$anchor, text_2);
					}),
					$$slots: { default: true }
				});
			}
		);

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Spinner_1);

	const components = {
	    path: '/components',
	    routes: [
	        {
	            component: ArticleCard_1,
	            path: '/components/articlecard',
	            name: 'Article card',
	        },
	        {
	            component: Badge,
	            path: '/components/badge',
	            name: 'Badge',
	        },
	        {
	            component: Button,
	            path: '/components/button',
	            name: 'Button',
	        },
	        {
	            component: ButtonGroup,
	            path: '/components/buttongroup',
	            name: 'Button group',
	        },
	        {
	            component: Card,
	            path: '/components/card',
	            name: 'Card',
	        },
	        {
	            component: Icon_1,
	            path: '/components/icon',
	            name: 'Icon',
	        },
	        {
	            component: HorizontalScroll_1,
	            path: '/components/horizontalscroll',
	            name: 'Horizontal scroll',
	        },
	        {
	            component: Spinner_1,
	            path: '/components/spinner',
	            name: 'Spinner',
	        },
	    ],
	    name: 'Components',
	};

	mark_module_start();
	Animation[FILENAME] = "docs_src/utilities/Animation.svelte";

	var root$A = add_locations(template(`<div class="grid-width--large"><h1 class="color--eb">Animation</h1> <h3>Anvendelse af animationer</h3> <p>Animationer anvendes ved tilføjelse af class: <code>className="animation-navnPåAnimation"</code></p> <p>Denne class kan anvendes på tværs af vores komponenter</p> <p><b>OBS:</b> anvendes en animation direkte på et html-element skal det anvendes på følgende måde:<br> <code>class="animation-navnPåAnimation"</code></p> <h3>Eksempler på animationer</h3> <div class="flex grid-width--small"><!></div> <div class="flex grid-width--small"><a href="#/utilities/animation" class="badge margin-s bg--bluedark animation-fogwave">Bandekriminialitet</a> <a href="#/utilities/animation" class="badge margin-s bg--green animation-fogwave">Sport</a> <a href="#/utilities/animation" class="badge margin-s bg--greendark animation-fogwave">Nicklas Bendtner</a></div> <!> <!> <h3>Overblik over animationer</h3> <div class="grid-width--large"><div class="flex flex-item--center bg--graa7" style="border-bottom: 1px solid rgba(0, 0, 0, .1);"><div class="width-1of3 padding-m fontweight-bold">Class</div> <div class="width-1of3 padding-m fontweight-bold">Use case</div></div> <div class="flex bg--graa7" style="border-bottom: 1px solid rgba(0, 0, 0, .1);"><div class="flex-item--center width-1of3 padding-m">animation-fogwave</div> <div class="flex-item--center width-2of3 padding-m"><!></div></div></div></div>`), Animation[FILENAME], [
		[
			15,
			0,
			[
				[16, 2],
				[17, 2],
				[18, 2, [[18, 51]]],
				[19, 2],
				[
					20,
					2,
					[[21, 4], [21, 100], [22, 4]]
				],
				[24, 2],
				[25, 2],
				[
					28,
					2,
					[[29, 4], [30, 4], [31, 4]]
				],
				[50, 2],
				[
					51,
					2,
					[
						[52, 4, [[53, 6], [54, 6]]],
						[56, 4, [[57, 6], [58, 6]]]
					]
				]
			]
		]
	]);

	function Animation($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		const article = {
			colorName: 'sport',
			url: '#',
			media: {
				src: 'https://loremflickr.com/640/360/city,people,nature,animal?random=0.09136348618909862'
			},
			section: 'Sport',
			published: '2 timer siden',
			title: 'List element'
		};

		var div = root$A();
		var div_1 = sibling(child(div), 12);
		var node = child(div_1);

		ArticleCard(node, spread_props({ className: "animation-fogwave" }, article));

		var node_1 = sibling(div_1, 4);

		Prism$1(node_1, {
			language: "html",
			source: `<ArticleCard
          className="animation-fogwave"
          href="{article.href}"
          media="{{src:'https://loremflickr.com/640/360/city,people,nature,animal?random=0.09136348618909862'}}"
          section="{article.section}"
          timestamp="{article.timestamp}"
          title="{article.title}"
          />`
		});

		var node_2 = sibling(node_1, 2);

		Prism$1(node_2, {
			language: "html",
			source: `<a href="#" class="badge badge--primary animation-fogwave margin-s--r">Bandekriminialitet</a>`
		});

		var div_2 = sibling(node_2, 4);
		var div_3 = sibling(child(div_2), 2);
		var div_4 = sibling(child(div_3), 2);
		var node_3 = child(div_4);

		Prism$1(node_3, {
			language: "html",
			source: `<component className="animation-fogwave"/></component>`
		});
		append($$anchor, div);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Animation);

	mark_module_start();
	Border[FILENAME] = "docs_src/utilities/Border.svelte";

	var root$z = add_locations(template(`<h1 class="color--eb">Border</h1> <h3>Border</h3> <div class="card bg--graa7"><div class="card-content flex flex-justify--between flex-wrap--wrap"><div class="border border--black width-1of3 padding-xl margin-l bg--eb">border</div> <div class="border--t border--black width-1of3 padding-xl margin-l bg--eb">border--t</div> <div class="border--b border--black width-1of3 padding-xl margin-l bg--eb">border--b</div> <div class="border--l border--black width-1of3 padding-xl margin-l bg--eb">border--l</div> <div class="border--r border--black width-1of3 padding-xl margin-l bg--eb">border--r</div></div></div> <!> <h3>Border-radius</h3> <div class="card bg--graa7"><div class="card-content flex flex-justify--between flex-wrap--wrap"><div class="border-radius padding-xl width-1of3 margin-l bg--eb">border-radius</div> <div class="border-radius-s padding-xl width-1of3 margin-l bg--eb">border-radius-s</div> <div class="border-radius--t padding-xl width-1of3 margin-l bg--eb">border-radius--t</div> <div class="border-radius-s--t padding-xl width-1of3 margin-l bg--eb">border-radius-s--t</div> <div class="border-radius--b padding-xl width-1of3 margin-l bg--eb">border-radius--b</div> <div class="border-radius-s--b padding-xl width-1of3 margin-l bg--eb">border-radius-s--b</div></div></div> <!> <h3>Border colors</h3> <p>All border colors available</p> <div class="card bg--graa7"><div class="card-content flex flex-justify--between flex-wrap--wrap"><div class="flex flex-align--center border border--black padding-xl width-1of3 margin-l">border--black</div> <div class="flex flex-align--center border border--graa1 padding-xl width-1of3 margin-l">border--graa1</div> <div class="flex flex-align--center border border--graa2 padding-xl width-1of3 margin-l">border--graa2</div> <div class="flex flex-align--center border border--graa3 padding-xl width-1of3 margin-l">border--graa3</div> <div class="flex flex-align--center border border--graa4 padding-xl width-1of3 margin-l">border--graa4</div> <div class="flex flex-align--center border border--graa5 padding-xl width-1of3 margin-l">border--graa5</div> <div class="flex flex-align--center border border--graa6 padding-xl width-1of3 margin-l">border--graa6</div> <div class="flex flex-align--center border border--graa7 padding-xl width-1of3 margin-l">border--graa7</div> <div class="flex flex-align--center border border--white padding-xl width-1of3 margin-l">border--white</div></div></div> <!>`, 1), Border[FILENAME], [
		[4, 0],
		[6, 0],
		[
			8,
			0,
			[
				[
					9,
					2,
					[
						[10, 4],
						[11, 4],
						[12, 4],
						[13, 4],
						[14, 4]
					]
				]
			]
		],
		[26, 0],
		[
			28,
			0,
			[
				[
					29,
					2,
					[
						[30, 4],
						[31, 4],
						[32, 4],
						[33, 4],
						[34, 4],
						[35, 4]
					]
				]
			]
		],
		[48, 0],
		[49, 0],
		[
			51,
			0,
			[
				[
					52,
					2,
					[
						[53, 4],
						[54, 4],
						[55, 4],
						[56, 4],
						[57, 4],
						[58, 4],
						[59, 4],
						[60, 4],
						[61, 4]
					]
				]
			]
		]
	]);

	function Border($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var fragment = root$z();
		var node = sibling(first_child(fragment), 6);

		Prism$1(node, {
			language: "html",
			children: wrap_snippet(Border, ($$anchor, $$slotProps) => {
				next();

				var text$1 = text();

				text$1.nodeValue = `<div class="border"></div>
<div class="border--t"></div>
<div class="border--b"></div>
<div class="border--l"></div>
<div class="border--r"></div>`;

				append($$anchor, text$1);
			}),
			$$slots: { default: true }
		});

		var node_1 = sibling(node, 6);

		Prism$1(node_1, {
			language: "html",
			children: wrap_snippet(Border, ($$anchor, $$slotProps) => {
				next();

				var text_1 = text();

				text_1.nodeValue = `<div class="border-radius"></div>
<div class="border-radius-s"></div>
<div class="border-radius--t"></div>
<div class="border-radius-s--t"></div>
<div class="border-radius--b"></div>
<div class="border-radius-s--b"></div>`;

				append($$anchor, text_1);
			}),
			$$slots: { default: true }
		});

		var node_2 = sibling(node_1, 8);

		Prism$1(node_2, {
			language: "html",
			children: wrap_snippet(Border, ($$anchor, $$slotProps) => {
				next();

				var text_2 = text();

				text_2.nodeValue = `<div class="border border--black"></div>
<div class="border border--graa1"></div>
<div class="border border--graa2"></div>
<div class="border border--graa3"></div>
<div class="border border--graa4"></div>
<div class="border border--graa5"></div>
<div class="border border--graa6"></div>
<div class="border border--graa7"></div>
<div class="border border--white"></div>`;

				append($$anchor, text_2);
			}),
			$$slots: { default: true }
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Border);

	mark_module_start();
	Color[FILENAME] = "docs_src/utilities/Color.svelte";

	function moveToAllColors() {
		const colorSection = document.getElementById('all-colors-section');

		if (colorSection) colorSection.scrollIntoView();
	}

	var root$y = add_locations(template(`<h1 class="color--eb">Color</h1> <h3>Text color</h3> <button class="button button--cancel margin-m--b" style="cursor: pointer;">View all colors available</button> <div class="card bg--graa7"><div class="card-content flex flex-justify--between flex-wrap--wrap"><div class="flex flex--column padding-xl width-1of3 margin-l bg--white color--black">color--black</div> <div class="flex flex--column padding-xl width-1of3 margin-l bg--black color--white">color--white</div> <div class="flex flex--column padding-xl width-1of3 margin-l bg--white color--sport">color--sport</div> <div class="flex flex--column padding-xl width-1of3 margin-l bg--white color--eb">color--eb</div> <div class="flex flex--column padding-xl width-1of3 margin-l bg--white color--orangedark">color--orangedark</div> <div class="flex flex--column padding-xl width-1of3 margin-l bg--white color--nyheder">color--nyheder</div> <div class="flex flex--column padding-xl width-1of3 margin-l bg--white color--section">color--section <em>(inherit the color of the section i.e sport)</em></div></div></div> <!> <h3>Background color</h3> <button class="button button--cancel margin-m--b" style="cursor: pointer;">View all colors available</button> <div class="card bg--graa7"><div class="card-content flex flex-justify--between flex-wrap--wrap"><div class="flex flex--column padding-xl width-1of3 margin-l bg--black">bg--black</div> <div class="flex flex--column padding-xl width-1of3 margin-l bg--white color--black">bg--white</div> <div class="flex flex--column padding-xl width-1of3 margin-l bg--underholdning">bg--underholdning</div> <div class="flex flex--column padding-xl width-1of3 margin-l bg--eb">bg--eb</div> <div class="flex flex--column padding-xl width-1of3 margin-l bg--orangedark">bg--orangedark</div> <div class="flex flex--column padding-xl width-1of3 margin-l bg--nyheder">bg--nyheder</div> <div class="flex flex--column padding-xl width-1of3 margin-l bg--white color--section">bg--section <em>(inherit the color of the section i.e sport)</em></div></div></div> <!> <h3 id="all-colors-section">All colors available on ekstrabladet</h3> <object data="https://ekstrabladetudvikling.github.io/eb-colors/" width="100%" height="500" title="eb-colors">Error: Embedded data could not be displayed. Visit this link instead: <a href="https://ekstrabladetudvikling.github.io/eb-colors/">eb-colors</a></object>`, 1), Color[FILENAME], [
		[9, 0],
		[11, 0],
		[12, 0],
		[
			16,
			0,
			[
				[
					17,
					2,
					[
						[18, 4],
						[19, 4],
						[20, 4],
						[21, 4],
						[22, 4],
						[23, 4],
						[24, 4, [[26, 6]]]
					]
				]
			]
		],
		[41, 0],
		[42, 0],
		[
			46,
			0,
			[
				[
					47,
					2,
					[
						[48, 4],
						[49, 4],
						[50, 4],
						[51, 4],
						[52, 4],
						[53, 4],
						[54, 4, [[56, 6]]]
					]
				]
			]
		],
		[71, 0],
		[73, 0, [[74, 72]]]
	]);

	function Color($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var fragment = root$y();
		var button = sibling(first_child(fragment), 4);

		button.__click = [moveToAllColors];

		var node = sibling(button, 4);

		Prism$1(node, {
			language: "html",
			children: wrap_snippet(Color, ($$anchor, $$slotProps) => {
				next();

				var text$1 = text();

				text$1.nodeValue = `<div class="color--black"></div>
<div class="color--white"></div>
<div class="color--blue"></div>
<div class="color--sport"></div>
<div class="color--orangedark"></div>
<div class="color--nyheder"></div>
<div class="color--section"></div>`;

				append($$anchor, text$1);
			}),
			$$slots: { default: true }
		});

		var button_1 = sibling(node, 4);

		button_1.__click = [moveToAllColors];

		var node_1 = sibling(button_1, 4);

		Prism$1(node_1, {
			language: "html",
			children: wrap_snippet(Color, ($$anchor, $$slotProps) => {
				next();

				var text_1 = text();

				text_1.nodeValue = `<div class="bg--black"></div>
<div class="bg--white"></div>
<div class="bg--underholdning"></div>
<div class="bg--eb"></div>
<div class="bg--orangedark"></div>
<div class="bg--nyheder"></div>
<div class="bg--section"></div>`;

				append($$anchor, text_1);
			}),
			$$slots: { default: true }
		});
		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Color);
	delegate(["click"]);

	mark_module_start();
	Flex[FILENAME] = "docs_src/utilities/Flex.svelte";

	var root$x = add_locations(
		template(
			`<h1 class="color--eb">Flex</h1> <h3>Flex container</h3> <!> <h3>Justify content</h3> <p>Justify content anvendes til <i>horizontal</i> placering af child elementer.</p> <div class="card bg--graa7"><strong class="margin-m">flex flex-justify--start</strong> <div class="flex flex-justify--start bg--eb"><div class="bg--graa4 padding-l">Flex item 1</div> <div class="bg--graa3 padding-l">Flex item 2</div> <div class="bg--graa2 padding-l">Flex item 3</div></div> <strong class="margin-m margin-l--t">flex flex-justify--end</strong> <div class="flex flex-justify--end bg--eb"><div class="bg--graa4 padding-l">Flex item 1</div> <div class="bg--graa3 padding-l">Flex item 2</div> <div class="bg--graa2 padding-l">Flex item 3</div></div> <strong class="margin-m margin-l--t">flex flex-justify--center</strong> <div class="flex flex-justify--center bg--eb"><div class="bg--graa4 padding-l">Flex item 1</div> <div class="bg--graa3 padding-l">Flex item 2</div> <div class="bg--graa2 padding-l">Flex item 3</div></div> <strong class="margin-m margin-l--t">flex flex-justify--around</strong> <div class="flex flex-justify--around bg--eb"><div class="bg--graa4 padding-l">Flex item 1</div> <div class="bg--graa3 padding-l">Flex item 2</div> <div class="bg--graa2 padding-l">Flex item 3</div></div> <strong class="margin-m margin-l--t">flex flex-justify--between</strong> <div class="flex flex-justify--between bg--eb"><div class="bg--graa4 padding-l">Flex item 1</div> <div class="bg--graa3 padding-l">Flex item 2</div> <div class="bg--graa2 padding-l">Flex item 3</div></div></div> <!> <h3>Align items</h3> <p>Align items anvendes til <i>veritcal</i> placering af child elementer.</p> <div class="card bg--graa7"><strong class="margin-m">flex flex-align--start</strong> <div class="flex flex-align--start bg--eb" style="height: 100px"><div class="bg--graa4 padding-l">Flex item 1</div> <div class="bg--graa3 padding-l">Flex item 2</div> <div class="bg--graa2 padding-l">Flex item 3</div></div> <strong class="margin-m margin-l--t">flex flex-align--end</strong> <div class="flex flex-align--end bg--eb" style="height: 100px"><div class="bg--graa4 padding-l">Flex item 1</div> <div class="bg--graa3 padding-l">Flex item 2</div> <div class="bg--graa2 padding-l">Flex item 3</div></div> <strong class="margin-m margin-l--t">flex flex-align--center</strong> <div class="flex flex-align--center bg--eb" style="height: 100px"><div class="bg--graa4 padding-l">Flex item 1</div> <div class="bg--graa3 padding-l">Flex item 2</div> <div class="bg--graa2 padding-l">Flex item 3</div></div> <strong class="margin-m margin-l--t">flex flex-align--stretch</strong> <div class="flex flex-align--stretch bg--eb" style="height: 100px"><div class="bg--graa4 padding-l">Flex item 1</div> <div class="bg--graa3 padding-l">Flex item 2</div> <div class="bg--graa2 padding-l">Flex item 3</div></div></div> <!> <h3>Flex center</h3> <p>Flex center centrere alle child elementer både <i>horizontalt</i> og <i>vertical</i>.</p> <div class="card bg--graa7"><div class="flex flex--center bg--eb" style="height: 100px"><div class="bg--graa4 padding-l">Flex item 1</div> <div class="bg--graa3 padding-l">Flex item 2</div> <div class="bg--graa2 padding-l">Flex item 3</div></div></div> <!> <h3>Directions</h3> <p>Directions bestemmer rækkefølgen for visning af child elementer.</p> <div class="card bg--graa7"><strong class="margin-m">flex flex--column</strong> <div class="flex flex--column"><div class="bg--graa4 padding-l">Flex item 1</div> <div class="bg--graa3 padding-l">Flex item 2</div> <div class="bg--graa2 padding-l">Flex item 3</div></div> <strong class="margin-m margin-l--t">flex flex--column-reverse</strong> <div class="flex flex--column-reverse"><div class="bg--graa4 padding-l">Flex item 1</div> <div class="bg--graa3 padding-l">Flex item 2</div> <div class="bg--graa2 padding-l">Flex item 3</div></div> <strong class="margin-m margin-l--t">flex</strong> <div class="flex bg--eb"><div class="bg--graa4 padding-l">Flex item 1</div> <div class="bg--graa3 padding-l">Flex item 2</div> <div class="bg--graa2 padding-l">Flex item 3</div></div> <strong class="margin-m margin-l--t">flex flex-row--reverse</strong> <div class="flex flex-row--reverse bg--eb"><div class="bg--graa4 padding-l">Flex item 1</div> <div class="bg--graa3 padding-l">Flex item 2</div> <div class="bg--graa2 padding-l">Flex item 3</div></div></div> <!> <h3>Wrap</h3> <p>Flex wrap sørger for at alle child elementer beholder deres størrelse og istedet wrapper elementerne på multiple lines
  istedet for one-line.</p> <div class="card bg--graa7"><strong class="margin-m">flex</strong> <div class="flex"><div class="bg--graa4 width-1of3 padding-l">Flex item 1</div> <div class="bg--graa3 width-1of3 padding-l">Flex item 2</div> <div class="bg--graa2 width-1of3 padding-l">Flex item 3</div> <div class="bg--graa1 width-1of3 padding-l">Flex item 4</div></div> <strong class="margin-m margin-l--t">flex flex-wrap--wrap</strong> <div class="flex flex-wrap--wrap bg--eb"><div class="bg--graa4 width-1of3 padding-l">Flex item 1</div> <div class="bg--graa3 width-1of3 padding-l">Flex item 2</div> <div class="bg--graa2 width-1of3 padding-l">Flex item 3</div> <div class="bg--graa1 width-1of3 padding-l">Flex item 4</div></div></div> <!> <h2>Flex items</h2> <h3>Align self</h3> <div class="card bg--graa7"><div class="flex bg--eb" style="height: 100px"><div class="flex-item--start bg--graa4 width-1of3 padding-l">flex-item--start</div> <div class="flex-item--end bg--graa2 width-1of3 padding-l">flex-item--end</div> <div class="flex-item--center bg--graa3 width-1of3 padding-l">flex-item--center</div> <div class="flex-item--stretch bg--graa1 width-1of3 padding-l">flex-item--stretch</div></div></div> <!> <h3>Grow and shrik</h3> <p><code>flex-item--grow</code> sørger for at child element udfylder den tilbageværende plads i flex containeren.</p> <p><code>flex-item--noshrink</code> sørger for at et child element altid vil have den samme størrelse også på scalering.</p> <div class="card bg--graa7"><strong class="margin-m margin-l--t">Grow</strong> <div class="flex bg--eb"><div class="flex-item--grow bg--graa4 padding-l">flex-item--grow</div> <div class="bg--graa3 padding-l">Flex item 2</div> <div class="bg--graa2 padding-l">Flex item 3</div></div> <strong class="margin-m margin-l--t">No shrink</strong> <div class="flex bg--eb"><div class="flex-item--noshrink width-2of3 bg--graa4 padding-l">flex-item--noshrink width-2of3</div> <div class="bg--graa3 width-1of3 padding-l">width-1of3</div> <div class="bg--graa2 width-1of3 padding-l">width-1of3</div></div></div> <!>`,
			1
		),
		Flex[FILENAME],
		[
			[4, 0],
			[6, 0],
			[12, 0],
			[13, 0, [[13, 32]]],
			[
				15,
				0,
				[
					[16, 2],
					[
						17,
						2,
						[[18, 4], [19, 4], [20, 4]]
					],
					[22, 2],
					[
						23,
						2,
						[[24, 4], [25, 4], [26, 4]]
					],
					[28, 2],
					[
						29,
						2,
						[[30, 4], [31, 4], [32, 4]]
					],
					[34, 2],
					[
						35,
						2,
						[[36, 4], [37, 4], [38, 4]]
					],
					[40, 2],
					[
						41,
						2,
						[[42, 4], [43, 4], [44, 4]]
					]
				]
			],
			[56, 0],
			[57, 0, [[57, 28]]],
			[
				59,
				0,
				[
					[60, 2],
					[
						61,
						2,
						[[62, 4], [63, 4], [64, 4]]
					],
					[66, 2],
					[
						67,
						2,
						[[68, 4], [69, 4], [70, 4]]
					],
					[72, 2],
					[
						73,
						2,
						[[74, 4], [75, 4], [76, 4]]
					],
					[78, 2],
					[
						79,
						2,
						[[80, 4], [81, 4], [82, 4]]
					]
				]
			],
			[93, 0],
			[94, 0, [[94, 50], [94, 72]]],
			[
				96,
				0,
				[
					[
						97,
						2,
						[[98, 4], [99, 4], [100, 4]]
					]
				]
			],
			[108, 0],
			[109, 0],
			[
				111,
				0,
				[
					[112, 2],
					[
						113,
						2,
						[[114, 4], [115, 4], [116, 4]]
					],
					[118, 2],
					[
						119,
						2,
						[[120, 4], [121, 4], [122, 4]]
					],
					[124, 2],
					[
						125,
						2,
						[[126, 4], [127, 4], [128, 4]]
					],
					[130, 2],
					[
						131,
						2,
						[[132, 4], [133, 4], [134, 4]]
					]
				]
			],
			[145, 0],
			[146, 0],
			[
				151,
				0,
				[
					[152, 2],
					[
						153,
						2,
						[
							[154, 4],
							[155, 4],
							[156, 4],
							[157, 4]
						]
					],
					[159, 2],
					[
						160,
						2,
						[
							[161, 4],
							[162, 4],
							[163, 4],
							[164, 4]
						]
					]
				]
			],
			[173, 0],
			[175, 0],
			[
				177,
				0,
				[
					[
						178,
						2,
						[
							[179, 4],
							[180, 4],
							[181, 4],
							[182, 4]
						]
					]
				]
			],
			[195, 0],
			[196, 0, [[196, 3]]],
			[197, 0, [[198, 2]]],
			[
				201,
				0,
				[
					[202, 2],
					[
						203,
						2,
						[[204, 4], [205, 4], [206, 4]]
					],
					[208, 2],
					[
						209,
						2,
						[[210, 4], [211, 4], [212, 4]]
					]
				]
			]
		]
	);

	function Flex($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var fragment = root$x();
		var node = sibling(first_child(fragment), 4);

		Prism$1(node, {
			language: "html",
			children: wrap_snippet(Flex, ($$anchor, $$slotProps) => {
				next();

				var text$1 = text();

				text$1.nodeValue = `<div class="flex"></div>`;
				append($$anchor, text$1);
			}),
			$$slots: { default: true }
		});

		var node_1 = sibling(node, 8);

		Prism$1(node_1, {
			language: "html",
			children: wrap_snippet(Flex, ($$anchor, $$slotProps) => {
				next();

				var text_1 = text();

				text_1.nodeValue = `<div class="flex flex-justify--start"></div>
<div class="flex flex-justify--end"></div>
<div class="flex flex-justify--center"></div>
<div class="flex flex-justify--around"></div>
<div class="flex flex-justify--between"></div>`;

				append($$anchor, text_1);
			}),
			$$slots: { default: true }
		});

		var node_2 = sibling(node_1, 8);

		Prism$1(node_2, {
			language: "html",
			children: wrap_snippet(Flex, ($$anchor, $$slotProps) => {
				next();

				var text_2 = text();

				text_2.nodeValue = `<div class="flex flex-align--start"></div>
<div class="flex flex-align--end"></div>
<div class="flex flex-align--center"></div>
<div class="flex flex-align--stretch"></div>`;

				append($$anchor, text_2);
			}),
			$$slots: { default: true }
		});

		var node_3 = sibling(node_2, 8);

		Prism$1(node_3, {
			language: "html",
			children: wrap_snippet(Flex, ($$anchor, $$slotProps) => {
				next();

				var text_3 = text();

				text_3.nodeValue = `<div class="flex flex--center"></div>`;
				append($$anchor, text_3);
			}),
			$$slots: { default: true }
		});

		var node_4 = sibling(node_3, 8);

		Prism$1(node_4, {
			language: "html",
			children: wrap_snippet(Flex, ($$anchor, $$slotProps) => {
				next();

				var text_4 = text();

				text_4.nodeValue = `<div class="flex flex--column"></div>
<div class="flex flex--column--reverse"></div>
<div class="flex"></div>
<div class="flex flex-row--reverse"></div>`;

				append($$anchor, text_4);
			}),
			$$slots: { default: true }
		});

		var node_5 = sibling(node_4, 8);

		Prism$1(node_5, {
			language: "html",
			children: wrap_snippet(Flex, ($$anchor, $$slotProps) => {
				next();

				var text_5 = text();

				text_5.nodeValue = `<div class="flex"></div>
<div class="flex flex-wrap--wrap"></div>`;

				append($$anchor, text_5);
			}),
			$$slots: { default: true }
		});

		var node_6 = sibling(node_5, 8);

		Prism$1(node_6, {
			language: "html",
			children: wrap_snippet(Flex, ($$anchor, $$slotProps) => {
				next();

				var text_6 = text();

				text_6.nodeValue = `<div class="flex">
  <div class="flex-item--start"></div>
  <div class="flex-item--end"></div>
  <div class="flex-item--center"></div>
  <div class="flex-item--stretch"></div>
</div>`;

				append($$anchor, text_6);
			}),
			$$slots: { default: true }
		});

		var node_7 = sibling(node_6, 10);

		Prism$1(node_7, {
			language: "html",
			children: wrap_snippet(Flex, ($$anchor, $$slotProps) => {
				next();

				var text_7 = text();

				text_7.nodeValue = `<div class="flex">
  <div class="flex-item--grow"></div>
  <div class="flex-item--noshrink"></div>
</div>`;

				append($$anchor, text_7);
			}),
			$$slots: { default: true }
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Flex);

	mark_module_start();
	Fonts$1[FILENAME] = "docs_src/utilities/Fonts.svelte";

	var root$w = add_locations(template(`<h1 class="color--eb">Fonts</h1> <h3>Font family</h3> <div class="card bg--graa7 padding-l--rl"><div class="ff-primary margin-l--tb"><strong>.ff-primary:</strong> <p>Aa Bb Cc Dd Ee Ff Gg Hh Ii Jj Kk Ll Mm Nn Oo Pp Qq Rr Ss Tt Uu Vv Ww Xx Yy Zz Ææ Øø Åå 1234567890</p></div> <div class="ff-secondary"><strong>.ff-secondary:</strong> <p>Aa Bb Cc Dd Ee Ff Gg Hh Ii Jj Kk Ll Mm Nn Oo Pp Qq Rr Ss Tt Uu Vv Ww Xx Yy Zz Ææ Øø Åå 1234567890</p></div></div> <!> <h3>Font-weight</h3> <div class="card bg--graa7 padding-l--rl"><p class="fontweight-normal">fontweight-normal</p> <p class="fontweight-bold">fontweight-bold</p> <p class="fontweight-bolder">fontweight-bolder</p></div> <!> <h3>Font-size</h3> <p>Font-size er sat i rem for at understøtte brugerens font-size valg i browseren.</p> <p>Rem værdien er udregnet i forhold til en basis font-size på 16px, hvilket er browser-standarden</p> <p>Der er både en <u>larger</u> og en <u>smaller</u> mulighed, der begge er relative til parent fontsize</p> <div class="card bg--graa7 padding-l"><div class="fontsize-xxsmall padding-m--b">fontsize-xxsmall = .625rem ~ 10px; <div class="fontsize-smaller">fontsize-smaller</div> <div class="fontsize-larger">fontsize-larger</div></div> <div class="fontsize-xsmall padding-m--tb">fontsize-xsmall = .75rem ~ 12px; <div class="fontsize-smaller">fontsize-smaller</div> <div class="fontsize-larger">fontsize-larger</div></div> <div class="fontsize-small padding-m--tb">fontsize-small = .875rem ~ 14px; <div class="fontsize-smaller">fontsize-smaller</div> <div class="fontsize-larger">fontsize-larger</div></div> <div class="fontsize-medium padding-m--tb">fontsize-medium = 1rem ~ 16px; <div class="fontsize-smaller">fontsize-smaller</div> <div class="fontsize-larger">fontsize-larger</div></div> <div class="fontsize-large padding-m--tb">fontsize-large = 1.125rem ~ 18px; <div class="fontsize-smaller">fontsize-smaller</div> <div class="fontsize-larger">fontsize-larger</div></div> <div class="fontsize-xlarge padding-m--tb">fontsize-xlarge = 1.25rem ~ 20px; <div class="fontsize-smaller">fontsize-smaller</div> <div class="fontsize-larger">fontsize-larger</div></div> <div class="fontsize-xxlarge padding-m--tb">fontsize-xxlarge = 1.875rem ~ 30px; <div class="fontsize-smaller">fontsize-smaller</div> <div class="fontsize-larger">fontsize-larger</div></div> <div class="fontsize-xxxlarge padding-m--tb">fontsize-xxxlarge = 2.25rem ~ 36px; <div class="fontsize-smaller">fontsize-smaller</div> <div class="fontsize-larger">fontsize-larger</div></div> <div class="fontsize-xxxxlarge padding-m--t">fontsize-xxxxlarge = 3.125rem ~ 50px; <div class="fontsize-smaller">fontsize-smaller</div> <div class="fontsize-larger">fontsize-larger</div></div></div> <!> <h3>Headers and font aliases</h3> <div class="card bg--graa7 padding-l--rl padding-l--t"><h1>h1</h1> <h2>h2</h2> <h3>h3</h3> <h4>h4</h4> <h5>h5</h5> <h6>h6</h6> <p class="fs-ads">fs-ads</p> <p class="fs-bodytext">fs-bodytext</p> <p class="fs-caption">fs-caption</p> <p class="fs-quote">fs-quote</p> <p class="fs-showmore">fs-showmore</p> <p class="fs-subtitle">fs-subtitle</p> <p class="fs-timestamp">fs-timestamp</p> <p class="fs-title">fs-title</p></div>`, 1), Fonts$1[FILENAME], [
		[4, 0],
		[6, 0],
		[
			8,
			0,
			[
				[9, 2, [[10, 4], [11, 4]]],
				[13, 2, [[14, 4], [15, 4]]]
			]
		],
		[24, 0],
		[
			26,
			0,
			[[27, 2], [28, 2], [29, 2]]
		],
		[38, 0],
		[40, 0],
		[41, 0],
		[42, 0, [[42, 18], [42, 38]]],
		[
			44,
			0,
			[
				[45, 2, [[47, 4], [48, 4]]],
				[50, 2, [[52, 4], [53, 4]]],
				[55, 2, [[57, 4], [58, 4]]],
				[60, 2, [[62, 4], [63, 4]]],
				[65, 2, [[67, 4], [68, 4]]],
				[70, 2, [[72, 4], [73, 4]]],
				[75, 2, [[77, 4], [78, 4]]],
				[80, 2, [[82, 4], [83, 4]]],
				[85, 2, [[87, 4], [88, 4]]]
			]
		],
		[107, 0],
		[
			109,
			0,
			[
				[110, 2],
				[111, 2],
				[112, 2],
				[113, 2],
				[114, 2],
				[115, 2],
				[117, 2],
				[118, 2],
				[119, 2],
				[120, 2],
				[121, 2],
				[122, 2],
				[123, 2],
				[124, 2]
			]
		]
	]);

	function Fonts$1($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var fragment = root$w();
		var node = sibling(first_child(fragment), 6);

		Prism$1(node, {
			language: "html",
			children: wrap_snippet(Fonts$1, ($$anchor, $$slotProps) => {
				next();

				var text$1 = text();

				text$1.nodeValue = `<div class="ff-primary"></div>
<div class="ff-secondary"></div>`;

				append($$anchor, text$1);
			}),
			$$slots: { default: true }
		});

		var node_1 = sibling(node, 6);

		Prism$1(node_1, {
			language: "html",
			children: wrap_snippet(Fonts$1, ($$anchor, $$slotProps) => {
				next();

				var text_1 = text();

				text_1.nodeValue = `<p class="fontweight-normal"></p>
<p class="fontweight-bold"></p>
<p class="fontweight-bolder"></p>`;

				append($$anchor, text_1);
			}),
			$$slots: { default: true }
		});

		var node_2 = sibling(node_1, 12);

		Prism$1(node_2, {
			language: "html",
			children: wrap_snippet(Fonts$1, ($$anchor, $$slotProps) => {
				next();

				var text_2 = text();

				text_2.nodeValue = `<div class="fontsize-xxsmall"></div>
<div class="fontsize-xsmall"></div>
<div class="fontsize-small"></div>
<div class="fontsize-medium"></div>
<div class="fontsize-large"></div>
<div class="fontsize-xlarge"></div>
<div class="fontsize-xxlarge"></div>
<div class="fontsize-xxxlarge"></div>
<div class="fontsize-xxxxlarge"></div>

<div class="fontsize-smaller"></div>
<div class="fontsize-larger"></div>`;

				append($$anchor, text_2);
			}),
			$$slots: { default: true }
		});
		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Fonts$1);

	mark_module_start();
	Grid[FILENAME] = "docs_src/utilities/Grid.svelte";

	var root$v = add_locations(template(`<h1 class="color--eb margin-l--b">Grid</h1> <div class="card bg--graa7 text-align--center"><div class="grid-width--xlarge vertical-center bg--eb" style="overflow: hidden"><p>grid-width--xlarge: 930px</p> <p>Page content width - frontpage</p> <div class="grid-width--large vertical-center bg--eb2" style="overflow: hidden"><p>grid-width--large: 910px</p> <p>Page content width</p> <div class="grid-width--medium vertical-center bg--eb" style="overflow: hidden"><p>grid-width--medium: 730px</p> <p>Bodytext container width</p> <div class="grid-width--small vertical-center bg--eb2" style="overflow: hidden"><p>grid-width--small: 610px</p> <p>Widget width</p></div></div></div></div></div> <h3>HTML class names</h3> <!> <h3>CSS variable names</h3> <!>`, 1), Grid[FILENAME], [
		[4, 0],
		[
			6,
			0,
			[
				[
					7,
					2,
					[
						[8, 4],
						[9, 4],
						[
							10,
							4,
							[
								[11, 6],
								[12, 6],
								[
									13,
									6,
									[
										[14, 8],
										[15, 8],
										[16, 8, [[17, 10], [18, 10]]]
									]
								]
							]
						]
					]
				]
			]
		],
		[25, 0],
		[34, 0]
	]);

	function Grid($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var fragment = root$v();
		var node = sibling(first_child(fragment), 6);

		Prism$1(node, {
			language: "html",
			children: wrap_snippet(Grid, ($$anchor, $$slotProps) => {
				next();

				var text$1 = text();

				text$1.nodeValue = `<div class="grid-width--xlarge"></div>
<div class="grid-width--large"></div>
<div class="grid-width--medium"></div>
<div class="grid-width--small"></div>`;

				append($$anchor, text$1);
			}),
			$$slots: { default: true }
		});

		var node_1 = sibling(node, 4);

		Prism$1(node_1, {
			language: "css",
			children: wrap_snippet(Grid, ($$anchor, $$slotProps) => {
				next();

				var text_1 = text();

				text_1.nodeValue = `--grid-small: 610px;
--grid-medium: 730px;
--grid-large: 910px;
--grid-xlarge: 930px;`;

				append($$anchor, text_1);
			}),
			$$slots: { default: true }
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Grid);

	mark_module_start();
	Helpers[FILENAME] = "docs_src/utilities/Helpers.svelte";

	var root$u = add_locations(
		template(
			`<h1 class="color--eb">Helpers</h1> <h3>Skjult element</h3> <!> <h3>Position</h3> <!> <h3>Floats</h3> <div class="card bg--graa7"><div><div class="bg--eb padding-m float-left">float-left</div> <div class="bg--eb padding-m float-right">float-right</div></div></div> <!> <h3>Clear</h3> <!> <h3>Centrér vertikalt</h3> <p>Kræver en fast bredde på elementet.</p> <div class="card bg--graa7"><div class="vertical-center width-1of3 padding-l bg--eb">vertical-center</div></div> <!> <h3>Margin & padding</h3> <p>For både <strong>margin</strong> og <strong>padding</strong> klassen har vi fem størrelser <em>(s, m, l, xl og xxl)</em> og så <em>none</em> som sættes på med bindesteg.</p> <!> <p>Ønskes der derimod kun at have <strong>margin</strong> og <strong>padding</strong> i en retning tilføjes dette med double
  bindestreg.</p> <!> <p>Vi har også to samle klasser for <em>top-bottom</em> og <em>right-left</em>.</p> <!> <h3>Box-shadow</h3> <div class="card bg--graa7"><div class="card-content"><div class="border-radius box-shadow--small padding-xl margin-l bg--eb">box-shadow--small</div> <div class="border-radius box-shadow padding-xl margin-l bg--eb">box-shadow</div> <div class="border-radius box-shadow--large padding-xl margin-l bg--eb">box-shadow--large</div></div></div> <!>`,
			1
		),
		Helpers[FILENAME],
		[
			[4, 0],
			[6, 0],
			[12, 0],
			[20, 0],
			[
				22,
				0,
				[
					[23, 2, [[24, 4], [25, 4]]]
				]
			],
			[34, 0],
			[40, 0],
			[41, 0],
			[43, 0, [[44, 2]]],
			[52, 0],
			[
				53,
				0,
				[
					[54, 11],
					[54, 38],
					[55, 2],
					[57, 2]
				]
			],
			[69, 0, [[70, 33], [70, 60]]],
			[81, 0, [[81, 36], [81, 59]]],
			[88, 0],
			[
				90,
				0,
				[
					[
						91,
						2,
						[[92, 4], [93, 4], [94, 4]]
					]
				]
			]
		]
	);

	function Helpers($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var fragment = root$u();
		var node = sibling(first_child(fragment), 4);

		Prism$1(node, {
			language: "html",
			children: wrap_snippet(Helpers, ($$anchor, $$slotProps) => {
				next();

				var text$1 = text();

				text$1.nodeValue = `<div class="hidden"></div>`;
				append($$anchor, text$1);
			}),
			$$slots: { default: true }
		});

		var node_1 = sibling(node, 4);

		Prism$1(node_1, {
			language: "html",
			children: wrap_snippet(Helpers, ($$anchor, $$slotProps) => {
				next();

				var text_1 = text();

				text_1.nodeValue = `<div class="position-absolute"></div>
<div class="position-fixed"></div>
<div class="position-relative"></div>`;

				append($$anchor, text_1);
			}),
			$$slots: { default: true }
		});

		var node_2 = sibling(node_1, 6);

		Prism$1(node_2, {
			language: "html",
			children: wrap_snippet(Helpers, ($$anchor, $$slotProps) => {
				next();

				var text_2 = text();

				text_2.nodeValue = `<div class="float-left"></div>
<div class="float-right"></div>`;

				append($$anchor, text_2);
			}),
			$$slots: { default: true }
		});

		var node_3 = sibling(node_2, 4);

		Prism$1(node_3, {
			language: "html",
			children: wrap_snippet(Helpers, ($$anchor, $$slotProps) => {
				next();

				var text_3 = text();

				text_3.nodeValue = `<div class="clear"></div>`;
				append($$anchor, text_3);
			}),
			$$slots: { default: true }
		});

		var node_4 = sibling(node_3, 8);

		Prism$1(node_4, {
			language: "html",
			children: wrap_snippet(Helpers, ($$anchor, $$slotProps) => {
				next();

				var text_4 = text();

				text_4.nodeValue = `<div class="vertical-center"></div>
<div class="vertical-auto"></div>`;

				append($$anchor, text_4);
			}),
			$$slots: { default: true }
		});

		var node_5 = sibling(node_4, 6);

		Prism$1(node_5, {
			language: "html",
			children: wrap_snippet(Helpers, ($$anchor, $$slotProps) => {
				next();

				var text_5 = text();

				text_5.nodeValue = `<div class="margin-none padding-none"></div>
<div class="margin-s padding-s"></div>
<div class="margin-m padding-m"></div>
<div class="margin-l padding-l"></div>
<div class="margin-xl padding-xl"></div>
<div class="margin-xxl padding-xxl"></div>`;

				append($$anchor, text_5);
			}),
			$$slots: { default: true }
		});

		var node_6 = sibling(node_5, 4);

		Prism$1(node_6, {
			language: "html",
			children: wrap_snippet(Helpers, ($$anchor, $$slotProps) => {
				next();

				var text_6 = text();

				text_6.nodeValue = `<div class="margin-l--t padding-l--t"></div>
<div class="margin-l--r padding-l--r"></div>
<div class="margin-l--b padding-l--b"></div>
<div class="margin-l--l padding-l--l"></div>`;

				append($$anchor, text_6);
			}),
			$$slots: { default: true }
		});

		var node_7 = sibling(node_6, 4);

		Prism$1(node_7, {
			language: "html",
			children: wrap_snippet(Helpers, ($$anchor, $$slotProps) => {
				next();

				var text_7 = text();

				text_7.nodeValue = `<div class="margin-l--tb padding-l--tb"></div>
<div class="margin-l--rl padding-l--rl"></div>`;

				append($$anchor, text_7);
			}),
			$$slots: { default: true }
		});

		var node_8 = sibling(node_7, 6);

		Prism$1(node_8, {
			language: "html",
			children: wrap_snippet(Helpers, ($$anchor, $$slotProps) => {
				next();

				var text_8 = text();

				text_8.nodeValue = `<div class="box-shadow--small"></div>
<div class="box-shadow"></div>
<div class="box-shadow--large"></div>`;

				append($$anchor, text_8);
			}),
			$$slots: { default: true }
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Helpers);

	mark_module_start();
	Separator[FILENAME] = "docs_src/utilities/Separator.svelte";

	var root$t = add_locations(template(`<h1 class="color--eb">Separator</h1> <h3>Separator</h3> <div><p>Separator is <i>class</i> that can be used to seperate content i.e in a box/container.</p></div> <div class="flex"><div class="width-1of3 padding-m box-shadow border-radius"><p>Header</p> <div class="separator"></div> <p>Content</p> <div class="separator"></div> <p>Footer</p></div></div> <!>`, 1), Separator[FILENAME], [
		[4, 0],
		[6, 0],
		[8, 0, [[9, 2, [[9, 18]]]]],
		[
			12,
			0,
			[
				[
					13,
					2,
					[
						[14, 4],
						[15, 4],
						[16, 4],
						[17, 4],
						[18, 4]
					]
				]
			]
		]
	]);

	function Separator($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var fragment = root$t();
		var node = sibling(first_child(fragment), 8);

		Prism$1(node, {
			language: "html",
			children: wrap_snippet(Separator, ($$anchor, $$slotProps) => {
				next();

				var text$1 = text();

				text$1.nodeValue = `<div class="separator"></div>`;
				append($$anchor, text$1);
			}),
			$$slots: { default: true }
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Separator);

	mark_module_start();
	Sizing[FILENAME] = "docs_src/utilities/Sizing.svelte";

	var root$s = add_locations(template(`<h1 class="color--eb">Sizing</h1> <h3>Bredder</h3> <div class="card bg--graa7"><div class="bg--eb padding-m width-100vw">width-100vw</div> <div class="bg--eb padding-m width-auto">width-auto</div> <div class="bg--eb padding-m width-1of1">width-1of1</div> <div class="bg--eb padding-m width-5of6">width-5of6</div> <div class="bg--eb padding-m width-3of4">width-3of4</div> <div class="bg--eb padding-m width-2of3">width-2of3</div> <div class="bg--eb padding-m width-1of2">width-1of2</div> <div class="bg--eb padding-m width-1of3">width-1of3</div> <div class="bg--eb padding-m width-1of4">width-1of4</div> <div class="bg--eb padding-m width-1of5">width-1of5</div> <div class="bg--eb padding-m width-1of6">width-1of6</div></div> <!> <h3>Højder</h3> <div class="card"><div class="text-align--center bg--graa7" style="height: 200px; overflow: hidden"><div class="bg--eb padding-m width-1of4 height-100vh" style="display: inline-block">height-100vh*</div> <div class="bg--eb padding-m width-1of4 height-auto" style="display: inline-block">height-auto</div> <div class="bg--eb padding-m width-1of4 height-1of1" style="display: inline-block">height-1of1</div></div> <div class="card-footer"><p class="fontsize-small">* Viewport height - Vær opmærksom på at disse opfører sig meget forskelligt på forskellige devices html</p></div></div> <!>`, 1), Sizing[FILENAME], [
		[4, 0],
		[6, 0],
		[
			8,
			0,
			[
				[9, 2],
				[10, 2],
				[11, 2],
				[12, 2],
				[13, 2],
				[14, 2],
				[15, 2],
				[16, 2],
				[17, 2],
				[18, 2],
				[19, 2]
			]
		],
		[36, 0],
		[
			38,
			0,
			[
				[
					39,
					2,
					[[40, 4], [41, 4], [42, 4]]
				],
				[44, 2, [[45, 4]]]
			]
		]
	]);

	function Sizing($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var fragment = root$s();
		var node = sibling(first_child(fragment), 6);

		Prism$1(node, {
			language: "html",
			children: wrap_snippet(Sizing, ($$anchor, $$slotProps) => {
				next();

				var text$1 = text();

				text$1.nodeValue = `<div class="width-100vw"></div>
<div class="width-auto"></div>
<div class="width-1of1"></div>
<div class="width-5of6"></div>
<div class="width-3of4"></div>
<div class="width-2of3"></div>
<div class="width-1of2"></div>
<div class="width-1of3"></div>
<div class="width-1of4"></div>
<div class="width-1of5"></div>
<div class="width-1of6"></div>`;

				append($$anchor, text$1);
			}),
			$$slots: { default: true }
		});

		var node_1 = sibling(node, 6);

		Prism$1(node_1, {
			language: "html",
			children: wrap_snippet(Sizing, ($$anchor, $$slotProps) => {
				next();

				var text_1 = text();

				text_1.nodeValue = `<div class="height-100vh"></div>
<div class="height-auto"></div>
<div class="height-1of1"></div>`;

				append($$anchor, text_1);
			}),
			$$slots: { default: true }
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Sizing);

	mark_module_start();
	Text$1[FILENAME] = "docs_src/utilities/Text.svelte";

	var root$r = add_locations(template(`<h1 class="color--eb">Text</h1> <h3>Text alignment</h3> <div class="card bg--graa7 padding-m"><p class="text-align--center">Centreret tekst</p> <p class="text-align--left">Venstrestillet tekst</p> <p class="text-align--right">Højrestillet tekst</p></div> <!> <h3>Text transform</h3> <div class="card bg--graa7 padding-m"><p class="text-transform--lowercase">SMÅ BOGSTAVER</p> <p class="text-transform--uppercase">store bogstaver</p></div> <!> <h3>Line height</h3> <p>Default line-height will be based on the browser usually around 1.2</p> <div class="card bg--graa7"><div class="card-content flex flex-justify--between"><div class="width-1of3 margin-m"><p>normal line-height</p> <p>normal line-height</p> <p>normal line-height</p></div> <div class="width-1of3 margin-m lineheight-m"><p>lineheight-m</p> <p>lineheight-m</p> <p>lineheight-m</p></div></div></div> <!>`, 1), Text$1[FILENAME], [
		[4, 0],
		[6, 0],
		[
			8,
			0,
			[[9, 2], [10, 2], [11, 2]]
		],
		[20, 0],
		[22, 0, [[23, 2], [24, 2]]],
		[32, 0],
		[33, 0],
		[
			34,
			0,
			[
				[
					35,
					2,
					[
						[
							36,
							4,
							[[37, 6], [38, 6], [39, 6]]
						],
						[
							41,
							4,
							[[42, 6], [43, 6], [44, 6]]
						]
					]
				]
			]
		]
	]);

	function Text$1($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var fragment = root$r();
		var node = sibling(first_child(fragment), 6);

		Prism$1(node, {
			language: "html",
			children: wrap_snippet(Text$1, ($$anchor, $$slotProps) => {
				next();

				var text$1 = text();

				text$1.nodeValue = `<p class="text-align--center"></p>
<p class="text-align--left"></p>
<p class="text-align--right"></p>`;

				append($$anchor, text$1);
			}),
			$$slots: { default: true }
		});

		var node_1 = sibling(node, 6);

		Prism$1(node_1, {
			language: "html",
			children: wrap_snippet(Text$1, ($$anchor, $$slotProps) => {
				next();

				var text_1 = text();

				text_1.nodeValue = `<p class="text-transform--lowercase"></p>
<p class="text-transform--uppercase"></p>`;

				append($$anchor, text_1);
			}),
			$$slots: { default: true }
		});

		var node_2 = sibling(node_1, 8);

		Prism$1(node_2, {
			language: "html",
			children: wrap_snippet(Text$1, ($$anchor, $$slotProps) => {
				next();

				var text_2 = text();

				text_2.nodeValue = `<div class="lineheight-m">
  <p>line-height: 1.5em</p>
</div>`;

				append($$anchor, text_2);
			}),
			$$slots: { default: true }
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Text$1);

	const utilities = {
	    path: '/utilities',
	    routes: [
	        { component: Animation, path: '/utilities/animation', name: 'Animation' },
	        { component: Border, path: '/utilities/border', name: 'Border' },
	        { component: Color, path: '/utilities/color', name: 'Color' },
	        { component: Flex, path: '/utilities/flex', name: 'Flex' },
	        { component: Fonts$1, path: '/utilities/fonts', name: 'Fonts' },
	        { component: Grid, path: '/utilities/grid', name: 'Grid' },
	        { component: Helpers, path: '/utilities/helpers', name: 'Helpers' },
	        { component: Separator, path: '/utilities/separator', name: 'Separator' },
	        { component: Sizing, path: '/utilities/sizing', name: 'Sizing' },
	        { component: Text$1, path: '/utilities/text', name: 'Text' },
	    ],
	    name: 'Utilities',
	};

	mark_module_start();
	Colors[FILENAME] = "docs_src/cssvariables/Colors.svelte";

	var root$q = add_locations(template(`<h1>Colors</h1> <div><p>Named colors for ease of use</p> <p><a>See list of colors</a></p></div> <!>`, 1), Colors[FILENAME], [
		[7, 0],
		[
			9,
			0,
			[
				[10, 2],
				[11, 2, [[11, 5]]]
			]
		]
	]);

	function Colors($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		const colorRoute = utilities.routes.find((util) => strict_equals(util.name, 'Color')) || { path: '' };

		init();

		var fragment = root$q();
		var div = sibling(first_child(fragment), 2);
		var p = sibling(child(div), 2);
		var a = child(p);

		action(a, ($$node) => link($$node));

		var node = sibling(div, 2);

		Prism$1(node, {
			language: "css",
			children: wrap_snippet(Colors, ($$anchor, $$slotProps) => {
				next();

				var text$1 = text();

				text$1.nodeValue = `
  --color--accept: var(--color--green);
  --fgcolor--accept: var(--fgcolor--green);
  --color--cancel: var(--color--red);
  --fgcolor--cancel: var(--fgcolor--red);
  --color--default: var(--color--bluedark);
  --fgcolor--default: var(--fgcolor--bluedark);
  --color--primary: var(--color--bruger);
  --fgcolor--primary: var(--fgcolor--bruger);
  --color--secondary: var(--color--graa3);
  --fgcolor--secondary: var(--fgcolor--graa3);
  `;

				append($$anchor, text$1);
			}),
			$$slots: { default: true }
		});

		template_effect(() => set_attribute(a, "href", colorRoute.path));
		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Colors);

	mark_module_start();
	Distance[FILENAME] = "docs_src/cssvariables/Distance.svelte";

	var root$p = add_locations(template(`<h1>Distance</h1> <!> <h2>Smartphone values</h2> <!>`, 1), Distance[FILENAME], [[4, 0], [16, 0]]);

	function Distance($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var fragment = root$p();
		var node = sibling(first_child(fragment), 2);

		Prism$1(node, {
			language: "css",
			children: wrap_snippet(Distance, ($$anchor, $$slotProps) => {
				next();

				var text$1 = text();

				text$1.nodeValue = `
  --distance-large: 20px;
  --distance-medium: 10px;
  --distance-small: 5px;
  --distance-standard: 10px;
  --distance-xlarge: 30px;
  --distance-xxlarge: 50px;
  `;

				append($$anchor, text$1);
			}),
			$$slots: { default: true }
		});

		var node_1 = sibling(node, 4);

		Prism$1(node_1, {
			language: "css",
			children: wrap_snippet(Distance, ($$anchor, $$slotProps) => {
				next();

				var text_1 = text();

				text_1.nodeValue = `
  --distance-large: 15px;
  --distance-medium: 10px;
  --distance-small: 5px;
  --distance-standard: 10px;
  --distance-xlarge: 20px;
  --distance-xxlarge: 30px;
  `;

				append($$anchor, text_1);
			}),
			$$slots: { default: true }
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Distance);

	mark_module_start();
	Fonts[FILENAME] = "docs_src/cssvariables/Fonts.svelte";

	var root$o = add_locations(template(`<h1>Fonts</h1> <h2>Font families</h2> <!> <h2>Fontsizes</h2> <!> <h2>Aliased Fontsizes</h2> <!> <h2>SMARTPHONE Fontsizes</h2> <!> <h2>SMARTPHONE Aliased Fontsizes</h2> <!>`, 1), Fonts[FILENAME], [
		[4, 0],
		[6, 0],
		[15, 0],
		[40, 0],
		[55, 0],
		[70, 0]
	]);

	function Fonts($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var fragment = root$o();
		var node = sibling(first_child(fragment), 4);

		Prism$1(node, {
			language: "css",
			children: wrap_snippet(Fonts, ($$anchor, $$slotProps) => {
				next();

				var text$1 = text();

				text$1.nodeValue = `
  --fontfamily--primary: "Work Sans", var(--fontfamily--secondary);
  --fontfamily--secondary: Arial, Helvetica, sans-serif;
  `;

				append($$anchor, text$1);
			}),
			$$slots: { default: true }
		});

		var node_1 = sibling(node, 4);

		Prism$1(node_1, {
			language: "css",
			children: wrap_snippet(Fonts, ($$anchor, $$slotProps) => {
				next();

				var text_1 = text();

				text_1.nodeValue = `
  --fs-rem-large: 1.125rem; /* 18px */
  --fs-rem-medium: 1rem; /* 16px */
  --fs-rem-small: .875rem; /* 14px */
  --fs-rem-xlarge: 1.25rem; /* 20px */
  --fs-rem-xsmall: .75rem; /* 12px */
  --fs-rem-xxlarge: 1.875rem; /* 30px */
  --fs-rem-xxsmall: .625rem; /* 10px */
  --fs-rem-xxxlarge: 2.25rem; /* 36px */
  --fs-rem-xxxsmall: .4375rem; /* 7px */
  --fs-rem-xxxxlarge: 3.125rem; /* 50px */
  --fs-large: var(--fs-rem-large);
  --fs-medium: var(--fs-rem-medium);
  --fs-small: var(--fs-rem-small);
  --fs-xlarge: var(--fs-rem-xlarge);
  --fs-xsmall: var(--fs-rem-xsmall);
  --fs-xxlarge: var(--fs-rem-xxlarge);
  --fs-xxsmall: var(--fs-rem-xxsmall);
  --fs-xxxlarge: var(--fs-rem-xxxxlarge);
  `;

				append($$anchor, text_1);
			}),
			$$slots: { default: true }
		});

		var node_2 = sibling(node_1, 4);

		Prism$1(node_2, {
			language: "css",
			children: wrap_snippet(Fonts, ($$anchor, $$slotProps) => {
				next();

				var text_2 = text();

				text_2.nodeValue = `
  --fs-ads: var(--fs-xxsmall);
  --fs-bodytext: var(--fs-large);
  --fs-caption: var(--fs-small);
  --fs-quote: var(--fs-xxlarge);
  --fs-showmore: var(--fs-medium);
  --fs-subtitle: var(--fs-xlarge);
  --fs-timestamp: var(--fs-xsmall);
  --fs-title: var(--fs-xxxlarge);
  `;

				append($$anchor, text_2);
			}),
			$$slots: { default: true }
		});

		var node_3 = sibling(node_2, 4);

		Prism$1(node_3, {
			language: "css",
			children: wrap_snippet(Fonts, ($$anchor, $$slotProps) => {
				next();

				var text_3 = text();

				text_3.nodeValue = `
  --fs-large: var(--fs-rem-medium);
  --fs-medium: var(--fs-rem-medium);
  --fs-small: var(--fs-rem-xsmall);
  --fs-xlarge: var(--fs-rem-xlarge);
  --fs-xsmall: var(--fs-rem-xxsmall);
  --fs-xxlarge: var(--fs-rem-xxlarge);
  --fs-xxsmall: var(--fs-rem-xxxsmall);
  --fs-xxxlarge: var(--fs-rem-xxxlarge);
  `;

				append($$anchor, text_3);
			}),
			$$slots: { default: true }
		});

		var node_4 = sibling(node_3, 4);

		Prism$1(node_4, {
			language: "css",
			children: wrap_snippet(Fonts, ($$anchor, $$slotProps) => {
				next();

				var text_4 = text();

				text_4.nodeValue = `
  --fs-ads: var(--fs-xxsmall);
  --fs-bodytext: var(--fs-large);
  --fs-caption: var(--fs-small);
  --fs-quote: var(--fs-xxlarge);
  --fs-showmore: var(--fs-medium);
  --fs-subtitle: var(--fs-xlarge);
  --fs-timestamp: var(--fs-xsmall);
  --fs-title: var(--fs-xxxlarge);
`;

				append($$anchor, text_4);
			}),
			$$slots: { default: true }
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Fonts);

	mark_module_start();
	Misc[FILENAME] = "docs_src/cssvariables/Misc.svelte";

	var root$n = add_locations(template(`<h1>Miscellaneous</h1> <div><p>Variables that didn't fit another category</p></div> <h2>Box shadow</h2> <!> <h2>Border radius</h2> <!>`, 1), Misc[FILENAME], [
		[4, 0],
		[6, 0, [[7, 2]]],
		[10, 0],
		[19, 0]
	]);

	function Misc($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var fragment = root$n();
		var node = sibling(first_child(fragment), 6);

		Prism$1(node, {
			language: "css",
			children: wrap_snippet(Misc, ($$anchor, $$slotProps) => {
				next();

				var text$1 = text();

				text$1.nodeValue = `
  --box-shadow: 0 5px 18px rgba(var(--rgb-color--black), .1);
  --box-shadow--dark: 0 5px 18px rgba(var(--rgb-color--black), .6);
  `;

				append($$anchor, text$1);
			}),
			$$slots: { default: true }
		});

		var node_1 = sibling(node, 4);

		Prism$1(node_1, {
			language: "css",
			children: wrap_snippet(Misc, ($$anchor, $$slotProps) => {
				next();

				var text_1 = text();

				text_1.nodeValue = `
  --border-radius--small: 5px;
  --border-radius: 10px;
  --border-radius--medium: var(--border-radius);
  `;

				append($$anchor, text_1);
			}),
			$$slots: { default: true }
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Misc);

	const path = '/cssvariables';
	const cssvariables = {
	    path,
	    routes: [
	        { component: Colors, path: `${path}/colors`, name: 'Colors' },
	        { component: Distance, path: `${path}/distance`, name: 'Distance' },
	        { component: Fonts, path: `${path}/fonts`, name: 'Font variables' },
	        { component: Misc, path: `${path}/misc`, name: 'Misc' },
	    ],
	    name: 'CSS variables',
	};

	mark_module_start();
	HorizontalScrollHandler[FILENAME] = "docs_src/exportedfunctions/HorizontalScrollHandler.svelte";

	var root_1$8 = add_locations(template(`<p>See full implementation in <b>HorizontalScroll.svelte</b></p> <!>`, 1), HorizontalScrollHandler[FILENAME], [[56, 2, [[56, 32]]]]);
	var root_3 = add_locations(template(`<!> <!>`, 1), HorizontalScrollHandler[FILENAME], []);

	var root$m = add_locations(
		template(
			`<h1>HorizontalScroll</h1> <p>The file exports an enum called SCROLLDIRECTION and a class called HorizontalScrollHandler.</p> <h2>SCROLLDIRECTION - enum</h2> <p>The idea of the enum is to ensure correct arguments is passed to <b>scrollWithButton</b> function.</p> <p>Properties:</p> <ul><li>left</li> <li>right</li></ul> <h2>HorizontalScrollHandler - Class</h2> <p>Instantiation takes no arguments.</p> <p>The class has three public functions</p> <code><div class="padding-xl--l padding-m--tb"><div><h3 class="margin-none">init</h3> <p>Sets up function to handle scrolling</p> <p><b>@param scrollItemContainer</b> HTMLDivElement <em>required</em> - the closest parent to the elements in the scroll
        list</p> <p><b>@param scrollContainer</b> HTMLDivElement <em>required</em> - the parent, which has the width of the element</p></div> <div><h3 class="margin-none">scrollWithButton</h3> <p>Moves the list to make the next element, which is not fully visible, the new "first" element of the list</p> <p><b>@param scrollContainer</b> HTMLDivElement <em>required</em> - the parent, which has the width of the element</p></div> <div><h3 class="margin-none">update</h3> <p>Should be called when new elements are added to list, to ensure all elements will be visible through click
        functionality</p></div></div></code> <p>The reason for the use of an init function and not utilizing the contructor is to ensure an instance exists when
  referencing <em>scrollWithButton</em> in svelte context</p> <!>`,
			1
		),
		HorizontalScrollHandler[FILENAME],
		[
			[5, 0],
			[7, 0],
			[9, 0],
			[11, 0, [[11, 68]]],
			[12, 0],
			[13, 0, [[14, 2], [15, 2]]],
			[18, 0],
			[20, 0],
			[21, 0],
			[
				22,
				0,
				[
					[
						23,
						2,
						[
							[
								24,
								4,
								[
									[25, 6],
									[26, 6],
									[27, 6, [[28, 8], [28, 57]]],
									[31, 6, [[32, 8], [32, 53]]]
								]
							],
							[
								35,
								4,
								[
									[36, 6],
									[37, 6],
									[38, 6, [[39, 8], [39, 53]]]
								]
							],
							[42, 4, [[43, 6], [44, 6]]]
						]
					]
				]
			],
			[51, 0, [[53, 14]]]
		]
	);

	function HorizontalScrollHandler($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		const $$stores = setup_stores();

		const $sourceType = () => (
			validate_store(sourceType),
			store_get(sourceType, "$sourceType", $$stores)
		);

		var fragment = root$m();
		var node = sibling(first_child(fragment), 22);

		if_block(
			node,
			() => strict_equals($sourceType(), 'svelte'),
			($$anchor) => {
				var fragment_1 = root_1$8();
				var node_1 = sibling(first_child(fragment_1), 2);

				Prism$1(node_1, {
					language: "js",
					children: wrap_snippet(HorizontalScrollHandler, ($$anchor, $$slotProps) => {
						next();

						var text$1 = text();

						text$1.nodeValue = `import { HorizontalScrollHandler, SCROLLDIRECTION } from '../../functions/horizontalscroll';

let scrollContainer: HTMLDivElement;
let scrollItemContainer: HTMLDivElement;

const horizontalScrollHandler = new HorizontalScrollHandler();

onMount(() => {
  horizontalScrollHandler.init(scrollItemContainer, scrollContainer);
});

afterUpdate(() => {
  horizontalScrollHandler.update();
});`;

						append($$anchor, text$1);
					}),
					$$slots: { default: true }
				});

				append($$anchor, fragment_1);
			},
			($$anchor) => {
				var fragment_3 = root_3();
				var node_2 = first_child(fragment_3);

				Prism$1(node_2, {
					language: "js",
					children: wrap_snippet(HorizontalScrollHandler, ($$anchor, $$slotProps) => {
						next();

						var text_1 = text();

						text_1.nodeValue = `import {
  HorizontalScrollHandler,
  SCROLLDIRECTION,
} from '@ekstra-bladet/designsystem';

const scrollItemContainer = document.getElementById('scrollItemContainer');
const scrollContainer = document.getElementById('scrollContainer');

const horizontalScrollHandler = new HorizontalScrollHandler();
horizontalScrollHandler.init(scrollItemContainer, scrollContainer);

prevScrollBtn.addEventListener('click', () => {
  horizontalScrollHandler.scrollWithButton(SCROLLDIRECTION.left);
});

nextScrollBtn.addEventListener('click', () => {
  horizontalScrollHandler.scrollWithButton(SCROLLDIRECTION.right);
});
`;

						append($$anchor, text_1);
					}),
					$$slots: { default: true }
				});

				var node_3 = sibling(node_2, 2);

				Prism$1(node_3, {
					language: "html",
					children: wrap_snippet(HorizontalScrollHandler, ($$anchor, $$slotProps) => {
						next();

						var text_2 = text();

						text_2.nodeValue = `<div
  id="scrollContainer"
  class="horizontal-scroll-container"
  data-atend="false"
  data-atstart="true"
>
  <div id="scrollItemContainer" data-horizontallist="itemcontainer" class="horizontal-scroll-items flex">
    ...
  </div>
</div>`;

						append($$anchor, text_2);
					}),
					$$slots: { default: true }
				});

				append($$anchor, fragment_3);
			}
		);

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(HorizontalScrollHandler);

	mark_module_start();
	SplitNfitTitle[FILENAME] = "docs_src/exportedfunctions/SplitNfitTitle.svelte";

	var root$l = add_locations(
		template(
			`<h1>SplitNfitTitle</h1> <p>Uses <a> </a> to split the title, and then uses <a href="https://www.npmjs.com/package/fitty" target="_blank" rel="noreferrer">fitty</a> to adjust font-size to make the
  lines fit the width of the parent element.</p> <p>Returns a document fragment</p> <code><div class="padding-xl--l padding-m--tb"><div><b>@param title</b> string <em>required</em></div> <div><b>@param options</b> object <div class="padding-l--l"><div><b>@prop maxLines?</b> number = 10</div> <div><b>@prop minLines?</b> number = 1</div> <div><b>@prop maxSize?</b> number</div> <div><b>@prop minSize?</b> number</div> <div><b>@prop multiLine?</b> boolean</div> <div><b>@prop observeMutations?</b> MutationObserverInit</div> <div><b>@prop safe?</b> boolean = false - when false the browser waits for document.fonts.ready, should be false if
          using custom fonts</div></div></div></div></code> <!>`,
			1
		),
		SplitNfitTitle[FILENAME],
		[
			[10, 0],
			[12, 0, [[14, 2], [15, 2]]],
			[18, 0],
			[
				19,
				0,
				[
					[
						20,
						2,
						[
							[21, 4, [[21, 9], [21, 36]]],
							[
								22,
								4,
								[
									[23, 6],
									[
										24,
										6,
										[
											[25, 8, [[25, 13]]],
											[26, 8, [[26, 13]]],
											[27, 8, [[27, 13]]],
											[28, 8, [[28, 13]]],
											[29, 8, [[29, 13]]],
											[30, 8, [[30, 13]]],
											[31, 8, [[32, 10]]]
										]
									]
								]
							]
						]
					]
				]
			]
		]
	);

	function SplitNfitTitle($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		const splitRoute = exportedfunctions.routes.find((exfunc) => strict_equals(exfunc.name, 'SplitTitle')) || { name: '', path: '' };

		init();

		var fragment = root$l();
		var p = sibling(first_child(fragment), 2);
		var a = sibling(child(p));
		var text$1 = child(a);
		action(a, ($$node) => link($$node));

		var node = sibling(p, 6);

		Prism$1(node, {
			language: "js",
			children: wrap_snippet(SplitNfitTitle, ($$anchor, $$slotProps) => {
				next();

				var text_1 = text();

				text_1.nodeValue = `import { splitNfitTitle } from '@ekstra-bladet/designsystem/svelte/functions/splitNfitTitle';

const titleEl = splitNfitTitle('This is my title that I want split and fitted');
document.appendChild(titleEl);
`;

				append($$anchor, text_1);
			}),
			$$slots: { default: true }
		});

		template_effect(() => {
			set_attribute(a, "href", splitRoute.path);
			set_text(text$1, splitRoute.name);
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(SplitNfitTitle);

	mark_module_start();
	SplitTitle[FILENAME] = "docs_src/exportedfunctions/SplitTitle.svelte";

	var root$k = add_locations(template(`<h1>SplitTitle</h1> <p>Splits the title into lines based on given min and max number of lines.</p> <p>The created lines is returned as an array of strings.</p> <code><div><div><b>@param input</b> string <em>required</em></div> <div><b>@param minLines</b> number = 1</div> <div><b>@param maxLines</b> number = 4</div></div></code> <!>`, 1), SplitTitle[FILENAME], [
		[4, 0],
		[5, 0],
		[6, 0],
		[
			7,
			0,
			[
				[
					8,
					2,
					[
						[9, 4, [[9, 9], [9, 36]]],
						[10, 4, [[10, 9]]],
						[11, 4, [[11, 9]]]
					]
				]
			]
		]
	]);

	function SplitTitle($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var fragment = root$k();
		var node = sibling(first_child(fragment), 8);

		Prism$1(node, {
			language: "js",
			children: wrap_snippet(SplitTitle, ($$anchor, $$slotProps) => {
				next();

				var text$1 = text();

				text$1.nodeValue = `import { splitTitle } from '@ekstra-bladet/designsystem/svelte/functions/splitTitle';

const lines = splitTitle('Split this into lines', 2, 3);
`;

				append($$anchor, text$1);
			}),
			$$slots: { default: true }
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(SplitTitle);

	mark_module_start();
	Throttle[FILENAME] = "docs_src/exportedfunctions/Throttle.svelte";

	var root$j = add_locations(
		template(
			`<h1>Throttle</h1> <p>Throttle the execution of a given callback. Usefull with scroll events as they fire rapidly and there is no good way
  to tell if the user stopped scrolling.</p> <p>Takes a callback function and a number, the amount of milliseconds to throttle, as arguments</p> <code><div><b>@param callback</b> <em>required</em> callback function</div> <div><b>@param wait</b> <em>required</em> number of milliseconds to wait</div></code> <!>`,
			1
		),
		Throttle[FILENAME],
		[
			[4, 0],
			[5, 0],
			[9, 0],
			[
				11,
				0,
				[
					[12, 2, [[13, 4], [13, 27]]],
					[15, 2, [[16, 4], [16, 23]]]
				]
			]
		]
	);

	function Throttle($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var fragment = root$j();
		var node = sibling(first_child(fragment), 8);

		Prism$1(node, {
			language: "js",
			children: wrap_snippet(Throttle, ($$anchor, $$slotProps) => {
				next();

				var text$1 = text();

				text$1.nodeValue = `import { throttle } from '@ekstra-bladet/designsystem';

window.addEventListener(
  'scroll',
  throttle((data) => {
    callback(data);
  }, 150)
);
`;

				append($$anchor, text$1);
			}),
			$$slots: { default: true }
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Throttle);

	mark_module_start();
	TimePassedSince[FILENAME] = "docs_src/exportedfunctions/TimePassedSince.svelte";

	var root$i = add_locations(template(`<h1>timePassedSince</h1> <p>Takes a datetimestring and transforms it to a string with the time passed since the given time</p> <code><div class="padding-xl--l padding-m--tb"><p><b>@param datetime</b> valid datetimestring <em>required</em></p> <p><b>@param todayAsText</b> boolean <em>optional</em></p></div></code> <!>`, 1), TimePassedSince[FILENAME], [
		[4, 0],
		[5, 0],
		[
			6,
			0,
			[
				[
					7,
					2,
					[
						[8, 4, [[8, 7], [8, 51]]],
						[9, 4, [[9, 7], [9, 41]]]
					]
				]
			]
		]
	]);

	function TimePassedSince($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var fragment = root$i();
		var node = sibling(first_child(fragment), 6);

		Prism$1(node, {
			language: "js",
			children: wrap_snippet(TimePassedSince, ($$anchor, $$slotProps) => {
				next();

				var text$1 = text();

				text$1.nodeValue = `import { timePassedSince } from '@ekstra-bladet/designsystem';`;
				append($$anchor, text$1);
			}),
			$$slots: { default: true }
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(TimePassedSince);

	var top = 'top';
	var bottom = 'bottom';
	var right = 'right';
	var left = 'left';
	var auto = 'auto';
	var basePlacements = [top, bottom, right, left];
	var start = 'start';
	var end = 'end';
	var clippingParents = 'clippingParents';
	var viewport = 'viewport';
	var popper = 'popper';
	var reference = 'reference';
	var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
	  return acc.concat([placement + "-" + start, placement + "-" + end]);
	}, []);
	var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
	  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
	}, []); // modifiers that need to read the DOM

	var beforeRead = 'beforeRead';
	var read = 'read';
	var afterRead = 'afterRead'; // pure-logic modifiers

	var beforeMain = 'beforeMain';
	var main = 'main';
	var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

	var beforeWrite = 'beforeWrite';
	var write = 'write';
	var afterWrite = 'afterWrite';
	var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

	function getNodeName(element) {
	  return element ? (element.nodeName || '').toLowerCase() : null;
	}

	function getWindow(node) {
	  if (node == null) {
	    return window;
	  }

	  if (node.toString() !== '[object Window]') {
	    var ownerDocument = node.ownerDocument;
	    return ownerDocument ? ownerDocument.defaultView || window : window;
	  }

	  return node;
	}

	function isElement$1(node) {
	  var OwnElement = getWindow(node).Element;
	  return node instanceof OwnElement || node instanceof Element;
	}

	function isHTMLElement(node) {
	  var OwnElement = getWindow(node).HTMLElement;
	  return node instanceof OwnElement || node instanceof HTMLElement;
	}

	function isShadowRoot(node) {
	  // IE 11 has no ShadowRoot
	  if (typeof ShadowRoot === 'undefined') {
	    return false;
	  }

	  var OwnElement = getWindow(node).ShadowRoot;
	  return node instanceof OwnElement || node instanceof ShadowRoot;
	}

	// and applies them to the HTMLElements such as popper and arrow

	function applyStyles(_ref) {
	  var state = _ref.state;
	  Object.keys(state.elements).forEach(function (name) {
	    var style = state.styles[name] || {};
	    var attributes = state.attributes[name] || {};
	    var element = state.elements[name]; // arrow is optional + virtual elements

	    if (!isHTMLElement(element) || !getNodeName(element)) {
	      return;
	    } // Flow doesn't support to extend this property, but it's the most
	    // effective way to apply styles to an HTMLElement
	    // $FlowFixMe[cannot-write]


	    Object.assign(element.style, style);
	    Object.keys(attributes).forEach(function (name) {
	      var value = attributes[name];

	      if (value === false) {
	        element.removeAttribute(name);
	      } else {
	        element.setAttribute(name, value === true ? '' : value);
	      }
	    });
	  });
	}

	function effect$2(_ref2) {
	  var state = _ref2.state;
	  var initialStyles = {
	    popper: {
	      position: state.options.strategy,
	      left: '0',
	      top: '0',
	      margin: '0'
	    },
	    arrow: {
	      position: 'absolute'
	    },
	    reference: {}
	  };
	  Object.assign(state.elements.popper.style, initialStyles.popper);
	  state.styles = initialStyles;

	  if (state.elements.arrow) {
	    Object.assign(state.elements.arrow.style, initialStyles.arrow);
	  }

	  return function () {
	    Object.keys(state.elements).forEach(function (name) {
	      var element = state.elements[name];
	      var attributes = state.attributes[name] || {};
	      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

	      var style = styleProperties.reduce(function (style, property) {
	        style[property] = '';
	        return style;
	      }, {}); // arrow is optional + virtual elements

	      if (!isHTMLElement(element) || !getNodeName(element)) {
	        return;
	      }

	      Object.assign(element.style, style);
	      Object.keys(attributes).forEach(function (attribute) {
	        element.removeAttribute(attribute);
	      });
	    });
	  };
	} // eslint-disable-next-line import/no-unused-modules


	var applyStyles$1 = {
	  name: 'applyStyles',
	  enabled: true,
	  phase: 'write',
	  fn: applyStyles,
	  effect: effect$2,
	  requires: ['computeStyles']
	};

	function getBasePlacement$1(placement) {
	  return placement.split('-')[0];
	}

	var max = Math.max;
	var min = Math.min;
	var round = Math.round;

	function getUAString() {
	  var uaData = navigator.userAgentData;

	  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
	    return uaData.brands.map(function (item) {
	      return item.brand + "/" + item.version;
	    }).join(' ');
	  }

	  return navigator.userAgent;
	}

	function isLayoutViewport() {
	  return !/^((?!chrome|android).)*safari/i.test(getUAString());
	}

	function getBoundingClientRect(element, includeScale, isFixedStrategy) {
	  if (includeScale === void 0) {
	    includeScale = false;
	  }

	  if (isFixedStrategy === void 0) {
	    isFixedStrategy = false;
	  }

	  var clientRect = element.getBoundingClientRect();
	  var scaleX = 1;
	  var scaleY = 1;

	  if (includeScale && isHTMLElement(element)) {
	    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
	    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
	  }

	  var _ref = isElement$1(element) ? getWindow(element) : window,
	      visualViewport = _ref.visualViewport;

	  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
	  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
	  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
	  var width = clientRect.width / scaleX;
	  var height = clientRect.height / scaleY;
	  return {
	    width: width,
	    height: height,
	    top: y,
	    right: x + width,
	    bottom: y + height,
	    left: x,
	    x: x,
	    y: y
	  };
	}

	// means it doesn't take into account transforms.

	function getLayoutRect(element) {
	  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
	  // Fixes https://github.com/popperjs/popper-core/issues/1223

	  var width = element.offsetWidth;
	  var height = element.offsetHeight;

	  if (Math.abs(clientRect.width - width) <= 1) {
	    width = clientRect.width;
	  }

	  if (Math.abs(clientRect.height - height) <= 1) {
	    height = clientRect.height;
	  }

	  return {
	    x: element.offsetLeft,
	    y: element.offsetTop,
	    width: width,
	    height: height
	  };
	}

	function contains(parent, child) {
	  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

	  if (parent.contains(child)) {
	    return true;
	  } // then fallback to custom implementation with Shadow DOM support
	  else if (rootNode && isShadowRoot(rootNode)) {
	      var next = child;

	      do {
	        if (next && parent.isSameNode(next)) {
	          return true;
	        } // $FlowFixMe[prop-missing]: need a better way to handle this...


	        next = next.parentNode || next.host;
	      } while (next);
	    } // Give up, the result is false


	  return false;
	}

	function getComputedStyle(element) {
	  return getWindow(element).getComputedStyle(element);
	}

	function isTableElement(element) {
	  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
	}

	function getDocumentElement(element) {
	  // $FlowFixMe[incompatible-return]: assume body is always available
	  return ((isElement$1(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
	  element.document) || window.document).documentElement;
	}

	function getParentNode(element) {
	  if (getNodeName(element) === 'html') {
	    return element;
	  }

	  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
	    // $FlowFixMe[incompatible-return]
	    // $FlowFixMe[prop-missing]
	    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
	    element.parentNode || ( // DOM Element detected
	    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
	    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
	    getDocumentElement(element) // fallback

	  );
	}

	function getTrueOffsetParent(element) {
	  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
	  getComputedStyle(element).position === 'fixed') {
	    return null;
	  }

	  return element.offsetParent;
	} // `.offsetParent` reports `null` for fixed elements, while absolute elements
	// return the containing block


	function getContainingBlock(element) {
	  var isFirefox = /firefox/i.test(getUAString());
	  var isIE = /Trident/i.test(getUAString());

	  if (isIE && isHTMLElement(element)) {
	    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
	    var elementCss = getComputedStyle(element);

	    if (elementCss.position === 'fixed') {
	      return null;
	    }
	  }

	  var currentNode = getParentNode(element);

	  if (isShadowRoot(currentNode)) {
	    currentNode = currentNode.host;
	  }

	  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
	    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
	    // create a containing block.
	    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

	    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
	      return currentNode;
	    } else {
	      currentNode = currentNode.parentNode;
	    }
	  }

	  return null;
	} // Gets the closest ancestor positioned element. Handles some edge cases,
	// such as table ancestors and cross browser bugs.


	function getOffsetParent(element) {
	  var window = getWindow(element);
	  var offsetParent = getTrueOffsetParent(element);

	  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
	    offsetParent = getTrueOffsetParent(offsetParent);
	  }

	  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
	    return window;
	  }

	  return offsetParent || getContainingBlock(element) || window;
	}

	function getMainAxisFromPlacement(placement) {
	  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
	}

	function within(min$1, value, max$1) {
	  return max(min$1, min(value, max$1));
	}
	function withinMaxClamp(min, value, max) {
	  var v = within(min, value, max);
	  return v > max ? max : v;
	}

	function getFreshSideObject() {
	  return {
	    top: 0,
	    right: 0,
	    bottom: 0,
	    left: 0
	  };
	}

	function mergePaddingObject(paddingObject) {
	  return Object.assign({}, getFreshSideObject(), paddingObject);
	}

	function expandToHashMap(value, keys) {
	  return keys.reduce(function (hashMap, key) {
	    hashMap[key] = value;
	    return hashMap;
	  }, {});
	}

	var toPaddingObject = function toPaddingObject(padding, state) {
	  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
	    placement: state.placement
	  })) : padding;
	  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
	};

	function arrow(_ref) {
	  var _state$modifiersData$;

	  var state = _ref.state,
	      name = _ref.name,
	      options = _ref.options;
	  var arrowElement = state.elements.arrow;
	  var popperOffsets = state.modifiersData.popperOffsets;
	  var basePlacement = getBasePlacement$1(state.placement);
	  var axis = getMainAxisFromPlacement(basePlacement);
	  var isVertical = [left, right].indexOf(basePlacement) >= 0;
	  var len = isVertical ? 'height' : 'width';

	  if (!arrowElement || !popperOffsets) {
	    return;
	  }

	  var paddingObject = toPaddingObject(options.padding, state);
	  var arrowRect = getLayoutRect(arrowElement);
	  var minProp = axis === 'y' ? top : left;
	  var maxProp = axis === 'y' ? bottom : right;
	  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
	  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
	  var arrowOffsetParent = getOffsetParent(arrowElement);
	  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
	  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
	  // outside of the popper bounds

	  var min = paddingObject[minProp];
	  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
	  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
	  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

	  var axisProp = axis;
	  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
	}

	function effect$1(_ref2) {
	  var state = _ref2.state,
	      options = _ref2.options;
	  var _options$element = options.element,
	      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

	  if (arrowElement == null) {
	    return;
	  } // CSS selector


	  if (typeof arrowElement === 'string') {
	    arrowElement = state.elements.popper.querySelector(arrowElement);

	    if (!arrowElement) {
	      return;
	    }
	  }

	  if (!contains(state.elements.popper, arrowElement)) {
	    return;
	  }

	  state.elements.arrow = arrowElement;
	} // eslint-disable-next-line import/no-unused-modules


	var arrow$1 = {
	  name: 'arrow',
	  enabled: true,
	  phase: 'main',
	  fn: arrow,
	  effect: effect$1,
	  requires: ['popperOffsets'],
	  requiresIfExists: ['preventOverflow']
	};

	function getVariation(placement) {
	  return placement.split('-')[1];
	}

	var unsetSides = {
	  top: 'auto',
	  right: 'auto',
	  bottom: 'auto',
	  left: 'auto'
	}; // Round the offsets to the nearest suitable subpixel based on the DPR.
	// Zooming can change the DPR, but it seems to report a value that will
	// cleanly divide the values into the appropriate subpixels.

	function roundOffsetsByDPR(_ref, win) {
	  var x = _ref.x,
	      y = _ref.y;
	  var dpr = win.devicePixelRatio || 1;
	  return {
	    x: round(x * dpr) / dpr || 0,
	    y: round(y * dpr) / dpr || 0
	  };
	}

	function mapToStyles(_ref2) {
	  var _Object$assign2;

	  var popper = _ref2.popper,
	      popperRect = _ref2.popperRect,
	      placement = _ref2.placement,
	      variation = _ref2.variation,
	      offsets = _ref2.offsets,
	      position = _ref2.position,
	      gpuAcceleration = _ref2.gpuAcceleration,
	      adaptive = _ref2.adaptive,
	      roundOffsets = _ref2.roundOffsets,
	      isFixed = _ref2.isFixed;
	  var _offsets$x = offsets.x,
	      x = _offsets$x === void 0 ? 0 : _offsets$x,
	      _offsets$y = offsets.y,
	      y = _offsets$y === void 0 ? 0 : _offsets$y;

	  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
	    x: x,
	    y: y
	  }) : {
	    x: x,
	    y: y
	  };

	  x = _ref3.x;
	  y = _ref3.y;
	  var hasX = offsets.hasOwnProperty('x');
	  var hasY = offsets.hasOwnProperty('y');
	  var sideX = left;
	  var sideY = top;
	  var win = window;

	  if (adaptive) {
	    var offsetParent = getOffsetParent(popper);
	    var heightProp = 'clientHeight';
	    var widthProp = 'clientWidth';

	    if (offsetParent === getWindow(popper)) {
	      offsetParent = getDocumentElement(popper);

	      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
	        heightProp = 'scrollHeight';
	        widthProp = 'scrollWidth';
	      }
	    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


	    offsetParent = offsetParent;

	    if (placement === top || (placement === left || placement === right) && variation === end) {
	      sideY = bottom;
	      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
	      offsetParent[heightProp];
	      y -= offsetY - popperRect.height;
	      y *= gpuAcceleration ? 1 : -1;
	    }

	    if (placement === left || (placement === top || placement === bottom) && variation === end) {
	      sideX = right;
	      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
	      offsetParent[widthProp];
	      x -= offsetX - popperRect.width;
	      x *= gpuAcceleration ? 1 : -1;
	    }
	  }

	  var commonStyles = Object.assign({
	    position: position
	  }, adaptive && unsetSides);

	  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
	    x: x,
	    y: y
	  }, getWindow(popper)) : {
	    x: x,
	    y: y
	  };

	  x = _ref4.x;
	  y = _ref4.y;

	  if (gpuAcceleration) {
	    var _Object$assign;

	    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
	  }

	  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
	}

	function computeStyles(_ref5) {
	  var state = _ref5.state,
	      options = _ref5.options;
	  var _options$gpuAccelerat = options.gpuAcceleration,
	      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
	      _options$adaptive = options.adaptive,
	      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
	      _options$roundOffsets = options.roundOffsets,
	      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
	  var commonStyles = {
	    placement: getBasePlacement$1(state.placement),
	    variation: getVariation(state.placement),
	    popper: state.elements.popper,
	    popperRect: state.rects.popper,
	    gpuAcceleration: gpuAcceleration,
	    isFixed: state.options.strategy === 'fixed'
	  };

	  if (state.modifiersData.popperOffsets != null) {
	    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
	      offsets: state.modifiersData.popperOffsets,
	      position: state.options.strategy,
	      adaptive: adaptive,
	      roundOffsets: roundOffsets
	    })));
	  }

	  if (state.modifiersData.arrow != null) {
	    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
	      offsets: state.modifiersData.arrow,
	      position: 'absolute',
	      adaptive: false,
	      roundOffsets: roundOffsets
	    })));
	  }

	  state.attributes.popper = Object.assign({}, state.attributes.popper, {
	    'data-popper-placement': state.placement
	  });
	} // eslint-disable-next-line import/no-unused-modules


	var computeStyles$1 = {
	  name: 'computeStyles',
	  enabled: true,
	  phase: 'beforeWrite',
	  fn: computeStyles,
	  data: {}
	};

	var passive = {
	  passive: true
	};

	function effect(_ref) {
	  var state = _ref.state,
	      instance = _ref.instance,
	      options = _ref.options;
	  var _options$scroll = options.scroll,
	      scroll = _options$scroll === void 0 ? true : _options$scroll,
	      _options$resize = options.resize,
	      resize = _options$resize === void 0 ? true : _options$resize;
	  var window = getWindow(state.elements.popper);
	  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

	  if (scroll) {
	    scrollParents.forEach(function (scrollParent) {
	      scrollParent.addEventListener('scroll', instance.update, passive);
	    });
	  }

	  if (resize) {
	    window.addEventListener('resize', instance.update, passive);
	  }

	  return function () {
	    if (scroll) {
	      scrollParents.forEach(function (scrollParent) {
	        scrollParent.removeEventListener('scroll', instance.update, passive);
	      });
	    }

	    if (resize) {
	      window.removeEventListener('resize', instance.update, passive);
	    }
	  };
	} // eslint-disable-next-line import/no-unused-modules


	var eventListeners = {
	  name: 'eventListeners',
	  enabled: true,
	  phase: 'write',
	  fn: function fn() {},
	  effect: effect,
	  data: {}
	};

	var hash$1 = {
	  left: 'right',
	  right: 'left',
	  bottom: 'top',
	  top: 'bottom'
	};
	function getOppositePlacement(placement) {
	  return placement.replace(/left|right|bottom|top/g, function (matched) {
	    return hash$1[matched];
	  });
	}

	var hash = {
	  start: 'end',
	  end: 'start'
	};
	function getOppositeVariationPlacement(placement) {
	  return placement.replace(/start|end/g, function (matched) {
	    return hash[matched];
	  });
	}

	function getWindowScroll(node) {
	  var win = getWindow(node);
	  var scrollLeft = win.pageXOffset;
	  var scrollTop = win.pageYOffset;
	  return {
	    scrollLeft: scrollLeft,
	    scrollTop: scrollTop
	  };
	}

	function getWindowScrollBarX(element) {
	  // If <html> has a CSS width greater than the viewport, then this will be
	  // incorrect for RTL.
	  // Popper 1 is broken in this case and never had a bug report so let's assume
	  // it's not an issue. I don't think anyone ever specifies width on <html>
	  // anyway.
	  // Browsers where the left scrollbar doesn't cause an issue report `0` for
	  // this (e.g. Edge 2019, IE11, Safari)
	  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
	}

	function getViewportRect(element, strategy) {
	  var win = getWindow(element);
	  var html = getDocumentElement(element);
	  var visualViewport = win.visualViewport;
	  var width = html.clientWidth;
	  var height = html.clientHeight;
	  var x = 0;
	  var y = 0;

	  if (visualViewport) {
	    width = visualViewport.width;
	    height = visualViewport.height;
	    var layoutViewport = isLayoutViewport();

	    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
	      x = visualViewport.offsetLeft;
	      y = visualViewport.offsetTop;
	    }
	  }

	  return {
	    width: width,
	    height: height,
	    x: x + getWindowScrollBarX(element),
	    y: y
	  };
	}

	// of the `<html>` and `<body>` rect bounds if horizontally scrollable

	function getDocumentRect(element) {
	  var _element$ownerDocumen;

	  var html = getDocumentElement(element);
	  var winScroll = getWindowScroll(element);
	  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
	  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
	  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
	  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
	  var y = -winScroll.scrollTop;

	  if (getComputedStyle(body || html).direction === 'rtl') {
	    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
	  }

	  return {
	    width: width,
	    height: height,
	    x: x,
	    y: y
	  };
	}

	function isScrollParent(element) {
	  // Firefox wants us to check `-x` and `-y` variations as well
	  var _getComputedStyle = getComputedStyle(element),
	      overflow = _getComputedStyle.overflow,
	      overflowX = _getComputedStyle.overflowX,
	      overflowY = _getComputedStyle.overflowY;

	  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
	}

	function getScrollParent(node) {
	  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
	    // $FlowFixMe[incompatible-return]: assume body is always available
	    return node.ownerDocument.body;
	  }

	  if (isHTMLElement(node) && isScrollParent(node)) {
	    return node;
	  }

	  return getScrollParent(getParentNode(node));
	}

	/*
	given a DOM element, return the list of all scroll parents, up the list of ancesors
	until we get to the top window object. This list is what we attach scroll listeners
	to, because if any of these parent elements scroll, we'll need to re-calculate the
	reference element's position.
	*/

	function listScrollParents(element, list) {
	  var _element$ownerDocumen;

	  if (list === void 0) {
	    list = [];
	  }

	  var scrollParent = getScrollParent(element);
	  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
	  var win = getWindow(scrollParent);
	  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
	  var updatedList = list.concat(target);
	  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
	  updatedList.concat(listScrollParents(getParentNode(target)));
	}

	function rectToClientRect(rect) {
	  return Object.assign({}, rect, {
	    left: rect.x,
	    top: rect.y,
	    right: rect.x + rect.width,
	    bottom: rect.y + rect.height
	  });
	}

	function getInnerBoundingClientRect(element, strategy) {
	  var rect = getBoundingClientRect(element, false, strategy === 'fixed');
	  rect.top = rect.top + element.clientTop;
	  rect.left = rect.left + element.clientLeft;
	  rect.bottom = rect.top + element.clientHeight;
	  rect.right = rect.left + element.clientWidth;
	  rect.width = element.clientWidth;
	  rect.height = element.clientHeight;
	  rect.x = rect.left;
	  rect.y = rect.top;
	  return rect;
	}

	function getClientRectFromMixedType(element, clippingParent, strategy) {
	  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
	} // A "clipping parent" is an overflowable container with the characteristic of
	// clipping (or hiding) overflowing elements with a position different from
	// `initial`


	function getClippingParents(element) {
	  var clippingParents = listScrollParents(getParentNode(element));
	  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
	  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

	  if (!isElement$1(clipperElement)) {
	    return [];
	  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


	  return clippingParents.filter(function (clippingParent) {
	    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
	  });
	} // Gets the maximum area that the element is visible in due to any number of
	// clipping parents


	function getClippingRect(element, boundary, rootBoundary, strategy) {
	  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
	  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
	  var firstClippingParent = clippingParents[0];
	  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
	    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
	    accRect.top = max(rect.top, accRect.top);
	    accRect.right = min(rect.right, accRect.right);
	    accRect.bottom = min(rect.bottom, accRect.bottom);
	    accRect.left = max(rect.left, accRect.left);
	    return accRect;
	  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
	  clippingRect.width = clippingRect.right - clippingRect.left;
	  clippingRect.height = clippingRect.bottom - clippingRect.top;
	  clippingRect.x = clippingRect.left;
	  clippingRect.y = clippingRect.top;
	  return clippingRect;
	}

	function computeOffsets(_ref) {
	  var reference = _ref.reference,
	      element = _ref.element,
	      placement = _ref.placement;
	  var basePlacement = placement ? getBasePlacement$1(placement) : null;
	  var variation = placement ? getVariation(placement) : null;
	  var commonX = reference.x + reference.width / 2 - element.width / 2;
	  var commonY = reference.y + reference.height / 2 - element.height / 2;
	  var offsets;

	  switch (basePlacement) {
	    case top:
	      offsets = {
	        x: commonX,
	        y: reference.y - element.height
	      };
	      break;

	    case bottom:
	      offsets = {
	        x: commonX,
	        y: reference.y + reference.height
	      };
	      break;

	    case right:
	      offsets = {
	        x: reference.x + reference.width,
	        y: commonY
	      };
	      break;

	    case left:
	      offsets = {
	        x: reference.x - element.width,
	        y: commonY
	      };
	      break;

	    default:
	      offsets = {
	        x: reference.x,
	        y: reference.y
	      };
	  }

	  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

	  if (mainAxis != null) {
	    var len = mainAxis === 'y' ? 'height' : 'width';

	    switch (variation) {
	      case start:
	        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
	        break;

	      case end:
	        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
	        break;
	    }
	  }

	  return offsets;
	}

	function detectOverflow(state, options) {
	  if (options === void 0) {
	    options = {};
	  }

	  var _options = options,
	      _options$placement = _options.placement,
	      placement = _options$placement === void 0 ? state.placement : _options$placement,
	      _options$strategy = _options.strategy,
	      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
	      _options$boundary = _options.boundary,
	      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
	      _options$rootBoundary = _options.rootBoundary,
	      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
	      _options$elementConte = _options.elementContext,
	      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
	      _options$altBoundary = _options.altBoundary,
	      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
	      _options$padding = _options.padding,
	      padding = _options$padding === void 0 ? 0 : _options$padding;
	  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
	  var altContext = elementContext === popper ? reference : popper;
	  var popperRect = state.rects.popper;
	  var element = state.elements[altBoundary ? altContext : elementContext];
	  var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
	  var referenceClientRect = getBoundingClientRect(state.elements.reference);
	  var popperOffsets = computeOffsets({
	    reference: referenceClientRect,
	    element: popperRect,
	    strategy: 'absolute',
	    placement: placement
	  });
	  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
	  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
	  // 0 or negative = within the clipping rect

	  var overflowOffsets = {
	    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
	    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
	    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
	    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
	  };
	  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

	  if (elementContext === popper && offsetData) {
	    var offset = offsetData[placement];
	    Object.keys(overflowOffsets).forEach(function (key) {
	      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
	      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
	      overflowOffsets[key] += offset[axis] * multiply;
	    });
	  }

	  return overflowOffsets;
	}

	function computeAutoPlacement(state, options) {
	  if (options === void 0) {
	    options = {};
	  }

	  var _options = options,
	      placement = _options.placement,
	      boundary = _options.boundary,
	      rootBoundary = _options.rootBoundary,
	      padding = _options.padding,
	      flipVariations = _options.flipVariations,
	      _options$allowedAutoP = _options.allowedAutoPlacements,
	      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
	  var variation = getVariation(placement);
	  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
	    return getVariation(placement) === variation;
	  }) : basePlacements;
	  var allowedPlacements = placements$1.filter(function (placement) {
	    return allowedAutoPlacements.indexOf(placement) >= 0;
	  });

	  if (allowedPlacements.length === 0) {
	    allowedPlacements = placements$1;
	  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


	  var overflows = allowedPlacements.reduce(function (acc, placement) {
	    acc[placement] = detectOverflow(state, {
	      placement: placement,
	      boundary: boundary,
	      rootBoundary: rootBoundary,
	      padding: padding
	    })[getBasePlacement$1(placement)];
	    return acc;
	  }, {});
	  return Object.keys(overflows).sort(function (a, b) {
	    return overflows[a] - overflows[b];
	  });
	}

	function getExpandedFallbackPlacements(placement) {
	  if (getBasePlacement$1(placement) === auto) {
	    return [];
	  }

	  var oppositePlacement = getOppositePlacement(placement);
	  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
	}

	function flip(_ref) {
	  var state = _ref.state,
	      options = _ref.options,
	      name = _ref.name;

	  if (state.modifiersData[name]._skip) {
	    return;
	  }

	  var _options$mainAxis = options.mainAxis,
	      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
	      _options$altAxis = options.altAxis,
	      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
	      specifiedFallbackPlacements = options.fallbackPlacements,
	      padding = options.padding,
	      boundary = options.boundary,
	      rootBoundary = options.rootBoundary,
	      altBoundary = options.altBoundary,
	      _options$flipVariatio = options.flipVariations,
	      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
	      allowedAutoPlacements = options.allowedAutoPlacements;
	  var preferredPlacement = state.options.placement;
	  var basePlacement = getBasePlacement$1(preferredPlacement);
	  var isBasePlacement = basePlacement === preferredPlacement;
	  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
	  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
	    return acc.concat(getBasePlacement$1(placement) === auto ? computeAutoPlacement(state, {
	      placement: placement,
	      boundary: boundary,
	      rootBoundary: rootBoundary,
	      padding: padding,
	      flipVariations: flipVariations,
	      allowedAutoPlacements: allowedAutoPlacements
	    }) : placement);
	  }, []);
	  var referenceRect = state.rects.reference;
	  var popperRect = state.rects.popper;
	  var checksMap = new Map();
	  var makeFallbackChecks = true;
	  var firstFittingPlacement = placements[0];

	  for (var i = 0; i < placements.length; i++) {
	    var placement = placements[i];

	    var _basePlacement = getBasePlacement$1(placement);

	    var isStartVariation = getVariation(placement) === start;
	    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
	    var len = isVertical ? 'width' : 'height';
	    var overflow = detectOverflow(state, {
	      placement: placement,
	      boundary: boundary,
	      rootBoundary: rootBoundary,
	      altBoundary: altBoundary,
	      padding: padding
	    });
	    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

	    if (referenceRect[len] > popperRect[len]) {
	      mainVariationSide = getOppositePlacement(mainVariationSide);
	    }

	    var altVariationSide = getOppositePlacement(mainVariationSide);
	    var checks = [];

	    if (checkMainAxis) {
	      checks.push(overflow[_basePlacement] <= 0);
	    }

	    if (checkAltAxis) {
	      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
	    }

	    if (checks.every(function (check) {
	      return check;
	    })) {
	      firstFittingPlacement = placement;
	      makeFallbackChecks = false;
	      break;
	    }

	    checksMap.set(placement, checks);
	  }

	  if (makeFallbackChecks) {
	    // `2` may be desired in some cases – research later
	    var numberOfChecks = flipVariations ? 3 : 1;

	    var _loop = function _loop(_i) {
	      var fittingPlacement = placements.find(function (placement) {
	        var checks = checksMap.get(placement);

	        if (checks) {
	          return checks.slice(0, _i).every(function (check) {
	            return check;
	          });
	        }
	      });

	      if (fittingPlacement) {
	        firstFittingPlacement = fittingPlacement;
	        return "break";
	      }
	    };

	    for (var _i = numberOfChecks; _i > 0; _i--) {
	      var _ret = _loop(_i);

	      if (_ret === "break") break;
	    }
	  }

	  if (state.placement !== firstFittingPlacement) {
	    state.modifiersData[name]._skip = true;
	    state.placement = firstFittingPlacement;
	    state.reset = true;
	  }
	} // eslint-disable-next-line import/no-unused-modules


	var flip$1 = {
	  name: 'flip',
	  enabled: true,
	  phase: 'main',
	  fn: flip,
	  requiresIfExists: ['offset'],
	  data: {
	    _skip: false
	  }
	};

	function getSideOffsets(overflow, rect, preventedOffsets) {
	  if (preventedOffsets === void 0) {
	    preventedOffsets = {
	      x: 0,
	      y: 0
	    };
	  }

	  return {
	    top: overflow.top - rect.height - preventedOffsets.y,
	    right: overflow.right - rect.width + preventedOffsets.x,
	    bottom: overflow.bottom - rect.height + preventedOffsets.y,
	    left: overflow.left - rect.width - preventedOffsets.x
	  };
	}

	function isAnySideFullyClipped(overflow) {
	  return [top, right, bottom, left].some(function (side) {
	    return overflow[side] >= 0;
	  });
	}

	function hide(_ref) {
	  var state = _ref.state,
	      name = _ref.name;
	  var referenceRect = state.rects.reference;
	  var popperRect = state.rects.popper;
	  var preventedOffsets = state.modifiersData.preventOverflow;
	  var referenceOverflow = detectOverflow(state, {
	    elementContext: 'reference'
	  });
	  var popperAltOverflow = detectOverflow(state, {
	    altBoundary: true
	  });
	  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
	  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
	  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
	  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
	  state.modifiersData[name] = {
	    referenceClippingOffsets: referenceClippingOffsets,
	    popperEscapeOffsets: popperEscapeOffsets,
	    isReferenceHidden: isReferenceHidden,
	    hasPopperEscaped: hasPopperEscaped
	  };
	  state.attributes.popper = Object.assign({}, state.attributes.popper, {
	    'data-popper-reference-hidden': isReferenceHidden,
	    'data-popper-escaped': hasPopperEscaped
	  });
	} // eslint-disable-next-line import/no-unused-modules


	var hide$1 = {
	  name: 'hide',
	  enabled: true,
	  phase: 'main',
	  requiresIfExists: ['preventOverflow'],
	  fn: hide
	};

	function distanceAndSkiddingToXY(placement, rects, offset) {
	  var basePlacement = getBasePlacement$1(placement);
	  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

	  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
	    placement: placement
	  })) : offset,
	      skidding = _ref[0],
	      distance = _ref[1];

	  skidding = skidding || 0;
	  distance = (distance || 0) * invertDistance;
	  return [left, right].indexOf(basePlacement) >= 0 ? {
	    x: distance,
	    y: skidding
	  } : {
	    x: skidding,
	    y: distance
	  };
	}

	function offset(_ref2) {
	  var state = _ref2.state,
	      options = _ref2.options,
	      name = _ref2.name;
	  var _options$offset = options.offset,
	      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
	  var data = placements.reduce(function (acc, placement) {
	    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
	    return acc;
	  }, {});
	  var _data$state$placement = data[state.placement],
	      x = _data$state$placement.x,
	      y = _data$state$placement.y;

	  if (state.modifiersData.popperOffsets != null) {
	    state.modifiersData.popperOffsets.x += x;
	    state.modifiersData.popperOffsets.y += y;
	  }

	  state.modifiersData[name] = data;
	} // eslint-disable-next-line import/no-unused-modules


	var offset$1 = {
	  name: 'offset',
	  enabled: true,
	  phase: 'main',
	  requires: ['popperOffsets'],
	  fn: offset
	};

	function popperOffsets(_ref) {
	  var state = _ref.state,
	      name = _ref.name;
	  // Offsets are the actual position the popper needs to have to be
	  // properly positioned near its reference element
	  // This is the most basic placement, and will be adjusted by
	  // the modifiers in the next step
	  state.modifiersData[name] = computeOffsets({
	    reference: state.rects.reference,
	    element: state.rects.popper,
	    strategy: 'absolute',
	    placement: state.placement
	  });
	} // eslint-disable-next-line import/no-unused-modules


	var popperOffsets$1 = {
	  name: 'popperOffsets',
	  enabled: true,
	  phase: 'read',
	  fn: popperOffsets,
	  data: {}
	};

	function getAltAxis(axis) {
	  return axis === 'x' ? 'y' : 'x';
	}

	function preventOverflow(_ref) {
	  var state = _ref.state,
	      options = _ref.options,
	      name = _ref.name;
	  var _options$mainAxis = options.mainAxis,
	      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
	      _options$altAxis = options.altAxis,
	      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
	      boundary = options.boundary,
	      rootBoundary = options.rootBoundary,
	      altBoundary = options.altBoundary,
	      padding = options.padding,
	      _options$tether = options.tether,
	      tether = _options$tether === void 0 ? true : _options$tether,
	      _options$tetherOffset = options.tetherOffset,
	      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
	  var overflow = detectOverflow(state, {
	    boundary: boundary,
	    rootBoundary: rootBoundary,
	    padding: padding,
	    altBoundary: altBoundary
	  });
	  var basePlacement = getBasePlacement$1(state.placement);
	  var variation = getVariation(state.placement);
	  var isBasePlacement = !variation;
	  var mainAxis = getMainAxisFromPlacement(basePlacement);
	  var altAxis = getAltAxis(mainAxis);
	  var popperOffsets = state.modifiersData.popperOffsets;
	  var referenceRect = state.rects.reference;
	  var popperRect = state.rects.popper;
	  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
	    placement: state.placement
	  })) : tetherOffset;
	  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
	    mainAxis: tetherOffsetValue,
	    altAxis: tetherOffsetValue
	  } : Object.assign({
	    mainAxis: 0,
	    altAxis: 0
	  }, tetherOffsetValue);
	  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
	  var data = {
	    x: 0,
	    y: 0
	  };

	  if (!popperOffsets) {
	    return;
	  }

	  if (checkMainAxis) {
	    var _offsetModifierState$;

	    var mainSide = mainAxis === 'y' ? top : left;
	    var altSide = mainAxis === 'y' ? bottom : right;
	    var len = mainAxis === 'y' ? 'height' : 'width';
	    var offset = popperOffsets[mainAxis];
	    var min$1 = offset + overflow[mainSide];
	    var max$1 = offset - overflow[altSide];
	    var additive = tether ? -popperRect[len] / 2 : 0;
	    var minLen = variation === start ? referenceRect[len] : popperRect[len];
	    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
	    // outside the reference bounds

	    var arrowElement = state.elements.arrow;
	    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
	      width: 0,
	      height: 0
	    };
	    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
	    var arrowPaddingMin = arrowPaddingObject[mainSide];
	    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
	    // to include its full size in the calculation. If the reference is small
	    // and near the edge of a boundary, the popper can overflow even if the
	    // reference is not overflowing as well (e.g. virtual elements with no
	    // width or height)

	    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
	    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
	    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
	    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
	    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
	    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
	    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
	    var tetherMax = offset + maxOffset - offsetModifierValue;
	    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
	    popperOffsets[mainAxis] = preventedOffset;
	    data[mainAxis] = preventedOffset - offset;
	  }

	  if (checkAltAxis) {
	    var _offsetModifierState$2;

	    var _mainSide = mainAxis === 'x' ? top : left;

	    var _altSide = mainAxis === 'x' ? bottom : right;

	    var _offset = popperOffsets[altAxis];

	    var _len = altAxis === 'y' ? 'height' : 'width';

	    var _min = _offset + overflow[_mainSide];

	    var _max = _offset - overflow[_altSide];

	    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

	    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

	    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

	    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

	    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

	    popperOffsets[altAxis] = _preventedOffset;
	    data[altAxis] = _preventedOffset - _offset;
	  }

	  state.modifiersData[name] = data;
	} // eslint-disable-next-line import/no-unused-modules


	var preventOverflow$1 = {
	  name: 'preventOverflow',
	  enabled: true,
	  phase: 'main',
	  fn: preventOverflow,
	  requiresIfExists: ['offset']
	};

	function getHTMLElementScroll(element) {
	  return {
	    scrollLeft: element.scrollLeft,
	    scrollTop: element.scrollTop
	  };
	}

	function getNodeScroll(node) {
	  if (node === getWindow(node) || !isHTMLElement(node)) {
	    return getWindowScroll(node);
	  } else {
	    return getHTMLElementScroll(node);
	  }
	}

	function isElementScaled(element) {
	  var rect = element.getBoundingClientRect();
	  var scaleX = round(rect.width) / element.offsetWidth || 1;
	  var scaleY = round(rect.height) / element.offsetHeight || 1;
	  return scaleX !== 1 || scaleY !== 1;
	} // Returns the composite rect of an element relative to its offsetParent.
	// Composite means it takes into account transforms as well as layout.


	function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
	  if (isFixed === void 0) {
	    isFixed = false;
	  }

	  var isOffsetParentAnElement = isHTMLElement(offsetParent);
	  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
	  var documentElement = getDocumentElement(offsetParent);
	  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
	  var scroll = {
	    scrollLeft: 0,
	    scrollTop: 0
	  };
	  var offsets = {
	    x: 0,
	    y: 0
	  };

	  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
	    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
	    isScrollParent(documentElement)) {
	      scroll = getNodeScroll(offsetParent);
	    }

	    if (isHTMLElement(offsetParent)) {
	      offsets = getBoundingClientRect(offsetParent, true);
	      offsets.x += offsetParent.clientLeft;
	      offsets.y += offsetParent.clientTop;
	    } else if (documentElement) {
	      offsets.x = getWindowScrollBarX(documentElement);
	    }
	  }

	  return {
	    x: rect.left + scroll.scrollLeft - offsets.x,
	    y: rect.top + scroll.scrollTop - offsets.y,
	    width: rect.width,
	    height: rect.height
	  };
	}

	function order(modifiers) {
	  var map = new Map();
	  var visited = new Set();
	  var result = [];
	  modifiers.forEach(function (modifier) {
	    map.set(modifier.name, modifier);
	  }); // On visiting object, check for its dependencies and visit them recursively

	  function sort(modifier) {
	    visited.add(modifier.name);
	    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
	    requires.forEach(function (dep) {
	      if (!visited.has(dep)) {
	        var depModifier = map.get(dep);

	        if (depModifier) {
	          sort(depModifier);
	        }
	      }
	    });
	    result.push(modifier);
	  }

	  modifiers.forEach(function (modifier) {
	    if (!visited.has(modifier.name)) {
	      // check for visited object
	      sort(modifier);
	    }
	  });
	  return result;
	}

	function orderModifiers(modifiers) {
	  // order based on dependencies
	  var orderedModifiers = order(modifiers); // order based on phase

	  return modifierPhases.reduce(function (acc, phase) {
	    return acc.concat(orderedModifiers.filter(function (modifier) {
	      return modifier.phase === phase;
	    }));
	  }, []);
	}

	function debounce$1(fn) {
	  var pending;
	  return function () {
	    if (!pending) {
	      pending = new Promise(function (resolve) {
	        Promise.resolve().then(function () {
	          pending = undefined;
	          resolve(fn());
	        });
	      });
	    }

	    return pending;
	  };
	}

	function mergeByName(modifiers) {
	  var merged = modifiers.reduce(function (merged, current) {
	    var existing = merged[current.name];
	    merged[current.name] = existing ? Object.assign({}, existing, current, {
	      options: Object.assign({}, existing.options, current.options),
	      data: Object.assign({}, existing.data, current.data)
	    }) : current;
	    return merged;
	  }, {}); // IE11 does not support Object.values

	  return Object.keys(merged).map(function (key) {
	    return merged[key];
	  });
	}

	var DEFAULT_OPTIONS = {
	  placement: 'bottom',
	  modifiers: [],
	  strategy: 'absolute'
	};

	function areValidElements() {
	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  return !args.some(function (element) {
	    return !(element && typeof element.getBoundingClientRect === 'function');
	  });
	}

	function popperGenerator(generatorOptions) {
	  if (generatorOptions === void 0) {
	    generatorOptions = {};
	  }

	  var _generatorOptions = generatorOptions,
	      _generatorOptions$def = _generatorOptions.defaultModifiers,
	      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
	      _generatorOptions$def2 = _generatorOptions.defaultOptions,
	      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
	  return function createPopper(reference, popper, options) {
	    if (options === void 0) {
	      options = defaultOptions;
	    }

	    var state = {
	      placement: 'bottom',
	      orderedModifiers: [],
	      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
	      modifiersData: {},
	      elements: {
	        reference: reference,
	        popper: popper
	      },
	      attributes: {},
	      styles: {}
	    };
	    var effectCleanupFns = [];
	    var isDestroyed = false;
	    var instance = {
	      state: state,
	      setOptions: function setOptions(setOptionsAction) {
	        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
	        cleanupModifierEffects();
	        state.options = Object.assign({}, defaultOptions, state.options, options);
	        state.scrollParents = {
	          reference: isElement$1(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
	          popper: listScrollParents(popper)
	        }; // Orders the modifiers based on their dependencies and `phase`
	        // properties

	        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

	        state.orderedModifiers = orderedModifiers.filter(function (m) {
	          return m.enabled;
	        });
	        runModifierEffects();
	        return instance.update();
	      },
	      // Sync update – it will always be executed, even if not necessary. This
	      // is useful for low frequency updates where sync behavior simplifies the
	      // logic.
	      // For high frequency updates (e.g. `resize` and `scroll` events), always
	      // prefer the async Popper#update method
	      forceUpdate: function forceUpdate() {
	        if (isDestroyed) {
	          return;
	        }

	        var _state$elements = state.elements,
	            reference = _state$elements.reference,
	            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
	        // anymore

	        if (!areValidElements(reference, popper)) {
	          return;
	        } // Store the reference and popper rects to be read by modifiers


	        state.rects = {
	          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
	          popper: getLayoutRect(popper)
	        }; // Modifiers have the ability to reset the current update cycle. The
	        // most common use case for this is the `flip` modifier changing the
	        // placement, which then needs to re-run all the modifiers, because the
	        // logic was previously ran for the previous placement and is therefore
	        // stale/incorrect

	        state.reset = false;
	        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
	        // is filled with the initial data specified by the modifier. This means
	        // it doesn't persist and is fresh on each update.
	        // To ensure persistent data, use `${name}#persistent`

	        state.orderedModifiers.forEach(function (modifier) {
	          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
	        });

	        for (var index = 0; index < state.orderedModifiers.length; index++) {
	          if (state.reset === true) {
	            state.reset = false;
	            index = -1;
	            continue;
	          }

	          var _state$orderedModifie = state.orderedModifiers[index],
	              fn = _state$orderedModifie.fn,
	              _state$orderedModifie2 = _state$orderedModifie.options,
	              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
	              name = _state$orderedModifie.name;

	          if (typeof fn === 'function') {
	            state = fn({
	              state: state,
	              options: _options,
	              name: name,
	              instance: instance
	            }) || state;
	          }
	        }
	      },
	      // Async and optimistically optimized update – it will not be executed if
	      // not necessary (debounced to run at most once-per-tick)
	      update: debounce$1(function () {
	        return new Promise(function (resolve) {
	          instance.forceUpdate();
	          resolve(state);
	        });
	      }),
	      destroy: function destroy() {
	        cleanupModifierEffects();
	        isDestroyed = true;
	      }
	    };

	    if (!areValidElements(reference, popper)) {
	      return instance;
	    }

	    instance.setOptions(options).then(function (state) {
	      if (!isDestroyed && options.onFirstUpdate) {
	        options.onFirstUpdate(state);
	      }
	    }); // Modifiers have the ability to execute arbitrary code before the first
	    // update cycle runs. They will be executed in the same order as the update
	    // cycle. This is useful when a modifier adds some persistent data that
	    // other modifiers need to use, but the modifier is run after the dependent
	    // one.

	    function runModifierEffects() {
	      state.orderedModifiers.forEach(function (_ref) {
	        var name = _ref.name,
	            _ref$options = _ref.options,
	            options = _ref$options === void 0 ? {} : _ref$options,
	            effect = _ref.effect;

	        if (typeof effect === 'function') {
	          var cleanupFn = effect({
	            state: state,
	            name: name,
	            instance: instance,
	            options: options
	          });

	          var noopFn = function noopFn() {};

	          effectCleanupFns.push(cleanupFn || noopFn);
	        }
	      });
	    }

	    function cleanupModifierEffects() {
	      effectCleanupFns.forEach(function (fn) {
	        return fn();
	      });
	      effectCleanupFns = [];
	    }

	    return instance;
	  };
	}

	var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
	var createPopper = /*#__PURE__*/popperGenerator({
	  defaultModifiers: defaultModifiers
	}); // eslint-disable-next-line import/no-unused-modules

	/**!
	* tippy.js v6.3.7
	* (c) 2017-2021 atomiks
	* MIT License
	*/
	var CONTENT_CLASS = "tippy-content";
	var BACKDROP_CLASS = "tippy-backdrop";
	var ARROW_CLASS = "tippy-arrow";
	var SVG_ARROW_CLASS = "tippy-svg-arrow";
	var TOUCH_OPTIONS = {
	  passive: true,
	  capture: true
	};
	var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {
	  return document.body;
	};

	function hasOwnProperty(obj, key) {
	  return {}.hasOwnProperty.call(obj, key);
	}
	function getValueAtIndexOrReturn(value, index, defaultValue) {
	  if (Array.isArray(value)) {
	    var v = value[index];
	    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
	  }

	  return value;
	}
	function isType(value, type) {
	  var str = {}.toString.call(value);
	  return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
	}
	function invokeWithArgsOrReturn(value, args) {
	  return typeof value === 'function' ? value.apply(void 0, args) : value;
	}
	function debounce(fn, ms) {
	  // Avoid wrapping in `setTimeout` if ms is 0 anyway
	  if (ms === 0) {
	    return fn;
	  }

	  var timeout;
	  return function (arg) {
	    clearTimeout(timeout);
	    timeout = setTimeout(function () {
	      fn(arg);
	    }, ms);
	  };
	}
	function removeProperties(obj, keys) {
	  var clone = Object.assign({}, obj);
	  keys.forEach(function (key) {
	    delete clone[key];
	  });
	  return clone;
	}
	function splitBySpaces(value) {
	  return value.split(/\s+/).filter(Boolean);
	}
	function normalizeToArray(value) {
	  return [].concat(value);
	}
	function pushIfUnique(arr, value) {
	  if (arr.indexOf(value) === -1) {
	    arr.push(value);
	  }
	}
	function unique(arr) {
	  return arr.filter(function (item, index) {
	    return arr.indexOf(item) === index;
	  });
	}
	function getBasePlacement(placement) {
	  return placement.split('-')[0];
	}
	function arrayFrom(value) {
	  return [].slice.call(value);
	}
	function removeUndefinedProps(obj) {
	  return Object.keys(obj).reduce(function (acc, key) {
	    if (obj[key] !== undefined) {
	      acc[key] = obj[key];
	    }

	    return acc;
	  }, {});
	}

	function div() {
	  return document.createElement('div');
	}
	function isElement(value) {
	  return ['Element', 'Fragment'].some(function (type) {
	    return isType(value, type);
	  });
	}
	function isNodeList(value) {
	  return isType(value, 'NodeList');
	}
	function isMouseEvent(value) {
	  return isType(value, 'MouseEvent');
	}
	function isReferenceElement(value) {
	  return !!(value && value._tippy && value._tippy.reference === value);
	}
	function getArrayOfElements(value) {
	  if (isElement(value)) {
	    return [value];
	  }

	  if (isNodeList(value)) {
	    return arrayFrom(value);
	  }

	  if (Array.isArray(value)) {
	    return value;
	  }

	  return arrayFrom(document.querySelectorAll(value));
	}
	function setTransitionDuration(els, value) {
	  els.forEach(function (el) {
	    if (el) {
	      el.style.transitionDuration = value + "ms";
	    }
	  });
	}
	function setVisibilityState(els, state) {
	  els.forEach(function (el) {
	    if (el) {
	      el.setAttribute('data-state', state);
	    }
	  });
	}
	function getOwnerDocument(elementOrElements) {
	  var _element$ownerDocumen;

	  var _normalizeToArray = normalizeToArray(elementOrElements),
	      element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body


	  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
	}
	function isCursorOutsideInteractiveBorder(popperTreeData, event) {
	  var clientX = event.clientX,
	      clientY = event.clientY;
	  return popperTreeData.every(function (_ref) {
	    var popperRect = _ref.popperRect,
	        popperState = _ref.popperState,
	        props = _ref.props;
	    var interactiveBorder = props.interactiveBorder;
	    var basePlacement = getBasePlacement(popperState.placement);
	    var offsetData = popperState.modifiersData.offset;

	    if (!offsetData) {
	      return true;
	    }

	    var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
	    var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
	    var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
	    var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
	    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
	    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
	    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
	    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
	    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
	  });
	}
	function updateTransitionEndListener(box, action, listener) {
	  var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
	  // `webkitTransitionEnd`...

	  ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
	    box[method](event, listener);
	  });
	}
	/**
	 * Compared to xxx.contains, this function works for dom structures with shadow
	 * dom
	 */

	function actualContains(parent, child) {
	  var target = child;

	  while (target) {
	    var _target$getRootNode;

	    if (parent.contains(target)) {
	      return true;
	    }

	    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
	  }

	  return false;
	}

	var currentInput = {
	  isTouch: false
	};
	var lastMouseMoveTime = 0;
	/**
	 * When a `touchstart` event is fired, it's assumed the user is using touch
	 * input. We'll bind a `mousemove` event listener to listen for mouse input in
	 * the future. This way, the `isTouch` property is fully dynamic and will handle
	 * hybrid devices that use a mix of touch + mouse input.
	 */

	function onDocumentTouchStart() {
	  if (currentInput.isTouch) {
	    return;
	  }

	  currentInput.isTouch = true;

	  if (window.performance) {
	    document.addEventListener('mousemove', onDocumentMouseMove);
	  }
	}
	/**
	 * When two `mousemove` event are fired consecutively within 20ms, it's assumed
	 * the user is using mouse input again. `mousemove` can fire on touch devices as
	 * well, but very rarely that quickly.
	 */

	function onDocumentMouseMove() {
	  var now = performance.now();

	  if (now - lastMouseMoveTime < 20) {
	    currentInput.isTouch = false;
	    document.removeEventListener('mousemove', onDocumentMouseMove);
	  }

	  lastMouseMoveTime = now;
	}
	/**
	 * When an element is in focus and has a tippy, leaving the tab/window and
	 * returning causes it to show again. For mouse users this is unexpected, but
	 * for keyboard use it makes sense.
	 * TODO: find a better technique to solve this problem
	 */

	function onWindowBlur() {
	  var activeElement = document.activeElement;

	  if (isReferenceElement(activeElement)) {
	    var instance = activeElement._tippy;

	    if (activeElement.blur && !instance.state.isVisible) {
	      activeElement.blur();
	    }
	  }
	}
	function bindGlobalEventListeners() {
	  document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
	  window.addEventListener('blur', onWindowBlur);
	}

	var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
	var isIE11 = isBrowser ? // @ts-ignore
	!!window.msCrypto : false;

	function createMemoryLeakWarning(method) {
	  var txt = method === 'destroy' ? 'n already-' : ' ';
	  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", 'indicates a potential memory leak.'].join(' ');
	}
	function clean(value) {
	  var spacesAndTabs = /[ \t]{2,}/g;
	  var lineStartWithSpaces = /^[ \t]*/gm;
	  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
	}

	function getDevMessage(message) {
	  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\uD83D\uDC77\u200D This is a development-only message. It will be removed in production.\n  ");
	}

	function getFormattedMessage(message) {
	  return [getDevMessage(message), // title
	  'color: #00C584; font-size: 1.3em; font-weight: bold;', // message
	  'line-height: 1.5', // footer
	  'color: #a6a095;'];
	} // Assume warnings and errors never have the same message

	var visitedMessages;

	{
	  resetVisitedMessages();
	}

	function resetVisitedMessages() {
	  visitedMessages = new Set();
	}
	function warnWhen(condition, message) {
	  if (condition && !visitedMessages.has(message)) {
	    var _console;

	    visitedMessages.add(message);

	    (_console = console).warn.apply(_console, getFormattedMessage(message));
	  }
	}
	function errorWhen(condition, message) {
	  if (condition && !visitedMessages.has(message)) {
	    var _console2;

	    visitedMessages.add(message);

	    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
	  }
	}
	function validateTargets(targets) {
	  var didPassFalsyValue = !targets;
	  var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;
	  errorWhen(didPassFalsyValue, ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element,', 'Element[], or NodeList.'].join(' '));
	  errorWhen(didPassPlainObject, ['tippy() was passed a plain object which is not supported as an argument', 'for virtual positioning. Use props.getReferenceClientRect instead.'].join(' '));
	}

	var pluginProps = {
	  animateFill: false,
	  followCursor: false,
	  inlinePositioning: false,
	  sticky: false
	};
	var renderProps = {
	  allowHTML: false,
	  animation: 'fade',
	  arrow: true,
	  content: '',
	  inertia: false,
	  maxWidth: 350,
	  role: 'tooltip',
	  theme: '',
	  zIndex: 9999
	};
	var defaultProps = Object.assign({
	  appendTo: TIPPY_DEFAULT_APPEND_TO,
	  aria: {
	    content: 'auto',
	    expanded: 'auto'
	  },
	  delay: 0,
	  duration: [300, 250],
	  getReferenceClientRect: null,
	  hideOnClick: true,
	  ignoreAttributes: false,
	  interactive: false,
	  interactiveBorder: 2,
	  interactiveDebounce: 0,
	  moveTransition: '',
	  offset: [0, 10],
	  onAfterUpdate: function onAfterUpdate() {},
	  onBeforeUpdate: function onBeforeUpdate() {},
	  onCreate: function onCreate() {},
	  onDestroy: function onDestroy() {},
	  onHidden: function onHidden() {},
	  onHide: function onHide() {},
	  onMount: function onMount() {},
	  onShow: function onShow() {},
	  onShown: function onShown() {},
	  onTrigger: function onTrigger() {},
	  onUntrigger: function onUntrigger() {},
	  onClickOutside: function onClickOutside() {},
	  placement: 'top',
	  plugins: [],
	  popperOptions: {},
	  render: null,
	  showOnCreate: false,
	  touch: true,
	  trigger: 'mouseenter focus',
	  triggerTarget: null
	}, pluginProps, renderProps);
	var defaultKeys = Object.keys(defaultProps);
	var setDefaultProps = function setDefaultProps(partialProps) {
	  /* istanbul ignore else */
	  {
	    validateProps(partialProps, []);
	  }

	  var keys = Object.keys(partialProps);
	  keys.forEach(function (key) {
	    defaultProps[key] = partialProps[key];
	  });
	};
	function getExtendedPassedProps(passedProps) {
	  var plugins = passedProps.plugins || [];
	  var pluginProps = plugins.reduce(function (acc, plugin) {
	    var name = plugin.name,
	        defaultValue = plugin.defaultValue;

	    if (name) {
	      var _name;

	      acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
	    }

	    return acc;
	  }, {});
	  return Object.assign({}, passedProps, pluginProps);
	}
	function getDataAttributeProps(reference, plugins) {
	  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
	    plugins: plugins
	  }))) : defaultKeys;
	  var props = propKeys.reduce(function (acc, key) {
	    var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

	    if (!valueAsString) {
	      return acc;
	    }

	    if (key === 'content') {
	      acc[key] = valueAsString;
	    } else {
	      try {
	        acc[key] = JSON.parse(valueAsString);
	      } catch (e) {
	        acc[key] = valueAsString;
	      }
	    }

	    return acc;
	  }, {});
	  return props;
	}
	function evaluateProps(reference, props) {
	  var out = Object.assign({}, props, {
	    content: invokeWithArgsOrReturn(props.content, [reference])
	  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
	  out.aria = Object.assign({}, defaultProps.aria, out.aria);
	  out.aria = {
	    expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
	    content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
	  };
	  return out;
	}
	function validateProps(partialProps, plugins) {
	  if (partialProps === void 0) {
	    partialProps = {};
	  }

	  if (plugins === void 0) {
	    plugins = [];
	  }

	  var keys = Object.keys(partialProps);
	  keys.forEach(function (prop) {
	    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
	    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`

	    if (didPassUnknownProp) {
	      didPassUnknownProp = plugins.filter(function (plugin) {
	        return plugin.name === prop;
	      }).length === 0;
	    }

	    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", 'a plugin, forgot to pass it in an array as props.plugins.', '\n\n', 'All props: https://atomiks.github.io/tippyjs/v6/all-props/\n', 'Plugins: https://atomiks.github.io/tippyjs/v6/plugins/'].join(' '));
	  });
	}

	function getChildren(popper) {
	  var box = popper.firstElementChild;
	  var boxChildren = arrayFrom(box.children);
	  return {
	    box: box,
	    content: boxChildren.find(function (node) {
	      return node.classList.contains(CONTENT_CLASS);
	    }),
	    arrow: boxChildren.find(function (node) {
	      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
	    }),
	    backdrop: boxChildren.find(function (node) {
	      return node.classList.contains(BACKDROP_CLASS);
	    })
	  };
	}

	var idCounter = 1;
	var mouseMoveListeners = []; // Used by `hideAll()`

	var mountedInstances = [];
	function createTippy(reference, passedProps) {
	  var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
	  // 🔒 Private members
	  // ===========================================================================

	  var showTimeout;
	  var hideTimeout;
	  var scheduleHideAnimationFrame;
	  var isVisibleFromClick = false;
	  var didHideDueToDocumentMouseDown = false;
	  var didTouchMove = false;
	  var ignoreOnFirstUpdate = false;
	  var lastTriggerEvent;
	  var currentTransitionEndListener;
	  var onFirstUpdate;
	  var listeners = [];
	  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
	  var currentTarget; // ===========================================================================
	  // 🔑 Public members
	  // ===========================================================================

	  var id = idCounter++;
	  var popperInstance = null;
	  var plugins = unique(props.plugins);
	  var state = {
	    // Is the instance currently enabled?
	    isEnabled: true,
	    // Is the tippy currently showing and not transitioning out?
	    isVisible: false,
	    // Has the instance been destroyed?
	    isDestroyed: false,
	    // Is the tippy currently mounted to the DOM?
	    isMounted: false,
	    // Has the tippy finished transitioning in?
	    isShown: false
	  };
	  var instance = {
	    // properties
	    id: id,
	    reference: reference,
	    popper: div(),
	    popperInstance: popperInstance,
	    props: props,
	    state: state,
	    plugins: plugins,
	    // methods
	    clearDelayTimeouts: clearDelayTimeouts,
	    setProps: setProps,
	    setContent: setContent,
	    show: show,
	    hide: hide,
	    hideWithInteractivity: hideWithInteractivity,
	    enable: enable,
	    disable: disable,
	    unmount: unmount,
	    destroy: destroy
	  }; // TODO: Investigate why this early return causes a TDZ error in the tests —
	  // it doesn't seem to happen in the browser

	  /* istanbul ignore if */

	  if (!props.render) {
	    {
	      errorWhen(true, 'render() function has not been supplied.');
	    }

	    return instance;
	  } // ===========================================================================
	  // Initial mutations
	  // ===========================================================================


	  var _props$render = props.render(instance),
	      popper = _props$render.popper,
	      onUpdate = _props$render.onUpdate;

	  popper.setAttribute('data-tippy-root', '');
	  popper.id = "tippy-" + instance.id;
	  instance.popper = popper;
	  reference._tippy = instance;
	  popper._tippy = instance;
	  var pluginsHooks = plugins.map(function (plugin) {
	    return plugin.fn(instance);
	  });
	  var hasAriaExpanded = reference.hasAttribute('aria-expanded');
	  addListeners();
	  handleAriaExpandedAttribute();
	  handleStyles();
	  invokeHook('onCreate', [instance]);

	  if (props.showOnCreate) {
	    scheduleShow();
	  } // Prevent a tippy with a delay from hiding if the cursor left then returned
	  // before it started hiding


	  popper.addEventListener('mouseenter', function () {
	    if (instance.props.interactive && instance.state.isVisible) {
	      instance.clearDelayTimeouts();
	    }
	  });
	  popper.addEventListener('mouseleave', function () {
	    if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
	      getDocument().addEventListener('mousemove', debouncedOnMouseMove);
	    }
	  });
	  return instance; // ===========================================================================
	  // 🔒 Private methods
	  // ===========================================================================

	  function getNormalizedTouchSettings() {
	    var touch = instance.props.touch;
	    return Array.isArray(touch) ? touch : [touch, 0];
	  }

	  function getIsCustomTouchBehavior() {
	    return getNormalizedTouchSettings()[0] === 'hold';
	  }

	  function getIsDefaultRenderFn() {
	    var _instance$props$rende;

	    // @ts-ignore
	    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
	  }

	  function getCurrentTarget() {
	    return currentTarget || reference;
	  }

	  function getDocument() {
	    var parent = getCurrentTarget().parentNode;
	    return parent ? getOwnerDocument(parent) : document;
	  }

	  function getDefaultTemplateChildren() {
	    return getChildren(popper);
	  }

	  function getDelay(isShow) {
	    // For touch or keyboard input, force `0` delay for UX reasons
	    // Also if the instance is mounted but not visible (transitioning out),
	    // ignore delay
	    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
	      return 0;
	    }

	    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
	  }

	  function handleStyles(fromHide) {
	    if (fromHide === void 0) {
	      fromHide = false;
	    }

	    popper.style.pointerEvents = instance.props.interactive && !fromHide ? '' : 'none';
	    popper.style.zIndex = "" + instance.props.zIndex;
	  }

	  function invokeHook(hook, args, shouldInvokePropsHook) {
	    if (shouldInvokePropsHook === void 0) {
	      shouldInvokePropsHook = true;
	    }

	    pluginsHooks.forEach(function (pluginHooks) {
	      if (pluginHooks[hook]) {
	        pluginHooks[hook].apply(pluginHooks, args);
	      }
	    });

	    if (shouldInvokePropsHook) {
	      var _instance$props;

	      (_instance$props = instance.props)[hook].apply(_instance$props, args);
	    }
	  }

	  function handleAriaContentAttribute() {
	    var aria = instance.props.aria;

	    if (!aria.content) {
	      return;
	    }

	    var attr = "aria-" + aria.content;
	    var id = popper.id;
	    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
	    nodes.forEach(function (node) {
	      var currentValue = node.getAttribute(attr);

	      if (instance.state.isVisible) {
	        node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
	      } else {
	        var nextValue = currentValue && currentValue.replace(id, '').trim();

	        if (nextValue) {
	          node.setAttribute(attr, nextValue);
	        } else {
	          node.removeAttribute(attr);
	        }
	      }
	    });
	  }

	  function handleAriaExpandedAttribute() {
	    if (hasAriaExpanded || !instance.props.aria.expanded) {
	      return;
	    }

	    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
	    nodes.forEach(function (node) {
	      if (instance.props.interactive) {
	        node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
	      } else {
	        node.removeAttribute('aria-expanded');
	      }
	    });
	  }

	  function cleanupInteractiveMouseListeners() {
	    getDocument().removeEventListener('mousemove', debouncedOnMouseMove);
	    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
	      return listener !== debouncedOnMouseMove;
	    });
	  }

	  function onDocumentPress(event) {
	    // Moved finger to scroll instead of an intentional tap outside
	    if (currentInput.isTouch) {
	      if (didTouchMove || event.type === 'mousedown') {
	        return;
	      }
	    }

	    var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper

	    if (instance.props.interactive && actualContains(popper, actualTarget)) {
	      return;
	    } // Clicked on the event listeners target


	    if (normalizeToArray(instance.props.triggerTarget || reference).some(function (el) {
	      return actualContains(el, actualTarget);
	    })) {
	      if (currentInput.isTouch) {
	        return;
	      }

	      if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
	        return;
	      }
	    } else {
	      invokeHook('onClickOutside', [instance, event]);
	    }

	    if (instance.props.hideOnClick === true) {
	      instance.clearDelayTimeouts();
	      instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
	      // currentTarget. This lets a tippy with `focus` trigger know that it
	      // should not show

	      didHideDueToDocumentMouseDown = true;
	      setTimeout(function () {
	        didHideDueToDocumentMouseDown = false;
	      }); // The listener gets added in `scheduleShow()`, but this may be hiding it
	      // before it shows, and hide()'s early bail-out behavior can prevent it
	      // from being cleaned up

	      if (!instance.state.isMounted) {
	        removeDocumentPress();
	      }
	    }
	  }

	  function onTouchMove() {
	    didTouchMove = true;
	  }

	  function onTouchStart() {
	    didTouchMove = false;
	  }

	  function addDocumentPress() {
	    var doc = getDocument();
	    doc.addEventListener('mousedown', onDocumentPress, true);
	    doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
	    doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
	    doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
	  }

	  function removeDocumentPress() {
	    var doc = getDocument();
	    doc.removeEventListener('mousedown', onDocumentPress, true);
	    doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
	    doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
	    doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
	  }

	  function onTransitionedOut(duration, callback) {
	    onTransitionEnd(duration, function () {
	      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
	        callback();
	      }
	    });
	  }

	  function onTransitionedIn(duration, callback) {
	    onTransitionEnd(duration, callback);
	  }

	  function onTransitionEnd(duration, callback) {
	    var box = getDefaultTemplateChildren().box;

	    function listener(event) {
	      if (event.target === box) {
	        updateTransitionEndListener(box, 'remove', listener);
	        callback();
	      }
	    } // Make callback synchronous if duration is 0
	    // `transitionend` won't fire otherwise


	    if (duration === 0) {
	      return callback();
	    }

	    updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
	    updateTransitionEndListener(box, 'add', listener);
	    currentTransitionEndListener = listener;
	  }

	  function on(eventType, handler, options) {
	    if (options === void 0) {
	      options = false;
	    }

	    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
	    nodes.forEach(function (node) {
	      node.addEventListener(eventType, handler, options);
	      listeners.push({
	        node: node,
	        eventType: eventType,
	        handler: handler,
	        options: options
	      });
	    });
	  }

	  function addListeners() {
	    if (getIsCustomTouchBehavior()) {
	      on('touchstart', onTrigger, {
	        passive: true
	      });
	      on('touchend', onMouseLeave, {
	        passive: true
	      });
	    }

	    splitBySpaces(instance.props.trigger).forEach(function (eventType) {
	      if (eventType === 'manual') {
	        return;
	      }

	      on(eventType, onTrigger);

	      switch (eventType) {
	        case 'mouseenter':
	          on('mouseleave', onMouseLeave);
	          break;

	        case 'focus':
	          on(isIE11 ? 'focusout' : 'blur', onBlurOrFocusOut);
	          break;

	        case 'focusin':
	          on('focusout', onBlurOrFocusOut);
	          break;
	      }
	    });
	  }

	  function removeListeners() {
	    listeners.forEach(function (_ref) {
	      var node = _ref.node,
	          eventType = _ref.eventType,
	          handler = _ref.handler,
	          options = _ref.options;
	      node.removeEventListener(eventType, handler, options);
	    });
	    listeners = [];
	  }

	  function onTrigger(event) {
	    var _lastTriggerEvent;

	    var shouldScheduleClickHide = false;

	    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
	      return;
	    }

	    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
	    lastTriggerEvent = event;
	    currentTarget = event.currentTarget;
	    handleAriaExpandedAttribute();

	    if (!instance.state.isVisible && isMouseEvent(event)) {
	      // If scrolling, `mouseenter` events can be fired if the cursor lands
	      // over a new target, but `mousemove` events don't get fired. This
	      // causes interactive tooltips to get stuck open until the cursor is
	      // moved
	      mouseMoveListeners.forEach(function (listener) {
	        return listener(event);
	      });
	    } // Toggle show/hide when clicking click-triggered tooltips


	    if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
	      shouldScheduleClickHide = true;
	    } else {
	      scheduleShow(event);
	    }

	    if (event.type === 'click') {
	      isVisibleFromClick = !shouldScheduleClickHide;
	    }

	    if (shouldScheduleClickHide && !wasFocused) {
	      scheduleHide(event);
	    }
	  }

	  function onMouseMove(event) {
	    var target = event.target;
	    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);

	    if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
	      return;
	    }

	    var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
	      var _instance$popperInsta;

	      var instance = popper._tippy;
	      var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

	      if (state) {
	        return {
	          popperRect: popper.getBoundingClientRect(),
	          popperState: state,
	          props: props
	        };
	      }

	      return null;
	    }).filter(Boolean);

	    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
	      cleanupInteractiveMouseListeners();
	      scheduleHide(event);
	    }
	  }

	  function onMouseLeave(event) {
	    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;

	    if (shouldBail) {
	      return;
	    }

	    if (instance.props.interactive) {
	      instance.hideWithInteractivity(event);
	      return;
	    }

	    scheduleHide(event);
	  }

	  function onBlurOrFocusOut(event) {
	    if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
	      return;
	    } // If focus was moved to within the popper


	    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
	      return;
	    }

	    scheduleHide(event);
	  }

	  function isEventListenerStopped(event) {
	    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
	  }

	  function createPopperInstance() {
	    destroyPopperInstance();
	    var _instance$props2 = instance.props,
	        popperOptions = _instance$props2.popperOptions,
	        placement = _instance$props2.placement,
	        offset = _instance$props2.offset,
	        getReferenceClientRect = _instance$props2.getReferenceClientRect,
	        moveTransition = _instance$props2.moveTransition;
	    var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
	    var computedReference = getReferenceClientRect ? {
	      getBoundingClientRect: getReferenceClientRect,
	      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
	    } : reference;
	    var tippyModifier = {
	      name: '$$tippy',
	      enabled: true,
	      phase: 'beforeWrite',
	      requires: ['computeStyles'],
	      fn: function fn(_ref2) {
	        var state = _ref2.state;

	        if (getIsDefaultRenderFn()) {
	          var _getDefaultTemplateCh = getDefaultTemplateChildren(),
	              box = _getDefaultTemplateCh.box;

	          ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
	            if (attr === 'placement') {
	              box.setAttribute('data-placement', state.placement);
	            } else {
	              if (state.attributes.popper["data-popper-" + attr]) {
	                box.setAttribute("data-" + attr, '');
	              } else {
	                box.removeAttribute("data-" + attr);
	              }
	            }
	          });
	          state.attributes.popper = {};
	        }
	      }
	    };
	    var modifiers = [{
	      name: 'offset',
	      options: {
	        offset: offset
	      }
	    }, {
	      name: 'preventOverflow',
	      options: {
	        padding: {
	          top: 2,
	          bottom: 2,
	          left: 5,
	          right: 5
	        }
	      }
	    }, {
	      name: 'flip',
	      options: {
	        padding: 5
	      }
	    }, {
	      name: 'computeStyles',
	      options: {
	        adaptive: !moveTransition
	      }
	    }, tippyModifier];

	    if (getIsDefaultRenderFn() && arrow) {
	      modifiers.push({
	        name: 'arrow',
	        options: {
	          element: arrow,
	          padding: 3
	        }
	      });
	    }

	    modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
	    instance.popperInstance = createPopper(computedReference, popper, Object.assign({}, popperOptions, {
	      placement: placement,
	      onFirstUpdate: onFirstUpdate,
	      modifiers: modifiers
	    }));
	  }

	  function destroyPopperInstance() {
	    if (instance.popperInstance) {
	      instance.popperInstance.destroy();
	      instance.popperInstance = null;
	    }
	  }

	  function mount() {
	    var appendTo = instance.props.appendTo;
	    var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
	    // it's directly after the reference element so the elements inside the
	    // tippy can be tabbed to
	    // If there are clipping issues, the user can specify a different appendTo
	    // and ensure focus management is handled correctly manually

	    var node = getCurrentTarget();

	    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === 'parent') {
	      parentNode = node.parentNode;
	    } else {
	      parentNode = invokeWithArgsOrReturn(appendTo, [node]);
	    } // The popper element needs to exist on the DOM before its position can be
	    // updated as Popper needs to read its dimensions


	    if (!parentNode.contains(popper)) {
	      parentNode.appendChild(popper);
	    }

	    instance.state.isMounted = true;
	    createPopperInstance();
	    /* istanbul ignore else */

	    {
	      // Accessibility check
	      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ['Interactive tippy element may not be accessible via keyboard', 'navigation because it is not directly after the reference element', 'in the DOM source order.', '\n\n', 'Using a wrapper <div> or <span> tag around the reference element', 'solves this by creating a new parentNode context.', '\n\n', 'Specifying `appendTo: document.body` silences this warning, but it', 'assumes you are using a focus management solution to handle', 'keyboard navigation.', '\n\n', 'See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity'].join(' '));
	    }
	  }

	  function getNestedPopperTree() {
	    return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
	  }

	  function scheduleShow(event) {
	    instance.clearDelayTimeouts();

	    if (event) {
	      invokeHook('onTrigger', [instance, event]);
	    }

	    addDocumentPress();
	    var delay = getDelay(true);

	    var _getNormalizedTouchSe = getNormalizedTouchSettings(),
	        touchValue = _getNormalizedTouchSe[0],
	        touchDelay = _getNormalizedTouchSe[1];

	    if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
	      delay = touchDelay;
	    }

	    if (delay) {
	      showTimeout = setTimeout(function () {
	        instance.show();
	      }, delay);
	    } else {
	      instance.show();
	    }
	  }

	  function scheduleHide(event) {
	    instance.clearDelayTimeouts();
	    invokeHook('onUntrigger', [instance, event]);

	    if (!instance.state.isVisible) {
	      removeDocumentPress();
	      return;
	    } // For interactive tippies, scheduleHide is added to a document.body handler
	    // from onMouseLeave so must intercept scheduled hides from mousemove/leave
	    // events when trigger contains mouseenter and click, and the tip is
	    // currently shown as a result of a click.


	    if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
	      return;
	    }

	    var delay = getDelay(false);

	    if (delay) {
	      hideTimeout = setTimeout(function () {
	        if (instance.state.isVisible) {
	          instance.hide();
	        }
	      }, delay);
	    } else {
	      // Fixes a `transitionend` problem when it fires 1 frame too
	      // late sometimes, we don't want hide() to be called.
	      scheduleHideAnimationFrame = requestAnimationFrame(function () {
	        instance.hide();
	      });
	    }
	  } // ===========================================================================
	  // 🔑 Public methods
	  // ===========================================================================


	  function enable() {
	    instance.state.isEnabled = true;
	  }

	  function disable() {
	    // Disabling the instance should also hide it
	    // https://github.com/atomiks/tippy.js-react/issues/106
	    instance.hide();
	    instance.state.isEnabled = false;
	  }

	  function clearDelayTimeouts() {
	    clearTimeout(showTimeout);
	    clearTimeout(hideTimeout);
	    cancelAnimationFrame(scheduleHideAnimationFrame);
	  }

	  function setProps(partialProps) {
	    /* istanbul ignore else */
	    {
	      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));
	    }

	    if (instance.state.isDestroyed) {
	      return;
	    }

	    invokeHook('onBeforeUpdate', [instance, partialProps]);
	    removeListeners();
	    var prevProps = instance.props;
	    var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
	      ignoreAttributes: true
	    }));
	    instance.props = nextProps;
	    addListeners();

	    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
	      cleanupInteractiveMouseListeners();
	      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
	    } // Ensure stale aria-expanded attributes are removed


	    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
	      normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
	        node.removeAttribute('aria-expanded');
	      });
	    } else if (nextProps.triggerTarget) {
	      reference.removeAttribute('aria-expanded');
	    }

	    handleAriaExpandedAttribute();
	    handleStyles();

	    if (onUpdate) {
	      onUpdate(prevProps, nextProps);
	    }

	    if (instance.popperInstance) {
	      createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
	      // and the nested ones get re-rendered first.
	      // https://github.com/atomiks/tippyjs-react/issues/177
	      // TODO: find a cleaner / more efficient solution(!)

	      getNestedPopperTree().forEach(function (nestedPopper) {
	        // React (and other UI libs likely) requires a rAF wrapper as it flushes
	        // its work in one
	        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
	      });
	    }

	    invokeHook('onAfterUpdate', [instance, partialProps]);
	  }

	  function setContent(content) {
	    instance.setProps({
	      content: content
	    });
	  }

	  function show() {
	    /* istanbul ignore else */
	    {
	      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));
	    } // Early bail-out


	    var isAlreadyVisible = instance.state.isVisible;
	    var isDestroyed = instance.state.isDestroyed;
	    var isDisabled = !instance.state.isEnabled;
	    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
	    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

	    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
	      return;
	    } // Normalize `disabled` behavior across browsers.
	    // Firefox allows events on disabled elements, but Chrome doesn't.
	    // Using a wrapper element (i.e. <span>) is recommended.


	    if (getCurrentTarget().hasAttribute('disabled')) {
	      return;
	    }

	    invokeHook('onShow', [instance], false);

	    if (instance.props.onShow(instance) === false) {
	      return;
	    }

	    instance.state.isVisible = true;

	    if (getIsDefaultRenderFn()) {
	      popper.style.visibility = 'visible';
	    }

	    handleStyles();
	    addDocumentPress();

	    if (!instance.state.isMounted) {
	      popper.style.transition = 'none';
	    } // If flipping to the opposite side after hiding at least once, the
	    // animation will use the wrong placement without resetting the duration


	    if (getIsDefaultRenderFn()) {
	      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
	          box = _getDefaultTemplateCh2.box,
	          content = _getDefaultTemplateCh2.content;

	      setTransitionDuration([box, content], 0);
	    }

	    onFirstUpdate = function onFirstUpdate() {
	      var _instance$popperInsta2;

	      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
	        return;
	      }

	      ignoreOnFirstUpdate = true; // reflow

	      void popper.offsetHeight;
	      popper.style.transition = instance.props.moveTransition;

	      if (getIsDefaultRenderFn() && instance.props.animation) {
	        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
	            _box = _getDefaultTemplateCh3.box,
	            _content = _getDefaultTemplateCh3.content;

	        setTransitionDuration([_box, _content], duration);
	        setVisibilityState([_box, _content], 'visible');
	      }

	      handleAriaContentAttribute();
	      handleAriaExpandedAttribute();
	      pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the
	      // popper has been positioned for the first time

	      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
	      invokeHook('onMount', [instance]);

	      if (instance.props.animation && getIsDefaultRenderFn()) {
	        onTransitionedIn(duration, function () {
	          instance.state.isShown = true;
	          invokeHook('onShown', [instance]);
	        });
	      }
	    };

	    mount();
	  }

	  function hide() {
	    /* istanbul ignore else */
	    {
	      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));
	    } // Early bail-out


	    var isAlreadyHidden = !instance.state.isVisible;
	    var isDestroyed = instance.state.isDestroyed;
	    var isDisabled = !instance.state.isEnabled;
	    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

	    if (isAlreadyHidden || isDestroyed || isDisabled) {
	      return;
	    }

	    invokeHook('onHide', [instance], false);

	    if (instance.props.onHide(instance) === false) {
	      return;
	    }

	    instance.state.isVisible = false;
	    instance.state.isShown = false;
	    ignoreOnFirstUpdate = false;
	    isVisibleFromClick = false;

	    if (getIsDefaultRenderFn()) {
	      popper.style.visibility = 'hidden';
	    }

	    cleanupInteractiveMouseListeners();
	    removeDocumentPress();
	    handleStyles(true);

	    if (getIsDefaultRenderFn()) {
	      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
	          box = _getDefaultTemplateCh4.box,
	          content = _getDefaultTemplateCh4.content;

	      if (instance.props.animation) {
	        setTransitionDuration([box, content], duration);
	        setVisibilityState([box, content], 'hidden');
	      }
	    }

	    handleAriaContentAttribute();
	    handleAriaExpandedAttribute();

	    if (instance.props.animation) {
	      if (getIsDefaultRenderFn()) {
	        onTransitionedOut(duration, instance.unmount);
	      }
	    } else {
	      instance.unmount();
	    }
	  }

	  function hideWithInteractivity(event) {
	    /* istanbul ignore else */
	    {
	      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hideWithInteractivity'));
	    }

	    getDocument().addEventListener('mousemove', debouncedOnMouseMove);
	    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
	    debouncedOnMouseMove(event);
	  }

	  function unmount() {
	    /* istanbul ignore else */
	    {
	      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('unmount'));
	    }

	    if (instance.state.isVisible) {
	      instance.hide();
	    }

	    if (!instance.state.isMounted) {
	      return;
	    }

	    destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
	    // tree by default. This seems mainly for interactive tippies, but we should
	    // find a workaround if possible

	    getNestedPopperTree().forEach(function (nestedPopper) {
	      nestedPopper._tippy.unmount();
	    });

	    if (popper.parentNode) {
	      popper.parentNode.removeChild(popper);
	    }

	    mountedInstances = mountedInstances.filter(function (i) {
	      return i !== instance;
	    });
	    instance.state.isMounted = false;
	    invokeHook('onHidden', [instance]);
	  }

	  function destroy() {
	    /* istanbul ignore else */
	    {
	      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));
	    }

	    if (instance.state.isDestroyed) {
	      return;
	    }

	    instance.clearDelayTimeouts();
	    instance.unmount();
	    removeListeners();
	    delete reference._tippy;
	    instance.state.isDestroyed = true;
	    invokeHook('onDestroy', [instance]);
	  }
	}

	function tippy(targets, optionalProps) {
	  if (optionalProps === void 0) {
	    optionalProps = {};
	  }

	  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
	  /* istanbul ignore else */

	  {
	    validateTargets(targets);
	    validateProps(optionalProps, plugins);
	  }

	  bindGlobalEventListeners();
	  var passedProps = Object.assign({}, optionalProps, {
	    plugins: plugins
	  });
	  var elements = getArrayOfElements(targets);
	  /* istanbul ignore else */

	  {
	    var isSingleContentElement = isElement(passedProps.content);
	    var isMoreThanOneReferenceElement = elements.length > 1;
	    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ['tippy() was passed an Element as the `content` prop, but more than', 'one tippy instance was created by this invocation. This means the', 'content element will only be appended to the last tippy instance.', '\n\n', 'Instead, pass the .innerHTML of the element, or use a function that', 'returns a cloned version of the element instead.', '\n\n', '1) content: element.innerHTML\n', '2) content: () => element.cloneNode(true)'].join(' '));
	  }

	  var instances = elements.reduce(function (acc, reference) {
	    var instance = reference && createTippy(reference, passedProps);

	    if (instance) {
	      acc.push(instance);
	    }

	    return acc;
	  }, []);
	  return isElement(targets) ? instances[0] : instances;
	}

	tippy.defaultProps = defaultProps;
	tippy.setDefaultProps = setDefaultProps;
	tippy.currentInput = currentInput;

	// every time the popper is destroyed (i.e. a new target), removing the styles
	// and causing transitions to break for singletons when the console is open, but
	// most notably for non-transform styles being used, `gpuAcceleration: false`.

	Object.assign({}, applyStyles$1, {
	  effect: function effect(_ref) {
	    var state = _ref.state;
	    var initialStyles = {
	      popper: {
	        position: state.options.strategy,
	        left: '0',
	        top: '0',
	        margin: '0'
	      },
	      arrow: {
	        position: 'absolute'
	      },
	      reference: {}
	    };
	    Object.assign(state.elements.popper.style, initialStyles.popper);
	    state.styles = initialStyles;

	    if (state.elements.arrow) {
	      Object.assign(state.elements.arrow.style, initialStyles.arrow);
	    } // intentionally return no cleanup function
	    // return () => { ... }

	  }
	});

	tippy.setDefaultProps({
	  animation: false
	});

	/**
	 *
	 * @param anchorNode
	 * @param tooltipNode
	 * @param tippyOptions
	 * @returns
	 */
	function tooltipRender(anchorNode, tooltipNode, tippyOptions = {}) {
	    return tippy(anchorNode, {
	        render() {
	            const popperElem = document.createElement('div');
	            const arrowElem = document.createElement('div');
	            popperElem.className = 'tooltip-container';
	            arrowElem.className = 'tooltip-arrow';
	            arrowElem.setAttribute('data-popper-arrow', '');
	            popperElem.appendChild(tooltipNode);
	            popperElem.appendChild(arrowElem);
	            return {
	                popper: popperElem,
	            };
	        },
	        zIndex: 9999999,
	        ...tippyOptions,
	    });
	}

	const tooltipStore = writable({});

	mark_module_start();
	Tooltip$1[FILENAME] = "src/components/tooltip/Tooltip.svelte";

	var root$h = add_locations(template(`<div><!></div>`), Tooltip$1[FILENAME], [[41, 0]]);

	function Tooltip$1($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		const $$stores = setup_stores();

		const $tooltipStore = () => (
			validate_store(tooltipStore),
			store_get(tooltipStore, "$tooltipStore", $$stores)
		);

		const textOnly = mutable_state();
		const svelteComponentContent = mutable_state();
		let allowHTML = prop($$props, "allowHTML", 8, false);
		let anchorNode = prop($$props, "anchorNode", 8);
		let content = prop($$props, "content", 8);
		let props = prop($$props, "props", 24, () => ({}));
		let tippyOptions = prop($$props, "tippyOptions", 24, () => ({}));
		let tooltipNode = mutable_state();
		let instance = null;

		onMount(() => {
			instance = tooltipRender(anchorNode(), get(tooltipNode), tippyOptions());

			// Add to store for programmatic access, if anchor has unique id
			if (anchorNode().hasAttribute('id')) {
				const id = anchorNode().getAttribute('id');

				if (id) {
					store_mutate(tooltipStore, untrack($tooltipStore)[id] = instance, untrack($tooltipStore));
				}
			}
		});

		afterUpdate(() => {
			if (instance) {
				instance.setProps(tippyOptions());
			}
		});

		onDestroy(() => {
			// Remove tooltip instance and store entry
			if (instance) {
				instance.destroy();
			}

			const id = anchorNode().getAttribute('id');

			if (id) {
				delete $tooltipStore()[id];
			}
		});

		legacy_pre_effect(() => (deep_read_state(content())), () => {
			set(textOnly, strict_equals(typeof content(), 'string') || content() instanceof String);
		});

		legacy_pre_effect(() => (deep_read_state(content())), () => {
			set(svelteComponentContent, content());
		});

		legacy_pre_effect_reset();
		init();

		var div = root$h();
		var node = child(div);

		if_block(
			node,
			() => !get(textOnly),
			($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				component(node_1, () => get(svelteComponentContent), ($$anchor, $$component) => {
					$$component($$anchor, spread_props(props));
				});

				append($$anchor, fragment);
			},
			($$anchor) => {
				var fragment_1 = comment();
				var node_2 = first_child(fragment_1);

				if_block(
					node_2,
					allowHTML,
					($$anchor) => {
						var fragment_2 = comment();
						var node_3 = first_child(fragment_2);

						html(node_3, content);
						append($$anchor, fragment_2);
					},
					($$anchor) => {
						var text$1 = text();

						template_effect(() => set_text(text$1, content()));
						append($$anchor, text$1);
					},
					true
				);

				append($$anchor, fragment_1);
			}
		);
		bind_this(div, ($$value) => set(tooltipNode, $$value), () => get(tooltipNode));
		template_effect(() => toggle_class(div, "tooltip-textonly", get(textOnly)));
		append($$anchor, div);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Tooltip$1);

	function tooltip (anchorNode, options) {
	    const target = document.createElement('div');
	    const instance = mount(Tooltip$1, {
	        props: { anchorNode, ...options },
	        target,
	    });
	    return {
	        destroy() {
	            unmount(instance);
	        },
	        update(newProps) {
	            instance.$set(newProps);
	        },
	    };
	}

	mark_module_start();
	Tooltip[FILENAME] = "docs_src/exportedfunctions/Tooltip.svelte";

	var on_click$1 = (_, $tooltipStore) => {
		$tooltipStore()['test-anchor'].show();
	};

	var root_1$7 = add_locations(template(`<h2 class="color--eb">Tooltip as an action (svelte)</h2> <p>More about actions <a href="https://svelte.dev/docs#template-syntax-element-directives-use-action" target="_blank" rel="noreferrer">svelte action</a></p> <!> <table class="table"><thead><tr><th>Option</th><th>Type</th><th>Default value</th><th>Description</th></tr></thead><tbody><tr><td>content</td><td>string / SvelteComponent</td><td></td><td>Input text, HTML or SvelteComponent</td></tr><tr><td>allowHTML</td><td>boolean</td><td>false</td><td>Optional: Parse content as HTML <a href="https://svelte.dev/tutorial/html-tags" target="_blank" rel="noreferrer">(see Svelte-docs)</a></td></tr><tr><td>props</td><td>Object</td><td>empty</td><td>Optional: Object of props to pass if using SvelteComponent</td></tr><tr><td>tippyOptions</td><td>Object</td><td>empty</td><td>Optional: Tippy options <a href="https://atomiks.github.io/tippyjs/v6/all-props/" target="_blank" rel="noreferrer">(see reference)</a><br>Props marked with <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTEiIGZpbGw9IiNEQUU2RkYiLz4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTEiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcikiLz4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTEiIHN0cm9rZT0iIzc3NjFEMSIgc3Ryb2tlLXdpZHRoPSIyIi8+CjxwYXRoIGQ9Ik03LjgwMTkxIDcuMkgxMy42ODE5QzE0LjY2MTkgNy4yIDE1LjM3MTIgNy40MjQgMTUuODA5OSA3Ljg3MkMxNi4yNTc5IDguMzEwNjcgMTYuNDgxOSA5LjAyIDE2LjQ4MTkgMTBWMTEuMjZDMTYuNDgxOSAxMi4wMzQ3IDE2LjM1MTIgMTIuNjM2NyAxNi4wODk5IDEzLjA2NkMxNS44Mzc5IDEzLjQ5NTMgMTUuNDMxOSAxMy43OCAxNC44NzE5IDEzLjkyTDE2LjYyMTkgMTdIMTMuODkxOUwxMi4yODE5IDE0LjA2SDEwLjMyMTlWMTdINy44MDE5MVY3LjJaTTEzLjk2MTkgMTBDMTMuOTYxOSA5LjQ0IDEzLjY4MTkgOS4xNiAxMy4xMjE5IDkuMTZIMTAuMzIxOVYxMi4xSDEzLjEyMTlDMTMuNjgxOSAxMi4xIDEzLjk2MTkgMTEuODIgMTMuOTYxOSAxMS4yNlYxMFoiIGZpbGw9IiM3NzYxRDEiLz4KPGRlZnM+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhciIgeDE9IjEyIiB5MT0iMCIgeDI9IjEyIiB5Mj0iMjQiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0VGREVGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IndoaXRlIiBzdG9wLW9wYWNpdHk9IjAiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K" alt="(R)"> not supported</td></tr></tbody></table> <h3>Simple tooltip</h3> <p style="display: inline-block;" class="margin-none">Hover me</p> <!> <h3>Advanced tooltip</h3> <div><p style="display: inline-block; cursor: pointer;" class="margin-none">Click me</p></div> <!> <h3>Programmatic access</h3> <div class="flex flex-justify--between"><div id="test-anchor" style="display: inline-block;"><!></div> <br> <button class="button">Show tooltip</button></div> <!> <!>`, 1), Tooltip[FILENAME], [
		[17, 2],
		[19, 2, [[21, 4]]],
		[
			30,
			2,
			[
				[
					31,
					4,
					[
						[
							32,
							6,
							[
								[33, 8],
								[34, 8],
								[35, 8],
								[36, 8]
							]
						]
					]
				],
				[
					39,
					4,
					[
						[
							40,
							6,
							[
								[41, 8],
								[42, 8],
								[43, 8],
								[44, 8]
							]
						],
						[
							46,
							6,
							[
								[47, 8],
								[48, 8],
								[49, 8],
								[50, 8, [[51, 43]]]
							]
						],
						[
							58,
							6,
							[
								[59, 8],
								[60, 8],
								[61, 8],
								[62, 8]
							]
						],
						[
							64,
							6,
							[
								[65, 8],
								[66, 8],
								[67, 8],
								[
									68,
									8,
									[[69, 35], [73, 11], [74, 10]]
								]
							]
						]
					]
				]
			]
		],
		[83, 2],
		[85, 2],
		[93, 2],
		[94, 2, [[95, 4]]],
		[118, 2],
		[
			120,
			2,
			[[121, 4], [130, 4], [131, 4]]
		]
	]);

	var root_7 = add_locations(template(`<h2 class="color--eb">Tooltip as a function</h2> <code><div class="padding-xl--l padding-m--tb"><div>@param anchorNode HTMLElement - required</div> <div>@param tooltipNode HTMLElement - required</div> <div>@param tippyOptions TTippyCustomOptions - optional</div> <div>@returns A tooltip instance</div></div></code> <!> <p>To make easier use of tooltips on ekstrabladet.dk it is globally avaible through the data-tooltip attributes</p> <div><div><b>data-tooltip</b> <em>required</em> String or id selector(#selector) for element to show in tooltip</div> <div><b>data-tooltip-callback</b> global function to call as callback</div> <div><b>data-tooltip-interactive</b> boolean deciding if the user can interact with the tooltip</div> <div><b>data-tooltip-placement</b> auto | top | right | bottom | left - where should the tooltip pop from, defaults to auto</div> <div><b>data-tooltip-trigger</b> which user action should trigger the popup, defaults to mouseenter</div></div> <h3>Simple tooltip</h3> <!> <h3>HTML tooltip</h3> <p>Content should be HTML Entity encoded if possible</p> <!> <h3>Custom tooltip</h3> <!>`, 1), Tooltip[FILENAME], [
		[153, 2],
		[
			155,
			2,
			[
				[
					156,
					4,
					[
						[157, 6],
						[158, 6],
						[159, 6],
						[160, 6]
					]
				]
			]
		],
		[167, 2],
		[
			169,
			2,
			[
				[170, 4, [[170, 9], [170, 29]]],
				[171, 4, [[171, 9]]],
				[172, 4, [[172, 9]]],
				[173, 4, [[174, 6]]],
				[176, 4, [[176, 9]]]
			]
		],
		[178, 2],
		[183, 2],
		[184, 2],
		[189, 2]
	]);

	var root$g = add_locations(template(`<h1 class="color--eb">Tooltip</h1> <p>Tooltips is a wrapper used to create tooltips with third party library <a href="https://atomiks.github.io/tippyjs/">tippy.js</a></p> <!>`, 1), Tooltip[FILENAME], [
		[9, 0],
		[11, 0, [[13, 2]]]
	]);

	function Tooltip($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		const $$stores = setup_stores();

		const $sourceType = () => (
			validate_store(sourceType),
			store_get(sourceType, "$sourceType", $$stores)
		);

		const $tooltipStore = () => (
			validate_store(tooltipStore),
			store_get(tooltipStore, "$tooltipStore", $$stores)
		);

		init();

		var fragment = root$g();
		var node = sibling(first_child(fragment), 4);

		if_block(
			node,
			() => strict_equals($sourceType(), 'svelte'),
			($$anchor) => {
				var fragment_1 = root_1$7();
				var node_1 = sibling(first_child(fragment_1), 4);

				Prism$1(node_1, {
					language: "js",
					children: wrap_snippet(Tooltip, ($$anchor, $$slotProps) => {
						next();

						var text$1 = text();

						text$1.nodeValue = `import { tooltipAction } from '@ekstra-bladet/designsystem/svelte/functions/tooltipAction';`;
						append($$anchor, text$1);
					}),
					$$slots: { default: true }
				});

				var p = sibling(node_1, 6);

				action(p, ($$node, $$action_arg) => tooltip($$node, $$action_arg), () => ({ content: 'Text, HTML or SvelteComponent' }));

				var node_2 = sibling(p, 2);

				Prism$1(node_2, {
					language: "html",
					children: wrap_snippet(Tooltip, ($$anchor, $$slotProps) => {
						next();

						var text_1 = text();

						text_1.nodeValue = `<p use:tooltipAction={{ content: 'Text, HTML or SvelteComponent' }}>Hover me</p>`;
						append($$anchor, text_1);
					}),
					$$slots: { default: true }
				});

				var div = sibling(node_2, 4);
				var p_1 = child(div);

				action(p_1, ($$node, $$action_arg) => tooltip($$node, $$action_arg), () => ({
					content: Spinner,
					props: { isLoading: true },
					tippyOptions: {
						interactive: true,
						placement: 'bottom',
						trigger: 'click'
					}
				}));

				var node_3 = sibling(div, 2);

				Prism$1(node_3, {
					language: "html",
					children: wrap_snippet(Tooltip, ($$anchor, $$slotProps) => {
						next();

						var text_2 = text();

						text_2.nodeValue = `<p use:tooltip={{
      content: Spinner,
      props: { isLoading: true },
      tippyOptions: { interactive: true, placement: 'bottom', trigger: 'click' },
    }}>
    Click me
</p>`;

						append($$anchor, text_2);
					}),
					$$slots: { default: true }
				});

				var div_1 = sibling(node_3, 4);
				var div_2 = child(div_1);
				var node_4 = child(div_2);

				Icon(node_4, {
					className: "tooltip-toggle",
					name: "question-circle",
					width: "18"
				});
				action(div_2, ($$node, $$action_arg) => tooltip($$node, $$action_arg), () => ({ content: 'String or SvelteTemplate' }));

				var button = sibling(div_2, 4);

				button.__click = [on_click$1, $tooltipStore];

				var node_5 = sibling(div_1, 2);

				Prism$1(node_5, {
					language: "js",
					children: wrap_snippet(Tooltip, ($$anchor, $$slotProps) => {
						next();

						var text_3 = text();

						text_3.nodeValue = `import { tooltipAction, tooltipStore } from '@ekstra-bladet/designsystem/svelte/functions/tooltipAction';`;
						append($$anchor, text_3);
					}),
					$$slots: { default: true }
				});

				var node_6 = sibling(node_5, 2);

				Prism$1(node_6, {
					language: "html",
					children: wrap_snippet(Tooltip, ($$anchor, $$slotProps) => {
						next();

						var text_4 = text();

						text_4.nodeValue = `<div id="uniqueid" use:tooltipAction={{ content: 'Test String' }}>
    <Icon className="tooltip-toggle" name="question-circle" width="18" />
</div>

<button class="button" on:click={(e) => {$tooltipStore['uniqueid'].show();}}>Show tooltip</button>`;

						append($$anchor, text_4);
					}),
					$$slots: { default: true }
				});

				append($$anchor, fragment_1);
			},
			($$anchor) => {
				var fragment_7 = root_7();
				var node_7 = sibling(first_child(fragment_7), 4);

				Prism$1(node_7, {
					language: "js",
					children: wrap_snippet(Tooltip, ($$anchor, $$slotProps) => {
						next();

						var text_5 = text();

						text_5.nodeValue = `import { tooltipRender } from '@ekstra-bladet/designsystem/svelte/functions/tooltipAction';`;
						append($$anchor, text_5);
					}),
					$$slots: { default: true }
				});

				var node_8 = sibling(node_7, 8);

				Prism$1(node_8, {
					language: "html",
					children: wrap_snippet(Tooltip, ($$anchor, $$slotProps) => {
						next();

						var text_6 = text();

						text_6.nodeValue = `<div data-tooltip="Simple text tooltip">Hover</div>`;
						append($$anchor, text_6);
					}),
					$$slots: { default: true }
				});

				var node_9 = sibling(node_8, 6);

				Prism$1(node_9, {
					language: "html",
					children: wrap_snippet(Tooltip, ($$anchor, $$slotProps) => {
						next();

						var text_7 = text();

						text_7.nodeValue = `<div data-tooltip="Simple text<br>tooltip" data-tooltip-allowhtml="true">Hover</div>`;
						append($$anchor, text_7);
					}),
					$$slots: { default: true }
				});

				var node_10 = sibling(node_9, 4);

				Prism$1(node_10, {
					language: "html",
					children: wrap_snippet(Tooltip, ($$anchor, $$slotProps) => {
						next();

						var text_8 = text();

						text_8.nodeValue = `<div
  data-tooltip="#testid"
  data-tooltip-interactive="true"
  data-tooltip-placement="bottom"
  data-tooltip-trigger="click">
    Click
</div>

<div id="testid" class="hidden">
  <p>Custom input</p>
  <button>Test</button>
</div>
    `;

						append($$anchor, text_8);
					}),
					$$slots: { default: true }
				});

				append($$anchor, fragment_7);
			}
		);

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Tooltip);
	delegate(["click"]);

	const exportedfunctions = {
	    path: '/exportedfunctions',
	    routes: [
	        {
	            component: HorizontalScrollHandler,
	            path: '/exportedfunctions/horizontalscrollhandler',
	            name: 'HorizontalScrollHandler',
	        },
	        { component: SplitNfitTitle, path: '/exportedfunctions/splitnfitname', name: 'SplitNfitname' },
	        { component: SplitTitle, path: '/exportedfunctions/splitname', name: 'Splitname' },
	        { component: Throttle, path: '/exportedfunctions/throttle', name: 'Throttle' },
	        { component: TimePassedSince, path: '/exportedfunctions/timepassedsince', name: 'TimePassedSince' },
	        { component: Tooltip, path: '/exportedfunctions/tooltip', name: 'Tooltip' },
	    ],
	    name: 'Functions',
	};

	mark_module_start();
	Svelte[FILENAME] = "docs_src/guidelines/Svelte.svelte";

	var root$f = add_locations(
		template(
			`<h1 class="color--eb">Svelte</h1> <h3>Rules</h3> <ol><li class="svelte-9h10az">There must be a rigorous division of logic (script-part) and views (template, class selection, etc.)</li> <li class="svelte-9h10az">Component-specific styling should preferably be solved using the designsystem instead of styling within the
    Svelte-files.</li> <li class="svelte-9h10az">Svelte functions should (if possible) be used instead of native functions (eg createEventListener).</li> <li class="svelte-9h10az">Script tag content must be kept to an absolute minimum.</li> <li class="svelte-9h10az">As a rule, the state must provide all data in the format required by the components. Ie. Filtering takes place in
    state management and not in the respective components.</li> <li class="svelte-9h10az">Design system: on:click should exist on all elements of the design system</li> <li class="svelte-9h10az">The use of Svelte is agreed in the front-end group, so that it is only used where it makes sense.</li> <li class="svelte-9h10az">Svelte-store is used and each part of the state is divided into several readable / writeable, instead of one object.</li> <li class="svelte-9h10az">Writables may only be updated using actions (functions) and may not be exported directly.</li></ol> <h3>Create Svelte App</h3> <p>The recommended way to start new apps with Svelte is by using our Svelte Template:</p> <!>`,
			1
		),
		Svelte[FILENAME],
		[
			[4, 0],
			[5, 0],
			[
				6,
				0,
				[
					[7, 2],
					[8, 2],
					[12, 2],
					[13, 2],
					[14, 2],
					[18, 2],
					[19, 2],
					[20, 2],
					[23, 2]
				]
			],
			[26, 0],
			[27, 0]
		]
	);

	function Svelte($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var fragment = root$f();
		var node = sibling(first_child(fragment), 10);

		Prism$1(node, {
			language: "js",
			children: wrap_snippet(Svelte, ($$anchor, $$slotProps) => {
				next();

				var text$1 = text();

				text$1.nodeValue = `npx degit EkstraBladetUdvikling/sveltetemplate my-svelte-project`;
				append($$anchor, text$1);
			}),
			$$slots: { default: true }
		});

		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Svelte);

	const guidelines = {
	    path: '/guidelines',
	    routes: [{ component: Svelte, path: '/guidelines/svelte', name: 'Svelte' }],
	    name: 'Guidelines',
	};

	mark_module_start();
	Home$5[FILENAME] = "docs_src/components/Home.svelte";

	var root_1$6 = add_locations(template(`<li><a> </a></li>`), Home$5[FILENAME], [[13, 4, [[13, 8]]]]);

	var root$e = add_locations(template(`<h1>Components</h1> <div class="grid-width--small"><p>Components mainly consists of svelte components but can be used as straight HTML components if it's a must</p></div> <ul></ul>`, 1), Home$5[FILENAME], [
		[5, 0],
		[7, 0, [[8, 2]]],
		[11, 0]
	]);

	function Home$5($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);
		init();

		var fragment = root$e();
		var ul = sibling(first_child(fragment), 4);

		each(ul, 5, () => components.routes, index, ($$anchor, route) => {
			var li = root_1$6();
			var a = child(li);
			var text = child(a);
			action(a, ($$node) => link($$node));

			template_effect(() => {
				set_attribute(a, "href", get(route).path);
				set_text(text, get(route).name);
			});

			append($$anchor, li);
		});
		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Home$5);

	mark_module_start();
	Home$4[FILENAME] = "docs_src/cssvariables/Home.svelte";

	var root_1$5 = add_locations(template(`<li><a> </a></li>`), Home$4[FILENAME], [[13, 4, [[13, 8]]]]);

	var root$d = add_locations(template(`<h1>CSS Variables</h1> <div class="grid-width--small"><p>Utility CSS variables to be used in styling</p> <p>These are not meant to be overridden</p></div> <ul></ul>`, 1), Home$4[FILENAME], [
		[5, 0],
		[7, 0, [[8, 2], [9, 2]]],
		[11, 0]
	]);

	function Home$4($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);
		init();

		var fragment = root$d();
		var ul = sibling(first_child(fragment), 4);

		each(ul, 5, () => cssvariables.routes, index, ($$anchor, route) => {
			var li = root_1$5();
			var a = child(li);
			var text = child(a);
			action(a, ($$node) => link($$node));

			template_effect(() => {
				set_attribute(a, "href", get(route).path);
				set_text(text, get(route).name);
			});

			append($$anchor, li);
		});
		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Home$4);

	mark_module_start();
	Home$3[FILENAME] = "docs_src/exportedfunctions/Home.svelte";

	var root_1$4 = add_locations(template(`<li><a> </a></li>`), Home$3[FILENAME], [[12, 4, [[12, 8]]]]);

	var root$c = add_locations(template(`<h1>Exported Functions</h1> <div class="grid-width--small"><p>Functions exported from the design system to be used in svelte/typescript/javascript applications</p></div> <ul></ul>`, 1), Home$3[FILENAME], [
		[5, 0],
		[7, 0, [[8, 2]]],
		[10, 0]
	]);

	function Home$3($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);
		init();

		var fragment = root$c();
		var ul = sibling(first_child(fragment), 4);

		each(ul, 5, () => exportedfunctions.routes, index, ($$anchor, route) => {
			var li = root_1$4();
			var a = child(li);
			var text = child(a);
			action(a, ($$node) => link($$node));

			template_effect(() => {
				set_attribute(a, "href", get(route).path);
				set_text(text, get(route).name);
			});

			append($$anchor, li);
		});
		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Home$3);

	mark_module_start();
	Home$2[FILENAME] = "docs_src/guidelines/Home.svelte";

	var root_1$3 = add_locations(template(`<li><a> </a></li>`), Home$2[FILENAME], [[15, 4, [[15, 8]]]]);

	var root$b = add_locations(
		template(
			`<h1>Guidelines</h1> <div class="grid-width--small"><p>Guidelines on how to implements languages or frameworks when working with frontend code in the context of Ekstra
    Bladet</p></div> <ul></ul>`,
			1
		),
		Home$2[FILENAME],
		[
			[5, 0],
			[7, 0, [[8, 2]]],
			[13, 0]
		]
	);

	function Home$2($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);
		init();

		var fragment = root$b();
		var ul = sibling(first_child(fragment), 4);

		each(ul, 5, () => guidelines.routes, index, ($$anchor, route) => {
			var li = root_1$3();
			var a = child(li);
			var text = child(a);
			action(a, ($$node) => link($$node));

			template_effect(() => {
				set_attribute(a, "href", get(route).path);
				set_text(text, get(route).name);
			});

			append($$anchor, li);
		});
		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Home$2);

	mark_module_start();
	Components[FILENAME] = "docs_src/assets/icons/components.svelte";

	var root$a = add_locations(ns_template(`<svg style="width:60px; height:60px;" aria-hidden="true" focusable="false" data-prefix="fal" data-icon="cubes" class="svg-inline--fa fa-cubes fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M488.6 256.7L388 219V107.9c0-15-9.3-28.4-23.4-33.7l-96-36c-8.1-3.1-17.1-3.1-25.3 0l-96 36c-14.1 5.3-23.4 18.7-23.4 33.7V219L23.4 256.7C9.3 262 0 275.4 0 290.4v101.3c0 13.6 7.7 26.1 19.9 32.2l96 48c10.1 5.1 22.1 5.1 32.2 0L256 418l107.9 54c10.1 5.1 22.1 5.1 32.2 0l96-48c12.2-6.1 19.9-18.6 19.9-32.2V290.4c0-15-9.3-28.4-23.4-33.7zM16.5 403.8V295.1l107.2 46.5v115.8zm231 0l-107.2 53.6V341.6l107.2-46.5zm0-126.7l-115.5 50-115.5-50v-.2L131 234l107.6 39.6 8.9 3.3zm.3-19.7L195 239.6l-54.5-20.4V112.5L247.8 159zM140.5 94.5v-.1L256 51l115.5 43.3v.2l-115.5 50zM264.2 159l107.2-46.5v106.7L317 239.6l-52.8 17.8zm107.6 298.4l-107.2-53.6V295.1l107.2 46.5zm123.7-53.6l-107.2 53.6V341.6l107.2-46.5zm0-126.7l-115.5 50L264.5 277v-.2l8.9-3.3L381 234l114.5 42.9z"></path></svg>`), Components[FILENAME], [[4, 0, [[14, 3]]]]);

	function Components($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var svg = root$a();

		append($$anchor, svg);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Components);

	mark_module_start();
	Css_vars[FILENAME] = "docs_src/assets/icons/css-vars.svelte";

	var root$9 = add_locations(ns_template(`<svg style="width: 45px;height: 60px;" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="css3-alt" class="svg-inline--fa fa-css3-alt fa-w-12" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="currentColor" d="M0 32l34.9 395.8L192 480l157.1-52.2L384 32H0zm313.1 80l-4.8 47.3L193 208.6l-.3.1h111.5l-12.8 146.6-98.2 28.7-98.8-29.2-6.4-73.9h48.9l3.2 38.3 52.6 13.3 54.7-15.4 3.7-61.6-166.3-.5v-.1l-.2.1-3.6-46.3L193.1 162l6.5-2.7H76.7L70.9 112h242.2z"></path></svg>`), Css_vars[FILENAME], [[4, 0, [[14, 3]]]]);

	function Css_vars($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var svg = root$9();

		append($$anchor, svg);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Css_vars);

	mark_module_start();
	Guideline[FILENAME] = "docs_src/assets/icons/guideline.svelte";

	var root$8 = add_locations(ns_template(`<svg style="width:45px; height:60px;" aria-hidden="true" focusable="false" data-prefix="fal" data-icon="book" class="svg-inline--fa fa-book fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M356 160H188c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12v8c0 6.6-5.4 12-12 12zm12 52v-8c0-6.6-5.4-12-12-12H188c-6.6 0-12 5.4-12 12v8c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12zm64.7 268h3.3c6.6 0 12 5.4 12 12v8c0 6.6-5.4 12-12 12H80c-44.2 0-80-35.8-80-80V80C0 35.8 35.8 0 80 0h344c13.3 0 24 10.7 24 24v368c0 10-6.2 18.6-14.9 22.2-3.6 16.1-4.4 45.6-.4 65.8zM128 384h288V32H128v352zm-96 16c13.4-10 30-16 48-16h16V32H80c-26.5 0-48 21.5-48 48v320zm372.3 80c-3.1-20.4-2.9-45.2 0-64H80c-64 0-64 64 0 64h324.3z"></path></svg>`), Guideline[FILENAME], [[4, 0, [[14, 3]]]]);

	function Guideline($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var svg = root$8();

		append($$anchor, svg);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Guideline);

	mark_module_start();
	Js_functions[FILENAME] = "docs_src/assets/icons/js-functions.svelte";

	var root$7 = add_locations(ns_template(`<svg style="width:60px; height:60px;" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="js-square" class="svg-inline--fa fa-js-square fa-w-14" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM243.8 381.4c0 43.6-25.6 63.5-62.9 63.5-33.7 0-53.2-17.4-63.2-38.5l34.3-20.7c6.6 11.7 12.6 21.6 27.1 21.6 13.8 0 22.6-5.4 22.6-26.5V237.7h42.1v143.7zm99.6 63.5c-39.1 0-64.4-18.6-76.7-43l34.3-19.8c9 14.7 20.8 25.6 41.5 25.6 17.4 0 28.6-8.7 28.6-20.8 0-14.4-11.4-19.5-30.7-28l-10.5-4.5c-30.4-12.9-50.5-29.2-50.5-63.5 0-31.6 24.1-55.6 61.6-55.6 26.8 0 46 9.3 59.8 33.7L368 290c-7.2-12.9-15-18-27.1-18-12.3 0-20.1 7.8-20.1 18 0 12.6 7.8 17.7 25.9 25.6l10.5 4.5c35.8 15.3 55.9 31 55.9 66.2 0 37.8-29.8 58.6-69.7 58.6z"></path></svg>`), Js_functions[FILENAME], [[4, 0, [[14, 3]]]]);

	function Js_functions($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var svg = root$7();

		append($$anchor, svg);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Js_functions);

	mark_module_start();
	Utility[FILENAME] = "docs_src/assets/icons/utility.svelte";

	var root$6 = add_locations(ns_template(`<svg style="width:60px; height:60px;" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="connectdevelop" class="svg-inline--fa fa-connectdevelop fa-w-18" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="currentColor" d="M550.5 241l-50.089-86.786c1.071-2.142 1.875-4.553 1.875-7.232 0-8.036-6.696-14.733-14.732-15.001l-55.447-95.893c.536-1.607 1.071-3.214 1.071-4.821 0-8.571-6.964-15.268-15.268-15.268-4.821 0-8.839 2.143-11.786 5.625H299.518C296.839 18.143 292.821 16 288 16s-8.839 2.143-11.518 5.625H170.411C167.464 18.143 163.447 16 158.625 16c-8.303 0-15.268 6.696-15.268 15.268 0 1.607.536 3.482 1.072 4.821l-55.983 97.233c-5.356 2.41-9.107 7.5-9.107 13.661 0 .535.268 1.071.268 1.607l-53.304 92.143c-7.232 1.339-12.59 7.5-12.59 15 0 7.232 5.089 13.393 12.054 15l55.179 95.358c-.536 1.607-.804 2.946-.804 4.821 0 7.232 5.089 13.393 12.054 14.732l51.697 89.732c-.536 1.607-1.071 3.482-1.071 5.357 0 8.571 6.964 15.268 15.268 15.268 4.821 0 8.839-2.143 11.518-5.357h106.875C279.161 493.857 283.447 496 288 496s8.839-2.143 11.518-5.357h107.143c2.678 2.946 6.696 4.821 10.982 4.821 8.571 0 15.268-6.964 15.268-15.268 0-1.607-.267-2.946-.803-4.285l51.697-90.268c6.964-1.339 12.054-7.5 12.054-14.732 0-1.607-.268-3.214-.804-4.821l54.911-95.358c6.964-1.339 12.322-7.5 12.322-15-.002-7.232-5.092-13.393-11.788-14.732zM153.535 450.732l-43.66-75.803h43.66v75.803zm0-83.839h-43.66c-.268-1.071-.804-2.142-1.339-3.214l44.999-47.41v50.624zm0-62.411l-50.357 53.304c-1.339-.536-2.679-1.34-4.018-1.607L43.447 259.75c.535-1.339.535-2.679.535-4.018s0-2.41-.268-3.482l51.965-90c2.679-.268 5.357-1.072 7.768-2.679l50.089 51.965v92.946zm0-102.322l-45.803-47.41c1.339-2.143 2.143-4.821 2.143-7.767 0-.268-.268-.804-.268-1.072l43.928-15.804v72.053zm0-80.625l-43.66 15.804 43.66-75.536v59.732zm326.519 39.108l.804 1.339L445.5 329.125l-63.75-67.232 98.036-101.518.268.268zM291.75 355.107l11.518 11.786H280.5l11.25-11.786zm-.268-11.25l-83.303-85.446 79.553-84.375 83.036 87.589-79.286 82.232zm5.357 5.893l79.286-82.232 67.5 71.25-5.892 28.125H313.714l-16.875-17.143zM410.411 44.393c1.071.536 2.142 1.072 3.482 1.34l57.857 100.714v.536c0 2.946.803 5.624 2.143 7.767L376.393 256l-83.035-87.589L410.411 44.393zm-9.107-2.143L287.732 162.518l-57.054-60.268 166.339-60h4.287zm-123.483 0c2.678 2.678 6.16 4.285 10.179 4.285s7.5-1.607 10.179-4.285h75L224.786 95.821 173.893 42.25h103.928zm-116.249 5.625l1.071-2.142a33.834 33.834 0 0 0 2.679-.804l51.161 53.84-54.911 19.821V47.875zm0 79.286l60.803-21.964 59.732 63.214-79.553 84.107-40.982-42.053v-83.304zm0 92.678L198 257.607l-36.428 38.304v-76.072zm0 87.858l42.053-44.464 82.768 85.982-17.143 17.678H161.572v-59.196zm6.964 162.053c-1.607-1.607-3.482-2.678-5.893-3.482l-1.071-1.607v-89.732h99.91l-91.607 94.821h-1.339zm129.911 0c-2.679-2.41-6.428-4.285-10.447-4.285s-7.767 1.875-10.447 4.285h-96.429l91.607-94.821h38.304l91.607 94.821H298.447zm120-11.786l-4.286 7.5c-1.339.268-2.41.803-3.482 1.339l-89.196-91.875h114.376l-17.412 83.036zm12.856-22.232l12.858-60.803h21.964l-34.822 60.803zm34.822-68.839h-20.357l4.553-21.16 17.143 18.214c-.535.803-1.071 1.874-1.339 2.946zm66.161-107.411l-55.447 96.697c-1.339.535-2.679 1.071-4.018 1.874l-20.625-21.964 34.554-163.928 45.803 79.286c-.267 1.339-.803 2.678-.803 4.285 0 1.339.268 2.411.536 3.75z"></path></svg>`), Utility[FILENAME], [[4, 0, [[14, 3]]]]);

	function Utility($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var svg = root$6();

		append($$anchor, svg);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Utility);

	mark_module_start();
	Home$1[FILENAME] = "docs_src/main/Home.svelte";

	var root$5 = add_locations(template(`<div class="flex flex-justify--around width-1of1"><div class="grid-width--medium"><div class="flex flex-justify--center"><img alt="" src="ekstrabladet.svg" style="height:70px;"></div> <div class="flex flex-justify--center margin-l--b"><h1>Design system</h1></div> <div class="text-align--center margin-m--tb padding-m bg--graa7">yarn add @ekstra-bladet/designsystem</div> <div class="grid home-section svelte-1rqm2fs"><a class="home-section-item components svelte-1rqm2fs"><div class="card padding-m"><div class="flex-item flex-item--center text-align--center"><h2 class="color--graa1">Components</h2> <!></div></div></a> <a class="home-section-item utilities svelte-1rqm2fs"><div class="card padding-m"><div class="flex-item flex-item--center text-align--center"><h2 class="color--graa1">Utilities</h2> <!></div></div></a> <a class="home-section-item guidelines svelte-1rqm2fs"><div class="card padding-m"><div class="flex-item flex-item--center text-align--center"><h2 class="color--graa1">Guidelines</h2> <!></div></div></a> <a class="home-section-item exportedfunctions svelte-1rqm2fs"><div class="card padding-m"><div class="flex-item flex-item--center text-align--center"><h2 class="color--graa1">JS Functions</h2> <!></div></div></a> <a class="home-section-item cssvariables svelte-1rqm2fs"><div class="card padding-m"><div class="flex-item flex-item--center text-align--center"><h2 class="color--graa1">CSS Variables</h2> <!></div></div></a></div></div></div>`), Home$1[FILENAME], [
		[
			14,
			0,
			[
				[
					15,
					2,
					[
						[16, 4, [[17, 6]]],
						[19, 4, [[20, 6]]],
						[22, 4],
						[
							23,
							4,
							[
								[
									24,
									6,
									[
										[
											25,
											8,
											[[26, 10, [[27, 12]]]]
										]
									]
								],
								[
									32,
									6,
									[
										[
											33,
											8,
											[[34, 10, [[35, 12]]]]
										]
									]
								],
								[
									40,
									6,
									[
										[
											41,
											8,
											[[42, 10, [[43, 12]]]]
										]
									]
								],
								[
									48,
									6,
									[
										[
											49,
											8,
											[[50, 10, [[51, 12]]]]
										]
									]
								],
								[
									56,
									6,
									[
										[
											57,
											8,
											[[58, 10, [[59, 12]]]]
										]
									]
								]
							]
						]
					]
				]
			]
		]
	]);

	function Home$1($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);
		init();

		var div = root$5();
		var div_1 = child(div);
		var div_2 = sibling(child(div_1), 6);
		var a = child(div_2);
		var div_3 = child(a);
		var div_4 = child(div_3);
		var node = sibling(child(div_4), 2);

		Components(node, {});
		action(a, ($$node) => link($$node));

		var a_1 = sibling(a, 2);
		var div_5 = child(a_1);
		var div_6 = child(div_5);
		var node_1 = sibling(child(div_6), 2);

		Utility(node_1, {});
		action(a_1, ($$node) => link($$node));

		var a_2 = sibling(a_1, 2);
		var div_7 = child(a_2);
		var div_8 = child(div_7);
		var node_2 = sibling(child(div_8), 2);

		Guideline(node_2, {});
		action(a_2, ($$node) => link($$node));

		var a_3 = sibling(a_2, 2);
		var div_9 = child(a_3);
		var div_10 = child(div_9);
		var node_3 = sibling(child(div_10), 2);

		Js_functions(node_3, {});
		action(a_3, ($$node) => link($$node));

		var a_4 = sibling(a_3, 2);
		var div_11 = child(a_4);
		var div_12 = child(div_11);
		var node_4 = sibling(child(div_12), 2);

		Css_vars(node_4, {});
		action(a_4, ($$node) => link($$node));

		template_effect(() => {
			set_attribute(a, "href", components.path);
			set_attribute(a_1, "href", utilities.path);
			set_attribute(a_2, "href", guidelines.path);
			set_attribute(a_3, "href", exportedfunctions.path);
			set_attribute(a_4, "href", cssvariables.path);
		});

		append($$anchor, div);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Home$1);

	mark_module_start();
	Home[FILENAME] = "docs_src/utilities/Home.svelte";

	var root_1$2 = add_locations(template(`<li><a> </a></li>`), Home[FILENAME], [[13, 4, [[13, 8]]]]);

	var root$4 = add_locations(template(`<h1>Utilities</h1> <div class="grid-width--small"><p>Utilities exposed from Ekstra Bladet designsystem</p></div> <ul></ul>`, 1), Home[FILENAME], [
		[5, 0],
		[7, 0, [[8, 2]]],
		[11, 0]
	]);

	function Home($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);
		init();

		var fragment = root$4();
		var ul = sibling(first_child(fragment), 4);

		each(ul, 5, () => utilities.routes, index, ($$anchor, route) => {
			var li = root_1$2();
			var a = child(li);
			var text = child(a);
			action(a, ($$node) => link($$node));

			template_effect(() => {
				set_attribute(a, "href", get(route).path);
				set_text(text, get(route).name);
			});

			append($$anchor, li);
		});
		append($$anchor, fragment);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Home);

	const menuItems = [guidelines, components, utilities, exportedfunctions, cssvariables];
	const routes = [
	    {
	        name: 'Home',
	        path: '/',
	        component: Home$1,
	    },
	    {
	        name: guidelines.name,
	        path: guidelines.path,
	        component: Home$2,
	    },
	    {
	        name: components.name,
	        path: components.path,
	        component: Home$5,
	    },
	    {
	        name: utilities.name,
	        path: utilities.path,
	        component: Home,
	    },
	    {
	        name: exportedfunctions.name,
	        path: exportedfunctions.path,
	        component: Home$3,
	    },
	    {
	        name: cssvariables.name,
	        path: cssvariables.path,
	        component: Home$4,
	    },
	    ...guidelines.routes,
	    ...components.routes,
	    ...utilities.routes,
	    ...exportedfunctions.routes,
	    ...cssvariables.routes,
	];
	const options = {
	    routes,
	};

	mark_module_start();
	Icons[FILENAME] = "docs/svg/symbol/icons.svelte";

	var root$3 = add_locations(ns_template(`<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><symbol viewBox="0 0 448 512" id="angle-down" xmlns="http://www.w3.org/2000/svg"><path d="m443.5 162.6-7.1-7.1c-4.7-4.7-12.3-4.7-17 0L224 351 28.5 155.5c-4.7-4.7-12.3-4.7-17 0l-7.1 7.1c-4.7 4.7-4.7 12.3 0 17l211 211.1c4.7 4.7 12.3 4.7 17 0l211-211.1c4.8-4.7 4.8-12.3.1-17z" style="filter:var(--icon-filter)"></path></symbol><symbol viewBox="0 0 256 512" id="angle-left" xmlns="http://www.w3.org/2000/svg"><path d="m238.475 475.535 7.071-7.07c4.686-4.686 4.686-12.284 0-16.971L50.053 256 245.546 60.506c4.686-4.686 4.686-12.284 0-16.971l-7.071-7.07c-4.686-4.686-12.284-4.686-16.97 0L10.454 247.515c-4.686 4.686-4.686 12.284 0 16.971l211.051 211.05c4.686 4.686 12.284 4.686 16.97-.001z" style="filter:var(--icon-filter)"></path></symbol><symbol viewBox="0 0 256 512" id="angle-right" xmlns="http://www.w3.org/2000/svg"><path d="m17.525 36.465-7.071 7.07c-4.686 4.686-4.686 12.284 0 16.971L205.947 256 10.454 451.494c-4.686 4.686-4.686 12.284 0 16.971l7.071 7.07c4.686 4.686 12.284 4.686 16.97 0l211.051-211.05c4.686-4.686 4.686-12.284 0-16.971L34.495 36.465c-4.686-4.687-12.284-4.687-16.97 0z" style="filter:var(--icon-filter)"></path></symbol><symbol viewBox="0 0 448 512" id="angle-up" xmlns="http://www.w3.org/2000/svg"><path d="m4.465 366.475 7.07 7.071c4.686 4.686 12.284 4.686 16.971 0L224 178.053l195.494 195.493c4.686 4.686 12.284 4.686 16.971 0l7.07-7.071c4.686-4.686 4.686-12.284 0-16.97l-211.05-211.051c-4.686-4.686-12.284-4.686-16.971 0L4.465 349.505c-4.687 4.686-4.687 12.284 0 16.97z" style="filter:var(--icon-filter)"></path></symbol><symbol viewBox="0 0 90 89" id="applepodcasts" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M45 34.344a6.784 6.784 0 1 0 0 13.568 6.784 6.784 0 0 0 0-13.568Zm-13.568 6.784c0-7.493 6.074-13.567 13.567-13.567s13.568 6.074 13.568 13.567-6.075 13.568-13.568 13.568c-7.493 0-13.567-6.075-13.567-13.568Z"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M38.288 54.696a3.418 3.418 0 0 0-3.356 4.218l5.161 20.324a3.476 3.476 0 0 0 3.38 2.593h3.053a3.477 3.477 0 0 0 3.38-2.593l5.162-20.324a3.418 3.418 0 0 0-3.356-4.218H38.288Zm.05-6.784a10.2 10.2 0 0 0-9.992 12.628l.007.028 5.168 20.35.005.02a10.26 10.26 0 0 0 9.972 7.677h3.004a10.261 10.261 0 0 0 9.972-7.677l.005-.02 5.168-20.35.007-.028a10.2 10.2 0 0 0-9.992-12.628H38.337Z"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M45 20.806a23.743 23.743 0 0 0-22.879 30.091 3.392 3.392 0 1 1-6.536 1.814 30.527 30.527 0 1 1 58.83 0 3.392 3.392 0 1 1-6.536-1.813A23.743 23.743 0 0 0 45 20.806Z"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M45 7.215A37.31 37.31 0 0 0 24.256 75.54a3.392 3.392 0 1 1-3.771 5.64 44.095 44.095 0 1 1 49.027 0 3.392 3.392 0 0 1-3.771-5.64A37.31 37.31 0 0 0 44.999 7.215Z"></path></symbol><symbol viewBox="0 0 448 512" id="arrow-down" xmlns="http://www.w3.org/2000/svg"><path d="m443.5 248.5-7.1-7.1c-4.7-4.7-12.3-4.7-17 0L241 419.9V44c0-6.6-5.4-12-12-12h-10c-6.6 0-12 5.4-12 12v375.9L28.5 241.4c-4.7-4.7-12.3-4.7-17 0l-7.1 7.1c-4.7 4.7-4.7 12.3 0 17l211 211.1c4.7 4.7 12.3 4.7 17 0l211-211.1c4.8-4.8 4.8-12.3.1-17z" style="filter:var(--icon-filter)"></path></symbol><symbol viewBox="0 0 448 512" id="arrow-left" xmlns="http://www.w3.org/2000/svg"><path d="m231.536 475.535 7.071-7.07c4.686-4.686 4.686-12.284 0-16.971L60.113 273H436c6.627 0 12-5.373 12-12v-10c0-6.627-5.373-12-12-12H60.113L238.607 60.506c4.686-4.686 4.686-12.284 0-16.971l-7.071-7.07c-4.686-4.686-12.284-4.686-16.97 0L3.515 247.515c-4.686 4.686-4.686 12.284 0 16.971l211.051 211.05c4.686 4.686 12.284 4.686 16.97-.001z" style="filter:var(--icon-filter)"></path></symbol><symbol viewBox="0 0 448 512" id="arrow-right" xmlns="http://www.w3.org/2000/svg"><path d="m216.464 36.465-7.071 7.07c-4.686 4.686-4.686 12.284 0 16.971L387.887 239H12c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h375.887L209.393 451.494c-4.686 4.686-4.686 12.284 0 16.971l7.071 7.07c4.686 4.686 12.284 4.686 16.97 0l211.051-211.05c4.686-4.686 4.686-12.284 0-16.971L233.434 36.465c-4.686-4.687-12.284-4.687-16.97 0z" style="filter:var(--icon-filter)"></path></symbol><symbol viewBox="0 0 448 512" id="arrow-up" xmlns="http://www.w3.org/2000/svg"><path d="m4.465 263.536 7.07 7.071c4.686 4.686 12.284 4.686 16.971 0L207 92.113V468c0 6.627 5.373 12 12 12h10c6.627 0 12-5.373 12-12V92.113l178.494 178.493c4.686 4.686 12.284 4.686 16.971 0l7.07-7.071c4.686-4.686 4.686-12.284 0-16.97l-211.05-211.05c-4.686-4.686-12.284-4.686-16.971 0L4.465 246.566c-4.687 4.686-4.687 12.284 0 16.97z" style="filter:var(--icon-filter)"></path></symbol><symbol viewBox="0 0 51 47" style="enable-background:new 0 0 51 47" xml:space="preserve" id="article" xmlns="http://www.w3.org/2000/svg"><path d="M27 46.5h-4.5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5H27c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5zm-12 0H2c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5h13c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5zm34-11.1H2c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5h47c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5zm0-11.1H33.5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5H49c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5zm-26.3 0H3.3c-1.6 0-2.8-1.2-2.8-2.8V3C.5 1.4 1.7.2 3.3.2h19.4c1.6 0 2.8 1.2 2.8 2.8v18.5c-.1 1.6-1.2 2.8-2.8 2.8zm-19.2-3h18.9v-18H3.5v18zM49 13.2H33.5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5H49c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5zm0-9.9H33.5c-.8 0-1.5-.7-1.5-1.5S32.7.3 33.5.3H49c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5z"></path></symbol><symbol viewBox="0 0 16 16" style="enable-background:new 0 0 16 16" xml:space="preserve" id="at" xmlns="http://www.w3.org/2000/svg"><path class="akst0" d="M8 15.6C3.8 15.6.4 12.2.4 8S3.8.4 8 .4s7.6 3.4 7.6 7.6v1.3c0 1.3-1.1 2.4-2.4 2.4-1 0-1.8-.6-2.2-1.4-.7.9-1.7 1.4-2.9 1.4C6 11.7 4.3 10 4.3 8S6 4.3 8 4.3c1.1 0 2 .5 2.7 1.2v-.7h1v4.5c0 .8.6 1.4 1.4 1.4s1.4-.6 1.4-1.4V8c0-3.6-2.9-6.6-6.6-6.6-3.5 0-6.5 3-6.5 6.6 0 3.6 2.9 6.6 6.6 6.6v1zM8 5.3C6.5 5.3 5.3 6.5 5.3 8c0 1.5 1.2 2.7 2.7 2.7 1.5 0 2.7-1.2 2.7-2.7 0-1.5-1.2-2.7-2.7-2.7z"></path></symbol><symbol class="alsvg-inline--fa alfa-bell alfa-w-14" viewBox="0 0 448 512" id="bell" xmlns="http://www.w3.org/2000/svg"><path d="M224 480c-17.66 0-32-14.38-32-32.03h-32c0 35.31 28.72 64.03 64 64.03s64-28.72 64-64.03h-32c0 17.65-14.34 32.03-32 32.03zm209.38-145.19c-27.96-26.62-49.34-54.48-49.34-148.91 0-79.59-63.39-144.5-144.04-152.35V16c0-8.84-7.16-16-16-16s-16 7.16-16 16v17.56C127.35 41.41 63.96 106.31 63.96 185.9c0 94.42-21.39 122.29-49.35 148.91-13.97 13.3-18.38 33.41-11.25 51.23C10.64 404.24 28.16 416 48 416h352c19.84 0 37.36-11.77 44.64-29.97 7.13-17.82 2.71-37.92-11.26-51.22zM400 384H48c-14.23 0-21.34-16.47-11.32-26.01 34.86-33.19 59.28-70.34 59.28-172.08C95.96 118.53 153.23 64 224 64c70.76 0 128.04 54.52 128.04 121.9 0 101.35 24.21 138.7 59.28 172.08C421.38 367.57 414.17 384 400 384z"></path></symbol><symbol viewBox="0 0 384 512" id="bookmark" xmlns="http://www.w3.org/2000/svg"><path d="M336 0H48C21.49 0 0 21.49 0 48v464l192-112 192 112V48c0-26.51-21.49-48-48-48zm16 456.287-160-93.333-160 93.333V48c0-8.822 7.178-16 16-16h288c8.822 0 16 7.178 16 16v408.287z"></path></symbol><symbol viewBox="0 0 384 512" id="bookmark-solid" xmlns="http://www.w3.org/2000/svg"><path d="M0 512V48C0 21.49 21.49 0 48 0h288c26.51 0 48 21.49 48 48v464L192 400 0 512z"></path></symbol><symbol class="aosvg-inline--fa aofa-calendar aofa-w-14" viewBox="0 0 448 512" id="calendar" xmlns="http://www.w3.org/2000/svg"><path d="M400 64h-48V12c0-6.627-5.373-12-12-12h-8c-6.627 0-12 5.373-12 12v52H128V12c0-6.627-5.373-12-12-12h-8c-6.627 0-12 5.373-12 12v52H48C21.49 64 0 85.49 0 112v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zM48 96h352c8.822 0 16 7.178 16 16v48H32v-48c0-8.822 7.178-16 16-16zm352 384H48c-8.822 0-16-7.178-16-16V192h384v272c0 8.822-7.178 16-16 16z"></path></symbol><symbol class="aqsvg-inline--fa aqfa-camera aqfa-w-16" viewBox="0 0 512 512" id="camera" xmlns="http://www.w3.org/2000/svg"><path d="M324.3 64c3.3 0 6.3 2.1 7.5 5.2l22.1 58.8H464c8.8 0 16 7.2 16 16v288c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V144c0-8.8 7.2-16 16-16h110.2l20.1-53.6c2.3-6.2 8.3-10.4 15-10.4h131m0-32h-131c-20 0-37.9 12.4-44.9 31.1L136 96H48c-26.5 0-48 21.5-48 48v288c0 26.5 21.5 48 48 48h416c26.5 0 48-21.5 48-48V144c0-26.5-21.5-48-48-48h-88l-14.3-38c-5.8-15.7-20.7-26-37.4-26zM256 408c-66.2 0-120-53.8-120-120s53.8-120 120-120 120 53.8 120 120-53.8 120-120 120zm0-208c-48.5 0-88 39.5-88 88s39.5 88 88 88 88-39.5 88-88-39.5-88-88-88z"></path></symbol><symbol class="apsvg-inline--fa apfa-camera apfa-w-16" viewBox="0 0 512 512" id="camera-solid" xmlns="http://www.w3.org/2000/svg"><path d="M512 144v288c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V144c0-26.5 21.5-48 48-48h88l12.3-32.9c7-18.7 24.9-31.1 44.9-31.1h125.5c20 0 37.9 12.4 44.9 31.1L376 96h88c26.5 0 48 21.5 48 48zM376 288c0-66.2-53.8-120-120-120s-120 53.8-120 120 53.8 120 120 120 120-53.8 120-120zm-32 0c0 48.5-39.5 88-88 88s-88-39.5-88-88 39.5-88 88-88 88 39.5 88 88z"></path></symbol><symbol viewBox="0 0 512 512" id="chart-bar" xmlns="http://www.w3.org/2000/svg"><path d="M424 352h16c4.4 0 8-3.6 8-8V104c0-4.4-3.6-8-8-8h-16c-4.4 0-8 3.6-8 8v240c0 4.4 3.6 8 8 8zm-96 0h16c4.4 0 8-3.6 8-8V200c0-4.4-3.6-8-8-8h-16c-4.4 0-8 3.6-8 8v144c0 4.4 3.6 8 8 8zm-192 0h16c4.4 0 8-3.6 8-8v-80c0-4.4-3.6-8-8-8h-16c-4.4 0-8 3.6-8 8v80c0 4.4 3.6 8 8 8zm96 0h16c4.4 0 8-3.6 8-8V136c0-4.4-3.6-8-8-8h-16c-4.4 0-8 3.6-8 8v208c0 4.4 3.6 8 8 8zm272 64H32V72c0-4.42-3.58-8-8-8H8c-4.42 0-8 3.58-8 8v360c0 8.84 7.16 16 16 16h488c4.42 0 8-3.58 8-8v-16c0-4.42-3.58-8-8-8z"></path></symbol><symbol class="axsvg-inline--fa axfa-check axfa-w-14" viewBox="0 0 448 512" id="check" xmlns="http://www.w3.org/2000/svg"><path d="M413.505 91.951 133.49 371.966l-98.995-98.995c-4.686-4.686-12.284-4.686-16.971 0L6.211 284.284c-4.686 4.686-4.686 12.284 0 16.971l118.794 118.794c4.686 4.686 12.284 4.686 16.971 0l299.813-299.813c4.686-4.686 4.686-12.284 0-16.971l-11.314-11.314c-4.686-4.686-12.284-4.686-16.97 0z"></path></symbol><symbol class="atsvg-inline--fa atfa-check-circle atfa-w-16" viewBox="0 0 512 512" id="check-circle" xmlns="http://www.w3.org/2000/svg"><path d="M256 8C119.033 8 8 119.033 8 256s111.033 248 248 248 248-111.033 248-248S392.967 8 256 8zm0 464c-118.664 0-216-96.055-216-216 0-118.663 96.055-216 216-216 118.664 0 216 96.055 216 216 0 118.663-96.055 216-216 216zm141.63-274.961L217.15 376.071c-4.705 4.667-12.303 4.637-16.97-.068l-85.878-86.572c-4.667-4.705-4.637-12.303.068-16.97l8.52-8.451c4.705-4.667 12.303-4.637 16.97.068l68.976 69.533 163.441-162.13c4.705-4.667 12.303-4.637 16.97.068l8.451 8.52c4.668 4.705 4.637 12.303-.068 16.97z"></path></symbol><symbol class="assvg-inline--fa asfa-check-circle asfa-w-16" viewBox="0 0 512 512" id="check-circle-solid" xmlns="http://www.w3.org/2000/svg"><path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"></path></symbol><symbol viewBox="0 0 512 512" id="check-solid" xmlns="http://www.w3.org/2000/svg"><path d="m173.898 439.404-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"></path></symbol><symbol class="awsvg-inline--fa awfa-check-square awfa-w-14" viewBox="0 0 448 512" id="check-square" xmlns="http://www.w3.org/2000/svg"><path d="M400 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zm0 32c8.823 0 16 7.178 16 16v352c0 8.822-7.177 16-16 16H48c-8.822 0-16-7.178-16-16V80c0-8.822 7.178-16 16-16h352m-34.301 98.293-8.451-8.52c-4.667-4.705-12.265-4.736-16.97-.068l-163.441 162.13-68.976-69.533c-4.667-4.705-12.265-4.736-16.97-.068l-8.52 8.451c-4.705 4.667-4.736 12.265-.068 16.97l85.878 86.572c4.667 4.705 12.265 4.736 16.97.068l180.48-179.032c4.704-4.667 4.735-12.265.068-16.97z"></path></symbol><symbol class="avsvg-inline--fa avfa-check-square avfa-w-14" viewBox="0 0 448 512" id="check-square-solid" xmlns="http://www.w3.org/2000/svg"><path d="M400 480H48c-26.51 0-48-21.49-48-48V80c0-26.51 21.49-48 48-48h352c26.51 0 48 21.49 48 48v352c0 26.51-21.49 48-48 48zm-204.686-98.059 184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.248-16.379-6.249-22.628 0L184 302.745l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.25 16.379 6.25 22.628.001z"></path></symbol><symbol class="bbsvg-inline--fa bbfa-circle bbfa-w-16" viewBox="0 0 512 512" id="circle" xmlns="http://www.w3.org/2000/svg"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm216 248c0 118.7-96.1 216-216 216-118.7 0-216-96.1-216-216 0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216z"></path></symbol><symbol viewBox="0 0 512 512" style="enable-background:new 0 0 512 512" xml:space="preserve" id="circle-nodes" xmlns="http://www.w3.org/2000/svg"><path d="M431.9 236.3c-20.8 0-39.6 8.3-53.5 21.7L228.6 108c3.4-8.7 5.3-18.1 5.3-27.9 0-42.5-34.4-76.9-76.9-76.9S80.1 37.6 80.1 80.1c0 31.7 19.2 59 46.6 70.7L83.5 355.4c-1.1 0-2.3-.1-3.4-.1-42.5 0-76.9 34.4-76.9 76.9S37.6 509 80.1 509c41.3 0 74.9-32.5 76.8-73.3l214.4-75.4c14.1 18.1 36 29.7 60.7 29.7 42.5 0 76.9-34.4 76.9-76.9s-34.5-76.8-77-76.8zM156.9 38c23.2 0 42 18.8 42 42s-18.8 42-42 42-42-18.8-42-42 18.8-42 42-42zM80.1 474.2c-23.2 0-42-18.8-42-42s18.8-42 42-42 42 18.8 42 42-18.8 42-42 42zm70.6-72.4c-6.9-16.1-19.1-29.3-34.4-37.5l43.9-207.5c18.8-.8 35.9-8.3 48.9-20.3L359.6 287c-2.9 8.1-4.5 16.9-4.5 26 0 5.6.6 11 1.7 16.2l-206.1 72.6zm281.2-46.6c-23.2 0-42-18.8-42-42s18.8-42 42-42 42 18.8 42 42-18.7 42-42 42z"></path></symbol><symbol class="azsvg-inline--fa azfa-circle-notch azfa-w-16" viewBox="0 0 512 512" id="circle-notch" xmlns="http://www.w3.org/2000/svg"><path d="M288 24.103v8.169a11.995 11.995 0 0 0 9.698 11.768C396.638 63.425 472 150.461 472 256c0 118.663-96.055 216-216 216-118.663 0-216-96.055-216-216 0-104.534 74.546-192.509 174.297-211.978A11.993 11.993 0 0 0 224 32.253v-8.147c0-7.523-6.845-13.193-14.237-11.798C94.472 34.048 7.364 135.575 8.004 257.332c.72 137.052 111.477 246.956 248.531 246.667C393.255 503.711 504 392.789 504 256c0-121.187-86.924-222.067-201.824-243.704C294.807 10.908 288 16.604 288 24.103z"></path></symbol><symbol class="basvg-inline--fa bafa-circle bafa-w-16" viewBox="0 0 512 512" id="circle-solid" xmlns="http://www.w3.org/2000/svg"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8z"></path></symbol><symbol class="bcsvg-inline--fa bcfa-clock bcfa-w-16" viewBox="0 0 512 512" id="clock" xmlns="http://www.w3.org/2000/svg"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm216 248c0 118.7-96.1 216-216 216-118.7 0-216-96.1-216-216 0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216zm-148.9 88.3-81.2-59c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h14c6.6 0 12 5.4 12 12v146.3l70.5 51.3c5.4 3.9 6.5 11.4 2.6 16.8l-8.2 11.3c-3.9 5.3-11.4 6.5-16.8 2.6z"></path></symbol><symbol class="besvg-inline--fa befa-cog befa-w-16" viewBox="0 0 512 512" id="cog" xmlns="http://www.w3.org/2000/svg"><path d="m482.696 299.276-32.61-18.827a195.168 195.168 0 0 0 0-48.899l32.61-18.827c9.576-5.528 14.195-16.902 11.046-27.501-11.214-37.749-31.175-71.728-57.535-99.595-7.634-8.07-19.817-9.836-29.437-4.282l-32.562 18.798a194.125 194.125 0 0 0-42.339-24.48V38.049c0-11.13-7.652-20.804-18.484-23.367-37.644-8.909-77.118-8.91-114.77 0-10.831 2.563-18.484 12.236-18.484 23.367v37.614a194.101 194.101 0 0 0-42.339 24.48L105.23 81.345c-9.621-5.554-21.804-3.788-29.437 4.282-26.36 27.867-46.321 61.847-57.535 99.595-3.149 10.599 1.47 21.972 11.046 27.501l32.61 18.827a195.168 195.168 0 0 0 0 48.899l-32.61 18.827c-9.576 5.528-14.195 16.902-11.046 27.501 11.214 37.748 31.175 71.728 57.535 99.595 7.634 8.07 19.817 9.836 29.437 4.283l32.562-18.798a194.08 194.08 0 0 0 42.339 24.479v37.614c0 11.13 7.652 20.804 18.484 23.367 37.645 8.909 77.118 8.91 114.77 0 10.831-2.563 18.484-12.236 18.484-23.367v-37.614a194.138 194.138 0 0 0 42.339-24.479l32.562 18.798c9.62 5.554 21.803 3.788 29.437-4.283 26.36-27.867 46.321-61.847 57.535-99.595 3.149-10.599-1.47-21.972-11.046-27.501zm-65.479 100.461-46.309-26.74c-26.988 23.071-36.559 28.876-71.039 41.059v53.479a217.145 217.145 0 0 1-87.738 0v-53.479c-33.621-11.879-43.355-17.395-71.039-41.059l-46.309 26.74c-19.71-22.09-34.689-47.989-43.929-75.958l46.329-26.74c-6.535-35.417-6.538-46.644 0-82.079l-46.329-26.74c9.24-27.969 24.22-53.869 43.929-75.969l46.309 26.76c27.377-23.434 37.063-29.065 71.039-41.069V44.464a216.79 216.79 0 0 1 87.738 0v53.479c33.978 12.005 43.665 17.637 71.039 41.069l46.309-26.76c19.709 22.099 34.689 47.999 43.929 75.969l-46.329 26.74c6.536 35.426 6.538 46.644 0 82.079l46.329 26.74c-9.24 27.968-24.219 53.868-43.929 75.957zM256 160c-52.935 0-96 43.065-96 96s43.065 96 96 96 96-43.065 96-96-43.065-96-96-96zm0 160c-35.29 0-64-28.71-64-64s28.71-64 64-64 64 28.71 64 64-28.71 64-64 64z"></path></symbol><symbol class="bdsvg-inline--fa bdfa-cog bdfa-w-16" viewBox="0 0 512 512" id="cog-solid" xmlns="http://www.w3.org/2000/svg"><path d="m487.4 315.7-42.6-24.6c4.3-23.2 4.3-47 0-70.2l42.6-24.6c4.9-2.8 7.1-8.6 5.5-14-11.1-35.6-30-67.8-54.7-94.6-3.8-4.1-10-5.1-14.8-2.3L380.8 110c-17.9-15.4-38.5-27.3-60.8-35.1V25.8c0-5.6-3.9-10.5-9.4-11.7-36.7-8.2-74.3-7.8-109.2 0-5.5 1.2-9.4 6.1-9.4 11.7V75c-22.2 7.9-42.8 19.8-60.8 35.1L88.7 85.5c-4.9-2.8-11-1.9-14.8 2.3-24.7 26.7-43.6 58.9-54.7 94.6-1.7 5.4.6 11.2 5.5 14L67.3 221c-4.3 23.2-4.3 47 0 70.2l-42.6 24.6c-4.9 2.8-7.1 8.6-5.5 14 11.1 35.6 30 67.8 54.7 94.6 3.8 4.1 10 5.1 14.8 2.3l42.6-24.6c17.9 15.4 38.5 27.3 60.8 35.1v49.2c0 5.6 3.9 10.5 9.4 11.7 36.7 8.2 74.3 7.8 109.2 0 5.5-1.2 9.4-6.1 9.4-11.7v-49.2c22.2-7.9 42.8-19.8 60.8-35.1l42.6 24.6c4.9 2.8 11 1.9 14.8-2.3 24.7-26.7 43.6-58.9 54.7-94.6 1.5-5.5-.7-11.3-5.6-14.1zM256 336c-44.1 0-80-35.9-80-80s35.9-80 80-80 80 35.9 80 80-35.9 80-80 80z"></path></symbol><symbol class="bgsvg-inline--fa bgfa-comment bgfa-w-16" viewBox="0 0 512 512" id="comment" xmlns="http://www.w3.org/2000/svg"><path d="M256 64c123.5 0 224 79 224 176S379.5 416 256 416c-28.3 0-56.3-4.3-83.2-12.8l-15.2-4.8-13 9.2c-23 16.3-58.5 35.3-102.6 39.6 12-15.1 29.8-40.4 40.8-69.6l7.1-18.7-13.7-14.6C47.3 313.7 32 277.6 32 240c0-97 100.5-176 224-176m0-32C114.6 32 0 125.1 0 240c0 47.6 19.9 91.2 52.9 126.3C38 405.7 7 439.1 6.5 439.5c-6.6 7-8.4 17.2-4.6 26 3.8 8.8 12.4 14.5 22 14.5 61.5 0 110-25.7 139.1-46.3 29 9.1 60.2 14.3 93 14.3 141.4 0 256-93.1 256-208S397.4 32 256 32z"></path></symbol><symbol class="bfsvg-inline--fa bffa-comment bffa-w-16" viewBox="0 0 512 512" id="comment-solid" xmlns="http://www.w3.org/2000/svg"><path d="M256 32C114.6 32 0 125.1 0 240c0 49.6 21.4 95 57 130.7C44.5 421.1 2.7 466 2.2 466.5c-2.2 2.3-2.8 5.7-1.5 8.7S4.8 480 8 480c66.3 0 116-31.8 140.6-51.4 32.7 12.3 69 19.4 107.4 19.4 141.4 0 256-93.1 256-208S397.4 32 256 32z"></path></symbol><symbol class="bhsvg-inline--fa bhfa-comments bhfa-w-18" viewBox="0 0 576 512" id="comments-solid" xmlns="http://www.w3.org/2000/svg"><path d="M416 192c0-88.4-93.1-160-208-160S0 103.6 0 192c0 34.3 14.1 65.9 38 92-13.4 30.2-35.5 54.2-35.8 54.5-2.2 2.3-2.8 5.7-1.5 8.7S4.8 352 8 352c36.6 0 66.9-12.3 88.7-25 32.2 15.7 70.3 25 111.3 25 114.9 0 208-71.6 208-160zm122 220c23.9-26 38-57.7 38-92 0-66.9-53.5-124.2-129.3-148.1.9 6.6 1.3 13.3 1.3 20.1 0 105.9-107.7 192-240 192-10.8 0-21.3-.8-31.7-1.9C207.8 439.6 281.8 480 368 480c41 0 79.1-9.2 111.3-25 21.8 12.7 52.1 25 88.7 25 3.2 0 6.1-1.9 7.3-4.8 1.3-2.9.7-6.3-1.5-8.7-.3-.3-22.4-24.2-35.8-54.5z"></path></symbol><symbol viewBox="0 0 512 512" id="cookie-bite-solid" xmlns="http://www.w3.org/2000/svg"><path d="M510.5 255.8c-70-.9-126.5-57.7-126.5-127.9-70.2 0-127-56.5-127.9-126.5-27.3-4.1-55.1.3-79.7 12.8l-69.1 35.2a132.2 132.2 0 0 0-57.8 57.8l-35.1 68.9a132.6 132.6 0 0 0-12.8 81l12.1 76.3a132.5 132.5 0 0 0 37.2 73l54.8 54.8a132 132 0 0 0 72.7 37.1l76.7 12.2c27.5 4.4 55.7-.1 80.5-12.8l69.1-35.2a132.3 132.3 0 0 0 57.8-57.8l35.1-68.9c12.6-24.6 17-52.6 12.9-79.9zM176 368c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm32-160c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm160 128c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z"></path></symbol><symbol viewBox="0 0 448 512" id="copy" xmlns="http://www.w3.org/2000/svg"><path d="m433.941 65.941-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path></symbol><symbol class="blsvg-inline--fa blfa-credit-card blfa-w-18" viewBox="0 0 576 512" id="creditcard" xmlns="http://www.w3.org/2000/svg"><path d="M528 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h480c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM48 64h480c8.8 0 16 7.2 16 16v48H32V80c0-8.8 7.2-16 16-16zm480 384H48c-8.8 0-16-7.2-16-16V224h512v208c0 8.8-7.2 16-16 16zm-336-84v8c0 6.6-5.4 12-12 12h-72c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h72c6.6 0 12 5.4 12 12zm192 0v8c0 6.6-5.4 12-12 12H236c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h136c6.6 0 12 5.4 12 12z"></path></symbol><symbol class="bksvg-inline--fa bkfa-credit-card bkfa-w-18" viewBox="0 0 576 512" id="creditcard-solid" xmlns="http://www.w3.org/2000/svg"><path d="M0 432c0 26.5 21.5 48 48 48h480c26.5 0 48-21.5 48-48V256H0v176zm192-68c0-6.6 5.4-12 12-12h136c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H204c-6.6 0-12-5.4-12-12v-40zm-128 0c0-6.6 5.4-12 12-12h72c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H76c-6.6 0-12-5.4-12-12v-40zM576 80v48H0V80c0-26.5 21.5-48 48-48h480c26.5 0 48 21.5 48 48z"></path></symbol><symbol class="bmsvg-inline--fa bmfa-desktop bmfa-w-18" viewBox="0 0 576 512" id="desktop" xmlns="http://www.w3.org/2000/svg"><path d="M528 0H48C21.5 0 0 21.5 0 48v288c0 26.5 21.5 48 48 48h192l-24 96h-72c-8.8 0-16 7.2-16 16s7.2 16 16 16h288c8.8 0 16-7.2 16-16s-7.2-16-16-16h-72l-24-96h192c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zM249 480l16-64h46l16 64h-78zm295-144c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V48c0-8.8 7.2-16 16-16h480c8.8 0 16 7.2 16 16v288z"></path></symbol><symbol viewBox="0 0 512 512" style="enable-background:new 0 0 512 512" xml:space="preserve" id="dot-circle" xmlns="http://www.w3.org/2000/svg"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 464c-118.7 0-216-96.1-216-216 0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216 0 118.7-96.1 216-216 216zm0-296c-44.2 0-80 35.8-80 80s35.8 80 80 80 80-35.8 80-80-35.8-80-80-80z"></path></symbol><symbol viewBox="0 122.1 595.3 597.4" xml:space="preserve" id="ebplus" xmlns="http://www.w3.org/2000/svg"><path d="M237.4 122.1h120.5v238.5h237.4V481H357.9v238.5H237.4V481H0V360.5h237.4V122.1z"></path></symbol><symbol viewBox="0 0 365 365" id="ebplus-black" xmlns="http://www.w3.org/2000/svg"><path style="fill:#000" d="M135 0h95v365h-95z"></path><path style="fill:#ddd" d="M135 230v33.493L230 230h-95z"></path><path transform="rotate(90 182.5 182.5)" style="fill:#000" d="M135 0h95v365h-95z"></path></symbol><symbol viewBox="0 0 72.8 72.8" style="enable-background:new 0 0 72.8 72.8" xml:space="preserve" id="ebplus-circle-solid" xmlns="http://www.w3.org/2000/svg"><path d="M36.4 0C16.3 0 0 16.3 0 36.4s16.3 36.4 36.4 36.4 36.4-16.3 36.4-36.4S56.5 0 36.4 0zm20.1 41.9H42.2v14.2H30.6V41.9H16.3V31.4h14.2V17.2h11.7v14.1h14.2v10.6z"></path></symbol><symbol viewBox="0 0 365 365" id="ebplus-white" xmlns="http://www.w3.org/2000/svg"><path style="fill:#fff" d="M135 0h95v365h-95z"></path><path style="fill:#690000" d="M135 230v33.493L230 230h-95z"></path><path transform="rotate(90 182.5 182.5)" style="fill:#fff" d="M135 0h95v365h-95z"></path></symbol><symbol viewBox="0 0 365 365" id="ebplus-white-blackshadow" xmlns="http://www.w3.org/2000/svg"><path style="fill:#fff" d="M135 0h95v365h-95z"></path><path style="fill:#333" d="M135 230v33.493L230 230h-95z"></path><path transform="rotate(90 182.5 182.5)" style="fill:#fff" d="M135 0h95v365h-95z"></path></symbol><symbol class="bqsvg-inline--fa bqfa-edit bqfa-w-18" viewBox="0 0 576 512" id="edit" xmlns="http://www.w3.org/2000/svg"><path d="m417.8 315.5 20-20c3.8-3.8 10.2-1.1 10.2 4.2V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h292.3c5.3 0 8 6.5 4.2 10.2l-20 20c-1.1 1.1-2.7 1.8-4.2 1.8H48c-8.8 0-16 7.2-16 16v352c0 8.8 7.2 16 16 16h352c8.8 0 16-7.2 16-16V319.7c0-1.6.6-3.1 1.8-4.2zm145.9-191.2L251.2 436.8l-99.9 11.1c-13.4 1.5-24.7-9.8-23.2-23.2l11.1-99.9L451.7 12.3c16.4-16.4 43-16.4 59.4 0l52.6 52.6c16.4 16.4 16.4 43 0 59.4zm-93.6 48.4L403.4 106 169.8 339.5l-8.3 75.1 75.1-8.3 233.5-233.6zm71-85.2-52.6-52.6c-3.8-3.8-10.2-4-14.1 0L426 83.3l66.7 66.7 48.4-48.4c3.9-3.8 3.9-10.2 0-14.1z"></path></symbol><symbol viewBox="0 0 100 88" xml:space="preserve" id="ekstrabladet" xmlns="http://www.w3.org/2000/svg"><path fill="#E3141D" d="M0-.9h100V78l-49.5 9.5L0 77.6V-.9z"></path><path fill="#FFF" d="M23 42.3H10.6v-4.5h9.8v-3.4h-9.8v-4.6h11.5v-3.3h-16v19.6h17zM39.7 46.1l-6-8.8 5-5.4h-4.8l-5.2 5.6v-11h-3.9v19.6h3.9v-3.9l2.3-2.3 3.8 6.2z"></path><path fill="#FFF" d="M46.3 43.9c-2.4 0-3.1-.5-3.5-2h-3.7c0 3.1 2.5 4.9 6.7 4.9 4.7 0 7.5-1.8 7.5-4.8 0-2-1.6-3.7-3.6-4.1l-5.6-.9c-.6-.1-1.2-.7-1.2-1.4 0-.8.8-1.4 2.3-1.4 3 0 3.5.4 3.6 2h3.8v-.5c0-2.4-2.8-4.5-6.5-4.5-4.2 0-6.9 1.8-6.9 4.9 0 1.8 1.3 3.6 3 3.8l5.8 1c.8.1 1.3.5 1.3 1.2.1 1.2-.8 1.8-3 1.8zM56.5 42.6c0 2.6 1.7 4.2 4.7 4.2 1.1 0 2-.2 3.6-1v-1.9c-.7.1-1.7.1-2 .1-1.6 0-2.2-.6-2.2-1.8v-7.6h3.8V32h-3.8v-5.4h-2.9l-.1 1.2c-.6 3.8-.7 4.2-1.8 4.2h-2.5v2.6h3.4l-.2 8zM70.8 39.9c0-3.1 1.7-4.8 4.7-4.8h1.7v-3.6H76c-2.3 0-4.1 1.1-5.3 3.2V32h-3.8v14.2h4v-6.3zM91 41.5v-5.9c0-1.7-.2-2.3-1-2.8-1.3-1.1-3.4-1.6-5.8-1.6-4.3 0-6.3 1.4-6.6 4.8h3.7c.2-1.6 1-2 3-2 2.2 0 2.9.6 2.9 2.3 0 .7-.2 1-1.1 1.1l-4.1.5c-4.1.5-5.6 1.8-5.6 4.6 0 2.6 2 4.2 5.4 4.2 2.5 0 4.1-.8 5.5-2.9.8 2.2 1.8 2.9 3.7 2.9 1 0 1.8-.2 3.4-1.1v-1.8c-.8.1-1.4.1-1.7.1-1.2 0-1.7-.7-1.7-2.4zm-8 2.4c-1.4 0-2.3-.7-2.3-1.8 0-1.6.7-1.9 5.3-2.8l1.2-.2c0 3.2-1.3 4.8-4.2 4.8zM20.1 58.8c2.8-.6 4.2-2.2 4.2-4.4 0-2.6-2.4-4.7-5.5-4.7H6.1v19.5h12.5c3.7 0 6.4-2.2 6.4-5.3 0-2.7-1.6-4.2-4.9-5.1zm-9.5-6h5.9c2.3 0 3.1.6 3.1 2.3 0 1.8-.8 2.4-3.1 2.4h-5.9v-4.7zm5.9 12.9h-6v-5.3h6c2.4 0 3.5.8 3.5 2.6 0 2.1-.9 2.7-3.5 2.7zM26.9 49.8H31v19.5h-4.1zM47.4 64.9l-.1-6.9c-.1-2.3-2.5-3.6-6.6-3.6-5.1 0-6.9 1.2-7.1 4.8h3.8c.2-1.4.8-1.9 2.9-1.9 2.4 0 3.1.5 3.1 2.2 0 .7-.4 1-1.2 1.1-.2 0-1.9.1-4.1.5-3.8.5-5.4 1.8-5.4 4.6 0 2.6 1.9 4.2 5.3 4.2 2.6 0 4.1-.7 5.6-2.9.7 2 1.8 2.9 3.9 2.9 1 0 1.7-.2 2.9-.8v-2c-.5.1-.8.1-1.2.1-1.3-.1-1.8-.7-1.8-2.3zm-8 2.1c-1.7 0-2.5-.6-2.5-1.7 0-1.3 1-2 3.1-2.4 1.9-.2 1.8-.2 3.2-.6.1 3.1-1.2 4.7-3.8 4.7zM61.7 57.3c-1.3-1.9-2.8-2.8-4.9-2.8-3.8 0-6.7 3.2-6.7 7.6 0 4.8 2.5 7.8 6.6 7.8 2.3 0 3.4-.6 5.2-2.8v2.3h3.9V49.8h-4v7.5zm-4.1 9.8c-2.4 0-3.5-1.7-3.5-4.9 0-3 1.2-4.7 3.5-4.7 2.2 0 3.6 1.9 3.6 4.7 0 3-1.4 4.9-3.6 4.9zM75.5 54.6c-4.5 0-7.8 3.4-7.8 7.7 0 4.6 3.2 7.8 7.8 7.8 4.4 0 7.2-1.8 7.7-5.1h-3.8c-.5 1.6-1.3 2-3.4 2-2.8 0-4.1-1.3-4.1-4h11.3c0-5-3-8.4-7.7-8.4zM72 60.9c.2-2.3 1.3-3.5 3.4-3.5 2.2 0 3.2 1.1 3.4 3.5H72zM90.3 65.7v-7.6h4v-2.9h-4v-5.3h-2.9l-.1 1.1c-.7 4.2-.6 4.2-1.7 4.2h-2.3v2.9h3l-.1 6.9v.5c0 3.2 1.4 4.7 4.6 4.7 1.6 0 2.4-.1 3.7-.8v-2.2c-.8.1-1.7.1-2 .1-1.6-.1-2.2-.5-2.2-1.6z"></path></symbol><symbol class="brsvg-inline--fa brfa-envelope brfa-w-16" viewBox="0 0 512 512" id="envelope" xmlns="http://www.w3.org/2000/svg"><path d="M464 64H48C21.5 64 0 85.5 0 112v288c0 26.5 21.5 48 48 48h416c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM48 96h416c8.8 0 16 7.2 16 16v41.4c-21.9 18.5-53.2 44-150.6 121.3-16.9 13.4-50.2 45.7-73.4 45.3-23.2.4-56.6-31.9-73.4-45.3C85.2 197.4 53.9 171.9 32 153.4V112c0-8.8 7.2-16 16-16zm416 320H48c-8.8 0-16-7.2-16-16V195c22.8 18.7 58.8 47.6 130.7 104.7 20.5 16.4 56.7 52.5 93.3 52.3 36.4.3 72.3-35.5 93.3-52.3 71.9-57.1 107.9-86 130.7-104.7v205c0 8.8-7.2 16-16 16z"></path></symbol><symbol class="btsvg-inline--fa btfa-exclamation-circle btfa-w-16" viewBox="0 0 512 512" id="exclamation-circle" xmlns="http://www.w3.org/2000/svg"><path d="M256 40c118.621 0 216 96.075 216 216 0 119.291-96.61 216-216 216-119.244 0-216-96.562-216-216 0-119.203 96.602-216 216-216m0-32C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm-11.49 120h22.979c6.823 0 12.274 5.682 11.99 12.5l-7 168c-.268 6.428-5.556 11.5-11.99 11.5h-8.979c-6.433 0-11.722-5.073-11.99-11.5l-7-168c-.283-6.818 5.167-12.5 11.99-12.5zM256 340c-15.464 0-28 12.536-28 28s12.536 28 28 28 28-12.536 28-28-12.536-28-28-28z"></path></symbol><symbol class="bssvg-inline--fa bsfa-exclamation-circle bsfa-w-16" viewBox="0 0 512 512" id="exclamation-circle-solid" xmlns="http://www.w3.org/2000/svg"><path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346 7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"></path></symbol><symbol class="bvsvg-inline--fa bvfa-exclamation-triangle bvfa-w-18" viewBox="0 0 576 512" id="exclamation-triangle" xmlns="http://www.w3.org/2000/svg"><path d="M270.2 160h35.5c3.4 0 6.1 2.8 6 6.2l-7.5 196c-.1 3.2-2.8 5.8-6 5.8h-20.5c-3.2 0-5.9-2.5-6-5.8l-7.5-196c-.1-3.4 2.6-6.2 6-6.2zM288 388c-15.5 0-28 12.5-28 28s12.5 28 28 28 28-12.5 28-28-12.5-28-28-28zm281.5 52L329.6 24c-18.4-32-64.7-32-83.2 0L6.5 440c-18.4 31.9 4.6 72 41.6 72H528c36.8 0 60-40 41.5-72zM528 480H48c-12.3 0-20-13.3-13.9-24l240-416c6.1-10.6 21.6-10.7 27.7 0l240 416c6.2 10.6-1.5 24-13.8 24z"></path></symbol><symbol class="busvg-inline--fa bufa-exclamation-triangle bufa-w-18" viewBox="0 0 576 512" id="exclamation-triangle-solid" xmlns="http://www.w3.org/2000/svg"><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346 7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"></path></symbol><symbol class="bwsvg-inline--fa bwfa-expand bwfa-w-14" viewBox="0 0 448 512" id="expand" xmlns="http://www.w3.org/2000/svg"><path d="M0 180V56c0-13.3 10.7-24 24-24h124c6.6 0 12 5.4 12 12v8c0 6.6-5.4 12-12 12H32v116c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zM300 32h124c13.3 0 24 10.7 24 24v124c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12V64H300c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12zm148 300v124c0 13.3-10.7 24-24 24H300c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h116V332c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12zM148 480H24c-13.3 0-24-10.7-24-24V332c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v116h116c6.6 0 12 5.4 12 12v8c0 6.6-5.4 12-12 12z"></path></symbol><symbol class="bxsvg-inline--fa bxfa-external-link-alt bxfa-w-16" viewBox="0 0 512 512" id="external-link" xmlns="http://www.w3.org/2000/svg"><path d="M440 256h-16a8 8 0 0 0-8 8v200a16 16 0 0 1-16 16H48a16 16 0 0 1-16-16V112a16 16 0 0 1 16-16h200a8 8 0 0 0 8-8V72a8 8 0 0 0-8-8H48a48 48 0 0 0-48 48v352a48 48 0 0 0 48 48h352a48 48 0 0 0 48-48V264a8 8 0 0 0-8-8ZM480 0h-.06l-96.16.17c-28.45 0-42.66 34.54-22.58 54.62l35.28 35.28-265 265a12 12 0 0 0 0 17l8.49 8.49a12 12 0 0 0 17 0l265-265 35.28 35.27c20 20 54.57 6 54.62-22.57l.13-96.21A32 32 0 0 0 480 0Zm-.17 128.17-96-96L480 32Z"></path></symbol><symbol class="bysvg-inline--fa byfa-facebook-f byfa-w-10" viewBox="0 0 320 512" id="facebook" xmlns="http://www.w3.org/2000/svg"><path d="m279.14 288 14.22-92.66h-88.91v-60.13c0-25.35 12.42-50.06 52.24-50.06h40.42V6.26S260.43 0 225.36 0c-73.22 0-121.08 44.38-121.08 124.72v70.62H22.89V288h81.39v224h100.17V288z"></path></symbol><symbol viewBox="0 0 34 16.4" id="figcaption-pin" xmlns="http://www.w3.org/2000/svg"><path d="M15.6.8c.8-.8 2-.8 2.8 0l6.7 6.7c1.9 1.9 4.4 2.9 7.1 2.9H34v6H0v-6h1.9c2.7 0 5.2-1.1 7.1-2.9L15.6.8z" fill="var(--ebds-figcaption-bg)"></path><path d="m9.7 12.9 6.6-6.6c.4-.4 1-.4 1.4 0l6.6 6.6c.6.6.2 1.7-.7 1.7H10.4c-.9 0-1.3-1-.7-1.7z"></path></symbol><symbol class="bzsvg-inline--fa bzfa-filter bzfa-w-16" viewBox="0 0 512 512" id="filter-solid" xmlns="http://www.w3.org/2000/svg"><path d="M487.976 0H24.028C2.71 0-8.047 25.866 7.058 40.971L192 225.941V432c0 7.831 3.821 15.17 10.237 19.662l80 55.98C298.02 518.69 320 507.493 320 487.98V225.941l184.947-184.97C520.021 25.896 509.338 0 487.976 0z"></path></symbol><symbol viewBox="0 0 496 512" id="futbol" xmlns="http://www.w3.org/2000/svg"><path d="M483.7 179.4C449.7 74.6 352.5 8 248.1 8 81.2 8-40 171.4 12.3 332.6 46.3 437.4 143.7 504 248 504c166.9 0 288-163.4 235.7-324.6zm-43 173.7-94.3 11.6-17.8-24.9 33.7-104.1 28.9-9 69.6 65c-3.6 21.1-10.3 41.8-20.1 61.4zM35.6 291.5l69.4-64.9 28.9 9 33.9 103.7-18.1 25.2-94.2-11.6c-13-26-17.2-45.2-19.9-61.4zm196.5-180.7v32.9L146.2 206l-31.5-9.8-18-93.9c15.3-15.1 32.8-27.8 52-37.8l83.4 46.3zm149.4 85.4L350 206l-85.9-62.3v-32.9l83.6-46.4c19.1 10 36.7 22.7 52 37.9l-18.2 93.9zm-215.4 35 82-59.5 82.1 59.6-31.1 96H197.5l-31.4-96.1zm297.7 19.5L412.7 203l13.3-68.3c34.5 50.8 37.3 97.2 37.8 116zM309.2 49.2l-61.1 33.9-61-33.8c71.5-21.2 122-.1 122.1-.1zM70.3 134.1 83.5 203l-51.1 47.5c.8-31.8 8.7-63.4 23.6-92.6 4.2-8.3 9.1-16.2 14.3-23.8zm7.5 254 68.7 8.4 29.2 62.7c-38.8-13.8-72.7-38.5-97.9-71.1zm137.9 81.3-40.1-86 17.4-24.2h110.2l17.3 24.2-40.1 86c-22.7 3.5-42.4 3.4-64.7 0zm104.8-10.2 29.2-62.7 69-8.5c-25 32.6-58.8 57.1-98.2 71.2z"></path></symbol><symbol viewBox="0 0 55 55" style="enable-background:new 0 0 55 55" xml:space="preserve" id="gallery" xmlns="http://www.w3.org/2000/svg"><path d="M43.7 54.5c-.3 0-.6 0-.9-.1l-32.7-6.6c-.8-.2-1.3-1-1.2-1.8.2-.8 1-1.3 1.8-1.2l32.8 6.6h.2c.1 0 .1 0 .6-.1h.1s0-.1.1-.1V51l7.1-35c0-.2 0-.4-.1-.6-.1-.1-.2-.2-.4-.3l-5.1-.8c-.8-.1-1.4-.9-1.2-1.7.1-.8.9-1.4 1.7-1.2l4.9.9c1 .2 1.8.7 2.4 1.5.6.9.8 1.9.6 2.9l-7.1 34.9c-.1 1-.8 2-1.7 2.5-.1 0-.1.1-.2.1l-.2.1c-.4 0-.9.2-1.5.2zm-4.1-11.2H4.2C2 43.3.5 41.7.5 39.6V4.2C.5 2 2.1.5 4.2.5h35.4c2.2 0 3.7 1.6 3.7 3.7v35.4c0 2.2-1.5 3.7-3.7 3.7zM3.5 36.7v2.9c0 .5.2.7.7.7h35.4c.5 0 .7-.2.7-.7v-2.9H3.5zm34.2-3h2.6V4.2c0-.5-.2-.7-.7-.7H4.2c-.5 0-.7.2-.7.7v29.5h2.6c.2-1.7.6-3.4 1.4-5.1 1.2-2.4 4.8-3.7 9.8-5.4.2-.5.2-1.7 0-2.1-2.1-2.4-3-5.2-2.8-8.1 0-2.2.6-4 1.9-5.5C17.8 5.9 19.7 5 22 5c2 0 3.9.9 5.5 2.4l.1.1c1.3 1.6 1.9 3.5 1.7 5.6.2 3-.8 5.9-2.7 7.9-.2.5-.2 1.8 0 2.3.6.2 1.3.5 1.9.7 4 1.5 6.9 2.6 7.9 4.6.7 1.7 1.2 3.4 1.3 5.1zm-28.6 0h25.6c-.2-1.3-.5-2.6-1.1-3.9-.4-.9-3.4-2-6.2-3-.7-.3-1.4-.5-2.2-.8-.5-.2-1.2-.7-1.5-1.8-.5-1.5-.3-3.9.4-4.9.1-.1.1-.2.2-.2 1.4-1.4 2.2-3.6 2-5.9v-.3c.2-1.3-.1-2.5-.9-3.4-.6-.6-1.8-1.5-3.3-1.5-1.4 0-2.5.5-3.3 1.5-.8 1-1.2 2.2-1.2 3.7v.1c-.2 2.2.5 4.2 2.1 6 .9.9 1.1 3.3.8 4.6-.4 1.6-1.3 2.1-1.8 2.3-2.8.9-7.5 2.5-8.2 3.9-.8 1-1.2 2.3-1.4 3.6zm8.2-12.6c0 .1 0 .1 0 0 0 .1 0 .1 0 0z"></path></symbol><symbol viewBox="0 0 640 512" id="gamepad-light" xmlns="http://www.w3.org/2000/svg"><path d="M480.07 96H160a160 160 0 1 0 114.24 272h91.52A160 160 0 1 0 480.07 96zM480 384a127 127 0 0 1-91.37-38.4l-9.43-9.6H260.8l-9.41 9.6A127 127 0 0 1 160 384c-70.57 0-128-57.42-128-128s57.43-128 128-128h320c70.61 0 128 57.42 128 128s-57.43 128-128 128zM222.18 236.36h-42.54v-42.54a9.86 9.86 0 0 0-9.82-9.82h-19.64a9.86 9.86 0 0 0-9.82 9.82v42.54H97.82a9.86 9.86 0 0 0-9.82 9.82v19.64a9.86 9.86 0 0 0 9.82 9.82h42.54v42.54a9.86 9.86 0 0 0 9.82 9.82h19.64a9.86 9.86 0 0 0 9.82-9.82v-42.54h42.54a9.86 9.86 0 0 0 9.82-9.82v-19.64a9.86 9.86 0 0 0-9.82-9.82zM448 256a32 32 0 1 0 32 32 32 32 0 0 0-32-32zm64-64a32 32 0 1 0 32 32 32 32 0 0 0-32-32z"></path></symbol><symbol viewBox="0 0 576 512" id="glasses" xmlns="http://www.w3.org/2000/svg"><path d="M560.51 225.9 528.75 98.64C522.05 71.78 495.01 32 443.33 32c-15.63 0-23.03 2.94-43.02 9.6-8.39 2.79-12.92 11.86-10.12 20.24l5.06 15.18c2.24 6.7 8.48 10.94 15.18 10.94 3.54 0 4.82-.74 18.23-5.21 26.07-8.68 48.2 6.13 53.53 27.54l29.67 118.68C490.97 215.88 466.47 208 440 208c-55.09 0-102.27 32.91-123.65 80h-56.7c-21.38-47.09-68.56-80-123.65-80-26.47 0-50.97 7.88-71.86 20.96l29.67-118.68c5.32-21.41 27.46-36.22 53.53-27.54 13.42 4.47 14.7 5.21 18.23 5.21 6.7 0 12.94-4.24 15.18-10.94l5.06-15.18c2.8-8.38-1.73-17.45-10.12-20.24C155.7 34.94 148.3 32 132.67 32 81 32 53.95 71.78 47.25 98.64L15.49 225.9C2.16 279.34 0 300.12 0 344c0 75.11 60.89 136 136 136 72.37 0 130.97-56.69 135.19-128h33.61c4.22 71.31 62.82 128 135.19 128 75.11 0 136-60.89 136-136 .01-43.88-2.15-64.66-15.48-118.1zM136 432c-48.52 0-88-39.48-88-88s39.48-88 88-88 88 39.48 88 88-39.48 88-88 88zm304 0c-48.52 0-88-39.48-88-88s39.48-88 88-88 88 39.48 88 88-39.48 88-88 88z"></path></symbol><symbol viewBox="0 0 53 53" style="enable-background:new 0 0 53 53" xml:space="preserve" id="headphones" xmlns="http://www.w3.org/2000/svg"><path d="M14.9 52.7c-.5 0-1.1-.1-1.6-.3-.9-.4-1.6-1.2-2-2.3L6.7 38.3c-.4-1-.4-2.1.1-3 .4-.9 1.2-1.6 2.2-1.9l2-.9c1-.4 2.1-.4 3.1 0 .9.4 1.6 1.2 2 2.3l4.6 11.8c.4 1 .4 2.1-.1 3-.4.9-1.2 1.6-2.2 1.9l-2 .9c-.5.2-1 .3-1.5.3zm-2.4-17.6c-.1 0-.2 0-.3.1l-2 .9s-.1 0-.1.1c-.2.1-.4.2-.5.4-.1.2-.1.4 0 .7l4.7 11.9c.1.3.2.5.4.6.2.1.4.1.7 0l2-.9s.1 0 .1-.1c.2-.1.4-.2.5-.4.1-.2.1-.4 0-.7l-4.7-11.9c-.1-.3-.2-.5-.4-.6-.2-.1-.3-.1-.4-.1zM38 52.6c-.5 0-.9-.1-1.3-.3l-2.2-1c-1.9-.8-2.9-3.1-2.2-5L37 34.6c.8-2 3.1-3 5-2.2l2.2 1c.9.3 1.6 1.1 2.1 2 .5 1 .5 2 .1 3l-4.7 11.9c-.4.9-1.1 1.7-2 2.1-.6.1-1.1.2-1.7.2zm2.7-17.5c-.3 0-.7.3-.9.6l-4.7 11.9c-.2.4.1.9.6 1.1l2.2 1c.3.1.9-.2 1-.6l4.7-11.9c.1-.2.1-.4 0-.6-.1-.2-.3-.4-.5-.5l-2.2-1h-.2zm-.4 14.5zm3.7 2.9c-.2 0-.5-.1-.7-.2-.7-.4-1-1.3-.6-2 .1-.1 6.8-12.6 6.8-23.8 0-12.7-10.3-23-23-23s-23 10.3-23 23c0 11.1 6.7 23.7 6.8 23.8.4.7.1 1.6-.6 2-.7.4-1.6.1-2-.6C7.4 51.2.5 38.4.5 26.5c0-14.3 11.7-26 26-26s26 11.7 26 26c0 11.9-6.9 24.7-7.2 25.2-.3.5-.8.8-1.3.8z"></path></symbol><symbol viewBox="0 0 512 512" id="headphones-klip" xmlns="http://www.w3.org/2000/svg"><path d="M256 32C114.52 32 0 146.497 0 288v49.714a24.001 24.001 0 0 0 12.319 20.966l19.702 10.977C32.908 430.748 82.698 480 144 480h24c13.255 0 24-10.745 24-24V280c0-13.255-10.745-24-24-24h-24c-40.744 0-76.402 21.758-96 54.287V288c0-114.691 93.309-208 208-208s208 93.309 208 208v22.287C444.402 277.758 408.744 256 368 256h-24c-13.255 0-24 10.745-24 24v176c0 13.255 10.745 24 24 24h24c61.302 0 111.092-49.252 111.979-110.344l19.702-10.977A24.001 24.001 0 0 0 512 337.713V288c0-141.48-114.497-256-256-256zM144 304v128c-35.29 0-64-28.71-64-64s28.71-64 64-64zm224 128V304c35.29 0 64 28.71 64 64s-28.71 64-64 64z"></path></symbol><symbol viewBox="0 0 512 512" id="headset" xmlns="http://www.w3.org/2000/svg"><path d="M192 208c0-17.67-14.33-32-32-32h-16c-35.35 0-64 28.65-64 64v48c0 35.35 28.65 64 64 64h16c17.67 0 32-14.33 32-32V208zm176 144c35.35 0 64-28.65 64-64v-48c0-35.35-28.65-64-64-64h-16c-17.67 0-32 14.33-32 32v112c0 17.67 14.33 32 32 32h16zM256 0C113.18 0 4.58 118.83 0 256v16c0 8.84 7.16 16 16 16h16c8.84 0 16-7.16 16-16v-16c0-114.69 93.31-208 208-208s208 93.31 208 208h-.12c.08 2.43.12 165.72.12 165.72 0 23.35-18.93 42.28-42.28 42.28H320c0-26.51-21.49-48-48-48h-32c-26.51 0-48 21.49-48 48s21.49 48 48 48h181.72c49.86 0 90.28-40.42 90.28-90.28V256C507.42 118.83 398.82 0 256 0z"></path></symbol><symbol class="cjsvg-inline--fa cjfa-heart cjfa-w-16" viewBox="0 0 512 512" id="heart" xmlns="http://www.w3.org/2000/svg"><path d="M462.3 62.7c-54.5-46.4-136-38.7-186.6 13.5L256 96.6l-19.7-20.3C195.5 34.1 113.2 8.7 49.7 62.7c-62.8 53.6-66.1 149.8-9.9 207.8l193.5 199.8c6.2 6.4 14.4 9.7 22.6 9.7 8.2 0 16.4-3.2 22.6-9.7L472 270.5c56.4-58 53.1-154.2-9.7-207.8zm-13.1 185.6L256.4 448.1 62.8 248.3c-38.4-39.6-46.4-115.1 7.7-161.2 54.8-46.8 119.2-12.9 142.8 11.5l42.7 44.1 42.7-44.1c23.2-24 88.2-58 142.8-11.5 54 46 46.1 121.5 7.7 161.2z"></path></symbol><symbol viewBox="0 0 512 512" style="enable-background:new 0 0 512 512" xml:space="preserve" id="heart-half-solid" xmlns="http://www.w3.org/2000/svg"><path d="m256 96.5-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c6.3 6.5 14.5 9.7 22.7 9.7V96.5z"></path></symbol><symbol class="cisvg-inline--fa cifa-heart cifa-w-16" viewBox="0 0 512 512" id="heart-solid" xmlns="http://www.w3.org/2000/svg"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3 0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"></path></symbol><symbol class="cksvg-inline--fa ckfa-history ckfa-w-16" viewBox="0 0 512 512" id="history" xmlns="http://www.w3.org/2000/svg"><path d="M20 24h10c6.627 0 12 5.373 12 12v94.625C85.196 57.047 165.239 7.715 256.793 8.001 393.18 8.428 504.213 120.009 504 256.396 503.786 393.181 392.834 504 256 504c-63.926 0-122.202-24.187-166.178-63.908-5.113-4.618-5.354-12.561-.482-17.433l7.069-7.069c4.503-4.503 11.749-4.714 16.482-.454C150.782 449.238 200.935 470 256 470c117.744 0 214-95.331 214-214 0-117.744-95.331-214-214-214-82.862 0-154.737 47.077-190.289 116H164c6.627 0 12 5.373 12 12v10c0 6.627-5.373 12-12 12H20c-6.627 0-12-5.373-12-12V36c0-6.627 5.373-12 12-12zm321.647 315.235 4.706-6.47c3.898-5.36 2.713-12.865-2.647-16.763L272 263.853V116c0-6.627-5.373-12-12-12h-8c-6.627 0-12 5.373-12 12v164.147l84.884 61.734c5.36 3.899 12.865 2.714 16.763-2.646z"></path></symbol><symbol class="cmsvg-inline--fa cmfa-info-circle cmfa-w-16" viewBox="0 0 512 512" id="info-circle" xmlns="http://www.w3.org/2000/svg"><path d="M256 40c118.621 0 216 96.075 216 216 0 119.291-96.61 216-216 216-119.244 0-216-96.562-216-216 0-119.203 96.602-216 216-216m0-32C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm-36 344h12V232h-12c-6.627 0-12-5.373-12-12v-8c0-6.627 5.373-12 12-12h48c6.627 0 12 5.373 12 12v140h12c6.627 0 12 5.373 12 12v8c0 6.627-5.373 12-12 12h-72c-6.627 0-12-5.373-12-12v-8c0-6.627 5.373-12 12-12zm36-240c-17.673 0-32 14.327-32 32s14.327 32 32 32 32-14.327 32-32-14.327-32-32-32z"></path></symbol><symbol class="clsvg-inline--fa clfa-info-circle clfa-w-16" viewBox="0 0 512 512" id="info-circle-solid" xmlns="http://www.w3.org/2000/svg"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"></path></symbol><symbol class="cnsvg-inline--fa cnfa-instagram cnfa-w-14" viewBox="0 0 448 512" id="instagram" xmlns="http://www.w3.org/2000/svg"><path d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"></path></symbol><symbol viewBox="0 0 10 16" id="lightning" xmlns="http://www.w3.org/2000/svg"><path d="M3.339 9.491.488 8.394a.733.733 0 0 1-.292-1.187L6.621.254C7.16-.332 8.156.179 7.95.938l-1.51 5.57 2.85 1.098a.733.733 0 0 1 .292 1.187l-6.425 6.953c-.541.586-1.535.075-1.33-.684l1.512-5.57Z"></path></symbol><symbol class="cpsvg-inline--fa cpfa-linkedin-in cpfa-w-14" viewBox="0 0 448 512" id="linkedin" xmlns="http://www.w3.org/2000/svg"><path d="M100.28 448H7.4V148.9h92.88zM53.79 108.1C24.09 108.1 0 83.5 0 53.8a53.79 53.79 0 0 1 107.58 0c0 29.7-24.1 54.3-53.79 54.3zM447.9 448h-92.68V302.4c0-34.7-.7-79.2-48.29-79.2-48.29 0-55.69 37.7-55.69 76.7V448h-92.78V148.9h89.08v40.8h1.3c12.4-23.5 42.69-48.3 87.88-48.3 94 0 111.28 61.9 111.28 142.3V448z"></path></symbol><symbol viewBox="0 0 512 512" id="list-ol" xmlns="http://www.w3.org/2000/svg"><path d="m61.77 401 17.5-20.15a19.92 19.92 0 0 0 5.07-14.19v-3.31C84.34 356 80.5 352 73 352H16a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8h22.84a154.82 154.82 0 0 0-11 12.31l-5.61 7c-4 5.07-5.25 10.13-2.8 14.88l1.05 1.93c3 5.76 6.3 7.88 12.25 7.88h4.73c10.33 0 15.94 2.44 15.94 9.09 0 4.72-4.2 8.22-14.36 8.22a41.54 41.54 0 0 1-15.47-3.12c-6.49-3.88-11.74-3.5-15.6 3.12l-5.59 9.31c-3.73 6.13-3.2 11.72 2.62 15.94 7.71 4.69 20.39 9.44 37 9.44 34.16 0 48.5-22.75 48.5-44.12-.03-14.38-9.12-29.76-28.73-34.88zM12.1 320H80a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8H41.33c3.28-10.29 48.33-18.68 48.33-56.44 0-29.06-25-39.56-44.47-39.56-21.36 0-33.8 10-40.45 18.75-4.38 5.59-3 10.84 2.79 15.37l8.58 6.88c5.61 4.56 11 2.47 16.13-2.44a13.4 13.4 0 0 1 9.45-3.84c3.33 0 9.28 1.56 9.28 8.75C51 248.19 0 257.31 0 304.59v4C0 316 5.08 320 12.1 320zM16 160h64a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8H64V40a8 8 0 0 0-8-8H32a8 8 0 0 0-7.14 4.42l-8 16A8 8 0 0 0 24 64h8v64H16a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8zm488-80H168a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8h336a8 8 0 0 0 8-8V88a8 8 0 0 0-8-8zm0 320H168a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8h336a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8zm0-160H168a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8h336a8 8 0 0 0 8-8v-16a8 8 0 0 0-8-8z"></path></symbol><symbol class="crsvg-inline--fa crfa-lock crfa-w-14" viewBox="0 0 448 512" id="lock" xmlns="http://www.w3.org/2000/svg"><path d="M400 224h-16v-62.5C384 73.1 312.9.3 224.5 0 136-.3 64 71.6 64 160v64H48c-26.5 0-48 21.5-48 48v192c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V272c0-26.5-21.5-48-48-48zM96 160c0-70.6 57.4-128 128-128s128 57.4 128 128v64H96v-64zm304 320H48c-8.8 0-16-7.2-16-16V272c0-8.8 7.2-16 16-16h352c8.8 0 16 7.2 16 16v192c0 8.8-7.2 16-16 16z"></path></symbol><symbol class="cssvg-inline--fa csfa-map-marker-alt csfa-w-12" viewBox="0 0 384 512" id="mappin-solid" xmlns="http://www.w3.org/2000/svg"><path d="M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0zM192 272c44.183 0 80-35.817 80-80s-35.817-80-80-80-80 35.817-80 80 35.817 80 80 80z"></path></symbol><symbol viewBox="0 0 63.6 81.5" style="enable-background:new 0 0 63.6 81.5" xml:space="preserve" id="medielogin" xmlns="http://www.w3.org/2000/svg"><path d="M0 70.7h63.3v10.9H0z"></path><path d="m0 81.5 21.2-19.7v-14L0 67.5z"></path><path d="M31.8 0C14.2 0 0 14.2 0 31.8c0 13.8 8.9 25.6 21.2 30v-14c-5.2-3.4-8.6-9.3-8.6-16 0-10.6 8.6-19.2 19.2-19.2S51 21.2 51 31.8c0 6.7-3.4 12.5-8.6 16v14c12.3-4.4 21.2-16.1 21.2-30C63.6 14.2 49.3 0 31.8 0z"></path><path d="M63.6 81.5 42.4 61.7V47.8l21.2 19.7z"></path></symbol><symbol class="cvsvg-inline--fa cvfa-bars cvfa-w-14" viewBox="0 0 448 512" id="menubars" xmlns="http://www.w3.org/2000/svg"><path d="M442 114H6a6 6 0 0 1-6-6V84a6 6 0 0 1 6-6h436a6 6 0 0 1 6 6v24a6 6 0 0 1-6 6zm0 160H6a6 6 0 0 1-6-6v-24a6 6 0 0 1 6-6h436a6 6 0 0 1 6 6v24a6 6 0 0 1-6 6zm0 160H6a6 6 0 0 1-6-6v-24a6 6 0 0 1 6-6h436a6 6 0 0 1 6 6v24a6 6 0 0 1-6 6z"></path></symbol><symbol viewBox="0 0 30 30" xml:space="preserve" id="menubars-solid" xmlns="http://www.w3.org/2000/svg"><path d="M0 4.3h30v4H0zM0 12.3h30v4H0zM0 20.3h30v4H0z"></path></symbol><symbol viewBox="0 0 512 512" style="enable-background:new 0 0 512 512" xml:space="preserve" id="miteb" xmlns="http://www.w3.org/2000/svg"><path d="M475 63.5v201.7H316V63.5h159m-279.1 0v86h-159v-86h159m0 208.8v176.2h-159V272.3h159M475 387.1v61.4H316v-61.4h159m14.4-360.6H301.6c-12.5 0-22.6 10-22.6 22.3v231.1c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V48.8c0-12.3-10.1-22.3-22.6-22.3zm-279.1 0H22.5C10 26.5-.1 36.5-.1 48.8v115.4c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V48.8c.1-12.3-10.1-22.3-22.6-22.3zm0 208.8H22.5c-12.5 0-22.6 10-22.6 22.3v205.6c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V257.6c.1-12.3-10.1-22.3-22.6-22.3zm279.1 114.8H301.6c-12.5 0-22.6 10-22.6 22.3v90.8c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3v-90.8c0-12.3-10.1-22.3-22.6-22.3z"></path></symbol><symbol viewBox="0 0 512 512" xml:space="preserve" id="miteb-solid" xmlns="http://www.w3.org/2000/svg"><path d="M210.3 26.5H22.5C10 26.5-.1 36.5-.1 48.8v115.4c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V48.8c.1-12.3-10.1-22.3-22.6-22.3zm279.1 0H301.6c-12.5 0-22.6 10-22.6 22.3v231.1c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V48.8c0-12.3-10.1-22.3-22.6-22.3zM210.3 235.3H22.5c-12.5 0-22.6 10-22.6 22.3v205.6c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V257.6c.1-12.3-10.1-22.3-22.6-22.3zm279.1 114.8H301.6c-12.5 0-22.6 10-22.6 22.3v90.8c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3v-90.8c0-12.3-10.1-22.3-22.6-22.3z"></path></symbol><symbol viewBox="0 0 42 39" style="enable-background:new 0 0 42 39" xml:space="preserve" id="newspaper" xmlns="http://www.w3.org/2000/svg"><path d="M35.8 38.5H6.2c-3.5 0-6.2-2.7-6.2-6.2V2.7C0 1.2 1.2 0 2.7 0h26.1c1.6 0 2.7 1.2 2.7 2.7v29.6c0 2.4 1.8 4.2 4.2 4.2s4.2-1.8 4.2-4.2V6.2c0-.6.4-1 1-1s1 .4 1 1v26.1c.1 3.5-2.6 6.2-6.1 6.2zM2.7 2c-.5 0-.7.2-.7.7v29.6c0 2.4 1.8 4.2 4.2 4.2h25c-1-1.1-1.6-2.6-1.6-4.2V2.7c0-.5-.2-.7-.7-.7H2.7zm33.1 31.8c-.6 0-1-.4-1-1V6.2c0-.6.4-1 1-1s1 .4 1 1v26.5c0 .6-.5 1.1-1 1.1zm-10.5-4H6.2c-.6 0-1-.4-1-1s.4-1 1-1h19.1c.6 0 1 .4 1 1s-.4 1-1 1zm0-5.2H6.2c-.6 0-1-.4-1-1s.4-1 1-1h19.1c.6 0 1 .4 1 1s-.4 1-1 1zm0-5.2h-4.9c-.6 0-1-.4-1-1s.4-1 1-1h4.9c.6 0 1 .4 1 1s-.4 1-1 1zm-9.5 0H7.1c-1.1 0-1.9-.8-1.9-1.9V8.8C5.2 7.8 6 7 7.1 7h8.7c1.1 0 1.9.8 1.9 1.9v8.7c0 1-.9 1.8-1.9 1.8zm-8.6-2h8.4V9H7.2v8.4zm18.1-3.2h-4.9c-.6 0-1-.4-1-1s.4-1 1-1h4.9c.6 0 1 .4 1 1s-.4 1-1 1zm0-5.2h-4.9c-.6 0-1-.4-1-1s.4-1 1-1h4.9c.6 0 1 .4 1 1s-.4 1-1 1z"></path></symbol><symbol viewBox="0 0 512 512" id="pause-circle" xmlns="http://www.w3.org/2000/svg"><path d="M218 160h-20c-3.3 0-6 2.7-6 6v180c0 3.3 2.7 6 6 6h20c3.3 0 6-2.7 6-6V166c0-3.3-2.7-6-6-6zm96 0h-20c-3.3 0-6 2.7-6 6v180c0 3.3 2.7 6 6 6h20c3.3 0 6-2.7 6-6V166c0-3.3-2.7-6-6-6zM256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 464c-118.7 0-216-96.1-216-216 0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216 0 118.7-96.1 216-216 216z"></path></symbol><symbol viewBox="0 0 448 512" id="pause-solid" xmlns="http://www.w3.org/2000/svg"><path d="M144 479H48c-26.5 0-48-21.5-48-48V79c0-26.5 21.5-48 48-48h96c26.5 0 48 21.5 48 48v352c0 26.5-21.5 48-48 48zm304-48V79c0-26.5-21.5-48-48-48h-96c-26.5 0-48 21.5-48 48v352c0 26.5 21.5 48 48 48h96c26.5 0 48-21.5 48-48z"></path></symbol><symbol viewBox="0 0 15 15" style="enable-background:new 0 0 15 15" xml:space="preserve" id="phone" xmlns="http://www.w3.org/2000/svg"><path d="M12.9 14.2h-.2c-6.3-.6-11.3-5.7-12-12 0-.5.1-.9.4-1.3.4-.3.9-.5 1.4-.5h2.3c.8 0 1.5.5 1.7 1.2l.7 2.2c.2.6 0 1.3-.4 1.8l-.4.4s-.1.1 0 .2c.7 1 1.3 1.6 2.4 2.4H9l.4-.4c.5-.5 1.2-.6 1.8-.4l2.2.7c.7.2 1.2.9 1.2 1.7v2.3c0 .5-.2 1-.6 1.3-.3.2-.7.4-1.1.4zM2.5 1.4c-.2 0-.4.1-.6.2-.1.2-.2.3-.1.5.5 5.9 5.2 10.5 11 11.1.2 0 .4 0 .5-.2.2-.1.2-.3.2-.6v-2.3c0-.3-.2-.6-.5-.7l-2.2-.7c-.3-.1-.6 0-.8.2l-.4.3c-.4.4-1 .4-1.4.1C7 8.5 6.3 7.9 5.6 6.7c-.3-.4-.2-1 .1-1.4l.4-.3c.2-.2.3-.5.2-.8l-.8-2.3c-.1-.3-.4-.5-.7-.5H2.5zM14 5.2c-.3 0-.5-.2-.5-.5 0-1.9-1.5-3.4-3.4-3.4-.3 0-.5-.2-.5-.5s.2-.5.5-.5c2.4 0 4.4 2 4.4 4.4 0 .3-.2.5-.5.5zm-2.5 0c-.3 0-.5-.2-.5-.4 0-.5-.4-.8-.8-.8-.3 0-.5-.3-.5-.5s.2-.5.5-.5c1 0 1.8.8 1.8 1.8 0 .2-.2.4-.5.4z"></path></symbol><symbol class="dcsvg-inline--fa dcfa-map-marker dcfa-w-12" viewBox="0 0 384 512" id="pin-solid" xmlns="http://www.w3.org/2000/svg"><path d="M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0z"></path></symbol><symbol class="ddsvg-inline--fa ddfa-play-circle ddfa-w-16" viewBox="0 0 512 512" id="play-circle" xmlns="http://www.w3.org/2000/svg"><path d="M256 504c137 0 248-111 248-248S393 8 256 8 8 119 8 256s111 248 248 248zM40 256c0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216 0 118.7-96.1 216-216 216-118.7 0-216-96.1-216-216zm331.7-18-176-107c-15.8-8.8-35.7 2.5-35.7 21v208c0 18.4 19.8 29.8 35.7 21l176-101c16.4-9.1 16.4-32.8 0-42zM192 335.8V176.9c0-4.7 5.1-7.6 9.1-5.1l134.5 81.7c3.9 2.4 3.8 8.1-.1 10.3L201 341c-4 2.3-9-.6-9-5.2z"></path></symbol><symbol viewBox="0 0 448 512" id="play-solid" xmlns="http://www.w3.org/2000/svg"><path d="M424.4 214.7 72.4 6.6C43.8-10.3 0 6.1 0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1 0-82.6z"></path></symbol><symbol class="dfsvg-inline--fa dffa-question-circle dffa-w-16" viewBox="0 0 512 512" id="question-circle" xmlns="http://www.w3.org/2000/svg"><path d="M256 340c-15.464 0-28 12.536-28 28s12.536 28 28 28 28-12.536 28-28-12.536-28-28-28zm7.67-24h-16c-6.627 0-12-5.373-12-12v-.381c0-70.343 77.44-63.619 77.44-107.408 0-20.016-17.761-40.211-57.44-40.211-29.144 0-44.265 9.649-59.211 28.692-3.908 4.98-11.054 5.995-16.248 2.376l-13.134-9.15c-5.625-3.919-6.86-11.771-2.645-17.177C185.658 133.514 210.842 116 255.67 116c52.32 0 97.44 29.751 97.44 80.211 0 67.414-77.44 63.849-77.44 107.408V304c0 6.627-5.373 12-12 12zM256 40c118.621 0 216 96.075 216 216 0 119.291-96.61 216-216 216-119.244 0-216-96.562-216-216 0-119.203 96.602-216 216-216m0-32C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8z"></path></symbol><symbol viewBox="0 0 24 10" style="enable-background:new 0 0 24 10" xml:space="preserve" id="rss" xmlns="http://www.w3.org/2000/svg"><path d="M0 9V.4h3.7c.9 0 1.6.1 2 .2.4.2.8.4 1 .8.2.5.3.9.3 1.4 0 .7-.2 1.2-.5 1.6-.4.4-1 .7-1.7.8.4.2.7.5.9.7.2.3.6.7 1 1.4l1 1.7H5.6L4.4 7.1c-.5-.6-.8-1.1-.9-1.2-.2-.2-.4-.3-.5-.4-.2-.1-.5-.1-.9-.1h-.4V9H0zm1.7-5H3c.8 0 1.4 0 1.6-.1s.4-.2.5-.4c.1-.2.2-.4.2-.6 0-.3-.1-.5-.2-.7-.2-.1-.5-.3-.7-.3H1.7V4zM8.2 6.2 9.9 6c.1.6.3 1 .6 1.2.3.3.7.4 1.3.4.6 0 1-.1 1.3-.4.3-.2.4-.5.4-.8 0-.2-.1-.4-.2-.5-.1-.1-.3-.3-.6-.4-.2-.1-.7-.2-1.4-.4-.9-.2-1.6-.5-2-.8-.5-.5-.8-1-.8-1.7 0-.4.1-.8.4-1.2.3-.3.6-.6 1.1-.8.5-.2 1-.3 1.7-.3 1.1 0 1.9.2 2.4.7.5.5.8 1.1.9 1.9l-1.7.1c-.1-.5-.3-.8-.5-1-.2-.2-.6-.3-1.1-.3-.5 0-.9.1-1.2.3-.2.1-.3.3-.3.5s.1.4.3.5c.2.2.8.4 1.6.6.8.2 1.5.4 1.9.6.4.2.7.5.9.9.2.4.3.8.3 1.4 0 .5-.1 1-.4 1.4-.3.4-.7.8-1.2 1-.5.2-1.1.3-1.9.3-1.1 0-1.9-.2-2.5-.8-.5-.5-.9-1.2-1-2.2zM16.2 6.2l1.7-.2c.1.6.3 1 .6 1.2.3.3.7.4 1.3.4.6 0 1-.1 1.3-.4.3-.2.4-.5.4-.8 0-.2-.1-.4-.2-.5-.1-.1-.3-.3-.6-.4-.2-.1-.7-.2-1.4-.4-.9-.2-1.6-.5-2-.8-.5-.5-.8-1-.8-1.7 0-.4.1-.8.4-1.2.2-.4.6-.7 1.1-.9.5-.2 1-.3 1.7-.3 1.1 0 1.9.2 2.4.7.5.5.8 1.1.9 1.9l-1.7.1c-.1-.4-.3-.7-.5-.9-.2-.2-.6-.3-1.1-.3-.5 0-.9.1-1.2.3-.2.1-.3.3-.3.5s.1.4.3.5c.2.2.8.4 1.6.6.8.2 1.5.4 1.9.6.4.2.7.5.9.9.2.4.3.8.3 1.4 0 .5-.1 1-.4 1.4-.3.4-.7.8-1.2 1-.5.2-1.1.3-1.9.3-1.1 0-1.9-.2-2.5-.8-.5-.5-.9-1.2-1-2.2z"></path></symbol><symbol class="dgsvg-inline--fa dgfa-rss dgfa-w-14" viewBox="0 0 448 512" id="rss-symbol" xmlns="http://www.w3.org/2000/svg"><path d="M80 352c26.467 0 48 21.533 48 48s-21.533 48-48 48-48-21.533-48-48 21.533-48 48-48m0-32c-44.183 0-80 35.817-80 80s35.817 80 80 80 80-35.817 80-80-35.817-80-80-80zm367.996 147.615c-6.448-237.848-198.06-429.164-435.61-435.61C5.609 31.821 0 37.229 0 44.007v8.006c0 6.482 5.146 11.816 11.626 11.994 220.81 6.05 398.319 183.913 404.367 404.367.178 6.48 5.512 11.626 11.994 11.626h8.007c6.778 0 12.185-5.609 12.002-12.385zm-144.245-.05c-6.347-158.132-133.207-284.97-291.316-291.316C5.643 175.976 0 181.45 0 188.247v8.005c0 6.459 5.114 11.72 11.567 11.989 141.134 5.891 254.301 119.079 260.192 260.192.269 6.453 5.531 11.567 11.989 11.567h8.005c6.798 0 12.271-5.643 11.998-12.435z"></path></symbol><symbol class="disvg-inline--fa difa-search difa-w-16" viewBox="0 0 512 512" id="search" xmlns="http://www.w3.org/2000/svg"><path d="m508.5 481.6-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395 312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5 0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17 0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208 32s176 78.7 176 176-78.7 176-176 176z"></path></symbol><symbol viewBox="0 0 512 512" id="share" xmlns="http://www.w3.org/2000/svg"><path d="M503.691 189.836 327.687 37.851C312.281 24.546 288 35.347 288 56.015v80.053C127.371 137.907 0 170.1 0 322.326c0 61.441 39.581 122.309 83.333 154.132 13.653 9.931 33.111-2.533 28.077-18.631C66.066 312.814 132.917 274.316 288 272.085V360c0 20.7 24.3 31.453 39.687 18.164l176.004-152c11.071-9.562 11.086-26.753 0-36.328z" style="filter:var(--icon-filter)"></path></symbol><symbol viewBox="0 0 320 512" id="smartphone" xmlns="http://www.w3.org/2000/svg"><path d="M272 0H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h224c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zM160 480c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm112-108c0 6.6-5.4 12-12 12H60c-6.6 0-12-5.4-12-12V60c0-6.6 5.4-12 12-12h200c6.6 0 12 5.4 12 12v312z"></path></symbol><symbol viewBox="0 0 19 19" id="spotify" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.52 1.6a7.92 7.92 0 1 0 0 15.84 7.92 7.92 0 0 0 0-15.84ZM.16 9.52a9.36 9.36 0 1 1 18.72 0 9.36 9.36 0 0 1-18.72 0Z"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M9.52 13.12a3.87 3.87 0 0 0-1.821.455.72.72 0 1 1-.678-1.27 5.31 5.31 0 0 1 4.998 0 .72.72 0 1 1-.678 1.27 3.87 3.87 0 0 0-1.821-.455ZM9.52 7.36a9.99 9.99 0 0 0-4.701 1.175.72.72 0 0 1-.678-1.27 11.43 11.43 0 0 1 10.758 0 .72.72 0 1 1-.678 1.27A9.99 9.99 0 0 0 9.52 7.36Z"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M9.52 10.24c-1.138 0-2.258.28-3.261.815a.72.72 0 1 1-.678-1.27 8.37 8.37 0 0 1 7.878 0 .72.72 0 0 1-.678 1.27 6.93 6.93 0 0 0-3.261-.815Z"></path></symbol><symbol class="dmsvg-inline--fa dmfa-square dmfa-w-14" viewBox="0 0 448 512" id="square" xmlns="http://www.w3.org/2000/svg"><path d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm16 400c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V80c0-8.8 7.2-16 16-16h352c8.8 0 16 7.2 16 16v352z"></path></symbol><symbol class="dpsvg-inline--fa dpfa-star dpfa-w-18" viewBox="0 0 576 512" id="star" xmlns="http://www.w3.org/2000/svg"><path d="M528.1 171.5 382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6zM405.8 317.9l27.8 162L288 403.5 142.5 480l27.8-162L52.5 203.1l162.7-23.6L288 32l72.8 147.5 162.7 23.6-117.7 114.8z"></path></symbol><symbol class="dnsvg-inline--fa dnfa-star-half dnfa-w-18" viewBox="0 0 576 512" id="star-half-solid" xmlns="http://www.w3.org/2000/svg"><path d="M288 0c-11.4 0-22.8 5.9-28.7 17.8L194 150.2 47.9 171.4c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.1 23 46 46.4 33.7L288 439.6V0z"></path></symbol><symbol class="dosvg-inline--fa dofa-star dofa-w-18" viewBox="0 0 576 512" id="star-solid" xmlns="http://www.w3.org/2000/svg"><path d="M259.3 17.8 194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z"></path></symbol><symbol class="dqsvg-inline--fa dqfa-sync-alt dqfa-w-16" viewBox="0 0 512 512" id="sync" xmlns="http://www.w3.org/2000/svg"><path d="m457.373 9.387-50.095 50.102C365.411 27.211 312.953 8 256 8 123.228 8 14.824 112.338 8.31 243.493 7.971 250.311 13.475 256 20.301 256h10.015c6.352 0 11.647-4.949 11.977-11.293C48.159 131.913 141.389 42 256 42c47.554 0 91.487 15.512 127.02 41.75l-53.615 53.622c-20.1 20.1-5.855 54.628 22.627 54.628H480c17.673 0 32-14.327 32-32V32.015c0-28.475-34.564-42.691-54.627-22.628zM480 160H352L480 32v128zm11.699 96h-10.014c-6.353 0-11.647 4.949-11.977 11.293C463.84 380.203 370.504 470 256 470c-47.525 0-91.468-15.509-127.016-41.757l53.612-53.616c20.099-20.1 5.855-54.627-22.627-54.627H32c-17.673 0-32 14.327-32 32v127.978c0 28.614 34.615 42.641 54.627 22.627l50.092-50.096C146.587 484.788 199.046 504 256 504c132.773 0 241.176-104.338 247.69-235.493.339-6.818-5.165-12.507-11.991-12.507zM32 480V352h128L32 480z"></path></symbol><symbol class="drsvg-inline--fa drfa-tablet-alt drfa-w-14" viewBox="0 0 448 512" id="tablet" xmlns="http://www.w3.org/2000/svg"><path d="M400 0H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zM224 480c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm176-108c0 6.6-5.4 12-12 12H60c-6.6 0-12-5.4-12-12V60c0-6.6 5.4-12 12-12h328c6.6 0 12 5.4 12 12v312z"></path></symbol><symbol class="dtsvg-inline--fa dtfa-tag dtfa-w-16" viewBox="0 0 512 512" id="tag" xmlns="http://www.w3.org/2000/svg"><path d="M497.941 225.941 286.059 14.059A48 48 0 0 0 252.118 0H48C21.49 0 0 21.49 0 48v204.118a48 48 0 0 0 14.059 33.941l211.882 211.882c18.745 18.745 49.137 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zm-22.627 45.255L271.196 475.314c-6.243 6.243-16.375 6.253-22.627 0L36.686 263.431A15.895 15.895 0 0 1 32 252.117V48c0-8.822 7.178-16 16-16h204.118c4.274 0 8.292 1.664 11.314 4.686l211.882 211.882c6.238 6.239 6.238 16.39 0 22.628zM144 124c11.028 0 20 8.972 20 20s-8.972 20-20 20-20-8.972-20-20 8.972-20 20-20m0-28c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></symbol><symbol class="dssvg-inline--fa dsfa-tag dsfa-w-16" viewBox="0 0 512 512" id="tag-solid" xmlns="http://www.w3.org/2000/svg"><path d="M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z"></path></symbol><symbol class="dvsvg-inline--fa dvfa-tags dvfa-w-20" viewBox="0 0 640 512" id="tags" xmlns="http://www.w3.org/2000/svg"><path d="M625.941 293.823 421.823 497.941c-18.746 18.746-49.138 18.745-67.882 0l-1.775-1.775 22.627-22.627 1.775 1.775c6.253 6.253 16.384 6.243 22.627 0l204.118-204.118c6.238-6.239 6.238-16.389 0-22.627L391.431 36.686A15.895 15.895 0 0 0 380.117 32h-19.549l-32-32h51.549a48 48 0 0 1 33.941 14.059L625.94 225.941c18.746 18.745 18.746 49.137.001 67.882zM252.118 32H48c-8.822 0-16 7.178-16 16v204.118c0 4.274 1.664 8.292 4.686 11.314l211.882 211.882c6.253 6.253 16.384 6.243 22.627 0l204.118-204.118c6.238-6.239 6.238-16.389 0-22.627L263.431 36.686A15.895 15.895 0 0 0 252.118 32m0-32a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.746 18.746-49.138 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118V48C0 21.49 21.49 0 48 0h204.118zM144 124c-11.028 0-20 8.972-20 20s8.972 20 20 20 20-8.972 20-20-8.972-20-20-20m0-28c26.51 0 48 21.49 48 48s-21.49 48-48 48-48-21.49-48-48 21.49-48 48-48z"></path></symbol><symbol class="dusvg-inline--fa dufa-tags dufa-w-20" viewBox="0 0 640 512" id="tags-solid" xmlns="http://www.w3.org/2000/svg"><path d="M497.941 225.941 286.059 14.059A48 48 0 0 0 252.118 0H48C21.49 0 0 21.49 0 48v204.118a48 48 0 0 0 14.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zM112 160c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882 0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397 0h48.721a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882z"></path></symbol><symbol class="dysvg-inline--fa dyfa-times dyfa-w-10" viewBox="0 0 320 512" id="times" xmlns="http://www.w3.org/2000/svg"><path d="M193.94 256 296.5 153.44l21.15-21.15c3.12-3.12 3.12-8.19 0-11.31l-22.63-22.63c-3.12-3.12-8.19-3.12-11.31 0L160 222.06 36.29 98.34c-3.12-3.12-8.19-3.12-11.31 0L2.34 120.97c-3.12 3.12-3.12 8.19 0 11.31L126.06 256 2.34 379.71c-3.12 3.12-3.12 8.19 0 11.31l22.63 22.63c3.12 3.12 8.19 3.12 11.31 0L160 289.94 262.56 392.5l21.15 21.15c3.12 3.12 8.19 3.12 11.31 0l22.63-22.63c3.12-3.12 3.12-8.19 0-11.31L193.94 256z"></path></symbol><symbol viewBox="0 0 524 524" id="times-circle" xmlns="http://www.w3.org/2000/svg"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 464c-118.7 0-216-96.1-216-216 0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216 0 118.7-96.1 216-216 216zm94.8-285.3L281.5 256l69.3 69.3c4.7 4.7 4.7 12.3 0 17l-8.5 8.5c-4.7 4.7-12.3 4.7-17 0L256 281.5l-69.3 69.3c-4.7 4.7-12.3 4.7-17 0l-8.5-8.5c-4.7-4.7-4.7-12.3 0-17l69.3-69.3-69.3-69.3c-4.7-4.7-4.7-12.3 0-17l8.5-8.5c4.7-4.7 12.3-4.7 17 0l69.3 69.3 69.3-69.3c4.7-4.7 12.3-4.7 17 0l8.5 8.5c4.6 4.7 4.6 12.3 0 17z" style="filter:var(--icon-filter);padding:2px"></path></symbol><symbol class="dwsvg-inline--fa dwfa-times-circle dwfa-w-16" viewBox="0 0 512 512" id="times-circle-solid" xmlns="http://www.w3.org/2000/svg"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"></path></symbol><symbol class="dzsvg-inline--fa dzfa-toggle-off dzfa-w-18" viewBox="0 0 576 512" id="toggle-off" xmlns="http://www.w3.org/2000/svg"><path d="M384 96c42.738 0 82.917 16.643 113.137 46.863S544 213.262 544 256s-16.643 82.917-46.863 113.137S426.738 416 384 416H192c-42.738 0-82.917-16.643-113.137-46.863S32 298.738 32 256s16.643-82.917 46.863-113.137S149.262 96 192 96h192m0-32H192C85.961 64 0 149.961 0 256s85.961 192 192 192h192c106.039 0 192-85.961 192-192S490.039 64 384 64zm-192 96c52.935 0 96 43.065 96 96s-43.065 96-96 96-96-43.065-96-96 43.065-96 96-96m0-32c-70.692 0-128 57.307-128 128s57.308 128 128 128 128-57.307 128-128-57.308-128-128-128z"></path></symbol><symbol class="easvg-inline--fa eafa-toggle-on eafa-w-18" viewBox="0 0 576 512" id="toggle-on" xmlns="http://www.w3.org/2000/svg"><path d="M384 64H192C86 64 0 150 0 256s86 192 192 192h192c106 0 192-86 192-192S490 64 384 64zm0 320c-70.8 0-128-57.3-128-128 0-70.8 57.3-128 128-128 70.8 0 128 57.3 128 128 0 70.8-57.3 128-128 128z"></path></symbol><symbol class="ecsvg-inline--fa ecfa-trash-alt ecfa-w-14" viewBox="0 0 448 512" id="trash" xmlns="http://www.w3.org/2000/svg"><path d="M296 432h16a8 8 0 0 0 8-8V152a8 8 0 0 0-8-8h-16a8 8 0 0 0-8 8v272a8 8 0 0 0 8 8zm-160 0h16a8 8 0 0 0 8-8V152a8 8 0 0 0-8-8h-16a8 8 0 0 0-8 8v272a8 8 0 0 0 8 8zM440 64H336l-33.6-44.8A48 48 0 0 0 264 0h-80a48 48 0 0 0-38.4 19.2L112 64H8a8 8 0 0 0-8 8v16a8 8 0 0 0 8 8h24v368a48 48 0 0 0 48 48h288a48 48 0 0 0 48-48V96h24a8 8 0 0 0 8-8V72a8 8 0 0 0-8-8zM171.2 38.4A16.1 16.1 0 0 1 184 32h80a16.1 16.1 0 0 1 12.8 6.4L296 64H152zM384 464a16 16 0 0 1-16 16H80a16 16 0 0 1-16-16V96h320zm-168-32h16a8 8 0 0 0 8-8V152a8 8 0 0 0-8-8h-16a8 8 0 0 0-8 8v272a8 8 0 0 0 8 8z"></path></symbol><symbol class="ebsvg-inline--fa ebfa-trash-alt ebfa-w-14" viewBox="0 0 448 512" id="trash-solid" xmlns="http://www.w3.org/2000/svg"><path d="M32 464a48 48 0 0 0 48 48h288a48 48 0 0 0 48-48V128H32zm272-256a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zM432 32H312l-9.4-18.7A24 24 0 0 0 281.1 0H166.8a23.72 23.72 0 0 0-21.4 13.3L136 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16z"></path></symbol><symbol class="eesvg-inline--fa eefa-user-circle eefa-w-16" viewBox="0 0 496 512" id="user-circle" xmlns="http://www.w3.org/2000/svg"><path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm128 421.6c-35.9 26.5-80.1 42.4-128 42.4s-92.1-15.9-128-42.4V416c0-35.3 28.7-64 64-64 11.1 0 27.5 11.4 64 11.4 36.6 0 52.8-11.4 64-11.4 35.3 0 64 28.7 64 64v13.6zm30.6-27.5c-6.8-46.4-46.3-82.1-94.6-82.1-20.5 0-30.4 11.4-64 11.4S204.6 320 184 320c-48.3 0-87.8 35.7-94.6 82.1C53.9 363.6 32 312.4 32 256c0-119.1 96.9-216 216-216s216 96.9 216 216c0 56.4-21.9 107.6-57.4 146.1zM248 120c-48.6 0-88 39.4-88 88s39.4 88 88 88 88-39.4 88-88-39.4-88-88-88zm0 144c-30.9 0-56-25.1-56-56s25.1-56 56-56 56 25.1 56 56-25.1 56-56 56z"></path></symbol><symbol class="edsvg-inline--fa edfa-user-circle edfa-w-16" viewBox="0 0 496 512" id="user-circle-solid" xmlns="http://www.w3.org/2000/svg"><path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 96c48.6 0 88 39.4 88 88s-39.4 88-88 88-88-39.4-88-88 39.4-88 88-88zm0 344c-58.7 0-111.3-26.6-146.5-68.2 18.8-35.4 55.6-59.8 98.5-59.8 2.4 0 4.8.4 7.1 1.1 13 4.2 26.6 6.9 40.9 6.9 14.3 0 28-2.7 40.9-6.9 2.3-.7 4.7-1.1 7.1-1.1 42.9 0 79.7 24.4 98.5 59.8C359.3 421.4 306.7 448 248 448z"></path></symbol><symbol class="efsvg-inline--fa effa-user effa-w-14" viewBox="0 0 448 512" id="user-solid" xmlns="http://www.w3.org/2000/svg"><path d="M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z"></path></symbol><symbol viewBox="0 0 640 512" id="users" xmlns="http://www.w3.org/2000/svg"><path d="M544 224c44.2 0 80-35.8 80-80s-35.8-80-80-80-80 35.8-80 80 35.8 80 80 80zm0-128c26.5 0 48 21.5 48 48s-21.5 48-48 48-48-21.5-48-48 21.5-48 48-48zM320 256c61.9 0 112-50.1 112-112S381.9 32 320 32 208 82.1 208 144s50.1 112 112 112zm0-192c44.1 0 80 35.9 80 80s-35.9 80-80 80-80-35.9-80-80 35.9-80 80-80zm244 192h-40c-15.2 0-29.3 4.8-41.1 12.9 9.4 6.4 17.9 13.9 25.4 22.4 4.9-2.1 10.2-3.3 15.7-3.3h40c24.2 0 44 21.5 44 48 0 8.8 7.2 16 16 16s16-7.2 16-16c0-44.1-34.1-80-76-80zM96 224c44.2 0 80-35.8 80-80s-35.8-80-80-80-80 35.8-80 80 35.8 80 80 80zm0-128c26.5 0 48 21.5 48 48s-21.5 48-48 48-48-21.5-48-48 21.5-48 48-48zm304.1 180c-33.4 0-41.7 12-80.1 12-38.4 0-46.7-12-80.1-12-36.3 0-71.6 16.2-92.3 46.9-12.4 18.4-19.6 40.5-19.6 64.3V432c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48v-44.8c0-23.8-7.2-45.9-19.6-64.3-20.7-30.7-56-46.9-92.3-46.9zM480 432c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16v-44.8c0-16.6 4.9-32.7 14.1-46.4 13.8-20.5 38.4-32.8 65.7-32.8 27.4 0 37.2 12 80.2 12s52.8-12 80.1-12c27.3 0 51.9 12.3 65.7 32.8 9.2 13.7 14.1 29.8 14.1 46.4V432zM157.1 268.9c-11.9-8.1-26-12.9-41.1-12.9H76c-41.9 0-76 35.9-76 80 0 8.8 7.2 16 16 16s16-7.2 16-16c0-26.5 19.8-48 44-48h40c5.5 0 10.8 1.2 15.7 3.3 7.5-8.5 16.1-16 25.4-22.4z"></path></symbol><symbol viewBox="0 0 51 48" style="enable-background:new 0 0 51 48" xml:space="preserve" id="video" xmlns="http://www.w3.org/2000/svg"><path d="M45 47.5H6.1C3 47.5.5 45 .5 41.9V6.1C.5 3 3 .5 6.1.5H45c3.1 0 5.6 2.5 5.6 5.6v35.8c0 3.1-2.5 5.6-5.6 5.6zM6.1 3.5c-1.4 0-2.6 1.2-2.6 2.6v35.8c0 1.4 1.2 2.6 2.6 2.6H45c1.4 0 2.6-1.2 2.6-2.6V6.1c0-1.4-1.2-2.6-2.6-2.6H6.1zm24.6 39.9c-2.1 0-3.5-1.5-3.5-3.5v-.5h-19c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5h19v-.5c0-2.1 1.5-3.5 3.5-3.5s3.5 1.5 3.5 3.5v.5H43c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5h-8.7v.5c-.1 2-1.5 3.5-3.6 3.5zm-.6-5.6v2c0 .4.1.5.5.5s.5-.1.5-.5v-4.1c0-.4-.1-.5-.5-.5s-.5.1-.5.5v2.1zm-9.9-7.5c-.5 0-.9-.1-1.3-.4-.8-.5-1.3-1.3-1.3-2.3V13.7c0-1 .6-1.9 1.4-2.4.9-.5 1.9-.4 2.6.1l12 6.9c.8.4 1.4 1.3 1.4 2.3 0 1-.6 1.9-1.4 2.4l-12 6.9h-.1c-.4.3-.9.4-1.3.4zm.6-1.6zm.1-1.1zm-.2-13.3V27l11-6.3-11-6.4zM32.2 21zm0-.6zm-12.4-6.6z"></path></symbol><symbol class="etvideo-icon" fill="none" style="box-shadow:0 6px 15px rgba(0,0,0,.12);border-radius:4px" viewBox="0 0 26 26" id="video-graphic" xmlns="http://www.w3.org/2000/svg"><rect width="26" height="26" rx="4" fill="#fff"></rect><path fill-rule="evenodd" clip-rule="evenodd" d="M8 8.587c0-1.223 1.349-1.985 2.423-1.369l7.778 4.463a1.572 1.572 0 0 1 0 2.738l-7.778 4.463C9.349 19.498 8 18.736 8 17.513V8.587Z" fill="#000"></path></symbol><symbol viewBox="0 0 480 512" id="volume" xmlns="http://www.w3.org/2000/svg"><path d="M394.23 100.85c-11.19-7.09-26.03-3.8-33.12 7.41s-3.78 26.03 7.41 33.12C408.27 166.6 432 209.44 432 256s-23.73 89.41-63.48 114.62c-11.19 7.09-14.5 21.92-7.41 33.12 6.51 10.28 21.12 15.03 33.12 7.41C447.94 377.09 480 319.09 480 256s-32.06-121.09-85.77-155.15zm-56 78.28c-11.58-6.33-26.19-2.16-32.61 9.45-6.39 11.61-2.16 26.2 9.45 32.61C327.98 228.28 336 241.63 336 256c0 14.37-8.02 27.72-20.92 34.81-11.61 6.41-15.84 21-9.45 32.61 6.43 11.66 21.05 15.8 32.61 9.45 28.23-15.55 45.77-45 45.77-76.87s-17.54-61.33-45.78-76.87zM231.81 64c-5.91 0-11.92 2.18-16.78 7.05L126.06 160H24c-13.26 0-24 10.74-24 24v144c0 13.25 10.74 24 24 24h102.06l88.97 88.95c4.87 4.87 10.88 7.05 16.78 7.05 12.33 0 24.19-9.52 24.19-24.02V88.02C256 73.51 244.13 64 231.81 64zM208 366.05 145.94 304H48v-96h97.94L208 145.95v220.1z" style="filter:var(--icon-filter)"></path></symbol><symbol fill="none" viewBox="0 0 512 512" id="volume-mute-color" xmlns="http://www.w3.org/2000/svg"><style>.eufilter{filter:var(--icon-filter)}</style><path class="eufilter" fill-rule="evenodd" clip-rule="evenodd" d="M231.81 64c-5.91 0-11.92 2.18-16.78 7.05L126.06 160H24c-13.26 0-24 10.74-24 24v144c0 13.25 10.74 24 24 24h102.06l88.97 88.95c4.87 4.87 10.88 7.05 16.78 7.05 12.33 0 24.19-9.52 24.19-24.02V88.02C256 73.51 244.13 64 231.81 64ZM160 318.06l48 47.99v-220.1l-48 47.99L145.94 208H48v96h97.94L160 318.06Z" style="fill:var(--icon-fill, currentColor)"></path><path class="eufilter" fill-rule="evenodd" clip-rule="evenodd" d="M507.31 214.63 465.94 256l41.37 41.37c6.25 6.25 6.25 16.38 0 22.63L496 331.31c-6.25 6.25-16.38 6.25-22.63 0L432 289.94l-41.37 41.38c-6.25 6.25-16.38 6.25-22.63 0L356.69 320c-6.25-6.25-6.25-16.38 0-22.63L398.06 256l-41.37-41.37c-6.25-6.25-6.25-16.38 0-22.63L368 180.69c6.25-6.25 16.38-6.25 22.63 0L432 222.06l41.37-41.37c6.25-6.25 16.38-6.25 22.63 0L507.31 192c6.25 6.25 6.25 16.38 0 22.63Z" fill="#e3141d"></path></symbol><symbol class="eisvg-inline--fa eifa-volume-slash eifa-w-20" viewBox="0 0 640 512" id="volume-muted-solid" xmlns="http://www.w3.org/2000/svg"><path d="m633.82 458.1-69-53.33C592.42 360.8 608 309.68 608 256c0-95.33-47.73-183.58-127.65-236.03-11.17-7.33-26.18-4.24-33.51 6.95-7.34 11.17-4.22 26.18 6.95 33.51 66.27 43.49 105.82 116.6 105.82 195.58 0 42.78-11.96 83.59-33.22 119.06l-38.12-29.46C503.49 318.68 512 288.06 512 256c0-63.09-32.06-122.09-85.77-156.16-11.19-7.09-26.03-3.8-33.12 7.41-7.09 11.2-3.78 26.03 7.41 33.13C440.27 165.59 464 209.44 464 256c0 21.21-5.03 41.57-14.2 59.88l-39.56-30.58c3.38-9.35 5.76-19.07 5.76-29.3 0-31.88-17.53-61.33-45.77-76.88-11.58-6.33-26.19-2.16-32.61 9.45-6.39 11.61-2.16 26.2 9.45 32.61 11.76 6.46 19.12 18.18 20.4 31.06L288 190.82V88.02c0-21.46-25.96-31.98-40.97-16.97l-49.71 49.7L45.47 3.37C38.49-2.05 28.43-.8 23.01 6.18L3.37 31.45C-2.05 38.42-.8 48.47 6.18 53.9l588.36 454.73c6.98 5.43 17.03 4.17 22.46-2.81l19.64-25.27c5.41-6.97 4.16-17.02-2.82-22.45zM32 184v144c0 13.25 10.74 24 24 24h102.06l88.97 88.95c15.03 15.03 40.97 4.47 40.97-16.97V352.6L43.76 163.84C36.86 168.05 32 175.32 32 184z"></path></symbol><symbol viewBox="0 0 256 512" id="volume-off" xmlns="http://www.w3.org/2000/svg"><path d="M231.81 64c-5.91 0-11.92 2.18-16.78 7.05L126.06 160H24c-13.26 0-24 10.74-24 24v144c0 13.25 10.74 24 24 24h102.06l88.97 88.95c4.87 4.87 10.88 7.05 16.78 7.05 12.33 0 24.19-9.52 24.19-24.02V88.02C256 73.51 244.13 64 231.81 64zM208 366.05 145.94 304H48v-96h97.94L208 145.95v220.1z" style="filter:var(--icon-filter)"></path></symbol><symbol class="eksvg-inline--fa ekfa-volume-up ekfa-w-18" viewBox="0 0 576 512" id="volume-up-solid" xmlns="http://www.w3.org/2000/svg"><path d="M215.03 71.05 126.06 160H24c-13.26 0-24 10.74-24 24v144c0 13.25 10.74 24 24 24h102.06l88.97 88.95c15.03 15.03 40.97 4.47 40.97-16.97V88.02c0-21.46-25.96-31.98-40.97-16.97zm233.32-51.08c-11.17-7.33-26.18-4.24-33.51 6.95-7.34 11.17-4.22 26.18 6.95 33.51 66.27 43.49 105.82 116.6 105.82 195.58 0 78.98-39.55 152.09-105.82 195.58-11.17 7.32-14.29 22.34-6.95 33.5 7.04 10.71 21.93 14.56 33.51 6.95C528.27 439.58 576 351.33 576 256S528.27 72.43 448.35 19.97zM480 256c0-63.53-32.06-121.94-85.77-156.24-11.19-7.14-26.03-3.82-33.12 7.46s-3.78 26.21 7.41 33.36C408.27 165.97 432 209.11 432 256s-23.73 90.03-63.48 115.42c-11.19 7.14-14.5 22.07-7.41 33.36 6.51 10.36 21.12 15.14 33.12 7.46C447.94 377.94 480 319.54 480 256zm-141.77-76.87c-11.58-6.33-26.19-2.16-32.61 9.45-6.39 11.61-2.16 26.2 9.45 32.61C327.98 228.28 336 241.63 336 256c0 14.38-8.02 27.72-20.92 34.81-11.61 6.41-15.84 21-9.45 32.61 6.43 11.66 21.05 15.8 32.61 9.45 28.23-15.55 45.77-45 45.77-76.88s-17.54-61.32-45.78-76.86z"></path></symbol><symbol viewBox="0 0 1200 1227" id="x" xmlns="http://www.w3.org/2000/svg"><path d="M714.163 519.284 1160.89 0h-105.86L667.137 450.887 357.328 0H0l468.492 681.821L0 1226.37h105.866l409.625-476.152 327.181 476.152H1200L714.137 519.284h.026ZM569.165 687.828l-47.468-67.894-377.686-540.24h162.604l304.797 435.991 47.468 67.894 396.2 566.721H892.476L569.165 687.854v-.026Z"></path></symbol><symbol class="ensvg-inline--fa enfa-youtube enfa-w-18" viewBox="0 0 576 512" id="youtube" xmlns="http://www.w3.org/2000/svg"><path d="M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z"></path></symbol></svg>`), Icons[FILENAME], [
		[
			2,
			9,
			[
				[2, 92, [[2, 173]]],
				[2, 410, [[2, 491]]],
				[2, 815, [[2, 897]]],
				[2, 1216, [[2, 1295]]],
				[
					2,
					1615,
					[
						[2, 1697],
						[2, 1954],
						[2, 2380],
						[2, 2595]
					]
				],
				[2, 2815, [[2, 2896]]],
				[2, 3187, [[2, 3268]]],
				[2, 3652, [[2, 3734]]],
				[2, 4117, [[2, 4196]]],
				[2, 4574, [[2, 4711]]],
				[2, 5386, [[2, 5518]]],
				[2, 5932, [[2, 6052]]],
				[2, 6745, [[2, 6824]]],
				[2, 7017, [[2, 7102]]],
				[2, 7199, [[2, 7327]]],
				[2, 7721, [[2, 7845]]],
				[2, 8383, [[2, 8513]]],
				[2, 8876, [[2, 8956]]],
				[2, 9448, [[2, 9570]]],
				[2, 9870, [[2, 10006]]],
				[2, 10516, [[2, 10658]]],
				[2, 11035, [[2, 11117]]],
				[2, 11411, [[2, 11547]]],
				[2, 12072, [[2, 12214]]],
				[2, 12614, [[2, 12738]]],
				[2, 12937, [[2, 13083]]],
				[2, 13813, [[2, 13949]]],
				[2, 14428, [[2, 14558]]],
				[2, 14648, [[2, 14770]]],
				[2, 15139, [[2, 15257]]],
				[2, 17107, [[2, 17231]]],
				[2, 18061, [[2, 18187]]],
				[2, 18653, [[2, 18785]]],
				[2, 19026, [[2, 19160]]],
				[2, 19680, [[2, 19919]]],
				[2, 20514, [[2, 20589]]],
				[2, 21117, [[2, 21250]]],
				[2, 21692, [[2, 21831]]],
				[2, 22175, [[2, 22301]]],
				[2, 22649, [[2, 22793]]],
				[2, 23062, [[2, 23168]]],
				[
					2,
					23266,
					[
						[2, 23349],
						[2, 23397],
						[2, 23455]
					]
				],
				[2, 23547, [[2, 23704]]],
				[
					2,
					23879,
					[
						[2, 23962],
						[2, 24010],
						[2, 24071]
					]
				],
				[
					2,
					24163,
					[
						[2, 24258],
						[2, 24306],
						[2, 24364]
					]
				],
				[2, 24456, [[2, 24576]]],
				[
					2,
					25177,
					[
						[2, 25280],
						[2, 25341],
						[2, 25502]
					]
				],
				[2, 27682, [[2, 27810]]],
				[2, 28294, [[2, 28442]]],
				[2, 28951, [[2, 29105]]],
				[2, 29508, [[2, 29660]]],
				[2, 30083, [[2, 30241]]],
				[2, 30710, [[2, 30834]]],
				[2, 31361, [[2, 31503]]],
				[2, 31953, [[2, 32083]]],
				[
					2,
					32276,
					[[2, 32361], [2, 32506]]
				],
				[2, 32612, [[2, 32742]]],
				[2, 32968, [[2, 33045]]],
				[2, 33989, [[2, 34126]]],
				[2, 35351, [[2, 35435]]],
				[2, 36090, [[2, 36168]]],
				[2, 37124, [[2, 37264]]],
				[2, 38264, [[2, 38350]]],
				[2, 38969, [[2, 39047]]],
				[2, 39640, [[2, 39762]]],
				[2, 40184, [[2, 40334]]],
				[2, 40482, [[2, 40610]]],
				[2, 40838, [[2, 40964]]],
				[2, 41696, [[2, 41830]]],
				[2, 42370, [[2, 42510]]],
				[2, 42930, [[2, 43060]]],
				[2, 44003, [[2, 44081]]],
				[2, 44292, [[2, 44423]]],
				[2, 44744, [[2, 44822]]],
				[2, 46025, [[2, 46145]]],
				[2, 46495, [[2, 46633]]],
				[
					2,
					46898,
					[
						[2, 47046],
						[2, 47078],
						[2, 47119],
						[2, 47330]
					]
				],
				[2, 47387, [[2, 47511]]],
				[2, 47761, [[2, 47865]]],
				[2, 47930, [[2, 48069]]],
				[2, 48756, [[2, 48859]]],
				[2, 49438, [[2, 49577]]],
				[2, 50408, [[2, 50491]]],
				[2, 50864, [[2, 50946]]],
				[2, 51181, [[2, 51316]]],
				[2, 52056, [[2, 52187]]],
				[2, 52369, [[2, 52503]]],
				[2, 52909, [[2, 52990]]],
				[2, 53122, [[2, 53264]]],
				[2, 53975, [[2, 54108]]],
				[2, 55386, [[2, 55511]]],
				[2, 56204, [[2, 56328]]],
				[2, 56675, [[2, 56751]]],
				[2, 57123, [[2, 57204]]],
				[
					2,
					57501,
					[
						[2, 57577],
						[2, 57745],
						[2, 58068]
					]
				],
				[2, 58266, [[2, 58390]]],
				[2, 58615, [[2, 58735]]],
				[2, 59127, [[2, 59263]]],
				[2, 59426, [[2, 59552]]],
				[2, 59829, [[2, 59953]]],
				[2, 60776, [[2, 60904]]],
				[2, 61201, [[2, 61319]]],
				[2, 61940, [[2, 62064]]],
				[2, 62375, [[2, 62495]]],
				[2, 63444, [[2, 63570]]],
				[2, 64141, [[2, 64263]]],
				[2, 64691, [[2, 64774]]],
				[2, 65325, [[2, 65467]]],
				[2, 65863, [[2, 65995]]],
				[2, 66523, [[2, 66653]]],
				[2, 66862, [[2, 66988]]],
				[2, 67568, [[2, 67700]]],
				[2, 68080, [[2, 68214]]],
				[2, 68820, [[2, 68960]]],
				[2, 69335, [[2, 69461]]],
				[2, 69738, [[2, 69814]]],
				[2, 71057, [[2, 71192]]],
				[
					2,
					71936,
					[[2, 72115], [2, 72164]]
				],
				[2, 72366, [[2, 72443]]],
				[
					2,
					73295,
					[
						[2, 73395],
						[2, 73446],
						[2, 73855]
					]
				],
				[2, 74337, [[2, 74479]]],
				[2, 75483, [[2, 75564]]],
				[2, 75896, [[2, 76032]]],
				[2, 77031, [[2, 77105]]],
				[2, 77410, [[2, 77536]]]
			]
		]
	]);

	function Icons($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var svg = root$3();

		append($$anchor, svg);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Icons);

	mark_module_start();
	Github[FILENAME] = "docs_src/assets/icons/github.svelte";

	var root$2 = add_locations(ns_template(`<svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg>`), Github[FILENAME], [[8, 0, [[18, 3]]]]);

	function Github($$anchor, $$props) {
		check_target(new.target);
		push($$props, true);
		validate_prop_bindings($$props, [], [], Github);

		let height = prop($$props, "height", 3, 'auto'),
			width = prop($$props, "width", 3, 'auto');

		const style = `
    height: ${strict_equals(typeof height(), 'number') ? `${height()}px` : height()};
    width: ${strict_equals(typeof width(), 'number') ? `${width()}px` : width()};`;

		var svg = root$2();

		set_attribute(svg, "style", style);
		append($$anchor, svg);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Github);

	mark_module_start();
	Navbar[FILENAME] = "docs_src/main/Navbar.svelte";

	var on_click = (_, changeSourceType) => changeSourceType('svelte');
	var on_click_1 = (__1, changeSourceType) => changeSourceType('html');

	var root$1 = add_locations(template(`<div class="navmenu-container position-fixed margin-xl--b bg-red svelte-1bwbuf8"><nav class="navmenu flex flex-justify--between flex-align--center padding-xl--rl svelte-1bwbuf8"><a href="https://github.com/EkstraBladetUdvikling/eb-designsystem" target="_blank" class="flex svelte-1bwbuf8" rel="noreferrer"><!> <span class="flex flex-align--end padding-s--l">Github</span></a> <div class="buttongroup buttongroup--secondary"><button class="button button--small">Svelte</button> <button class="button button--small">HTML</button></div></nav></div>`), Navbar[FILENAME], [
		[
			8,
			0,
			[
				[
					9,
					2,
					[
						[10, 4, [[12, 6]]],
						[14, 4, [[15, 6], [20, 6]]]
					]
				]
			]
		]
	]);

	function Navbar($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		const $$stores = setup_stores();

		const $sourceType = () => (
			validate_store(sourceType),
			store_get(sourceType, "$sourceType", $$stores)
		);

		function changeSourceType(source) {
			sourceType.set(source);
		}

		init();

		var div = root$1();
		var nav = child(div);
		var a = child(nav);
		var node = child(a);

		Github(node, { width: 20 });

		var div_1 = sibling(a, 2);
		var button = child(div_1);

		button.__click = [on_click, changeSourceType];

		var button_1 = sibling(button, 2);

		button_1.__click = [on_click_1, changeSourceType];

		template_effect(() => {
			set_attribute(button, "data-selected", strict_equals($sourceType(), 'svelte'));
			set_attribute(button_1, "data-selected", strict_equals($sourceType(), 'html'));
		});

		append($$anchor, div);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Navbar);
	delegate(["click"]);

	mark_module_start();
	Sidebar[FILENAME] = "docs_src/main/Sidebar.svelte";

	var root_2 = add_locations(template(`<a class="sidebar-item width-1of1 padding-m--t padding-m--rl svelte-1hxd992"> </a>`), Sidebar[FILENAME], [[31, 10]]);

	var root_1$1 = add_locations(template(`<div class="sidebar-menuitem-container padding-l svelte-1hxd992"><div class="sidebar-submenu-title fontsize-small svelte-1hxd992"><a class="svelte-1hxd992"> </a></div> <div class="sidebar-submenu-items"></div></div>`), Sidebar[FILENAME], [
		[
			22,
			4,
			[
				[23, 6, [[24, 8]]],
				[29, 6]
			]
		]
	]);

	var root = add_locations(template(`<div id="sidebar-menu" class="sidebar-container height-100vh bg--white margin-l--r svelte-1hxd992"><div class="flex flex-justify--around sidebar-logo-container padding-m--rl svelte-1hxd992"><div><a href="#/" class="svelte-1hxd992"><img alt="" src="ekstrabladet.svg" style="height:70px;"></a></div> <div class="flex-item flex-item--center"><p class="flex--grow width-1of1 color--graa1 fontweight-bold">Design system</p></div></div> <div class="sidebar-menuitem-container padding-l svelte-1hxd992"><div class="sidebar-submenu-items"><a class="sidebar-item width-1of1 padding-m--t padding-m--rl svelte-1hxd992" href="/">Overview</a></div></div> <!></div>`), Sidebar[FILENAME], [
		[
			5,
			0,
			[
				[
					6,
					2,
					[
						[7, 4, [[8, 6, [[9, 8]]]]],
						[12, 4, [[13, 6]]]
					]
				],
				[
					16,
					2,
					[[17, 4, [[18, 6]]]]
				]
			]
		]
	]);

	function Sidebar($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		var div = root();
		var div_1 = sibling(child(div), 2);
		var div_2 = child(div_1);
		var a = child(div_2);

		action(a, ($$node) => active($$node));
		action(a, ($$node) => link($$node));

		var node = sibling(div_1, 2);

		each(node, 1, () => menuItems, index, ($$anchor, group) => {
			var div_3 = root_1$1();
			var div_4 = child(div_3);
			var a_1 = child(div_4);
			var text = child(a_1);
			action(a_1, ($$node) => link($$node));
			action(a_1, ($$node) => active($$node));

			var div_5 = sibling(div_4, 2);

			each(div_5, 5, () => get(group).routes, index, ($$anchor, menuItem) => {
				var a_2 = root_2();
				var text_1 = child(a_2);
				action(a_2, ($$node) => link($$node));
				action(a_2, ($$node) => active($$node));

				template_effect(() => {
					set_attribute(a_2, "href", get(menuItem).path);
					set_text(text_1, get(menuItem).name);
				});

				append($$anchor, a_2);
			});

			template_effect(() => {
				set_attribute(a_1, "href", get(group).path);
				set_text(text, get(group).name);
			});

			append($$anchor, div_3);
		});
		append($$anchor, div);
		return pop({ ...legacy_api() });
	}

	mark_module_end(Sidebar);

	mark_module_start();
	App[FILENAME] = "docs_src/App.svelte";

	var root_1 = add_locations(template(`<!> <!> <div class="content-container padding-xl svelte-ftylog"><!></div> <!>`, 1), App[FILENAME], [[12, 2]]);

	function App($$anchor, $$props) {
		check_target(new.target);
		push($$props, false);

		RouterContext($$anchor, {
			options,
			children: wrap_snippet(App, ($$anchor, $$slotProps) => {
				var fragment_1 = root_1();
				var node = first_child(fragment_1);

				Navbar(node, {});

				var node_1 = sibling(node, 2);

				Sidebar(node_1, {});

				var div = sibling(node_1, 2);
				var node_2 = child(div);

				RouterView(node_2, {});
				reset(div);

				var node_3 = sibling(div, 2);

				Icons(node_3, {});
				append($$anchor, fragment_1);
			}),
			$$slots: { default: true }
		});

		return pop({ ...legacy_api() });
	}

	mark_module_end(App);

	const app = mount(App, {
	    target: document.body,
	});

	return app;

})();
