
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35730/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_svg_attributes(node, attributes) {
        for (const key in attributes) {
            attr(node, key, attributes[key]);
        }
    }
    function xlink_attr(node, attribute, value) {
        node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
        select.selectedIndex = -1; // no option should be selected
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }
    class HtmlTag {
        constructor(is_svg = false) {
            this.is_svg = false;
            this.is_svg = is_svg;
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                if (this.is_svg)
                    this.e = svg_element(target.nodeName);
                else
                    this.e = element(target.nodeName);
                this.t = target;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    /**
     * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
     * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
     * it can be called from an external module).
     *
     * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
     *
     * https://svelte.dev/docs#run-time-svelte-onmount
     */
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    /**
     * Schedules a callback to run immediately after the component has been updated.
     *
     * The first time the callback runs will be after the initial `onMount`
     */
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    /**
     * Schedules a callback to run immediately before the component is unmounted.
     *
     * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
     * only one that runs inside a server-side component.
     *
     * https://svelte.dev/docs#run-time-svelte-ondestroy
     */
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    /**
     * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
     * Event dispatchers are functions that can take two arguments: `name` and `detail`.
     *
     * Component events created with `createEventDispatcher` create a
     * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
     * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
     * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
     * property and can contain any type of data.
     *
     * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
     */
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail, { cancelable = false } = {}) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail, { cancelable });
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
                return !event.defaultPrevented;
            }
            return true;
        };
    }
    /**
     * Associates an arbitrary `context` object with the current component and the specified `key`
     * and returns that object. The context is then available to children of the component
     * (including slotted content) with `getContext`.
     *
     * Like lifecycle functions, this must be called during component initialisation.
     *
     * https://svelte.dev/docs#run-time-svelte-setcontext
     */
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
        return context;
    }
    /**
     * Retrieves the context that belongs to the closest parent component with the specified `key`.
     * Must be called during component initialisation.
     *
     * https://svelte.dev/docs#run-time-svelte-getcontext
     */
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
                // if the component was destroyed immediately
                // it will update the `$$.on_destroy` reference to `null`.
                // the destructured on_destroy may still reference to the old array
                if (component.$$.on_destroy) {
                    component.$$.on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: [],
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            if (!is_function(callback)) {
                return noop;
            }
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.53.1' }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    function construct_svelte_component_dev(component, props) {
        const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';
        try {
            const instance = new component(props);
            if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {
                throw new Error(error_message);
            }
            return instance;
        }
        catch (err) {
            const { message } = err;
            if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {
                throw new Error(error_message);
            }
            else {
                throw err;
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /**
     * @typedef {Object} WrappedComponent Object returned by the `wrap` method
     * @property {SvelteComponent} component - Component to load (this is always asynchronous)
     * @property {RoutePrecondition[]} [conditions] - Route pre-conditions to validate
     * @property {Object} [props] - Optional dictionary of static props
     * @property {Object} [userData] - Optional user data dictionary
     * @property {bool} _sveltesparouter - Internal flag; always set to true
     */

    /**
     * @callback AsyncSvelteComponent
     * @returns {Promise<SvelteComponent>} Returns a Promise that resolves with a Svelte component
     */

    /**
     * @callback RoutePrecondition
     * @param {RouteDetail} detail - Route detail object
     * @returns {boolean|Promise<boolean>} If the callback returns a false-y value, it's interpreted as the precondition failed, so it aborts loading the component (and won't process other pre-condition callbacks)
     */

    /**
     * @typedef {Object} WrapOptions Options object for the call to `wrap`
     * @property {SvelteComponent} [component] - Svelte component to load (this is incompatible with `asyncComponent`)
     * @property {AsyncSvelteComponent} [asyncComponent] - Function that returns a Promise that fulfills with a Svelte component (e.g. `{asyncComponent: () => import('Foo.svelte')}`)
     * @property {SvelteComponent} [loadingComponent] - Svelte component to be displayed while the async route is loading (as a placeholder); when unset or false-y, no component is shown while component
     * @property {object} [loadingParams] - Optional dictionary passed to the `loadingComponent` component as params (for an exported prop called `params`)
     * @property {object} [userData] - Optional object that will be passed to events such as `routeLoading`, `routeLoaded`, `conditionsFailed`
     * @property {object} [props] - Optional key-value dictionary of static props that will be passed to the component. The props are expanded with {...props}, so the key in the dictionary becomes the name of the prop.
     * @property {RoutePrecondition[]|RoutePrecondition} [conditions] - Route pre-conditions to add, which will be executed in order
     */

    /**
     * Wraps a component to enable multiple capabilities:
     * 1. Using dynamically-imported component, with (e.g. `{asyncComponent: () => import('Foo.svelte')}`), which also allows bundlers to do code-splitting.
     * 2. Adding route pre-conditions (e.g. `{conditions: [...]}`)
     * 3. Adding static props that are passed to the component
     * 4. Adding custom userData, which is passed to route events (e.g. route loaded events) or to route pre-conditions (e.g. `{userData: {foo: 'bar}}`)
     * 
     * @param {WrapOptions} args - Arguments object
     * @returns {WrappedComponent} Wrapped component
     */
    function wrap$1(args) {
        if (!args) {
            throw Error('Parameter args is required')
        }

        // We need to have one and only one of component and asyncComponent
        // This does a "XNOR"
        if (!args.component == !args.asyncComponent) {
            throw Error('One and only one of component and asyncComponent is required')
        }

        // If the component is not async, wrap it into a function returning a Promise
        if (args.component) {
            args.asyncComponent = () => Promise.resolve(args.component);
        }

        // Parameter asyncComponent and each item of conditions must be functions
        if (typeof args.asyncComponent != 'function') {
            throw Error('Parameter asyncComponent must be a function')
        }
        if (args.conditions) {
            // Ensure it's an array
            if (!Array.isArray(args.conditions)) {
                args.conditions = [args.conditions];
            }
            for (let i = 0; i < args.conditions.length; i++) {
                if (!args.conditions[i] || typeof args.conditions[i] != 'function') {
                    throw Error('Invalid parameter conditions[' + i + ']')
                }
            }
        }

        // Check if we have a placeholder component
        if (args.loadingComponent) {
            args.asyncComponent.loading = args.loadingComponent;
            args.asyncComponent.loadingParams = args.loadingParams || undefined;
        }

        // Returns an object that contains all the functions to execute too
        // The _sveltesparouter flag is to confirm the object was created by this router
        const obj = {
            component: args.asyncComponent,
            userData: args.userData,
            conditions: (args.conditions && args.conditions.length) ? args.conditions : undefined,
            props: (args.props && Object.keys(args.props).length) ? args.props : {},
            _sveltesparouter: true
        };

        return obj
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    function parse(str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules/svelte-spa-router/Router.svelte generated by Svelte v3.53.1 */

    const { Error: Error_1, Object: Object_1$1, console: console_1 } = globals;

    // (267:0) {:else}
    function create_else_block$l(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$l.name,
    		type: "else",
    		source: "(267:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (260:0) {#if componentParams}
    function create_if_block$s(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ params: /*componentParams*/ ctx[1] }, /*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*componentParams, props*/ 6)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*componentParams*/ 2 && { params: /*componentParams*/ ctx[1] },
    					dirty & /*props*/ 4 && get_spread_object(/*props*/ ctx[2])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(260:0) {#if componentParams}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1a(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$s, create_else_block$l];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*componentParams*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function wrap(component, userData, ...conditions) {
    	// Use the new wrap method and show a deprecation warning
    	// eslint-disable-next-line no-console
    	console.warn('Method `wrap` from `svelte-spa-router` is deprecated and will be removed in a future version. Please use `svelte-spa-router/wrap` instead. See http://bit.ly/svelte-spa-router-upgrading');

    	return wrap$1({ component, userData, conditions });
    }

    /**
     * @typedef {Object} Location
     * @property {string} location - Location (page/view), for example `/book`
     * @property {string} [querystring] - Querystring from the hash, as a string not parsed
     */
    /**
     * Returns the current location from the hash.
     *
     * @returns {Location} Location object
     * @private
     */
    function getLocation() {
    	const hashPosition = window.location.href.indexOf('#/');

    	let location = hashPosition > -1
    	? window.location.href.substr(hashPosition + 1)
    	: '/';

    	// Check if there's a querystring
    	const qsPosition = location.indexOf('?');

    	let querystring = '';

    	if (qsPosition > -1) {
    		querystring = location.substr(qsPosition + 1);
    		location = location.substr(0, qsPosition);
    	}

    	return { location, querystring };
    }

    const loc = readable(null, // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
    	set(getLocation());

    	const update = () => {
    		set(getLocation());
    	};

    	window.addEventListener('hashchange', update, false);

    	return function stop() {
    		window.removeEventListener('hashchange', update, false);
    	};
    });

    const location = derived(loc, $loc => $loc.location);
    const querystring = derived(loc, $loc => $loc.querystring);
    const params = writable(undefined);

    async function push(location) {
    	if (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {
    		throw Error('Invalid parameter location');
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	// Note: this will include scroll state in history even when restoreScrollState is false
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined
    	);

    	window.location.hash = (location.charAt(0) == '#' ? '' : '#') + location;
    }

    async function pop() {
    	// Execute this code when the current call stack is complete
    	await tick();

    	window.history.back();
    }

    async function replace(location) {
    	if (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {
    		throw Error('Invalid parameter location');
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	const dest = (location.charAt(0) == '#' ? '' : '#') + location;

    	try {
    		const newState = { ...history.state };
    		delete newState['__svelte_spa_router_scrollX'];
    		delete newState['__svelte_spa_router_scrollY'];
    		window.history.replaceState(newState, undefined, dest);
    	} catch(e) {
    		// eslint-disable-next-line no-console
    		console.warn('Caught exception while replacing the current page. If you\'re running this in the Svelte REPL, please note that the `replace` method might not work in this environment.');
    	}

    	// The method above doesn't trigger the hashchange event, so let's do that manually
    	window.dispatchEvent(new Event('hashchange'));
    }

    function link(node, opts) {
    	opts = linkOpts(opts);

    	// Only apply to <a> tags
    	if (!node || !node.tagName || node.tagName.toLowerCase() != 'a') {
    		throw Error('Action "link" can only be used with <a> tags');
    	}

    	updateLink(node, opts);

    	return {
    		update(updated) {
    			updated = linkOpts(updated);
    			updateLink(node, updated);
    		}
    	};
    }

    function restoreScroll(state) {
    	// If this exists, then this is a back navigation: restore the scroll position
    	if (state) {
    		window.scrollTo(state.__svelte_spa_router_scrollX, state.__svelte_spa_router_scrollY);
    	} else {
    		// Otherwise this is a forward navigation: scroll to top
    		window.scrollTo(0, 0);
    	}
    }

    // Internal function used by the link function
    function updateLink(node, opts) {
    	let href = opts.href || node.getAttribute('href');

    	// Destination must start with '/' or '#/'
    	if (href && href.charAt(0) == '/') {
    		// Add # to the href attribute
    		href = '#' + href;
    	} else if (!href || href.length < 2 || href.slice(0, 2) != '#/') {
    		throw Error('Invalid value for "href" attribute: ' + href);
    	}

    	node.setAttribute('href', href);

    	node.addEventListener('click', event => {
    		// Prevent default anchor onclick behaviour
    		event.preventDefault();

    		if (!opts.disabled) {
    			scrollstateHistoryHandler(event.currentTarget.getAttribute('href'));
    		}
    	});
    }

    // Internal function that ensures the argument of the link action is always an object
    function linkOpts(val) {
    	if (val && typeof val == 'string') {
    		return { href: val };
    	} else {
    		return val || {};
    	}
    }

    /**
     * The handler attached to an anchor tag responsible for updating the
     * current history state with the current scroll state
     *
     * @param {string} href - Destination
     */
    function scrollstateHistoryHandler(href) {
    	// Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined
    	);

    	// This will force an update as desired, but this time our scroll state will be attached
    	window.location.hash = href;
    }

    function instance$19($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Router', slots, []);
    	let { routes = {} } = $$props;
    	let { prefix = '' } = $$props;
    	let { restoreScrollState = false } = $$props;

    	/**
     * Container for a route: path, component
     */
    	class RouteItem {
    		/**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
     */
    		constructor(path, component) {
    			if (!component || typeof component != 'function' && (typeof component != 'object' || component._sveltesparouter !== true)) {
    				throw Error('Invalid component object');
    			}

    			// Path must be a regular or expression, or a string starting with '/' or '*'
    			if (!path || typeof path == 'string' && (path.length < 1 || path.charAt(0) != '/' && path.charAt(0) != '*') || typeof path == 'object' && !(path instanceof RegExp)) {
    				throw Error('Invalid value for "path" argument - strings must start with / or *');
    			}

    			const { pattern, keys } = parse(path);
    			this.path = path;

    			// Check if the component is wrapped and we have conditions
    			if (typeof component == 'object' && component._sveltesparouter === true) {
    				this.component = component.component;
    				this.conditions = component.conditions || [];
    				this.userData = component.userData;
    				this.props = component.props || {};
    			} else {
    				// Convert the component to a function that returns a Promise, to normalize it
    				this.component = () => Promise.resolve(component);

    				this.conditions = [];
    				this.props = {};
    			}

    			this._pattern = pattern;
    			this._keys = keys;
    		}

    		/**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    		match(path) {
    			// If there's a prefix, check if it matches the start of the path.
    			// If not, bail early, else remove it before we run the matching.
    			if (prefix) {
    				if (typeof prefix == 'string') {
    					if (path.startsWith(prefix)) {
    						path = path.substr(prefix.length) || '/';
    					} else {
    						return null;
    					}
    				} else if (prefix instanceof RegExp) {
    					const match = path.match(prefix);

    					if (match && match[0]) {
    						path = path.substr(match[0].length) || '/';
    					} else {
    						return null;
    					}
    				}
    			}

    			// Check if the pattern matches
    			const matches = this._pattern.exec(path);

    			if (matches === null) {
    				return null;
    			}

    			// If the input was a regular expression, this._keys would be false, so return matches as is
    			if (this._keys === false) {
    				return matches;
    			}

    			const out = {};
    			let i = 0;

    			while (i < this._keys.length) {
    				// In the match parameters, URL-decode all values
    				try {
    					out[this._keys[i]] = decodeURIComponent(matches[i + 1] || '') || null;
    				} catch(e) {
    					out[this._keys[i]] = null;
    				}

    				i++;
    			}

    			return out;
    		}

    		/**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {object} [userData] - Custom data passed by the user
     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
     */
    		/**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {boolean} Returns true if all the conditions succeeded
     */
    		async checkConditions(detail) {
    			for (let i = 0; i < this.conditions.length; i++) {
    				if (!await this.conditions[i](detail)) {
    					return false;
    				}
    			}

    			return true;
    		}
    	}

    	// Set up all routes
    	const routesList = [];

    	if (routes instanceof Map) {
    		// If it's a map, iterate on it right away
    		routes.forEach((route, path) => {
    			routesList.push(new RouteItem(path, route));
    		});
    	} else {
    		// We have an object, so iterate on its own properties
    		Object.keys(routes).forEach(path => {
    			routesList.push(new RouteItem(path, routes[path]));
    		});
    	}

    	// Props for the component to render
    	let component = null;

    	let componentParams = null;
    	let props = {};

    	// Event dispatcher from Svelte
    	const dispatch = createEventDispatcher();

    	// Just like dispatch, but executes on the next iteration of the event loop
    	async function dispatchNextTick(name, detail) {
    		// Execute this code when the current call stack is complete
    		await tick();

    		dispatch(name, detail);
    	}

    	// If this is set, then that means we have popped into this var the state of our last scroll position
    	let previousScrollState = null;

    	let popStateChanged = null;

    	if (restoreScrollState) {
    		popStateChanged = event => {
    			// If this event was from our history.replaceState, event.state will contain
    			// our scroll history. Otherwise, event.state will be null (like on forward
    			// navigation)
    			if (event.state && (event.state.__svelte_spa_router_scrollY || event.state.__svelte_spa_router_scrollX)) {
    				previousScrollState = event.state;
    			} else {
    				previousScrollState = null;
    			}
    		};

    		// This is removed in the destroy() invocation below
    		window.addEventListener('popstate', popStateChanged);

    		afterUpdate(() => {
    			restoreScroll(previousScrollState);
    		});
    	}

    	// Always have the latest value of loc
    	let lastLoc = null;

    	// Current object of the component loaded
    	let componentObj = null;

    	// Handle hash change events
    	// Listen to changes in the $loc store and update the page
    	// Do not use the $: syntax because it gets triggered by too many things
    	const unsubscribeLoc = loc.subscribe(async newLoc => {
    		lastLoc = newLoc;

    		// Find a route matching the location
    		let i = 0;

    		while (i < routesList.length) {
    			const match = routesList[i].match(newLoc.location);

    			if (!match) {
    				i++;
    				continue;
    			}

    			const detail = {
    				route: routesList[i].path,
    				location: newLoc.location,
    				querystring: newLoc.querystring,
    				userData: routesList[i].userData,
    				params: match && typeof match == 'object' && Object.keys(match).length
    				? match
    				: null
    			};

    			// Check if the route can be loaded - if all conditions succeed
    			if (!await routesList[i].checkConditions(detail)) {
    				// Don't display anything
    				$$invalidate(0, component = null);

    				componentObj = null;

    				// Trigger an event to notify the user, then exit
    				dispatchNextTick('conditionsFailed', detail);

    				return;
    			}

    			// Trigger an event to alert that we're loading the route
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoading', Object.assign({}, detail));

    			// If there's a component to show while we're loading the route, display it
    			const obj = routesList[i].component;

    			// Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted
    			if (componentObj != obj) {
    				if (obj.loading) {
    					$$invalidate(0, component = obj.loading);
    					componentObj = obj;
    					$$invalidate(1, componentParams = obj.loadingParams);
    					$$invalidate(2, props = {});

    					// Trigger the routeLoaded event for the loading component
    					// Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)
    					dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    						component,
    						name: component.name,
    						params: componentParams
    					}));
    				} else {
    					$$invalidate(0, component = null);
    					componentObj = null;
    				}

    				// Invoke the Promise
    				const loaded = await obj();

    				// Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile
    				if (newLoc != lastLoc) {
    					// Don't update the component, just exit
    					return;
    				}

    				// If there is a "default" property, which is used by async routes, then pick that
    				$$invalidate(0, component = loaded && loaded.default || loaded);

    				componentObj = obj;
    			}

    			// Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`
    			// Of course, this assumes that developers always add a "params" prop when they are expecting parameters
    			if (match && typeof match == 'object' && Object.keys(match).length) {
    				$$invalidate(1, componentParams = match);
    			} else {
    				$$invalidate(1, componentParams = null);
    			}

    			// Set static props, if any
    			$$invalidate(2, props = routesList[i].props);

    			// Dispatch the routeLoaded event then exit
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    				component,
    				name: component.name,
    				params: componentParams
    			})).then(() => {
    				params.set(componentParams);
    			});

    			return;
    		}

    		// If we're still here, there was no match, so show the empty component
    		$$invalidate(0, component = null);

    		componentObj = null;
    		params.set(undefined);
    	});

    	onDestroy(() => {
    		unsubscribeLoc();
    		popStateChanged && window.removeEventListener('popstate', popStateChanged);
    	});

    	const writable_props = ['routes', 'prefix', 'restoreScrollState'];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	function routeEvent_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function routeEvent_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('routes' in $$props) $$invalidate(3, routes = $$props.routes);
    		if ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    	};

    	$$self.$capture_state = () => ({
    		readable,
    		writable,
    		derived,
    		tick,
    		_wrap: wrap$1,
    		wrap,
    		getLocation,
    		loc,
    		location,
    		querystring,
    		params,
    		push,
    		pop,
    		replace,
    		link,
    		restoreScroll,
    		updateLink,
    		linkOpts,
    		scrollstateHistoryHandler,
    		onDestroy,
    		createEventDispatcher,
    		afterUpdate,
    		parse,
    		routes,
    		prefix,
    		restoreScrollState,
    		RouteItem,
    		routesList,
    		component,
    		componentParams,
    		props,
    		dispatch,
    		dispatchNextTick,
    		previousScrollState,
    		popStateChanged,
    		lastLoc,
    		componentObj,
    		unsubscribeLoc
    	});

    	$$self.$inject_state = $$props => {
    		if ('routes' in $$props) $$invalidate(3, routes = $$props.routes);
    		if ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    		if ('component' in $$props) $$invalidate(0, component = $$props.component);
    		if ('componentParams' in $$props) $$invalidate(1, componentParams = $$props.componentParams);
    		if ('props' in $$props) $$invalidate(2, props = $$props.props);
    		if ('previousScrollState' in $$props) previousScrollState = $$props.previousScrollState;
    		if ('popStateChanged' in $$props) popStateChanged = $$props.popStateChanged;
    		if ('lastLoc' in $$props) lastLoc = $$props.lastLoc;
    		if ('componentObj' in $$props) componentObj = $$props.componentObj;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*restoreScrollState*/ 32) {
    			// Update history.scrollRestoration depending on restoreScrollState
    			history.scrollRestoration = restoreScrollState ? 'manual' : 'auto';
    		}
    	};

    	return [
    		component,
    		componentParams,
    		props,
    		routes,
    		prefix,
    		restoreScrollState,
    		routeEvent_handler,
    		routeEvent_handler_1
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$19, create_fragment$1a, safe_not_equal, {
    			routes: 3,
    			prefix: 4,
    			restoreScrollState: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment$1a.name
    		});
    	}

    	get routes() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get restoreScrollState() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set restoreScrollState(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    if (typeof window !== "undefined") {
    	if (window.Prism)
    		console.warn(
    			"Prism has already been initiated. Please ensure that svelte-prism is imported first."
    		);

    	window.Prism = window.Prism || {};
    	window.Prism.manual = true;
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    var prism$2 = {exports: {}};

    (function (module) {
    	/* **********************************************
    	     Begin prism-core.js
    	********************************************** */

    	/// <reference lib="WebWorker"/>

    	var _self = (typeof window !== 'undefined')
    		? window   // if in browser
    		: (
    			(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
    				? self // if in worker
    				: {}   // if in node js
    		);

    	/**
    	 * Prism: Lightweight, robust, elegant syntax highlighting
    	 *
    	 * @license MIT <https://opensource.org/licenses/MIT>
    	 * @author Lea Verou <https://lea.verou.me>
    	 * @namespace
    	 * @public
    	 */
    	var Prism = (function (_self) {

    		// Private helper vars
    		var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
    		var uniqueId = 0;

    		// The grammar object for plaintext
    		var plainTextGrammar = {};


    		var _ = {
    			/**
    			 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
    			 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
    			 * additional languages or plugins yourself.
    			 *
    			 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
    			 *
    			 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
    			 * empty Prism object into the global scope before loading the Prism script like this:
    			 *
    			 * ```js
    			 * window.Prism = window.Prism || {};
    			 * Prism.manual = true;
    			 * // add a new <script> to load Prism's script
    			 * ```
    			 *
    			 * @default false
    			 * @type {boolean}
    			 * @memberof Prism
    			 * @public
    			 */
    			manual: _self.Prism && _self.Prism.manual,
    			/**
    			 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
    			 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
    			 * own worker, you don't want it to do this.
    			 *
    			 * By setting this value to `true`, Prism will not add its own listeners to the worker.
    			 *
    			 * You obviously have to change this value before Prism executes. To do this, you can add an
    			 * empty Prism object into the global scope before loading the Prism script like this:
    			 *
    			 * ```js
    			 * window.Prism = window.Prism || {};
    			 * Prism.disableWorkerMessageHandler = true;
    			 * // Load Prism's script
    			 * ```
    			 *
    			 * @default false
    			 * @type {boolean}
    			 * @memberof Prism
    			 * @public
    			 */
    			disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

    			/**
    			 * A namespace for utility methods.
    			 *
    			 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
    			 * change or disappear at any time.
    			 *
    			 * @namespace
    			 * @memberof Prism
    			 */
    			util: {
    				encode: function encode(tokens) {
    					if (tokens instanceof Token) {
    						return new Token(tokens.type, encode(tokens.content), tokens.alias);
    					} else if (Array.isArray(tokens)) {
    						return tokens.map(encode);
    					} else {
    						return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
    					}
    				},

    				/**
    				 * Returns the name of the type of the given value.
    				 *
    				 * @param {any} o
    				 * @returns {string}
    				 * @example
    				 * type(null)      === 'Null'
    				 * type(undefined) === 'Undefined'
    				 * type(123)       === 'Number'
    				 * type('foo')     === 'String'
    				 * type(true)      === 'Boolean'
    				 * type([1, 2])    === 'Array'
    				 * type({})        === 'Object'
    				 * type(String)    === 'Function'
    				 * type(/abc+/)    === 'RegExp'
    				 */
    				type: function (o) {
    					return Object.prototype.toString.call(o).slice(8, -1);
    				},

    				/**
    				 * Returns a unique number for the given object. Later calls will still return the same number.
    				 *
    				 * @param {Object} obj
    				 * @returns {number}
    				 */
    				objId: function (obj) {
    					if (!obj['__id']) {
    						Object.defineProperty(obj, '__id', { value: ++uniqueId });
    					}
    					return obj['__id'];
    				},

    				/**
    				 * Creates a deep clone of the given object.
    				 *
    				 * The main intended use of this function is to clone language definitions.
    				 *
    				 * @param {T} o
    				 * @param {Record<number, any>} [visited]
    				 * @returns {T}
    				 * @template T
    				 */
    				clone: function deepClone(o, visited) {
    					visited = visited || {};

    					var clone; var id;
    					switch (_.util.type(o)) {
    						case 'Object':
    							id = _.util.objId(o);
    							if (visited[id]) {
    								return visited[id];
    							}
    							clone = /** @type {Record<string, any>} */ ({});
    							visited[id] = clone;

    							for (var key in o) {
    								if (o.hasOwnProperty(key)) {
    									clone[key] = deepClone(o[key], visited);
    								}
    							}

    							return /** @type {any} */ (clone);

    						case 'Array':
    							id = _.util.objId(o);
    							if (visited[id]) {
    								return visited[id];
    							}
    							clone = [];
    							visited[id] = clone;

    							(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
    								clone[i] = deepClone(v, visited);
    							});

    							return /** @type {any} */ (clone);

    						default:
    							return o;
    					}
    				},

    				/**
    				 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
    				 *
    				 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
    				 *
    				 * @param {Element} element
    				 * @returns {string}
    				 */
    				getLanguage: function (element) {
    					while (element) {
    						var m = lang.exec(element.className);
    						if (m) {
    							return m[1].toLowerCase();
    						}
    						element = element.parentElement;
    					}
    					return 'none';
    				},

    				/**
    				 * Sets the Prism `language-xxxx` class of the given element.
    				 *
    				 * @param {Element} element
    				 * @param {string} language
    				 * @returns {void}
    				 */
    				setLanguage: function (element, language) {
    					// remove all `language-xxxx` classes
    					// (this might leave behind a leading space)
    					element.className = element.className.replace(RegExp(lang, 'gi'), '');

    					// add the new `language-xxxx` class
    					// (using `classList` will automatically clean up spaces for us)
    					element.classList.add('language-' + language);
    				},

    				/**
    				 * Returns the script element that is currently executing.
    				 *
    				 * This does __not__ work for line script element.
    				 *
    				 * @returns {HTMLScriptElement | null}
    				 */
    				currentScript: function () {
    					if (typeof document === 'undefined') {
    						return null;
    					}
    					if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
    						return /** @type {any} */ (document.currentScript);
    					}

    					// IE11 workaround
    					// we'll get the src of the current script by parsing IE11's error stack trace
    					// this will not work for inline scripts

    					try {
    						throw new Error();
    					} catch (err) {
    						// Get file src url from stack. Specifically works with the format of stack traces in IE.
    						// A stack will look like this:
    						//
    						// Error
    						//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
    						//    at Global code (http://localhost/components/prism-core.js:606:1)

    						var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
    						if (src) {
    							var scripts = document.getElementsByTagName('script');
    							for (var i in scripts) {
    								if (scripts[i].src == src) {
    									return scripts[i];
    								}
    							}
    						}
    						return null;
    					}
    				},

    				/**
    				 * Returns whether a given class is active for `element`.
    				 *
    				 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
    				 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
    				 * given class is just the given class with a `no-` prefix.
    				 *
    				 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
    				 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
    				 * ancestors have the given class or the negated version of it, then the default activation will be returned.
    				 *
    				 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
    				 * version of it, the class is considered active.
    				 *
    				 * @param {Element} element
    				 * @param {string} className
    				 * @param {boolean} [defaultActivation=false]
    				 * @returns {boolean}
    				 */
    				isActive: function (element, className, defaultActivation) {
    					var no = 'no-' + className;

    					while (element) {
    						var classList = element.classList;
    						if (classList.contains(className)) {
    							return true;
    						}
    						if (classList.contains(no)) {
    							return false;
    						}
    						element = element.parentElement;
    					}
    					return !!defaultActivation;
    				}
    			},

    			/**
    			 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
    			 *
    			 * @namespace
    			 * @memberof Prism
    			 * @public
    			 */
    			languages: {
    				/**
    				 * The grammar for plain, unformatted text.
    				 */
    				plain: plainTextGrammar,
    				plaintext: plainTextGrammar,
    				text: plainTextGrammar,
    				txt: plainTextGrammar,

    				/**
    				 * Creates a deep copy of the language with the given id and appends the given tokens.
    				 *
    				 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
    				 * will be overwritten at its original position.
    				 *
    				 * ## Best practices
    				 *
    				 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
    				 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
    				 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
    				 *
    				 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
    				 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
    				 *
    				 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
    				 * @param {Grammar} redef The new tokens to append.
    				 * @returns {Grammar} The new language created.
    				 * @public
    				 * @example
    				 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
    				 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
    				 *     // at its original position
    				 *     'comment': { ... },
    				 *     // CSS doesn't have a 'color' token, so this token will be appended
    				 *     'color': /\b(?:red|green|blue)\b/
    				 * });
    				 */
    				extend: function (id, redef) {
    					var lang = _.util.clone(_.languages[id]);

    					for (var key in redef) {
    						lang[key] = redef[key];
    					}

    					return lang;
    				},

    				/**
    				 * Inserts tokens _before_ another token in a language definition or any other grammar.
    				 *
    				 * ## Usage
    				 *
    				 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
    				 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
    				 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
    				 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
    				 * this:
    				 *
    				 * ```js
    				 * Prism.languages.markup.style = {
    				 *     // token
    				 * };
    				 * ```
    				 *
    				 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
    				 * before existing tokens. For the CSS example above, you would use it like this:
    				 *
    				 * ```js
    				 * Prism.languages.insertBefore('markup', 'cdata', {
    				 *     'style': {
    				 *         // token
    				 *     }
    				 * });
    				 * ```
    				 *
    				 * ## Special cases
    				 *
    				 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
    				 * will be ignored.
    				 *
    				 * This behavior can be used to insert tokens after `before`:
    				 *
    				 * ```js
    				 * Prism.languages.insertBefore('markup', 'comment', {
    				 *     'comment': Prism.languages.markup.comment,
    				 *     // tokens after 'comment'
    				 * });
    				 * ```
    				 *
    				 * ## Limitations
    				 *
    				 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
    				 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
    				 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
    				 * deleting properties which is necessary to insert at arbitrary positions.
    				 *
    				 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
    				 * Instead, it will create a new object and replace all references to the target object with the new one. This
    				 * can be done without temporarily deleting properties, so the iteration order is well-defined.
    				 *
    				 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
    				 * you hold the target object in a variable, then the value of the variable will not change.
    				 *
    				 * ```js
    				 * var oldMarkup = Prism.languages.markup;
    				 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
    				 *
    				 * assert(oldMarkup !== Prism.languages.markup);
    				 * assert(newMarkup === Prism.languages.markup);
    				 * ```
    				 *
    				 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
    				 * object to be modified.
    				 * @param {string} before The key to insert before.
    				 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
    				 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
    				 * object to be modified.
    				 *
    				 * Defaults to `Prism.languages`.
    				 * @returns {Grammar} The new grammar object.
    				 * @public
    				 */
    				insertBefore: function (inside, before, insert, root) {
    					root = root || /** @type {any} */ (_.languages);
    					var grammar = root[inside];
    					/** @type {Grammar} */
    					var ret = {};

    					for (var token in grammar) {
    						if (grammar.hasOwnProperty(token)) {

    							if (token == before) {
    								for (var newToken in insert) {
    									if (insert.hasOwnProperty(newToken)) {
    										ret[newToken] = insert[newToken];
    									}
    								}
    							}

    							// Do not insert token which also occur in insert. See #1525
    							if (!insert.hasOwnProperty(token)) {
    								ret[token] = grammar[token];
    							}
    						}
    					}

    					var old = root[inside];
    					root[inside] = ret;

    					// Update references in other language definitions
    					_.languages.DFS(_.languages, function (key, value) {
    						if (value === old && key != inside) {
    							this[key] = ret;
    						}
    					});

    					return ret;
    				},

    				// Traverse a language definition with Depth First Search
    				DFS: function DFS(o, callback, type, visited) {
    					visited = visited || {};

    					var objId = _.util.objId;

    					for (var i in o) {
    						if (o.hasOwnProperty(i)) {
    							callback.call(o, i, o[i], type || i);

    							var property = o[i];
    							var propertyType = _.util.type(property);

    							if (propertyType === 'Object' && !visited[objId(property)]) {
    								visited[objId(property)] = true;
    								DFS(property, callback, null, visited);
    							} else if (propertyType === 'Array' && !visited[objId(property)]) {
    								visited[objId(property)] = true;
    								DFS(property, callback, i, visited);
    							}
    						}
    					}
    				}
    			},

    			plugins: {},

    			/**
    			 * This is the most high-level function in Prisms API.
    			 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
    			 * each one of them.
    			 *
    			 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
    			 *
    			 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
    			 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
    			 * @memberof Prism
    			 * @public
    			 */
    			highlightAll: function (async, callback) {
    				_.highlightAllUnder(document, async, callback);
    			},

    			/**
    			 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
    			 * {@link Prism.highlightElement} on each one of them.
    			 *
    			 * The following hooks will be run:
    			 * 1. `before-highlightall`
    			 * 2. `before-all-elements-highlight`
    			 * 3. All hooks of {@link Prism.highlightElement} for each element.
    			 *
    			 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
    			 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
    			 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
    			 * @memberof Prism
    			 * @public
    			 */
    			highlightAllUnder: function (container, async, callback) {
    				var env = {
    					callback: callback,
    					container: container,
    					selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
    				};

    				_.hooks.run('before-highlightall', env);

    				env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

    				_.hooks.run('before-all-elements-highlight', env);

    				for (var i = 0, element; (element = env.elements[i++]);) {
    					_.highlightElement(element, async === true, env.callback);
    				}
    			},

    			/**
    			 * Highlights the code inside a single element.
    			 *
    			 * The following hooks will be run:
    			 * 1. `before-sanity-check`
    			 * 2. `before-highlight`
    			 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
    			 * 4. `before-insert`
    			 * 5. `after-highlight`
    			 * 6. `complete`
    			 *
    			 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
    			 * the element's language.
    			 *
    			 * @param {Element} element The element containing the code.
    			 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
    			 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
    			 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
    			 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
    			 *
    			 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
    			 * asynchronous highlighting to work. You can build your own bundle on the
    			 * [Download page](https://prismjs.com/download.html).
    			 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
    			 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
    			 * @memberof Prism
    			 * @public
    			 */
    			highlightElement: function (element, async, callback) {
    				// Find language
    				var language = _.util.getLanguage(element);
    				var grammar = _.languages[language];

    				// Set language on the element, if not present
    				_.util.setLanguage(element, language);

    				// Set language on the parent, for styling
    				var parent = element.parentElement;
    				if (parent && parent.nodeName.toLowerCase() === 'pre') {
    					_.util.setLanguage(parent, language);
    				}

    				var code = element.textContent;

    				var env = {
    					element: element,
    					language: language,
    					grammar: grammar,
    					code: code
    				};

    				function insertHighlightedCode(highlightedCode) {
    					env.highlightedCode = highlightedCode;

    					_.hooks.run('before-insert', env);

    					env.element.innerHTML = env.highlightedCode;

    					_.hooks.run('after-highlight', env);
    					_.hooks.run('complete', env);
    					callback && callback.call(env.element);
    				}

    				_.hooks.run('before-sanity-check', env);

    				// plugins may change/add the parent/element
    				parent = env.element.parentElement;
    				if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
    					parent.setAttribute('tabindex', '0');
    				}

    				if (!env.code) {
    					_.hooks.run('complete', env);
    					callback && callback.call(env.element);
    					return;
    				}

    				_.hooks.run('before-highlight', env);

    				if (!env.grammar) {
    					insertHighlightedCode(_.util.encode(env.code));
    					return;
    				}

    				if (async && _self.Worker) {
    					var worker = new Worker(_.filename);

    					worker.onmessage = function (evt) {
    						insertHighlightedCode(evt.data);
    					};

    					worker.postMessage(JSON.stringify({
    						language: env.language,
    						code: env.code,
    						immediateClose: true
    					}));
    				} else {
    					insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
    				}
    			},

    			/**
    			 * Low-level function, only use if you know what youre doing. It accepts a string of text as input
    			 * and the language definitions to use, and returns a string with the HTML produced.
    			 *
    			 * The following hooks will be run:
    			 * 1. `before-tokenize`
    			 * 2. `after-tokenize`
    			 * 3. `wrap`: On each {@link Token}.
    			 *
    			 * @param {string} text A string with the code to be highlighted.
    			 * @param {Grammar} grammar An object containing the tokens to use.
    			 *
    			 * Usually a language definition like `Prism.languages.markup`.
    			 * @param {string} language The name of the language definition passed to `grammar`.
    			 * @returns {string} The highlighted HTML.
    			 * @memberof Prism
    			 * @public
    			 * @example
    			 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
    			 */
    			highlight: function (text, grammar, language) {
    				var env = {
    					code: text,
    					grammar: grammar,
    					language: language
    				};
    				_.hooks.run('before-tokenize', env);
    				if (!env.grammar) {
    					throw new Error('The language "' + env.language + '" has no grammar.');
    				}
    				env.tokens = _.tokenize(env.code, env.grammar);
    				_.hooks.run('after-tokenize', env);
    				return Token.stringify(_.util.encode(env.tokens), env.language);
    			},

    			/**
    			 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
    			 * and the language definitions to use, and returns an array with the tokenized code.
    			 *
    			 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
    			 *
    			 * This method could be useful in other contexts as well, as a very crude parser.
    			 *
    			 * @param {string} text A string with the code to be highlighted.
    			 * @param {Grammar} grammar An object containing the tokens to use.
    			 *
    			 * Usually a language definition like `Prism.languages.markup`.
    			 * @returns {TokenStream} An array of strings and tokens, a token stream.
    			 * @memberof Prism
    			 * @public
    			 * @example
    			 * let code = `var foo = 0;`;
    			 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
    			 * tokens.forEach(token => {
    			 *     if (token instanceof Prism.Token && token.type === 'number') {
    			 *         console.log(`Found numeric literal: ${token.content}`);
    			 *     }
    			 * });
    			 */
    			tokenize: function (text, grammar) {
    				var rest = grammar.rest;
    				if (rest) {
    					for (var token in rest) {
    						grammar[token] = rest[token];
    					}

    					delete grammar.rest;
    				}

    				var tokenList = new LinkedList();
    				addAfter(tokenList, tokenList.head, text);

    				matchGrammar(text, tokenList, grammar, tokenList.head, 0);

    				return toArray(tokenList);
    			},

    			/**
    			 * @namespace
    			 * @memberof Prism
    			 * @public
    			 */
    			hooks: {
    				all: {},

    				/**
    				 * Adds the given callback to the list of callbacks for the given hook.
    				 *
    				 * The callback will be invoked when the hook it is registered for is run.
    				 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
    				 *
    				 * One callback function can be registered to multiple hooks and the same hook multiple times.
    				 *
    				 * @param {string} name The name of the hook.
    				 * @param {HookCallback} callback The callback function which is given environment variables.
    				 * @public
    				 */
    				add: function (name, callback) {
    					var hooks = _.hooks.all;

    					hooks[name] = hooks[name] || [];

    					hooks[name].push(callback);
    				},

    				/**
    				 * Runs a hook invoking all registered callbacks with the given environment variables.
    				 *
    				 * Callbacks will be invoked synchronously and in the order in which they were registered.
    				 *
    				 * @param {string} name The name of the hook.
    				 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
    				 * @public
    				 */
    				run: function (name, env) {
    					var callbacks = _.hooks.all[name];

    					if (!callbacks || !callbacks.length) {
    						return;
    					}

    					for (var i = 0, callback; (callback = callbacks[i++]);) {
    						callback(env);
    					}
    				}
    			},

    			Token: Token
    		};
    		_self.Prism = _;


    		// Typescript note:
    		// The following can be used to import the Token type in JSDoc:
    		//
    		//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

    		/**
    		 * Creates a new token.
    		 *
    		 * @param {string} type See {@link Token#type type}
    		 * @param {string | TokenStream} content See {@link Token#content content}
    		 * @param {string|string[]} [alias] The alias(es) of the token.
    		 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
    		 * @class
    		 * @global
    		 * @public
    		 */
    		function Token(type, content, alias, matchedStr) {
    			/**
    			 * The type of the token.
    			 *
    			 * This is usually the key of a pattern in a {@link Grammar}.
    			 *
    			 * @type {string}
    			 * @see GrammarToken
    			 * @public
    			 */
    			this.type = type;
    			/**
    			 * The strings or tokens contained by this token.
    			 *
    			 * This will be a token stream if the pattern matched also defined an `inside` grammar.
    			 *
    			 * @type {string | TokenStream}
    			 * @public
    			 */
    			this.content = content;
    			/**
    			 * The alias(es) of the token.
    			 *
    			 * @type {string|string[]}
    			 * @see GrammarToken
    			 * @public
    			 */
    			this.alias = alias;
    			// Copy of the full string this token was created from
    			this.length = (matchedStr || '').length | 0;
    		}

    		/**
    		 * A token stream is an array of strings and {@link Token Token} objects.
    		 *
    		 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
    		 * them.
    		 *
    		 * 1. No adjacent strings.
    		 * 2. No empty strings.
    		 *
    		 *    The only exception here is the token stream that only contains the empty string and nothing else.
    		 *
    		 * @typedef {Array<string | Token>} TokenStream
    		 * @global
    		 * @public
    		 */

    		/**
    		 * Converts the given token or token stream to an HTML representation.
    		 *
    		 * The following hooks will be run:
    		 * 1. `wrap`: On each {@link Token}.
    		 *
    		 * @param {string | Token | TokenStream} o The token or token stream to be converted.
    		 * @param {string} language The name of current language.
    		 * @returns {string} The HTML representation of the token or token stream.
    		 * @memberof Token
    		 * @static
    		 */
    		Token.stringify = function stringify(o, language) {
    			if (typeof o == 'string') {
    				return o;
    			}
    			if (Array.isArray(o)) {
    				var s = '';
    				o.forEach(function (e) {
    					s += stringify(e, language);
    				});
    				return s;
    			}

    			var env = {
    				type: o.type,
    				content: stringify(o.content, language),
    				tag: 'span',
    				classes: ['token', o.type],
    				attributes: {},
    				language: language
    			};

    			var aliases = o.alias;
    			if (aliases) {
    				if (Array.isArray(aliases)) {
    					Array.prototype.push.apply(env.classes, aliases);
    				} else {
    					env.classes.push(aliases);
    				}
    			}

    			_.hooks.run('wrap', env);

    			var attributes = '';
    			for (var name in env.attributes) {
    				attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
    			}

    			return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
    		};

    		/**
    		 * @param {RegExp} pattern
    		 * @param {number} pos
    		 * @param {string} text
    		 * @param {boolean} lookbehind
    		 * @returns {RegExpExecArray | null}
    		 */
    		function matchPattern(pattern, pos, text, lookbehind) {
    			pattern.lastIndex = pos;
    			var match = pattern.exec(text);
    			if (match && lookbehind && match[1]) {
    				// change the match to remove the text matched by the Prism lookbehind group
    				var lookbehindLength = match[1].length;
    				match.index += lookbehindLength;
    				match[0] = match[0].slice(lookbehindLength);
    			}
    			return match;
    		}

    		/**
    		 * @param {string} text
    		 * @param {LinkedList<string | Token>} tokenList
    		 * @param {any} grammar
    		 * @param {LinkedListNode<string | Token>} startNode
    		 * @param {number} startPos
    		 * @param {RematchOptions} [rematch]
    		 * @returns {void}
    		 * @private
    		 *
    		 * @typedef RematchOptions
    		 * @property {string} cause
    		 * @property {number} reach
    		 */
    		function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
    			for (var token in grammar) {
    				if (!grammar.hasOwnProperty(token) || !grammar[token]) {
    					continue;
    				}

    				var patterns = grammar[token];
    				patterns = Array.isArray(patterns) ? patterns : [patterns];

    				for (var j = 0; j < patterns.length; ++j) {
    					if (rematch && rematch.cause == token + ',' + j) {
    						return;
    					}

    					var patternObj = patterns[j];
    					var inside = patternObj.inside;
    					var lookbehind = !!patternObj.lookbehind;
    					var greedy = !!patternObj.greedy;
    					var alias = patternObj.alias;

    					if (greedy && !patternObj.pattern.global) {
    						// Without the global flag, lastIndex won't work
    						var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
    						patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
    					}

    					/** @type {RegExp} */
    					var pattern = patternObj.pattern || patternObj;

    					for ( // iterate the token list and keep track of the current token/string position
    						var currentNode = startNode.next, pos = startPos;
    						currentNode !== tokenList.tail;
    						pos += currentNode.value.length, currentNode = currentNode.next
    					) {

    						if (rematch && pos >= rematch.reach) {
    							break;
    						}

    						var str = currentNode.value;

    						if (tokenList.length > text.length) {
    							// Something went terribly wrong, ABORT, ABORT!
    							return;
    						}

    						if (str instanceof Token) {
    							continue;
    						}

    						var removeCount = 1; // this is the to parameter of removeBetween
    						var match;

    						if (greedy) {
    							match = matchPattern(pattern, pos, text, lookbehind);
    							if (!match || match.index >= text.length) {
    								break;
    							}

    							var from = match.index;
    							var to = match.index + match[0].length;
    							var p = pos;

    							// find the node that contains the match
    							p += currentNode.value.length;
    							while (from >= p) {
    								currentNode = currentNode.next;
    								p += currentNode.value.length;
    							}
    							// adjust pos (and p)
    							p -= currentNode.value.length;
    							pos = p;

    							// the current node is a Token, then the match starts inside another Token, which is invalid
    							if (currentNode.value instanceof Token) {
    								continue;
    							}

    							// find the last node which is affected by this match
    							for (
    								var k = currentNode;
    								k !== tokenList.tail && (p < to || typeof k.value === 'string');
    								k = k.next
    							) {
    								removeCount++;
    								p += k.value.length;
    							}
    							removeCount--;

    							// replace with the new match
    							str = text.slice(pos, p);
    							match.index -= pos;
    						} else {
    							match = matchPattern(pattern, 0, str, lookbehind);
    							if (!match) {
    								continue;
    							}
    						}

    						// eslint-disable-next-line no-redeclare
    						var from = match.index;
    						var matchStr = match[0];
    						var before = str.slice(0, from);
    						var after = str.slice(from + matchStr.length);

    						var reach = pos + str.length;
    						if (rematch && reach > rematch.reach) {
    							rematch.reach = reach;
    						}

    						var removeFrom = currentNode.prev;

    						if (before) {
    							removeFrom = addAfter(tokenList, removeFrom, before);
    							pos += before.length;
    						}

    						removeRange(tokenList, removeFrom, removeCount);

    						var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
    						currentNode = addAfter(tokenList, removeFrom, wrapped);

    						if (after) {
    							addAfter(tokenList, currentNode, after);
    						}

    						if (removeCount > 1) {
    							// at least one Token object was removed, so we have to do some rematching
    							// this can only happen if the current pattern is greedy

    							/** @type {RematchOptions} */
    							var nestedRematch = {
    								cause: token + ',' + j,
    								reach: reach
    							};
    							matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

    							// the reach might have been extended because of the rematching
    							if (rematch && nestedRematch.reach > rematch.reach) {
    								rematch.reach = nestedRematch.reach;
    							}
    						}
    					}
    				}
    			}
    		}

    		/**
    		 * @typedef LinkedListNode
    		 * @property {T} value
    		 * @property {LinkedListNode<T> | null} prev The previous node.
    		 * @property {LinkedListNode<T> | null} next The next node.
    		 * @template T
    		 * @private
    		 */

    		/**
    		 * @template T
    		 * @private
    		 */
    		function LinkedList() {
    			/** @type {LinkedListNode<T>} */
    			var head = { value: null, prev: null, next: null };
    			/** @type {LinkedListNode<T>} */
    			var tail = { value: null, prev: head, next: null };
    			head.next = tail;

    			/** @type {LinkedListNode<T>} */
    			this.head = head;
    			/** @type {LinkedListNode<T>} */
    			this.tail = tail;
    			this.length = 0;
    		}

    		/**
    		 * Adds a new node with the given value to the list.
    		 *
    		 * @param {LinkedList<T>} list
    		 * @param {LinkedListNode<T>} node
    		 * @param {T} value
    		 * @returns {LinkedListNode<T>} The added node.
    		 * @template T
    		 */
    		function addAfter(list, node, value) {
    			// assumes that node != list.tail && values.length >= 0
    			var next = node.next;

    			var newNode = { value: value, prev: node, next: next };
    			node.next = newNode;
    			next.prev = newNode;
    			list.length++;

    			return newNode;
    		}
    		/**
    		 * Removes `count` nodes after the given node. The given node will not be removed.
    		 *
    		 * @param {LinkedList<T>} list
    		 * @param {LinkedListNode<T>} node
    		 * @param {number} count
    		 * @template T
    		 */
    		function removeRange(list, node, count) {
    			var next = node.next;
    			for (var i = 0; i < count && next !== list.tail; i++) {
    				next = next.next;
    			}
    			node.next = next;
    			next.prev = node;
    			list.length -= i;
    		}
    		/**
    		 * @param {LinkedList<T>} list
    		 * @returns {T[]}
    		 * @template T
    		 */
    		function toArray(list) {
    			var array = [];
    			var node = list.head.next;
    			while (node !== list.tail) {
    				array.push(node.value);
    				node = node.next;
    			}
    			return array;
    		}


    		if (!_self.document) {
    			if (!_self.addEventListener) {
    				// in Node.js
    				return _;
    			}

    			if (!_.disableWorkerMessageHandler) {
    				// In worker
    				_self.addEventListener('message', function (evt) {
    					var message = JSON.parse(evt.data);
    					var lang = message.language;
    					var code = message.code;
    					var immediateClose = message.immediateClose;

    					_self.postMessage(_.highlight(code, _.languages[lang], lang));
    					if (immediateClose) {
    						_self.close();
    					}
    				}, false);
    			}

    			return _;
    		}

    		// Get current script and highlight
    		var script = _.util.currentScript();

    		if (script) {
    			_.filename = script.src;

    			if (script.hasAttribute('data-manual')) {
    				_.manual = true;
    			}
    		}

    		function highlightAutomaticallyCallback() {
    			if (!_.manual) {
    				_.highlightAll();
    			}
    		}

    		if (!_.manual) {
    			// If the document state is "loading", then we'll use DOMContentLoaded.
    			// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
    			// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
    			// might take longer one animation frame to execute which can create a race condition where only some plugins have
    			// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
    			// See https://github.com/PrismJS/prism/issues/2102
    			var readyState = document.readyState;
    			if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
    				document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
    			} else {
    				if (window.requestAnimationFrame) {
    					window.requestAnimationFrame(highlightAutomaticallyCallback);
    				} else {
    					window.setTimeout(highlightAutomaticallyCallback, 16);
    				}
    			}
    		}

    		return _;

    	}(_self));

    	if (module.exports) {
    		module.exports = Prism;
    	}

    	// hack for components to work correctly in node.js
    	if (typeof commonjsGlobal !== 'undefined') {
    		commonjsGlobal.Prism = Prism;
    	}

    	// some additional documentation/types

    	/**
    	 * The expansion of a simple `RegExp` literal to support additional properties.
    	 *
    	 * @typedef GrammarToken
    	 * @property {RegExp} pattern The regular expression of the token.
    	 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
    	 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
    	 * @property {boolean} [greedy=false] Whether the token is greedy.
    	 * @property {string|string[]} [alias] An optional alias or list of aliases.
    	 * @property {Grammar} [inside] The nested grammar of this token.
    	 *
    	 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
    	 *
    	 * This can be used to make nested and even recursive language definitions.
    	 *
    	 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
    	 * each another.
    	 * @global
    	 * @public
    	 */

    	/**
    	 * @typedef Grammar
    	 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
    	 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
    	 * @global
    	 * @public
    	 */

    	/**
    	 * A function which will invoked after an element was successfully highlighted.
    	 *
    	 * @callback HighlightCallback
    	 * @param {Element} element The element successfully highlighted.
    	 * @returns {void}
    	 * @global
    	 * @public
    	 */

    	/**
    	 * @callback HookCallback
    	 * @param {Object<string, any>} env The environment variables of the hook.
    	 * @returns {void}
    	 * @global
    	 * @public
    	 */


    	/* **********************************************
    	     Begin prism-markup.js
    	********************************************** */

    	Prism.languages.markup = {
    		'comment': {
    			pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
    			greedy: true
    		},
    		'prolog': {
    			pattern: /<\?[\s\S]+?\?>/,
    			greedy: true
    		},
    		'doctype': {
    			// https://www.w3.org/TR/xml/#NT-doctypedecl
    			pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    			greedy: true,
    			inside: {
    				'internal-subset': {
    					pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
    					lookbehind: true,
    					greedy: true,
    					inside: null // see below
    				},
    				'string': {
    					pattern: /"[^"]*"|'[^']*'/,
    					greedy: true
    				},
    				'punctuation': /^<!|>$|[[\]]/,
    				'doctype-tag': /^DOCTYPE/i,
    				'name': /[^\s<>'"]+/
    			}
    		},
    		'cdata': {
    			pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    			greedy: true
    		},
    		'tag': {
    			pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    			greedy: true,
    			inside: {
    				'tag': {
    					pattern: /^<\/?[^\s>\/]+/,
    					inside: {
    						'punctuation': /^<\/?/,
    						'namespace': /^[^\s>\/:]+:/
    					}
    				},
    				'special-attr': [],
    				'attr-value': {
    					pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
    					inside: {
    						'punctuation': [
    							{
    								pattern: /^=/,
    								alias: 'attr-equals'
    							},
    							{
    								pattern: /^(\s*)["']|["']$/,
    								lookbehind: true
    							}
    						]
    					}
    				},
    				'punctuation': /\/?>/,
    				'attr-name': {
    					pattern: /[^\s>\/]+/,
    					inside: {
    						'namespace': /^[^\s>\/:]+:/
    					}
    				}

    			}
    		},
    		'entity': [
    			{
    				pattern: /&[\da-z]{1,8};/i,
    				alias: 'named-entity'
    			},
    			/&#x?[\da-f]{1,8};/i
    		]
    	};

    	Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
    		Prism.languages.markup['entity'];
    	Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

    	// Plugin to make entity title show the real entity, idea by Roman Komarov
    	Prism.hooks.add('wrap', function (env) {

    		if (env.type === 'entity') {
    			env.attributes['title'] = env.content.replace(/&amp;/, '&');
    		}
    	});

    	Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
    		/**
    		 * Adds an inlined language to markup.
    		 *
    		 * An example of an inlined language is CSS with `<style>` tags.
    		 *
    		 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
    		 * case insensitive.
    		 * @param {string} lang The language key.
    		 * @example
    		 * addInlined('style', 'css');
    		 */
    		value: function addInlined(tagName, lang) {
    			var includedCdataInside = {};
    			includedCdataInside['language-' + lang] = {
    				pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
    				lookbehind: true,
    				inside: Prism.languages[lang]
    			};
    			includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

    			var inside = {
    				'included-cdata': {
    					pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    					inside: includedCdataInside
    				}
    			};
    			inside['language-' + lang] = {
    				pattern: /[\s\S]+/,
    				inside: Prism.languages[lang]
    			};

    			var def = {};
    			def[tagName] = {
    				pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
    				lookbehind: true,
    				greedy: true,
    				inside: inside
    			};

    			Prism.languages.insertBefore('markup', 'cdata', def);
    		}
    	});
    	Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
    		/**
    		 * Adds an pattern to highlight languages embedded in HTML attributes.
    		 *
    		 * An example of an inlined language is CSS with `style` attributes.
    		 *
    		 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
    		 * case insensitive.
    		 * @param {string} lang The language key.
    		 * @example
    		 * addAttribute('style', 'css');
    		 */
    		value: function (attrName, lang) {
    			Prism.languages.markup.tag.inside['special-attr'].push({
    				pattern: RegExp(
    					/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
    					'i'
    				),
    				lookbehind: true,
    				inside: {
    					'attr-name': /^[^\s=]+/,
    					'attr-value': {
    						pattern: /=[\s\S]+/,
    						inside: {
    							'value': {
    								pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
    								lookbehind: true,
    								alias: [lang, 'language-' + lang],
    								inside: Prism.languages[lang]
    							},
    							'punctuation': [
    								{
    									pattern: /^=/,
    									alias: 'attr-equals'
    								},
    								/"|'/
    							]
    						}
    					}
    				}
    			});
    		}
    	});

    	Prism.languages.html = Prism.languages.markup;
    	Prism.languages.mathml = Prism.languages.markup;
    	Prism.languages.svg = Prism.languages.markup;

    	Prism.languages.xml = Prism.languages.extend('markup', {});
    	Prism.languages.ssml = Prism.languages.xml;
    	Prism.languages.atom = Prism.languages.xml;
    	Prism.languages.rss = Prism.languages.xml;


    	/* **********************************************
    	     Begin prism-css.js
    	********************************************** */

    	(function (Prism) {

    		var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;

    		Prism.languages.css = {
    			'comment': /\/\*[\s\S]*?\*\//,
    			'atrule': {
    				pattern: RegExp('@[\\w-](?:' + /[^;{\s"']|\s+(?!\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\s*\{))/.source),
    				inside: {
    					'rule': /^@[\w-]+/,
    					'selector-function-argument': {
    						pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
    						lookbehind: true,
    						alias: 'selector'
    					},
    					'keyword': {
    						pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
    						lookbehind: true
    					}
    					// See rest below
    				}
    			},
    			'url': {
    				// https://drafts.csswg.org/css-values-3/#urls
    				pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
    				greedy: true,
    				inside: {
    					'function': /^url/i,
    					'punctuation': /^\(|\)$/,
    					'string': {
    						pattern: RegExp('^' + string.source + '$'),
    						alias: 'url'
    					}
    				}
    			},
    			'selector': {
    				pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
    				lookbehind: true
    			},
    			'string': {
    				pattern: string,
    				greedy: true
    			},
    			'property': {
    				pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
    				lookbehind: true
    			},
    			'important': /!important\b/i,
    			'function': {
    				pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
    				lookbehind: true
    			},
    			'punctuation': /[(){};:,]/
    		};

    		Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

    		var markup = Prism.languages.markup;
    		if (markup) {
    			markup.tag.addInlined('style', 'css');
    			markup.tag.addAttribute('style', 'css');
    		}

    	}(Prism));


    	/* **********************************************
    	     Begin prism-clike.js
    	********************************************** */

    	Prism.languages.clike = {
    		'comment': [
    			{
    				pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    				lookbehind: true,
    				greedy: true
    			},
    			{
    				pattern: /(^|[^\\:])\/\/.*/,
    				lookbehind: true,
    				greedy: true
    			}
    		],
    		'string': {
    			pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    			greedy: true
    		},
    		'class-name': {
    			pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
    			lookbehind: true,
    			inside: {
    				'punctuation': /[.\\]/
    			}
    		},
    		'keyword': /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    		'boolean': /\b(?:false|true)\b/,
    		'function': /\b\w+(?=\()/,
    		'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    		'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    		'punctuation': /[{}[\];(),.:]/
    	};


    	/* **********************************************
    	     Begin prism-javascript.js
    	********************************************** */

    	Prism.languages.javascript = Prism.languages.extend('clike', {
    		'class-name': [
    			Prism.languages.clike['class-name'],
    			{
    				pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
    				lookbehind: true
    			}
    		],
    		'keyword': [
    			{
    				pattern: /((?:^|\})\s*)catch\b/,
    				lookbehind: true
    			},
    			{
    				pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    				lookbehind: true
    			},
    		],
    		// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    		'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    		'number': {
    			pattern: RegExp(
    				/(^|[^\w$])/.source +
    				'(?:' +
    				(
    					// constant
    					/NaN|Infinity/.source +
    					'|' +
    					// binary integer
    					/0[bB][01]+(?:_[01]+)*n?/.source +
    					'|' +
    					// octal integer
    					/0[oO][0-7]+(?:_[0-7]+)*n?/.source +
    					'|' +
    					// hexadecimal integer
    					/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
    					'|' +
    					// decimal bigint
    					/\d+(?:_\d+)*n/.source +
    					'|' +
    					// decimal number (integer or float) but no bigint
    					/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source
    				) +
    				')' +
    				/(?![\w$])/.source
    			),
    			lookbehind: true
    		},
    		'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    	});

    	Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;

    	Prism.languages.insertBefore('javascript', 'keyword', {
    		'regex': {
    			pattern: RegExp(
    				// lookbehind
    				// eslint-disable-next-line regexp/no-dupe-characters-character-class
    				/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
    				// Regex pattern:
    				// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
    				// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
    				// with the only syntax, so we have to define 2 different regex patterns.
    				/\//.source +
    				'(?:' +
    				/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
    				'|' +
    				// `v` flag syntax. This supports 3 levels of nested character classes.
    				/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +
    				')' +
    				// lookahead
    				/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    			),
    			lookbehind: true,
    			greedy: true,
    			inside: {
    				'regex-source': {
    					pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
    					lookbehind: true,
    					alias: 'language-regex',
    					inside: Prism.languages.regex
    				},
    				'regex-delimiter': /^\/|\/$/,
    				'regex-flags': /^[a-z]+$/,
    			}
    		},
    		// This must be declared before keyword because we use "function" inside the look-forward
    		'function-variable': {
    			pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    			alias: 'function'
    		},
    		'parameter': [
    			{
    				pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
    				lookbehind: true,
    				inside: Prism.languages.javascript
    			},
    			{
    				pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
    				lookbehind: true,
    				inside: Prism.languages.javascript
    			},
    			{
    				pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
    				lookbehind: true,
    				inside: Prism.languages.javascript
    			},
    			{
    				pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
    				lookbehind: true,
    				inside: Prism.languages.javascript
    			}
    		],
    		'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    	});

    	Prism.languages.insertBefore('javascript', 'string', {
    		'hashbang': {
    			pattern: /^#!.*/,
    			greedy: true,
    			alias: 'comment'
    		},
    		'template-string': {
    			pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    			greedy: true,
    			inside: {
    				'template-punctuation': {
    					pattern: /^`|`$/,
    					alias: 'string'
    				},
    				'interpolation': {
    					pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
    					lookbehind: true,
    					inside: {
    						'interpolation-punctuation': {
    							pattern: /^\$\{|\}$/,
    							alias: 'punctuation'
    						},
    						rest: Prism.languages.javascript
    					}
    				},
    				'string': /[\s\S]+/
    			}
    		},
    		'string-property': {
    			pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    			lookbehind: true,
    			greedy: true,
    			alias: 'property'
    		}
    	});

    	Prism.languages.insertBefore('javascript', 'operator', {
    		'literal-property': {
    			pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    			lookbehind: true,
    			alias: 'property'
    		},
    	});

    	if (Prism.languages.markup) {
    		Prism.languages.markup.tag.addInlined('script', 'javascript');

    		// add attribute support for all DOM events.
    		// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
    		Prism.languages.markup.tag.addAttribute(
    			/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    			'javascript'
    		);
    	}

    	Prism.languages.js = Prism.languages.javascript;


    	/* **********************************************
    	     Begin prism-file-highlight.js
    	********************************************** */

    	(function () {

    		if (typeof Prism === 'undefined' || typeof document === 'undefined') {
    			return;
    		}

    		// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
    		if (!Element.prototype.matches) {
    			Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    		}

    		var LOADING_MESSAGE = 'Loading';
    		var FAILURE_MESSAGE = function (status, message) {
    			return ' Error ' + status + ' while fetching file: ' + message;
    		};
    		var FAILURE_EMPTY_MESSAGE = ' Error: File does not exist or is empty';

    		var EXTENSIONS = {
    			'js': 'javascript',
    			'py': 'python',
    			'rb': 'ruby',
    			'ps1': 'powershell',
    			'psm1': 'powershell',
    			'sh': 'bash',
    			'bat': 'batch',
    			'h': 'c',
    			'tex': 'latex'
    		};

    		var STATUS_ATTR = 'data-src-status';
    		var STATUS_LOADING = 'loading';
    		var STATUS_LOADED = 'loaded';
    		var STATUS_FAILED = 'failed';

    		var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])'
    			+ ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';

    		/**
    		 * Loads the given file.
    		 *
    		 * @param {string} src The URL or path of the source file to load.
    		 * @param {(result: string) => void} success
    		 * @param {(reason: string) => void} error
    		 */
    		function loadFile(src, success, error) {
    			var xhr = new XMLHttpRequest();
    			xhr.open('GET', src, true);
    			xhr.onreadystatechange = function () {
    				if (xhr.readyState == 4) {
    					if (xhr.status < 400 && xhr.responseText) {
    						success(xhr.responseText);
    					} else {
    						if (xhr.status >= 400) {
    							error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
    						} else {
    							error(FAILURE_EMPTY_MESSAGE);
    						}
    					}
    				}
    			};
    			xhr.send(null);
    		}

    		/**
    		 * Parses the given range.
    		 *
    		 * This returns a range with inclusive ends.
    		 *
    		 * @param {string | null | undefined} range
    		 * @returns {[number, number | undefined] | undefined}
    		 */
    		function parseRange(range) {
    			var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || '');
    			if (m) {
    				var start = Number(m[1]);
    				var comma = m[2];
    				var end = m[3];

    				if (!comma) {
    					return [start, start];
    				}
    				if (!end) {
    					return [start, undefined];
    				}
    				return [start, Number(end)];
    			}
    			return undefined;
    		}

    		Prism.hooks.add('before-highlightall', function (env) {
    			env.selector += ', ' + SELECTOR;
    		});

    		Prism.hooks.add('before-sanity-check', function (env) {
    			var pre = /** @type {HTMLPreElement} */ (env.element);
    			if (pre.matches(SELECTOR)) {
    				env.code = ''; // fast-path the whole thing and go to complete

    				pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading

    				// add code element with loading message
    				var code = pre.appendChild(document.createElement('CODE'));
    				code.textContent = LOADING_MESSAGE;

    				var src = pre.getAttribute('data-src');

    				var language = env.language;
    				if (language === 'none') {
    					// the language might be 'none' because there is no language set;
    					// in this case, we want to use the extension as the language
    					var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
    					language = EXTENSIONS[extension] || extension;
    				}

    				// set language classes
    				Prism.util.setLanguage(code, language);
    				Prism.util.setLanguage(pre, language);

    				// preload the language
    				var autoloader = Prism.plugins.autoloader;
    				if (autoloader) {
    					autoloader.loadLanguages(language);
    				}

    				// load file
    				loadFile(
    					src,
    					function (text) {
    						// mark as loaded
    						pre.setAttribute(STATUS_ATTR, STATUS_LOADED);

    						// handle data-range
    						var range = parseRange(pre.getAttribute('data-range'));
    						if (range) {
    							var lines = text.split(/\r\n?|\n/g);

    							// the range is one-based and inclusive on both ends
    							var start = range[0];
    							var end = range[1] == null ? lines.length : range[1];

    							if (start < 0) { start += lines.length; }
    							start = Math.max(0, Math.min(start - 1, lines.length));
    							if (end < 0) { end += lines.length; }
    							end = Math.max(0, Math.min(end, lines.length));

    							text = lines.slice(start, end).join('\n');

    							// add data-start for line numbers
    							if (!pre.hasAttribute('data-start')) {
    								pre.setAttribute('data-start', String(start + 1));
    							}
    						}

    						// highlight code
    						code.textContent = text;
    						Prism.highlightElement(code);
    					},
    					function (error) {
    						// mark as failed
    						pre.setAttribute(STATUS_ATTR, STATUS_FAILED);

    						code.textContent = error;
    					}
    				);
    			}
    		});

    		Prism.plugins.fileHighlight = {
    			/**
    			 * Executes the File Highlight plugin for all matching `pre` elements under the given container.
    			 *
    			 * Note: Elements which are already loaded or currently loading will not be touched by this method.
    			 *
    			 * @param {ParentNode} [container=document]
    			 */
    			highlight: function highlight(container) {
    				var elements = (container || document).querySelectorAll(SELECTOR);

    				for (var i = 0, element; (element = elements[i++]);) {
    					Prism.highlightElement(element);
    				}
    			}
    		};

    		var logged = false;
    		/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */
    		Prism.fileHighlight = function () {
    			if (!logged) {
    				console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
    				logged = true;
    			}
    			Prism.plugins.fileHighlight.highlight.apply(this, arguments);
    		};

    	}());
    } (prism$2));

    var prism$1 = prism$2.exports;

    const blocks = '(if|else if|await|then|catch|each|html|debug)';

    Prism.languages.svelte = Prism.languages.extend('markup', {
    	each: {
    		pattern: new RegExp(
    			'{[#/]each' +
    				'(?:(?:\\{(?:(?:\\{(?:[^{}])*\\})|(?:[^{}]))*\\})|(?:[^{}]))*}'
    		),
    		inside: {
    			'language-javascript': [
    				{
    					pattern: /(as[\s\S]*)\([\s\S]*\)(?=\s*\})/,
    					lookbehind: true,
    					inside: Prism.languages['javascript'],
    				},
    				{
    					pattern: /(as[\s]*)[\s\S]*(?=\s*)/,
    					lookbehind: true,
    					inside: Prism.languages['javascript'],
    				},
    				{
    					pattern: /(#each[\s]*)[\s\S]*(?=as)/,
    					lookbehind: true,
    					inside: Prism.languages['javascript'],
    				},
    			],
    			keyword: /[#/]each|as/,
    			punctuation: /{|}/,
    		},
    	},
    	block: {
    		pattern: new RegExp(
    			'{[#:/@]/s' +
    				blocks +
    				'(?:(?:\\{(?:(?:\\{(?:[^{}])*\\})|(?:[^{}]))*\\})|(?:[^{}]))*}'
    		),
    		inside: {
    			punctuation: /^{|}$/,
    			keyword: [new RegExp('[#:/@]' + blocks + '( )*'), /as/, /then/],
    			'language-javascript': {
    				pattern: /[\s\S]*/,
    				inside: Prism.languages['javascript'],
    			},
    		},
    	},
    	tag: {
    		pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?:"[^"]*"|'[^']*'|{[\s\S]+?}(?=[\s/>])))|(?=[\s/>])))+)?\s*\/?>/i,
    		greedy: true,
    		inside: {
    			tag: {
    				pattern: /^<\/?[^\s>\/]+/i,
    				inside: {
    					punctuation: /^<\/?/,
    					namespace: /^[^\s>\/:]+:/,
    				},
    			},
    			'language-javascript': {
    				pattern: /\{(?:(?:\{(?:(?:\{(?:[^{}])*\})|(?:[^{}]))*\})|(?:[^{}]))*\}/,
    				inside: Prism.languages['javascript'],
    			},
    			'attr-value': {
    				pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/i,
    				inside: {
    					punctuation: [
    						/^=/,
    						{
    							pattern: /^(\s*)["']|["']$/,
    							lookbehind: true,
    						},
    					],
    					'language-javascript': {
    						pattern: /{[\s\S]+}/,
    						inside: Prism.languages['javascript'],
    					},
    				},
    			},
    			punctuation: /\/?>/,
    			'attr-name': {
    				pattern: /[^\s>\/]+/,
    				inside: {
    					namespace: /^[^\s>\/:]+:/,
    				},
    			},
    		},
    	},
    	'language-javascript': {
    		pattern: /\{(?:(?:\{(?:(?:\{(?:[^{}])*\})|(?:[^{}]))*\})|(?:[^{}]))*\}/,
    		lookbehind: true,
    		inside: Prism.languages['javascript'],
    	},
    });

    Prism.languages.svelte['tag'].inside['attr-value'].inside['entity'] =
    	Prism.languages.svelte['entity'];

    Prism.hooks.add('wrap', env => {
    	if (env.type === 'entity') {
    		env.attributes['title'] = env.content.replace(/&amp;/, '&');
    	}
    });

    Object.defineProperty(Prism.languages.svelte.tag, 'addInlined', {
    	value: function addInlined(tagName, lang) {
    		const includedCdataInside = {};
    		includedCdataInside['language-' + lang] = {
    			pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
    			lookbehind: true,
    			inside: Prism.languages[lang],
    		};
    		includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

    		const inside = {
    			'included-cdata': {
    				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    				inside: includedCdataInside,
    			},
    		};
    		inside['language-' + lang] = {
    			pattern: /[\s\S]+/,
    			inside: Prism.languages[lang],
    		};

    		const def = {};
    		def[tagName] = {
    			pattern: RegExp(
    				/(<__[\s\S]*?>)(?:<!\[CDATA\[[\s\S]*?\]\]>\s*|[\s\S])*?(?=<\/__>)/.source.replace(
    					/__/g,
    					tagName
    				),
    				'i'
    			),
    			lookbehind: true,
    			greedy: true,
    			inside,
    		};

    		Prism.languages.insertBefore('svelte', 'cdata', def);
    	},
    });

    Prism.languages.svelte.tag.addInlined('style', 'css');
    Prism.languages.svelte.tag.addInlined('script', 'javascript');

    /* node_modules/svelte-prism/src/Prism.svelte generated by Svelte v3.53.1 */
    const file$18 = "node_modules/svelte-prism/src/Prism.svelte";

    // (32:45) {:else}
    function create_else_block$k(ctx) {
    	let html_tag;
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag(false);
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(/*formattedCode*/ ctx[2], target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*formattedCode*/ 4) html_tag.p(/*formattedCode*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$k.name,
    		type: "else",
    		source: "(32:45) {:else}",
    		ctx
    	});

    	return block;
    }

    // (32:5) {#if language === "none"}
    function create_if_block$r(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*formattedCode*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*formattedCode*/ 4) set_data_dev(t, /*formattedCode*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(32:5) {#if language === \\\"none\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$19(ctx) {
    	let code0;
    	let t;
    	let pre;
    	let code1;
    	let code1_class_value;
    	let pre_class_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	function select_block_type(ctx, dirty) {
    		if (/*language*/ ctx[0] === "none") return create_if_block$r;
    		return create_else_block$k;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			code0 = element("code");
    			if (default_slot) default_slot.c();
    			t = space();
    			pre = element("pre");
    			code1 = element("code");
    			if_block.c();
    			set_style(code0, "display", "none");
    			add_location(code0, file$18, 26, 0, 727);
    			attr_dev(code1, "class", code1_class_value = "language-" + /*language*/ ctx[0]);
    			add_location(code1, file$18, 30, 65, 860);
    			attr_dev(pre, "class", pre_class_value = "language-" + /*language*/ ctx[0]);
    			attr_dev(pre, "command-line", "");
    			attr_dev(pre, "data-output", "2-17");
    			add_location(pre, file$18, 30, 0, 795);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, code0, anchor);

    			if (default_slot) {
    				default_slot.m(code0, null);
    			}

    			/*code0_binding*/ ctx[7](code0);
    			insert_dev(target, t, anchor);
    			insert_dev(target, pre, anchor);
    			append_dev(pre, code1);
    			if_block.m(code1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(code1, null);
    				}
    			}

    			if (!current || dirty & /*language*/ 1 && code1_class_value !== (code1_class_value = "language-" + /*language*/ ctx[0])) {
    				attr_dev(code1, "class", code1_class_value);
    			}

    			if (!current || dirty & /*language*/ 1 && pre_class_value !== (pre_class_value = "language-" + /*language*/ ctx[0])) {
    				attr_dev(pre, "class", pre_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(code0);
    			if (default_slot) default_slot.d(detaching);
    			/*code0_binding*/ ctx[7](null);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(pre);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$19.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const prism = prism$1;
    const highlight = prism$1.highlightElement;
    const globalConfig = { transform: x => x };

    function instance$18($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Prism', slots, ['default']);
    	let { language = "javascript" } = $$props;
    	let { source = "" } = $$props;
    	let { transform = x => x } = $$props;
    	let element, formattedCode;

    	function highlightCode() {
    		const grammar = prism.languages[language];
    		let body = source || element.textContent;
    		body = globalConfig.transform(body);
    		body = transform(body);

    		$$invalidate(2, formattedCode = language === "none"
    		? body
    		: prism.highlight(body, grammar, language));
    	}

    	function code0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(1, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('language' in $$new_props) $$invalidate(0, language = $$new_props.language);
    		if ('source' in $$new_props) $$invalidate(3, source = $$new_props.source);
    		if ('transform' in $$new_props) $$invalidate(4, transform = $$new_props.transform);
    		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		_prism: prism$1,
    		prism,
    		highlight,
    		globalConfig,
    		language,
    		source,
    		transform,
    		element,
    		formattedCode,
    		highlightCode
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    		if ('language' in $$props) $$invalidate(0, language = $$new_props.language);
    		if ('source' in $$props) $$invalidate(3, source = $$new_props.source);
    		if ('transform' in $$props) $$invalidate(4, transform = $$new_props.transform);
    		if ('element' in $$props) $$invalidate(1, element = $$new_props.element);
    		if ('formattedCode' in $$props) $$invalidate(2, formattedCode = $$new_props.formattedCode);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$props && (source || element) && highlightCode();
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		language,
    		element,
    		formattedCode,
    		source,
    		transform,
    		$$scope,
    		slots,
    		code0_binding
    	];
    }

    class Prism$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$18, create_fragment$19, safe_not_equal, { language: 0, source: 3, transform: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Prism",
    			options,
    			id: create_fragment$19.name
    		});
    	}

    	get language() {
    		throw new Error("<Prism>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set language(value) {
    		throw new Error("<Prism>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get source() {
    		throw new Error("<Prism>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set source(value) {
    		throw new Error("<Prism>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transform() {
    		throw new Error("<Prism>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transform(value) {
    		throw new Error("<Prism>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/icon/Icon.svelte generated by Svelte v3.53.1 */

    const file$17 = "src/components/icon/Icon.svelte";

    // (10:0) {#if name}
    function create_if_block$q(ctx) {
    	let svg;
    	let use;
    	let use_xlink_href_value;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			use = svg_element("use");
    			xlink_attr(use, "xlink:href", use_xlink_href_value = "#" + /*name*/ ctx[0]);
    			add_location(use, file$17, 11, 4, 412);
    			attr_dev(svg, "style", /*styleAttr*/ ctx[1]);
    			attr_dev(svg, "class", /*baseClass*/ ctx[2]);
    			attr_dev(svg, "viewBox", "0 0 14 14");
    			add_location(svg, file$17, 10, 2, 346);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, use);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*name*/ 1 && use_xlink_href_value !== (use_xlink_href_value = "#" + /*name*/ ctx[0])) {
    				xlink_attr(use, "xlink:href", use_xlink_href_value);
    			}

    			if (dirty & /*styleAttr*/ 2) {
    				attr_dev(svg, "style", /*styleAttr*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(10:0) {#if name}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$18(ctx) {
    	let if_block_anchor;
    	let if_block = /*name*/ ctx[0] && create_if_block$q(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*name*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$q(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$18.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$17($$self, $$props, $$invalidate) {
    	let cssWidth;
    	let styleAttr;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Icon', slots, []);
    	let { className = undefined } = $$props;
    	let { name = undefined } = $$props;
    	let { width = undefined } = $$props;
    	let { style = undefined } = $$props;
    	const baseClass = className ? `icon-svg ${className}` : 'icon-svg';
    	const writable_props = ['className', 'name', 'width', 'style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Icon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(3, className = $$props.className);
    		if ('name' in $$props) $$invalidate(0, name = $$props.name);
    		if ('width' in $$props) $$invalidate(4, width = $$props.width);
    		if ('style' in $$props) $$invalidate(5, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		name,
    		width,
    		style,
    		baseClass,
    		cssWidth,
    		styleAttr
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(3, className = $$props.className);
    		if ('name' in $$props) $$invalidate(0, name = $$props.name);
    		if ('width' in $$props) $$invalidate(4, width = $$props.width);
    		if ('style' in $$props) $$invalidate(5, style = $$props.style);
    		if ('cssWidth' in $$props) $$invalidate(6, cssWidth = $$props.cssWidth);
    		if ('styleAttr' in $$props) $$invalidate(1, styleAttr = $$props.styleAttr);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*width*/ 16) {
    			$$invalidate(6, cssWidth = width ? `--icon-size: ${width}px;` : '');
    		}

    		if ($$self.$$.dirty & /*style, cssWidth*/ 96) {
    			$$invalidate(1, styleAttr = style ? `${cssWidth} ${style}` : cssWidth);
    		}
    	};

    	return [name, styleAttr, baseClass, className, width, style, cssWidth];
    }

    class Icon$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$17, create_fragment$18, safe_not_equal, {
    			className: 3,
    			name: 0,
    			width: 4,
    			style: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon",
    			options,
    			id: create_fragment$18.name
    		});
    	}

    	get className() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/accordion/Accordion.svelte generated by Svelte v3.53.1 */
    const file$16 = "src/components/accordion/Accordion.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (13:2) {#each tabs as tab, i}
    function create_each_block$9(ctx) {
    	let div2;
    	let div0;
    	let span;
    	let t0_value = /*tab*/ ctx[7].title + "";
    	let t0;
    	let t1;
    	let icon;
    	let div0_aria_label_value;
    	let t2;
    	let div1;
    	let raw_value = /*tab*/ ctx[7].content + "";
    	let t3;
    	let current;
    	let mounted;
    	let dispose;

    	icon = new Icon$1({
    			props: { name: "angle-down", width: "14" },
    			$$inline: true
    		});

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[5](/*i*/ ctx[9], ...args);
    	}

    	function keydown_handler(...args) {
    		return /*keydown_handler*/ ctx[6](/*i*/ ctx[9], ...args);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(icon.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			t3 = space();
    			attr_dev(span, "class", "fontweight-bold fontsize-medium");
    			add_location(span, file$16, 22, 8, 830);
    			attr_dev(div0, "class", "accordion-header flex flex-justify--between flex-align--center padding-m");
    			attr_dev(div0, "role", "button");
    			attr_dev(div0, "tabindex", 0);
    			attr_dev(div0, "aria-label", div0_aria_label_value = /*tab*/ ctx[7].title);
    			add_location(div0, file$16, 14, 6, 548);
    			attr_dev(div1, "class", "accordion-body padding-m padding-l--rl");
    			add_location(div1, file$16, 25, 6, 960);
    			attr_dev(div2, "class", "accordion-tab margin-m--b");
    			toggle_class(div2, "accordion-expanded", /*$activeTab*/ ctx[3] === /*i*/ ctx[9]);
    			add_location(div2, file$16, 13, 4, 458);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, span);
    			append_dev(span, t0);
    			append_dev(div0, t1);
    			mount_component(icon, div0, null);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			div1.innerHTML = raw_value;
    			append_dev(div2, t3);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", click_handler, false, false, false),
    					listen_dev(div0, "keydown", keydown_handler, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*tabs*/ 4) && t0_value !== (t0_value = /*tab*/ ctx[7].title + "")) set_data_dev(t0, t0_value);

    			if (!current || dirty & /*tabs*/ 4 && div0_aria_label_value !== (div0_aria_label_value = /*tab*/ ctx[7].title)) {
    				attr_dev(div0, "aria-label", div0_aria_label_value);
    			}

    			if ((!current || dirty & /*tabs*/ 4) && raw_value !== (raw_value = /*tab*/ ctx[7].content + "")) div1.innerHTML = raw_value;
    			if (!current || dirty & /*$activeTab*/ 8) {
    				toggle_class(div2, "accordion-expanded", /*$activeTab*/ ctx[3] === /*i*/ ctx[9]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(icon);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(13:2) {#each tabs as tab, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$17(ctx) {
    	let div;
    	let current;
    	let each_value = /*tabs*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "data-theme", /*dataTheme*/ ctx[1]);
    			attr_dev(div, "class", "accordion card-mode padding-l ff-secondary width-1of1");
    			add_location(div, file$16, 11, 0, 338);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$activeTab, tabs, toggleAccordion*/ 28) {
    				each_value = /*tabs*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*dataTheme*/ 2) {
    				attr_dev(div, "data-theme", /*dataTheme*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$17.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$16($$self, $$props, $$invalidate) {
    	let $activeTab,
    		$$unsubscribe_activeTab = noop,
    		$$subscribe_activeTab = () => ($$unsubscribe_activeTab(), $$unsubscribe_activeTab = subscribe(activeTab, $$value => $$invalidate(3, $activeTab = $$value)), activeTab);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_activeTab());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Accordion', slots, []);

    	function toggleAccordion(event, index) {
    		event.stopPropagation();
    		set_store_value(activeTab, $activeTab = $activeTab !== index ? index : undefined, $activeTab);
    	}

    	const activeTab = writable(undefined);
    	validate_store(activeTab, 'activeTab');
    	$$subscribe_activeTab();
    	let { dataTheme = undefined } = $$props;
    	let { tabs } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (tabs === undefined && !('tabs' in $$props || $$self.$$.bound[$$self.$$.props['tabs']])) {
    			console.warn("<Accordion> was created without expected prop 'tabs'");
    		}
    	});

    	const writable_props = ['dataTheme', 'tabs'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Accordion> was created with unknown prop '${key}'`);
    	});

    	const click_handler = (i, e) => toggleAccordion(e, i);
    	const keydown_handler = (i, e) => toggleAccordion(e, i);

    	$$self.$$set = $$props => {
    		if ('dataTheme' in $$props) $$invalidate(1, dataTheme = $$props.dataTheme);
    		if ('tabs' in $$props) $$invalidate(2, tabs = $$props.tabs);
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		Icon: Icon$1,
    		toggleAccordion,
    		activeTab,
    		dataTheme,
    		tabs,
    		$activeTab
    	});

    	$$self.$inject_state = $$props => {
    		if ('dataTheme' in $$props) $$invalidate(1, dataTheme = $$props.dataTheme);
    		if ('tabs' in $$props) $$invalidate(2, tabs = $$props.tabs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		activeTab,
    		dataTheme,
    		tabs,
    		$activeTab,
    		toggleAccordion,
    		click_handler,
    		keydown_handler
    	];
    }

    class Accordion extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$16, create_fragment$17, safe_not_equal, { activeTab: 0, dataTheme: 1, tabs: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Accordion",
    			options,
    			id: create_fragment$17.name
    		});
    	}

    	get activeTab() {
    		return this.$$.ctx[0];
    	}

    	set activeTab(value) {
    		throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dataTheme() {
    		throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataTheme(value) {
    		throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabs() {
    		throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabs(value) {
    		throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var colorNames = Background = void 0;
    var Background = { "bordeaux": { "background": "#8a0c36", "color": "#fff" }, "reddark": { "background": "#900", "color": "#fff" }, "red": { "background": "#bd1118", "color": "#fff" }, "pink": { "background": "#b31e61", "color": "#fff" }, "rose": { "background": "#dc7095", "color": "#fff" }, "orangedark": { "background": "#e96c0d", "color": "#fff" }, "orange": { "background": "#e5ad02", "color": "#fff" }, "yellow": { "background": "#fae500", "color": "#000" }, "yellowlight": { "background": "#ff0", "color": "#000" }, "sand": { "background": "#cec4a6", "color": "#fff" }, "greendark": { "background": "#2f7820", "color": "#fff" }, "green": { "background": "#029e5d", "color": "#fff" }, "greenlight": { "background": "#93b923", "color": "#fff" }, "lime": { "background": "#cbfe33", "color": "#000" }, "purpledark": { "background": "#51208c", "color": "#fff" }, "bluenavy": { "background": "#1a237e", "color": "#fff" }, "bluedark": { "background": "#1058c2", "color": "#fff" }, "blue": { "background": "#31769b", "color": "#fff" }, "bluelight": { "background": "#4fa8df", "color": "#fff" }, "cyan": { "background": "#00b6d2", "color": "#fff" }, "sea": { "background": "#84a8c4", "color": "#fff" }, "black": { "background": "#000", "color": "#fff" }, "graa0": { "background": "#1b1b1b", "color": "#efefef" }, "graa1": { "background": "#3c3c3c", "color": "#fff" }, "graa2": { "background": "#484848", "color": "#fff" }, "graa3": { "background": "#999", "color": "#fff" }, "graa4": { "background": "#c8c8c8", "color": "#000" }, "graa5": { "background": "#ddd", "color": "#000" }, "graa6": { "background": "#e5e5e5", "color": "#000" }, "graa7": { "background": "#efefef", "color": "#000" }, "white": { "background": "#fff", "color": "#000" }, "pastelred": { "background": "#db5040", "color": "#fff" }, "pasteldarkred": { "background": "#954839", "color": "#fff" }, "pastellightred": { "background": "#d67e9b", "color": "#fff" }, "pastelgreen": { "background": "#9fc29c", "color": "#fff" }, "pasteldarkgreen": { "background": "#91a34f", "color": "#fff" }, "pastelyellow": { "background": "#d4c564", "color": "#fff" }, "eb": { "background": "#bd1118", "color": "#fff" }, "eb2": { "background": "#900", "color": "#fff" }, "breaking": { "background": "#ff0", "color": "#000" }, "bruger": { "background": "#4fa8df", "color": "#fff" }, "live": { "background": "#000", "color": "#fff" }, "native": { "background": "#cec4a6", "color": "#fff" }, "native2": { "background": "#84a8c4", "color": "#fff" }, "facebook": { "background": "#31769b", "color": "#fff" }, "twitter": { "background": "#4fa8df", "color": "#fff" }, "flash": { "background": "#e5ad02", "color": "#fff" }, "forbrug": { "background": "#00b6d2", "color": "#fff" }, "leder": { "background": "#1a237e", "color": "#fff" }, "livescore": { "background": "#029e5d", "color": "#fff" }, "livescore2": { "background": "#cbfe33", "color": "#000" }, "nyheder": { "background": "#1058c2", "color": "#fff" }, "nyheder2": { "background": "#000", "color": "#fff" }, "sexsamliv": { "background": "#b31e61", "color": "#fff" }, "sexsamliv2": { "background": "#dc7095", "color": "#fff" }, "skolefodbold": { "background": "#93b923", "color": "#fff" }, "sport": { "background": "#029e5d", "color": "#fff" }, "tv": { "background": "#bd1118", "color": "#fff" }, "underholdning": { "background": "#51208c", "color": "#fff" } };
    colorNames = { "eb": "eb", "eb2": "eb2", "breaking": "breaking", "bruger": "bruger", "live": "live", "native": "native", "native2": "native2", "facebook": "facebook", "twitter": "twitter", "flash": "flash", "forbrug": "forbrug", "leder": "leder", "livescore": "livescore", "livescore2": "livescore2", "nyheder": "nyheder", "nyheder2": "nyheder2", "sexsamliv": "sex-samliv", "sexsamliv2": "sex-samliv2", "skolefodbold": "skolefodbold", "sport": "sport", "tv": "tv", "underholdning": "underholdning" };

    /**
     * timePassedSince
     *
     * @param datetime {string}
     * @returns {string}
     */
    function timePassedSince(datetime) {
        const monthNames = ['jan', 'feb', 'mar', 'apr', 'maj', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'];
        const inputdate = new Date(datetime); // UTC-time from server (Z)
        const now = new Date();
        const inputDateLocalTz = new Date(inputdate.getTime() + now.getTimezoneOffset() * 60);
        const secondsSince = Math.round((now.getTime() - inputDateLocalTz.getTime()) / 1000);
        const days = Math.floor(secondsSince / 86400);
        let output = '';
        if (days) {
            // More than 24 hours old
            const yesterday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
            if (inputDateLocalTz.getTime() > yesterday.getTime()) {
                output = 'I gr';
            }
            else {
                output = `${inputDateLocalTz.getDate()}. ${monthNames[inputDateLocalTz.getMonth()]}.${now.getFullYear() !== inputDateLocalTz.getFullYear() ? ` ${inputDateLocalTz.getFullYear()}` : ''}`;
            }
        }
        else {
            // Less than 24 hours old
            const hours = Math.floor((secondsSince % 86400) / 3600);
            const minutes = Math.floor(((secondsSince % 86400) % 3600) / 60);
            const seconds = secondsSince % 60;
            if (hours) {
                output = hours === 1 ? `${hours} time` : `${hours} timer`;
            }
            else if (minutes) {
                output = `${minutes} min`;
            }
            else if (seconds) {
                output = `${seconds} sek`;
            }
        }
        return output;
    }

    /* src/components/toggler/Toggler.svelte generated by Svelte v3.53.1 */
    const file$15 = "src/components/toggler/Toggler.svelte";
    const get_off_slot_changes_1 = dirty => ({});
    const get_off_slot_context_1 = ctx => ({});
    const get_on_slot_changes_1 = dirty => ({});
    const get_on_slot_context_1 = ctx => ({});
    const get_off_slot_changes = dirty => ({});
    const get_off_slot_context = ctx => ({});
    const get_on_slot_changes = dirty => ({});
    const get_on_slot_context = ctx => ({});

    // (46:0) {:else}
    function create_else_block$j(ctx) {
    	let button;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1$a, create_else_block_1$6];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*defaultState*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if_block.c();
    			t = space();
    			if (default_slot) default_slot.c();
    			attr_dev(button, "class", /*baseClass*/ ctx[3]);
    			button.disabled = /*disabled*/ ctx[2];
    			toggle_class(button, "toggle-disabled", /*disabled*/ ctx[2]);
    			add_location(button, file$15, 46, 2, 1414);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			if_blocks[current_block_type_index].m(button, null);
    			append_dev(button, t);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", stop_propagation(/*toggle*/ ctx[5]), false, false, true);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(button, t);
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*baseClass*/ 8) {
    				attr_dev(button, "class", /*baseClass*/ ctx[3]);
    			}

    			if (!current || dirty & /*disabled*/ 4) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[2]);
    			}

    			if (!current || dirty & /*baseClass, disabled*/ 12) {
    				toggle_class(button, "toggle-disabled", /*disabled*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if_blocks[current_block_type_index].d();
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$j.name,
    		type: "else",
    		source: "(46:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (24:0) {#if isSwitch}
    function create_if_block$p(ctx) {
    	let div;
    	let button0;
    	let button0_class_value;
    	let t0;
    	let icon;
    	let updating_name;
    	let t1;
    	let button1;
    	let button1_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const on_slot_template = /*#slots*/ ctx[8].on;
    	const on_slot = create_slot(on_slot_template, ctx, /*$$scope*/ ctx[7], get_on_slot_context);

    	function icon_name_binding(value) {
    		/*icon_name_binding*/ ctx[10](value);
    	}

    	let icon_props = {
    		className: "margin-s--rl",
    		width: "30",
    		style: "cursor: pointer;"
    	};

    	if (/*name*/ ctx[4] !== void 0) {
    		icon_props.name = /*name*/ ctx[4];
    	}

    	icon = new Icon$1({ props: icon_props, $$inline: true });
    	binding_callbacks.push(() => bind(icon, 'name', icon_name_binding));
    	icon.$on("click", /*toggle*/ ctx[5]);
    	const off_slot_template = /*#slots*/ ctx[8].off;
    	const off_slot = create_slot(off_slot_template, ctx, /*$$scope*/ ctx[7], get_off_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			if (on_slot) on_slot.c();
    			t0 = space();
    			create_component(icon.$$.fragment);
    			t1 = space();
    			button1 = element("button");
    			if (off_slot) off_slot.c();
    			attr_dev(button0, "data-status", /*defaultState*/ ctx[0]);
    			attr_dev(button0, "class", button0_class_value = "toggle--switch " + /*baseClass*/ ctx[3]);
    			button0.disabled = /*disabled*/ ctx[2];
    			toggle_class(button0, "toggle-disabled", /*disabled*/ ctx[2]);
    			add_location(button0, file$15, 25, 4, 801);
    			attr_dev(button1, "data-status", /*defaultState*/ ctx[0]);
    			attr_dev(button1, "class", button1_class_value = "toggle--switch " + /*baseClass*/ ctx[3]);
    			button1.disabled = /*disabled*/ ctx[2];
    			toggle_class(button1, "toggle-disabled", /*disabled*/ ctx[2]);
    			add_location(button1, file$15, 35, 4, 1150);
    			attr_dev(div, "class", "flex flex-align--center");
    			add_location(div, file$15, 24, 2, 759);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);

    			if (on_slot) {
    				on_slot.m(button0, null);
    			}

    			append_dev(div, t0);
    			mount_component(icon, div, null);
    			append_dev(div, t1);
    			append_dev(div, button1);

    			if (off_slot) {
    				off_slot.m(button1, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", stop_propagation(/*click_handler*/ ctx[9]), false, false, true),
    					listen_dev(button1, "click", stop_propagation(/*click_handler_1*/ ctx[11]), false, false, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (on_slot) {
    				if (on_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						on_slot,
    						on_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(on_slot_template, /*$$scope*/ ctx[7], dirty, get_on_slot_changes),
    						get_on_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*defaultState*/ 1) {
    				attr_dev(button0, "data-status", /*defaultState*/ ctx[0]);
    			}

    			if (!current || dirty & /*baseClass*/ 8 && button0_class_value !== (button0_class_value = "toggle--switch " + /*baseClass*/ ctx[3])) {
    				attr_dev(button0, "class", button0_class_value);
    			}

    			if (!current || dirty & /*disabled*/ 4) {
    				prop_dev(button0, "disabled", /*disabled*/ ctx[2]);
    			}

    			if (!current || dirty & /*baseClass, disabled*/ 12) {
    				toggle_class(button0, "toggle-disabled", /*disabled*/ ctx[2]);
    			}

    			const icon_changes = {};

    			if (!updating_name && dirty & /*name*/ 16) {
    				updating_name = true;
    				icon_changes.name = /*name*/ ctx[4];
    				add_flush_callback(() => updating_name = false);
    			}

    			icon.$set(icon_changes);

    			if (off_slot) {
    				if (off_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						off_slot,
    						off_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(off_slot_template, /*$$scope*/ ctx[7], dirty, get_off_slot_changes),
    						get_off_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*defaultState*/ 1) {
    				attr_dev(button1, "data-status", /*defaultState*/ ctx[0]);
    			}

    			if (!current || dirty & /*baseClass*/ 8 && button1_class_value !== (button1_class_value = "toggle--switch " + /*baseClass*/ ctx[3])) {
    				attr_dev(button1, "class", button1_class_value);
    			}

    			if (!current || dirty & /*disabled*/ 4) {
    				prop_dev(button1, "disabled", /*disabled*/ ctx[2]);
    			}

    			if (!current || dirty & /*baseClass, disabled*/ 12) {
    				toggle_class(button1, "toggle-disabled", /*disabled*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(on_slot, local);
    			transition_in(icon.$$.fragment, local);
    			transition_in(off_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(on_slot, local);
    			transition_out(icon.$$.fragment, local);
    			transition_out(off_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (on_slot) on_slot.d(detaching);
    			destroy_component(icon);
    			if (off_slot) off_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(24:0) {#if isSwitch}",
    		ctx
    	});

    	return block;
    }

    // (50:4) {:else}
    function create_else_block_1$6(ctx) {
    	let current;
    	const off_slot_template = /*#slots*/ ctx[8].off;
    	const off_slot = create_slot(off_slot_template, ctx, /*$$scope*/ ctx[7], get_off_slot_context_1);

    	const block = {
    		c: function create() {
    			if (off_slot) off_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (off_slot) {
    				off_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (off_slot) {
    				if (off_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						off_slot,
    						off_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(off_slot_template, /*$$scope*/ ctx[7], dirty, get_off_slot_changes_1),
    						get_off_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(off_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(off_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (off_slot) off_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$6.name,
    		type: "else",
    		source: "(50:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (48:4) {#if defaultState}
    function create_if_block_1$a(ctx) {
    	let current;
    	const on_slot_template = /*#slots*/ ctx[8].on;
    	const on_slot = create_slot(on_slot_template, ctx, /*$$scope*/ ctx[7], get_on_slot_context_1);

    	const block = {
    		c: function create() {
    			if (on_slot) on_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (on_slot) {
    				on_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (on_slot) {
    				if (on_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						on_slot,
    						on_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(on_slot_template, /*$$scope*/ ctx[7], dirty, get_on_slot_changes_1),
    						get_on_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(on_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(on_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (on_slot) on_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(48:4) {#if defaultState}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$16(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$p, create_else_block$j];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isSwitch*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$16.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$15($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Toggler', slots, ['on','off','default']);
    	let { className = undefined } = $$props;
    	let { defaultState = true } = $$props;
    	let { isSwitch = false } = $$props;
    	let { disabled = false } = $$props;
    	let baseClass = `toggle-button`;
    	if (className) baseClass = `${className} ${baseClass}`;

    	/**
     * Handle user click on toggle element
     */
    	let name = defaultState ? 'toggle-on' : 'toggle-off';

    	const dispatch = createEventDispatcher();

    	function toggle(evt, status) {
    		evt.preventDefault();

    		$$invalidate(0, defaultState = status !== null && status !== void 0
    		? status
    		: !defaultState);

    		$$invalidate(4, name = defaultState ? 'toggle-on' : 'toggle-off');
    		dispatch('toggle', defaultState);
    	}

    	const writable_props = ['className', 'defaultState', 'isSwitch', 'disabled'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Toggler> was created with unknown prop '${key}'`);
    	});

    	const click_handler = evt => toggle(evt, true);

    	function icon_name_binding(value) {
    		name = value;
    		$$invalidate(4, name);
    	}

    	const click_handler_1 = evt => toggle(evt, false);

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('defaultState' in $$props) $$invalidate(0, defaultState = $$props.defaultState);
    		if ('isSwitch' in $$props) $$invalidate(1, isSwitch = $$props.isSwitch);
    		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
    		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		Icon: Icon$1,
    		className,
    		defaultState,
    		isSwitch,
    		disabled,
    		baseClass,
    		name,
    		dispatch,
    		toggle
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('defaultState' in $$props) $$invalidate(0, defaultState = $$props.defaultState);
    		if ('isSwitch' in $$props) $$invalidate(1, isSwitch = $$props.isSwitch);
    		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
    		if ('baseClass' in $$props) $$invalidate(3, baseClass = $$props.baseClass);
    		if ('name' in $$props) $$invalidate(4, name = $$props.name);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*defaultState*/ 1) {
    			$$invalidate(0, defaultState);
    		}
    	};

    	return [
    		defaultState,
    		isSwitch,
    		disabled,
    		baseClass,
    		name,
    		toggle,
    		className,
    		$$scope,
    		slots,
    		click_handler,
    		icon_name_binding,
    		click_handler_1
    	];
    }

    class Toggler extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$15, create_fragment$16, safe_not_equal, {
    			className: 6,
    			defaultState: 0,
    			isSwitch: 1,
    			disabled: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Toggler",
    			options,
    			id: create_fragment$16.name
    		});
    	}

    	get className() {
    		throw new Error("<Toggler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Toggler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get defaultState() {
    		throw new Error("<Toggler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set defaultState(value) {
    		throw new Error("<Toggler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isSwitch() {
    		throw new Error("<Toggler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isSwitch(value) {
    		throw new Error("<Toggler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Toggler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Toggler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/articlecard/ArticleCard.svelte generated by Svelte v3.53.1 */
    const file$14 = "src/components/articlecard/ArticleCard.svelte";
    const get_default_slot_changes_1$1 = dirty => ({});
    const get_default_slot_context_1$1 = ctx => ({ slot: "on" });
    const get_default_slot_changes$1 = dirty => ({});
    const get_default_slot_context$1 = ctx => ({ slot: "off" });

    // (59:0) {#if loading || (!loading && title)}
    function create_if_block$o(ctx) {
    	let a;
    	let div2;
    	let t0;
    	let t1;
    	let t2;
    	let div1;
    	let div0;
    	let t3;
    	let t4;
    	let h2;
    	let t5;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*premium*/ ctx[7] && create_if_block_10(ctx);
    	let if_block1 = /*loading*/ ctx[0] && create_if_block_9(ctx);
    	let if_block2 = /*media*/ ctx[6] && create_if_block_6(ctx);
    	let if_block3 = (/*section*/ ctx[10] || /*published*/ ctx[8]) && create_if_block_2$5(ctx);
    	let if_block4 = /*videoIcon*/ ctx[13] && !/*media*/ ctx[6] && create_if_block_1$9(ctx);

    	const block = {
    		c: function create() {
    			a = element("a");
    			div2 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			h2 = element("h2");
    			t5 = text(/*title*/ ctx[1]);
    			attr_dev(h2, "class", "card-title");
    			attr_dev(h2, "style", /*titleStyle*/ ctx[19]);
    			toggle_class(h2, "padding-l--r", /*videoIcon*/ ctx[13] && !/*media*/ ctx[6]);
    			toggle_class(h2, "card-title--truncate", /*truncateTitle*/ ctx[11]);
    			add_location(h2, file$14, 143, 10, 5404);
    			attr_dev(div0, "class", "card-content");
    			add_location(div0, file$14, 103, 8, 3650);
    			attr_dev(div1, "class", "card-content-wrapper");
    			add_location(div1, file$14, 102, 6, 3607);
    			attr_dev(div2, "class", /*innerClass*/ ctx[15]);
    			add_location(div2, file$14, 60, 4, 2223);
    			attr_dev(a, "href", /*url*/ ctx[12]);
    			attr_dev(a, "class", /*cssClass*/ ctx[17]);
    			attr_dev(a, "style", /*styleProp*/ ctx[18]);
    			attr_dev(a, "data-breaking", /*breaking*/ ctx[2]);
    			add_location(a, file$14, 59, 2, 2135);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, div2);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t0);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t1);
    			if (if_block2) if_block2.m(div2, null);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			if (if_block3) if_block3.m(div0, null);
    			append_dev(div0, t3);
    			if (if_block4) if_block4.m(div0, null);
    			append_dev(div0, t4);
    			append_dev(div0, h2);
    			append_dev(h2, t5);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[29], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*premium*/ ctx[7]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*premium*/ 128) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_10(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div2, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*loading*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_9(ctx);
    					if_block1.c();
    					if_block1.m(div2, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*media*/ ctx[6]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*media*/ 64) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_6(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div2, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*section*/ ctx[10] || /*published*/ ctx[8]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*section, published*/ 1280) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_2$5(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div0, t3);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*videoIcon*/ ctx[13] && !/*media*/ ctx[6]) {
    				if (if_block4) {
    					if (dirty[0] & /*videoIcon, media*/ 8256) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_1$9(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div0, t4);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*title*/ 2) set_data_dev(t5, /*title*/ ctx[1]);

    			if (!current || dirty[0] & /*videoIcon, media*/ 8256) {
    				toggle_class(h2, "padding-l--r", /*videoIcon*/ ctx[13] && !/*media*/ ctx[6]);
    			}

    			if (!current || dirty[0] & /*truncateTitle*/ 2048) {
    				toggle_class(h2, "card-title--truncate", /*truncateTitle*/ ctx[11]);
    			}

    			if (!current || dirty[0] & /*innerClass*/ 32768) {
    				attr_dev(div2, "class", /*innerClass*/ ctx[15]);
    			}

    			if (!current || dirty[0] & /*url*/ 4096) {
    				attr_dev(a, "href", /*url*/ ctx[12]);
    			}

    			if (!current || dirty[0] & /*cssClass*/ 131072) {
    				attr_dev(a, "class", /*cssClass*/ ctx[17]);
    			}

    			if (!current || dirty[0] & /*styleProp*/ 262144) {
    				attr_dev(a, "style", /*styleProp*/ ctx[18]);
    			}

    			if (!current || dirty[0] & /*breaking*/ 4) {
    				attr_dev(a, "data-breaking", /*breaking*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(59:0) {#if loading || (!loading && title)}",
    		ctx
    	});

    	return block;
    }

    // (62:6) {#if premium}
    function create_if_block_10(ctx) {
    	let div;
    	let icon;
    	let div_class_value;
    	let current;

    	icon = new Icon$1({
    			props: {
    				className: "color--white",
    				name: "ebplus-white"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(icon.$$.fragment);

    			attr_dev(div, "class", div_class_value = "premium-dogear " + (/*premiumMarkerSize*/ ctx[4]
    			? `premium-dogear--${/*premiumMarkerSize*/ ctx[4]}`
    			: ''));

    			add_location(div, file$14, 62, 8, 2276);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(icon, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*premiumMarkerSize*/ 16 && div_class_value !== (div_class_value = "premium-dogear " + (/*premiumMarkerSize*/ ctx[4]
    			? `premium-dogear--${/*premiumMarkerSize*/ ctx[4]}`
    			: ''))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(62:6) {#if premium}",
    		ctx
    	});

    	return block;
    }

    // (67:6) {#if loading}
    function create_if_block_9(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", "card-image bg--graa4");
    			attr_dev(div0, "style", /*loadingStyle*/ ctx[14]);
    			add_location(div0, file$14, 68, 10, 2525);
    			attr_dev(div1, "class", "card-media");
    			add_location(div1, file$14, 67, 8, 2490);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*loadingStyle*/ 16384) {
    				attr_dev(div0, "style", /*loadingStyle*/ ctx[14]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(67:6) {#if loading}",
    		ctx
    	});

    	return block;
    }

    // (72:6) {#if media}
    function create_if_block_6(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let img;
    	let img_src_value;
    	let img_height_value;
    	let img_width_value;
    	let current;
    	let if_block0 = /*update*/ ctx[5] && create_if_block_8(ctx);
    	let if_block1 = /*videoIcon*/ ctx[13] && create_if_block_7(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			img = element("img");
    			attr_dev(img, "alt", /*title*/ ctx[1]);
    			attr_dev(img, "class", "card-image");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[6].src)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "height", img_height_value = /*media*/ ctx[6].height);
    			attr_dev(img, "width", img_width_value = /*media*/ ctx[6].width);
    			set_style(img, "width", /*media*/ ctx[6].width + "px");
    			add_location(img, file$14, 92, 10, 3364);
    			attr_dev(div, "class", /*mediaCssClass*/ ctx[16]);
    			add_location(div, file$14, 72, 8, 2636);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			append_dev(div, img);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*update*/ ctx[5]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*update*/ 32) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_8(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*videoIcon*/ ctx[13]) {
    				if (if_block1) {
    					if (dirty[0] & /*videoIcon*/ 8192) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_7(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*title*/ 2) {
    				attr_dev(img, "alt", /*title*/ ctx[1]);
    			}

    			if (!current || dirty[0] & /*media*/ 64 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[6].src)) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (!current || dirty[0] & /*media*/ 64 && img_height_value !== (img_height_value = /*media*/ ctx[6].height)) {
    				attr_dev(img, "height", img_height_value);
    			}

    			if (!current || dirty[0] & /*media*/ 64 && img_width_value !== (img_width_value = /*media*/ ctx[6].width)) {
    				attr_dev(img, "width", img_width_value);
    			}

    			if (!current || dirty[0] & /*media*/ 64) {
    				set_style(img, "width", /*media*/ ctx[6].width + "px");
    			}

    			if (!current || dirty[0] & /*mediaCssClass*/ 65536) {
    				attr_dev(div, "class", /*mediaCssClass*/ ctx[16]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(72:6) {#if media}",
    		ctx
    	});

    	return block;
    }

    // (74:10) {#if update}
    function create_if_block_8(ctx) {
    	let span;
    	let icon;
    	let t;
    	let current;

    	icon = new Icon$1({
    			props: {
    				name: "lightning",
    				className: "bg--white color--" + /*colorName*/ ctx[3] + " border-radius-s padding-s margin-s--r",
    				style: "margin-left: -1px;",
    				width: "15"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(icon.$$.fragment);
    			t = text("\n              UPDATE");
    			attr_dev(span, "class", "badge margin-s position-absolute padding-none padding-s--r card--shadow bg--black fontsize-small");
    			set_style(span, "bottom", "5px");
    			set_style(span, "left", "5px");
    			add_location(span, file$14, 74, 12, 2699);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(icon, span, null);
    			append_dev(span, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};
    			if (dirty[0] & /*colorName*/ 8) icon_changes.className = "bg--white color--" + /*colorName*/ ctx[3] + " border-radius-s padding-s margin-s--r";
    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(74:10) {#if update}",
    		ctx
    	});

    	return block;
    }

    // (88:10) {#if videoIcon}
    function create_if_block_7(ctx) {
    	let div;
    	let icon;
    	let current;

    	icon = new Icon$1({
    			props: {
    				className: "color--white",
    				name: "video-graphic",
    				width: "25"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(icon.$$.fragment);
    			attr_dev(div, "class", "video-icon");
    			add_location(div, file$14, 88, 12, 3214);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(icon, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(88:10) {#if videoIcon}",
    		ctx
    	});

    	return block;
    }

    // (105:10) {#if section || published}
    function create_if_block_2$5(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let current;
    	let if_block0 = /*section*/ ctx[10] && /*section*/ ctx[10] !== 'New Articles' && create_if_block_5$2(ctx);
    	let if_block1 = /*published*/ ctx[8] && create_if_block_4$4(ctx);
    	let if_block2 = /*saved*/ ctx[9] !== undefined && create_if_block_3$4(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(div, "class", "card-meta flex flex-wrap--wrap fontsize-xxsmall");
    			add_location(div, file$14, 105, 12, 3726);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*section*/ ctx[10] && /*section*/ ctx[10] !== 'New Articles') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*section*/ 1024) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*published*/ ctx[8]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*published*/ 256) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_4$4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*saved*/ ctx[9] !== undefined) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*saved*/ 512) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_3$4(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(105:10) {#if section || published}",
    		ctx
    	});

    	return block;
    }

    // (107:14) {#if section && section !== 'New Articles'}
    function create_if_block_5$2(ctx) {
    	let div;
    	let span1;
    	let icon;
    	let t0;
    	let span0;
    	let t1;
    	let current;

    	icon = new Icon$1({
    			props: { name: "tag", width: "12" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			span1 = element("span");
    			create_component(icon.$$.fragment);
    			t0 = space();
    			span0 = element("span");
    			t1 = text(/*section*/ ctx[10]);
    			attr_dev(span0, "class", "padding-s--l");
    			add_location(span0, file$14, 110, 20, 4021);
    			attr_dev(span1, "class", "flex flex-justify--center");
    			add_location(span1, file$14, 108, 18, 3909);
    			attr_dev(div, "class", "card-meta-item");
    			add_location(div, file$14, 107, 16, 3862);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span1);
    			mount_component(icon, span1, null);
    			append_dev(span1, t0);
    			append_dev(span1, span0);
    			append_dev(span0, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*section*/ 1024) set_data_dev(t1, /*section*/ ctx[10]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(107:14) {#if section && section !== 'New Articles'}",
    		ctx
    	});

    	return block;
    }

    // (115:14) {#if published}
    function create_if_block_4$4(ctx) {
    	let div;
    	let icon;
    	let t0;
    	let span;
    	let t1_value = timePassedSince(/*published*/ ctx[8]) + "";
    	let t1;
    	let current;

    	icon = new Icon$1({
    			props: { name: "clock", width: "12" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(icon.$$.fragment);
    			t0 = space();
    			span = element("span");
    			t1 = text(t1_value);
    			attr_dev(span, "class", "padding-s--l");
    			add_location(span, file$14, 117, 18, 4278);
    			attr_dev(div, "class", "card-meta-item");
    			add_location(div, file$14, 115, 16, 4180);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(icon, div, null);
    			append_dev(div, t0);
    			append_dev(div, span);
    			append_dev(span, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*published*/ 256) && t1_value !== (t1_value = timePassedSince(/*published*/ ctx[8]) + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(115:14) {#if published}",
    		ctx
    	});

    	return block;
    }

    // (121:14) {#if saved !== undefined}
    function create_if_block_3$4(ctx) {
    	let toggler;
    	let current;

    	toggler = new Toggler({
    			props: {
    				className: "card-meta-item padding-m--r padding-s--b",
    				defaultState: /*saved*/ ctx[9],
    				$$slots: {
    					off: [create_off_slot$1],
    					on: [create_on_slot$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toggler.$on("toggle", /*toggleSave*/ ctx[20]);

    	const block = {
    		c: function create() {
    			create_component(toggler.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(toggler, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const toggler_changes = {};
    			if (dirty[0] & /*saved*/ 512) toggler_changes.defaultState = /*saved*/ ctx[9];

    			if (dirty[0] & /*$$scope*/ 1073741824) {
    				toggler_changes.$$scope = { dirty, ctx };
    			}

    			toggler.$set(toggler_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toggler.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toggler.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(toggler, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(121:14) {#if saved !== undefined}",
    		ctx
    	});

    	return block;
    }

    // (127:34)                      
    function fallback_block_1$1(ctx) {
    	let icon;
    	let t0;
    	let span;
    	let current;

    	icon = new Icon$1({
    			props: {
    				name: "bookmark-solid",
    				style: "color: var(--fgcolor--list);",
    				width: 12
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    			t0 = space();
    			span = element("span");
    			span.textContent = "Gemt";
    			attr_dev(span, "class", "padding-s--l");
    			set_style(span, "color", "var(--fgcolor--list)");
    			add_location(span, file$14, 128, 20, 4772);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1$1.name,
    		type: "fallback",
    		source: "(127:34)                      ",
    		ctx
    	});

    	return block;
    }

    // (127:18) 
    function create_on_slot$1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[28].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[30], get_default_slot_context_1$1);
    	const default_slot_or_fallback = default_slot || fallback_block_1$1(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 1073741824)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[30],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[30])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[30], dirty, get_default_slot_changes_1$1),
    						get_default_slot_context_1$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_on_slot$1.name,
    		type: "slot",
    		source: "(127:18) ",
    		ctx
    	});

    	return block;
    }

    // (131:35)                      
    function fallback_block$1(ctx) {
    	let icon;
    	let t0;
    	let span;
    	let current;

    	icon = new Icon$1({
    			props: {
    				name: "bookmark",
    				style: "color: var(--fgcolor--list);",
    				width: 12
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    			t0 = space();
    			span = element("span");
    			span.textContent = "Gem";
    			attr_dev(span, "class", "padding-s--l");
    			set_style(span, "color", "var(--fgcolor--list)");
    			add_location(span, file$14, 132, 20, 5023);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(131:35)                      ",
    		ctx
    	});

    	return block;
    }

    // (131:18) 
    function create_off_slot$1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[28].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[30], get_default_slot_context$1);
    	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 1073741824)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[30],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[30])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[30], dirty, get_default_slot_changes$1),
    						get_default_slot_context$1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_off_slot$1.name,
    		type: "slot",
    		source: "(131:18) ",
    		ctx
    	});

    	return block;
    }

    // (139:10) {#if videoIcon && !media}
    function create_if_block_1$9(ctx) {
    	let div;
    	let icon;
    	let current;

    	icon = new Icon$1({
    			props: {
    				className: "color--white",
    				name: "video-graphic",
    				width: "20"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(icon.$$.fragment);
    			attr_dev(div, "class", "video-icon");
    			add_location(div, file$14, 139, 12, 5254);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(icon, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(139:10) {#if videoIcon && !media}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$15(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = (/*loading*/ ctx[0] || !/*loading*/ ctx[0] && /*title*/ ctx[1]) && create_if_block$o(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*loading*/ ctx[0] || !/*loading*/ ctx[0] && /*title*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*loading, title*/ 3) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$o(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$15.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$14($$self, $$props, $$invalidate) {
    	let styleProp;
    	let cssClass;
    	let mediaCssClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ArticleCard', slots, ['default']);
    	let { loading = false } = $$props;
    	let { title = '' } = $$props;
    	let { breaking = false } = $$props;
    	let { cardType = undefined } = $$props;
    	let { className = undefined } = $$props;
    	let { colorName = undefined } = $$props;
    	let { premiumMarkerSize = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { update = false } = $$props;
    	let { maxLines = undefined } = $$props;
    	let { media = undefined } = $$props;
    	let { premium = false } = $$props;
    	let { published = undefined } = $$props;
    	let { saved = undefined } = $$props;
    	let { section = undefined } = $$props;
    	let { style = '' } = $$props;
    	let { truncateTitle = false } = $$props;
    	let { url = undefined } = $$props;
    	let { videoIcon = false } = $$props;
    	let { width = '100%' } = $$props;
    	const dispatch = createEventDispatcher();
    	let baseClass = `card-mode card-mode--article`;
    	let loadingStyle = 'padding-top: 56.25%; width: 100%;';

    	if (loading) {
    		baseClass = `${baseClass} animation-fogwave`;

    		switch (cardType) {
    			case 'small-media':
    			case 'small-media--reverse':
    				loadingStyle = 'width: 200px;height: 115px;';
    				break;
    		}
    	}

    	let innerClass = 'card-inner';

    	switch (cardType) {
    		case 'small-media':
    			innerClass = `${innerClass} card--small-media`;
    			break;
    		case 'small-media--reverse':
    			innerClass = `${innerClass} card--small-media card--small-media--reverse`;
    			break;
    	}

    	const titleStyle = maxLines ? `--max-lines: ${maxLines};` : undefined;

    	function toggleSave(evt) {
    		dispatch('save', { id, save: evt.detail });
    	}

    	const writable_props = [
    		'loading',
    		'title',
    		'breaking',
    		'cardType',
    		'className',
    		'colorName',
    		'premiumMarkerSize',
    		'id',
    		'update',
    		'maxLines',
    		'media',
    		'premium',
    		'published',
    		'saved',
    		'section',
    		'style',
    		'truncateTitle',
    		'url',
    		'videoIcon',
    		'width'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArticleCard> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('loading' in $$props) $$invalidate(0, loading = $$props.loading);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    		if ('breaking' in $$props) $$invalidate(2, breaking = $$props.breaking);
    		if ('cardType' in $$props) $$invalidate(21, cardType = $$props.cardType);
    		if ('className' in $$props) $$invalidate(22, className = $$props.className);
    		if ('colorName' in $$props) $$invalidate(3, colorName = $$props.colorName);
    		if ('premiumMarkerSize' in $$props) $$invalidate(4, premiumMarkerSize = $$props.premiumMarkerSize);
    		if ('id' in $$props) $$invalidate(23, id = $$props.id);
    		if ('update' in $$props) $$invalidate(5, update = $$props.update);
    		if ('maxLines' in $$props) $$invalidate(24, maxLines = $$props.maxLines);
    		if ('media' in $$props) $$invalidate(6, media = $$props.media);
    		if ('premium' in $$props) $$invalidate(7, premium = $$props.premium);
    		if ('published' in $$props) $$invalidate(8, published = $$props.published);
    		if ('saved' in $$props) $$invalidate(9, saved = $$props.saved);
    		if ('section' in $$props) $$invalidate(10, section = $$props.section);
    		if ('style' in $$props) $$invalidate(25, style = $$props.style);
    		if ('truncateTitle' in $$props) $$invalidate(11, truncateTitle = $$props.truncateTitle);
    		if ('url' in $$props) $$invalidate(12, url = $$props.url);
    		if ('videoIcon' in $$props) $$invalidate(13, videoIcon = $$props.videoIcon);
    		if ('width' in $$props) $$invalidate(26, width = $$props.width);
    		if ('$$scope' in $$props) $$invalidate(30, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		colorNames,
    		createEventDispatcher,
    		timePassedSince,
    		Icon: Icon$1,
    		Toggler,
    		loading,
    		title,
    		breaking,
    		cardType,
    		className,
    		colorName,
    		premiumMarkerSize,
    		id,
    		update,
    		maxLines,
    		media,
    		premium,
    		published,
    		saved,
    		section,
    		style,
    		truncateTitle,
    		url,
    		videoIcon,
    		width,
    		dispatch,
    		baseClass,
    		loadingStyle,
    		innerClass,
    		titleStyle,
    		toggleSave,
    		mediaCssClass,
    		cssClass,
    		styleProp
    	});

    	$$self.$inject_state = $$props => {
    		if ('loading' in $$props) $$invalidate(0, loading = $$props.loading);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    		if ('breaking' in $$props) $$invalidate(2, breaking = $$props.breaking);
    		if ('cardType' in $$props) $$invalidate(21, cardType = $$props.cardType);
    		if ('className' in $$props) $$invalidate(22, className = $$props.className);
    		if ('colorName' in $$props) $$invalidate(3, colorName = $$props.colorName);
    		if ('premiumMarkerSize' in $$props) $$invalidate(4, premiumMarkerSize = $$props.premiumMarkerSize);
    		if ('id' in $$props) $$invalidate(23, id = $$props.id);
    		if ('update' in $$props) $$invalidate(5, update = $$props.update);
    		if ('maxLines' in $$props) $$invalidate(24, maxLines = $$props.maxLines);
    		if ('media' in $$props) $$invalidate(6, media = $$props.media);
    		if ('premium' in $$props) $$invalidate(7, premium = $$props.premium);
    		if ('published' in $$props) $$invalidate(8, published = $$props.published);
    		if ('saved' in $$props) $$invalidate(9, saved = $$props.saved);
    		if ('section' in $$props) $$invalidate(10, section = $$props.section);
    		if ('style' in $$props) $$invalidate(25, style = $$props.style);
    		if ('truncateTitle' in $$props) $$invalidate(11, truncateTitle = $$props.truncateTitle);
    		if ('url' in $$props) $$invalidate(12, url = $$props.url);
    		if ('videoIcon' in $$props) $$invalidate(13, videoIcon = $$props.videoIcon);
    		if ('width' in $$props) $$invalidate(26, width = $$props.width);
    		if ('baseClass' in $$props) $$invalidate(27, baseClass = $$props.baseClass);
    		if ('loadingStyle' in $$props) $$invalidate(14, loadingStyle = $$props.loadingStyle);
    		if ('innerClass' in $$props) $$invalidate(15, innerClass = $$props.innerClass);
    		if ('mediaCssClass' in $$props) $$invalidate(16, mediaCssClass = $$props.mediaCssClass);
    		if ('cssClass' in $$props) $$invalidate(17, cssClass = $$props.cssClass);
    		if ('styleProp' in $$props) $$invalidate(18, styleProp = $$props.styleProp);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*style, breaking, colorName, width*/ 100663308) {
    			$$invalidate(18, styleProp = `${style}; --color--list: var(--color--${breaking ? colorNames.breaking : colorName}); --fgcolor--list: var(--fgcolor--${breaking ? colorNames.breaking : colorName}); --card-width: ${width};`);
    		}

    		if ($$self.$$.dirty[0] & /*className, baseClass*/ 138412032) {
    			$$invalidate(17, cssClass = className ? `${className} ${baseClass}` : baseClass);
    		}

    		if ($$self.$$.dirty[0] & /*media*/ 64) {
    			$$invalidate(16, mediaCssClass = media && media.className
    			? `${media.className} card-media`
    			: 'card-media');
    		}
    	};

    	return [
    		loading,
    		title,
    		breaking,
    		colorName,
    		premiumMarkerSize,
    		update,
    		media,
    		premium,
    		published,
    		saved,
    		section,
    		truncateTitle,
    		url,
    		videoIcon,
    		loadingStyle,
    		innerClass,
    		mediaCssClass,
    		cssClass,
    		styleProp,
    		titleStyle,
    		toggleSave,
    		cardType,
    		className,
    		id,
    		maxLines,
    		style,
    		width,
    		baseClass,
    		slots,
    		click_handler,
    		$$scope
    	];
    }

    class ArticleCard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$14,
    			create_fragment$15,
    			safe_not_equal,
    			{
    				loading: 0,
    				title: 1,
    				breaking: 2,
    				cardType: 21,
    				className: 22,
    				colorName: 3,
    				premiumMarkerSize: 4,
    				id: 23,
    				update: 5,
    				maxLines: 24,
    				media: 6,
    				premium: 7,
    				published: 8,
    				saved: 9,
    				section: 10,
    				style: 25,
    				truncateTitle: 11,
    				url: 12,
    				videoIcon: 13,
    				width: 26
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ArticleCard",
    			options,
    			id: create_fragment$15.name
    		});
    	}

    	get loading() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get breaking() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set breaking(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cardType() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cardType(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get colorName() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colorName(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get premiumMarkerSize() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set premiumMarkerSize(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get update() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set update(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maxLines() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxLines(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get media() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set media(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get premium() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set premium(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get published() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set published(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get saved() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set saved(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get section() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set section(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get truncateTitle() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set truncateTitle(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get videoIcon() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set videoIcon(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function throttle(callback, wait) {
        let inThrottle;
        return function (...args) {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const context = this;
            if (!inThrottle) {
                callback.apply(context, args);
                inThrottle = true;
                setTimeout(() => (inThrottle = false), wait);
            }
        };
    }

    var SCROLLDIRECTION$1;
    (function (SCROLLDIRECTION) {
        SCROLLDIRECTION[SCROLLDIRECTION["left"] = 0] = "left";
        SCROLLDIRECTION[SCROLLDIRECTION["right"] = 1] = "right";
    })(SCROLLDIRECTION$1 || (SCROLLDIRECTION$1 = {}));
    var BLOCKING$1;
    (function (BLOCKING) {
        BLOCKING[BLOCKING["disabled"] = 0] = "disabled";
        BLOCKING[BLOCKING["enabled"] = 1] = "enabled";
    })(BLOCKING$1 || (BLOCKING$1 = {}));
    var SCROLLPOS$1;
    (function (SCROLLPOS) {
        SCROLLPOS[SCROLLPOS["disabled"] = 0] = "disabled";
        SCROLLPOS[SCROLLPOS["end"] = 1] = "end";
        SCROLLPOS[SCROLLPOS["neutral"] = 2] = "neutral";
        SCROLLPOS[SCROLLPOS["start"] = 3] = "start";
        SCROLLPOS[SCROLLPOS["unset"] = 4] = "unset";
    })(SCROLLPOS$1 || (SCROLLPOS$1 = {}));
    class HorizontalScrollHandler$1 {
        constructor() {
            this.currentState = SCROLLPOS$1.unset;
            this.listLength = 0;
            this.currentBlock = 0;
            this.blocks = [0];
            this.blocking = BLOCKING$1.enabled;
        }
        /**
         *
         * @param scrollItemContainer {HTMLDivElement}
         * @param scrollContainer {HTMLDivElement}
         * @returns {void}
         */
        init(scrollItemContainer, scrollContainer) {
            this.scrollItemContainer = scrollItemContainer;
            this.scrollContainer = scrollContainer;
            this.scrollItemContainer.addEventListener('wheel', throttle((data) => {
                this.updateButtonsThroughScroll(data);
            }, 150));
            this.wrapLeft = scrollItemContainer.getBoundingClientRect().left;
            this.wrapRight = scrollItemContainer.getBoundingClientRect().right;
            this.wrapClientWidth = scrollItemContainer.clientWidth;
            this.update();
        }
        /**
         *
         * @param dir {SCROLLDIRECTION}
         * @returns {void}
         *
         * Advance scroll to make next or previous elements visible
         */
        scrollWithButton(dir) {
            let left = this.findPosition(dir);
            if (dir === SCROLLDIRECTION$1.right && this.wrapMaxLeft < left) {
                left = this.wrapMaxLeft;
                this.updateDataSet(SCROLLPOS$1.end);
            }
            else if (left <= 0) {
                left = 0;
                this.updateDataSet(SCROLLPOS$1.start);
            }
            else {
                this.updateDataSet(SCROLLPOS$1.neutral);
            }
            this.scrollItemContainer.scrollTo({
                behavior: 'smooth',
                left,
                top: 0,
            });
        }
        /**
         *
         * @returns {void}
         */
        update() {
            if (this.listLength === this.scrollItemContainer.children.length)
                return;
            this.children = this.scrollItemContainer.children;
            this.listLength = this.children.length;
            const containerBBox = this.scrollContainer.getBoundingClientRect();
            /**
             * Find how many visible elements we have
             */
            const visibleChildren = Array.from(this.children).filter((child) => child.getBoundingClientRect().left >= containerBBox.left &&
                child.getBoundingClientRect().right <= containerBBox.right).length;
            const maxLength = this.listLength - visibleChildren;
            this.wrapMaxLeft = this.scrollItemContainer.scrollWidth - this.wrapClientWidth;
            if (maxLength) {
                // Some children not visible - enable scroling
                this.updateButtons();
            }
            else {
                this.updateDataSet(SCROLLPOS$1.disabled);
            }
        }
        /**
         * updateDataSet
         *
         * update the visibility of buttons through data attributes
         *
         * @param pos {SCROLLPOS}
         */
        updateDataSet(pos) {
            if (this.currentState === pos)
                return;
            switch (pos) {
                case SCROLLPOS$1.neutral:
                    this.scrollContainer.dataset.atstart = 'false';
                    this.scrollContainer.dataset.atend = 'false';
                    break;
                case SCROLLPOS$1.end:
                    this.scrollContainer.dataset.atstart = 'false';
                    this.scrollContainer.dataset.atend = 'true';
                    break;
                case SCROLLPOS$1.start:
                    this.scrollContainer.dataset.atstart = 'true';
                    this.scrollContainer.dataset.atend = 'false';
                    break;
                case SCROLLPOS$1.disabled:
                    this.scrollContainer.dataset.atstart = 'true';
                    this.scrollContainer.dataset.atend = 'true';
                    break;
            }
            this.currentState = pos;
        }
        /**
         * updateButtons
         *
         * calculate where in the list we are when the user scrolls
         */
        updateButtons() {
            const childLeft = this.children[0].getBoundingClientRect().left;
            const childRight = this.children[this.listLength - 1].getBoundingClientRect().right;
            const childrenHiddenLeft = childLeft < this.wrapLeft;
            const childrenHiddenRight = childRight > this.wrapRight;
            let dir;
            if (childrenHiddenLeft && childrenHiddenRight) {
                dir = SCROLLPOS$1.neutral;
            }
            else if (childrenHiddenLeft) {
                dir = SCROLLPOS$1.end;
            }
            else if (childrenHiddenRight) {
                dir = SCROLLPOS$1.start;
            }
            else {
                dir = SCROLLPOS$1.disabled;
            }
            this.updateDataSet(dir);
        }
        /**
         * Go backwards through children to find the first element on the left which
         * is partially visible/invisible to the user
         */
        findPrevChild() {
            return Array.from(this.children)
                .reverse()
                .find((child) => {
                return child.getBoundingClientRect().left < this.wrapLeft;
            });
        }
        /**
         * Go through children to find the first element on the right which is
         * partially visible/invisible to the user
         */
        findNextChild() {
            return Array.from(this.children).find((child) => {
                return child.getBoundingClientRect().right > this.wrapRight;
            });
        }
        /**
         * updateButtonsThroughScroll
         *
         * if the user scrolls horizontally in the list with mousewheel/trackpad we
         * update the visibility of the buttons
         *
         * @param ev {WheelEvent}
         */
        updateButtonsThroughScroll(ev) {
            if (Math.abs(ev.deltaX) > Math.abs(ev.deltaY)) {
                this.blocking = BLOCKING$1.disabled;
                this.updateButtons();
            }
        }
        /**
         * findPosition
         *
         * Find the position of the next element we need to show
         *
         * @param dir {SCROLLDIRECTION}
         */
        findPosition(dir) {
            try {
                let position;
                if (dir === SCROLLDIRECTION$1.left) {
                    if (this.blocking === BLOCKING$1.enabled && this.blocks[this.currentBlock - 1]) {
                        this.currentBlock--;
                        position = this.blocks[this.currentBlock];
                    }
                    else {
                        this.blocks = [0];
                        this.currentBlock = 0;
                        const el = this.findPrevChild();
                        if (!el) {
                            console.warn('No prev child found, assume at start');
                            return 0;
                        }
                        position =
                            this.scrollItemContainer.scrollLeft -
                                (this.wrapClientWidth - (el.clientWidth - (this.wrapLeft - el.getBoundingClientRect().left)));
                    }
                }
                else if (dir === SCROLLDIRECTION$1.right) {
                    if (this.blocking === BLOCKING$1.enabled && this.blocks[this.currentBlock + 1]) {
                        this.currentBlock++;
                        position = this.blocks[this.currentBlock];
                    }
                    else {
                        const el = this.findNextChild();
                        if (!el) {
                            console.warn('No next child found, assume at end');
                            return this.wrapMaxLeft;
                        }
                        position = el.offsetLeft;
                        this.currentBlock++;
                        this.blocks.push(position);
                    }
                }
                return position;
            }
            catch (err) {
                console.error('findPosition', err);
                return -1;
            }
        }
    }

    /* src/components/buttongroup/ButtonGroup.svelte generated by Svelte v3.53.1 */
    const file$13 = "src/components/buttongroup/ButtonGroup.svelte";

    function create_fragment$14(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", /*cssClass*/ ctx[1]);
    			attr_dev(div, "style", /*style*/ ctx[0]);
    			add_location(div, file$13, 57, 0, 2042);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 2) {
    				attr_dev(div, "class", /*cssClass*/ ctx[1]);
    			}

    			if (!current || dirty & /*style*/ 1) {
    				attr_dev(div, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$14.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const BUTTONS$1 = {};

    function instance$13($$self, $$props, $$invalidate) {
    	let cssClass;
    	let style;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ButtonGroup', slots, ['default']);
    	const selectedId = writable(0);
    	const selectedButton = writable(null);
    	const buttons = [];

    	selectedId.subscribe(i => {
    		selectedButton.set(buttons[i]);
    	});

    	setContext(BUTTONS$1, {
    		createContextButton: () => {
    			return { button: buttons.length };
    		},
    		registerButton: button => {
    			buttons.push(button);
    			selectedButton.update(current => current || button);

    			onDestroy(() => {
    				const i = buttons.indexOf(button);
    				buttons.splice(i, 1);

    				selectedButton.update(current => current === button
    				? buttons[i] || buttons[buttons.length - 1]
    				: current);
    			});
    		},
    		selectButton: button => {
    			const i = buttons.indexOf(button);
    			selectedId.set(i);
    		},
    		selectedButton
    	});

    	let { className = undefined } = $$props;
    	let { type = undefined } = $$props;
    	let { color = undefined } = $$props;
    	let { colorHover = undefined } = $$props;
    	let { solid = false } = $$props;
    	let baseClass = `buttongroup`;

    	if (solid) {
    		baseClass = `${baseClass} buttongroup--solid`;
    	}

    	if (type) {
    		baseClass = `${baseClass} buttongroup--${type}`;
    	}

    	const { background: colorBackground, color: colorForeground } = Background[color]
    	? Background[color]
    	: Background.bruger;

    	/**
     * If hovercolor is not specified, use color and utimately fall back to "Bruger"
     */
    	colorHover = color && !colorHover ? color : colorHover;

    	const { background: hoverColor, color: hoverColorForeground } = Background[colorHover]
    	? Background[colorHover]
    	: Background.bruger;

    	const writable_props = ['className', 'type', 'color', 'colorHover', 'solid'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ButtonGroup> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('type' in $$props) $$invalidate(5, type = $$props.type);
    		if ('color' in $$props) $$invalidate(6, color = $$props.color);
    		if ('colorHover' in $$props) $$invalidate(2, colorHover = $$props.colorHover);
    		if ('solid' in $$props) $$invalidate(7, solid = $$props.solid);
    		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		BUTTONS: BUTTONS$1,
    		Background,
    		onDestroy,
    		setContext,
    		writable,
    		selectedId,
    		selectedButton,
    		buttons,
    		className,
    		type,
    		color,
    		colorHover,
    		solid,
    		baseClass,
    		colorBackground,
    		colorForeground,
    		hoverColor,
    		hoverColorForeground,
    		style,
    		cssClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('type' in $$props) $$invalidate(5, type = $$props.type);
    		if ('color' in $$props) $$invalidate(6, color = $$props.color);
    		if ('colorHover' in $$props) $$invalidate(2, colorHover = $$props.colorHover);
    		if ('solid' in $$props) $$invalidate(7, solid = $$props.solid);
    		if ('baseClass' in $$props) $$invalidate(8, baseClass = $$props.baseClass);
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    		if ('cssClass' in $$props) $$invalidate(1, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, baseClass*/ 272) {
    			$$invalidate(1, cssClass = className ? `${className} ${baseClass}` : baseClass);
    		}
    	};

    	$$invalidate(0, style = `--buttongroup-color: ${colorBackground}; --buttongroup-fgcolor: ${colorForeground}; --buttongroup-color--hover: ${hoverColor}; --buttongroup-fgcolor--hover: ${hoverColorForeground};`);

    	return [
    		style,
    		cssClass,
    		colorHover,
    		selectedId,
    		className,
    		type,
    		color,
    		solid,
    		baseClass,
    		$$scope,
    		slots
    	];
    }

    class ButtonGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$13, create_fragment$14, safe_not_equal, {
    			selectedId: 3,
    			className: 4,
    			type: 5,
    			color: 6,
    			colorHover: 2,
    			solid: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ButtonGroup",
    			options,
    			id: create_fragment$14.name
    		});
    	}

    	get selectedId() {
    		return this.$$.ctx[3];
    	}

    	set selectedId(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get colorHover() {
    		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colorHover(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get solid() {
    		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set solid(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/button/Button.svelte generated by Svelte v3.53.1 */
    const file$12 = "src/components/button/Button.svelte";

    // (53:0) {:else}
    function create_else_block$i(ctx) {
    	let button;
    	let button_data_selected_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();
    			attr_dev(button, "class", /*cssClass*/ ctx[5]);
    			button.disabled = /*disabled*/ ctx[0];
    			attr_dev(button, "data-selected", button_data_selected_value = /*$selectedButton*/ ctx[6] === /*contextButton*/ ctx[3]);
    			add_location(button, file$12, 53, 2, 1522);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			/*button_binding*/ ctx[18](button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[16], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 32) {
    				attr_dev(button, "class", /*cssClass*/ ctx[5]);
    			}

    			if (!current || dirty & /*disabled*/ 1) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[0]);
    			}

    			if (!current || dirty & /*$selectedButton, contextButton*/ 72 && button_data_selected_value !== (button_data_selected_value = /*$selectedButton*/ ctx[6] === /*contextButton*/ ctx[3])) {
    				attr_dev(button, "data-selected", button_data_selected_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			/*button_binding*/ ctx[18](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$i.name,
    		type: "else",
    		source: "(53:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (49:0) {#if href}
    function create_if_block$n(ctx) {
    	let a;
    	let a_data_selected_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			attr_dev(a, "href", /*href*/ ctx[1]);
    			attr_dev(a, "class", /*cssClass*/ ctx[5]);
    			attr_dev(a, "disabled", /*disabled*/ ctx[0]);
    			attr_dev(a, "data-selected", a_data_selected_value = /*$selectedButton*/ ctx[6] === /*contextButton*/ ctx[3]);
    			add_location(a, file$12, 49, 2, 1373);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			/*a_binding*/ ctx[17](a);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[15], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*href*/ 2) {
    				attr_dev(a, "href", /*href*/ ctx[1]);
    			}

    			if (!current || dirty & /*cssClass*/ 32) {
    				attr_dev(a, "class", /*cssClass*/ ctx[5]);
    			}

    			if (!current || dirty & /*disabled*/ 1) {
    				attr_dev(a, "disabled", /*disabled*/ ctx[0]);
    			}

    			if (!current || dirty & /*$selectedButton, contextButton*/ 72 && a_data_selected_value !== (a_data_selected_value = /*$selectedButton*/ ctx[6] === /*contextButton*/ ctx[3])) {
    				attr_dev(a, "data-selected", a_data_selected_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			/*a_binding*/ ctx[17](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(49:0) {#if href}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$13(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$n, create_else_block$i];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*href*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$13.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$12($$self, $$props, $$invalidate) {
    	let cssClass;

    	let $selectedButton,
    		$$unsubscribe_selectedButton = noop,
    		$$subscribe_selectedButton = () => ($$unsubscribe_selectedButton(), $$unsubscribe_selectedButton = subscribe(selectedButton, $$value => $$invalidate(6, $selectedButton = $$value)), selectedButton);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_selectedButton());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, ['default']);
    	let { className = undefined } = $$props;
    	let { disabled = false } = $$props;
    	let { extension = undefined } = $$props;
    	let { href = undefined } = $$props;
    	let { size = undefined } = $$props;
    	let { type = undefined } = $$props;
    	let baseClass = 'button';

    	if (extension) {
    		const extSplit = extension.split(' ');

    		extSplit.forEach(extClass => {
    			$$invalidate(12, baseClass = `${baseClass} button--${extClass}`);
    		});
    	}

    	if (size) {
    		baseClass = `${baseClass} button--${size}`;
    	}

    	if (type) {
    		baseClass = `${baseClass} button--${type}`;
    	}

    	let buttonEl;
    	let { initial = false } = $$props;
    	let contextButton;
    	let selectButton;
    	let selectedButton;
    	const contextButtons = getContext(BUTTONS$1);

    	if (contextButtons) {
    		const registerButton = contextButtons.registerButton;
    		contextButton = contextButtons.createContextButton();
    		selectButton = contextButtons.selectButton;
    		$$subscribe_selectedButton(selectedButton = contextButtons.selectedButton);
    		registerButton(contextButton);

    		if (initial) {
    			selectButton(contextButton);
    		}
    	}

    	onMount(() => {
    		if (typeof selectButton !== 'undefined') {
    			buttonEl.addEventListener('click', () => selectButton(contextButton));
    		}
    	});

    	const writable_props = ['className', 'disabled', 'extension', 'href', 'size', 'type', 'initial'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Button> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			buttonEl = $$value;
    			$$invalidate(2, buttonEl);
    		});
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			buttonEl = $$value;
    			$$invalidate(2, buttonEl);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(7, className = $$props.className);
    		if ('disabled' in $$props) $$invalidate(0, disabled = $$props.disabled);
    		if ('extension' in $$props) $$invalidate(8, extension = $$props.extension);
    		if ('href' in $$props) $$invalidate(1, href = $$props.href);
    		if ('size' in $$props) $$invalidate(9, size = $$props.size);
    		if ('type' in $$props) $$invalidate(10, type = $$props.type);
    		if ('initial' in $$props) $$invalidate(11, initial = $$props.initial);
    		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		disabled,
    		extension,
    		href,
    		size,
    		type,
    		baseClass,
    		buttonEl,
    		getContext,
    		onMount,
    		BUTTONS: BUTTONS$1,
    		initial,
    		contextButton,
    		selectButton,
    		selectedButton,
    		contextButtons,
    		cssClass,
    		$selectedButton
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(7, className = $$props.className);
    		if ('disabled' in $$props) $$invalidate(0, disabled = $$props.disabled);
    		if ('extension' in $$props) $$invalidate(8, extension = $$props.extension);
    		if ('href' in $$props) $$invalidate(1, href = $$props.href);
    		if ('size' in $$props) $$invalidate(9, size = $$props.size);
    		if ('type' in $$props) $$invalidate(10, type = $$props.type);
    		if ('baseClass' in $$props) $$invalidate(12, baseClass = $$props.baseClass);
    		if ('buttonEl' in $$props) $$invalidate(2, buttonEl = $$props.buttonEl);
    		if ('initial' in $$props) $$invalidate(11, initial = $$props.initial);
    		if ('contextButton' in $$props) $$invalidate(3, contextButton = $$props.contextButton);
    		if ('selectButton' in $$props) selectButton = $$props.selectButton;
    		if ('selectedButton' in $$props) $$subscribe_selectedButton($$invalidate(4, selectedButton = $$props.selectedButton));
    		if ('cssClass' in $$props) $$invalidate(5, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, baseClass*/ 4224) {
    			$$invalidate(5, cssClass = className ? `${baseClass} ${className}` : baseClass);
    		}
    	};

    	return [
    		disabled,
    		href,
    		buttonEl,
    		contextButton,
    		selectedButton,
    		cssClass,
    		$selectedButton,
    		className,
    		extension,
    		size,
    		type,
    		initial,
    		baseClass,
    		$$scope,
    		slots,
    		click_handler,
    		click_handler_1,
    		a_binding,
    		button_binding
    	];
    }

    class Button$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$12, create_fragment$13, safe_not_equal, {
    			className: 7,
    			disabled: 0,
    			extension: 8,
    			href: 1,
    			size: 9,
    			type: 10,
    			initial: 11
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$13.name
    		});
    	}

    	get className() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get extension() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set extension(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get initial() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set initial(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/horizontalScroll/HorizontalScroll.svelte generated by Svelte v3.53.1 */
    const file$11 = "src/components/horizontalScroll/HorizontalScroll.svelte";

    // (20:2) <Button     on:click={() => horizontalScrollHandler.scrollWithButton(SCROLLDIRECTION.left)}     className="horizontal-scroll-nav button-prev bg--white"     extension="icon"   >
    function create_default_slot_1$s(ctx) {
    	let icon;
    	let current;

    	icon = new Icon$1({
    			props: { name: "angle-left", width: "14" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$s.name,
    		type: "slot",
    		source: "(20:2) <Button     on:click={() => horizontalScrollHandler.scrollWithButton(SCROLLDIRECTION.left)}     className=\\\"horizontal-scroll-nav button-prev bg--white\\\"     extension=\\\"icon\\\"   >",
    		ctx
    	});

    	return block;
    }

    // (27:2) <Button     on:click={() => horizontalScrollHandler.scrollWithButton(SCROLLDIRECTION.right)}     className="horizontal-scroll-nav button-next bg--white"     extension="icon"   >
    function create_default_slot$B(ctx) {
    	let icon;
    	let current;

    	icon = new Icon$1({
    			props: { name: "angle-right", width: "14" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$B.name,
    		type: "slot",
    		source: "(27:2) <Button     on:click={() => horizontalScrollHandler.scrollWithButton(SCROLLDIRECTION.right)}     className=\\\"horizontal-scroll-nav button-next bg--white\\\"     extension=\\\"icon\\\"   >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$12(ctx) {
    	let div1;
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let div0;
    	let current;

    	button0 = new Button$1({
    			props: {
    				className: "horizontal-scroll-nav button-prev bg--white",
    				extension: "icon",
    				$$slots: { default: [create_default_slot_1$s] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler*/ ctx[6]);

    	button1 = new Button$1({
    			props: {
    				className: "horizontal-scroll-nav button-next bg--white",
    				extension: "icon",
    				$$slots: { default: [create_default_slot$B] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_1*/ ctx[7]);
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", "horizontal-scroll-items horizontal-scroll-items--gap flex position-relative");
    			attr_dev(div0, "data-horizontallist", "horizontallist");
    			add_location(div0, file$11, 33, 2, 1207);
    			attr_dev(div1, "class", /*cssClass*/ ctx[2]);
    			add_location(div1, file$11, 18, 0, 686);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(button0, div1, null);
    			append_dev(div1, t0);
    			mount_component(button1, div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			/*div0_binding*/ ctx[8](div0);
    			/*div1_binding*/ ctx[9](div1);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 4) {
    				attr_dev(div1, "class", /*cssClass*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(button0);
    			destroy_component(button1);
    			if (default_slot) default_slot.d(detaching);
    			/*div0_binding*/ ctx[8](null);
    			/*div1_binding*/ ctx[9](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$12.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$11($$self, $$props, $$invalidate) {
    	let cssClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('HorizontalScroll', slots, ['default']);
    	let { className = undefined } = $$props;
    	const baseClass = `horizontal-scroll-container position-relative`;
    	let scrollContainer;
    	let scrollItemContainer;
    	const horizontalScrollHandler = new HorizontalScrollHandler$1();

    	onMount(() => {
    		horizontalScrollHandler.init(scrollItemContainer, scrollContainer);
    	});

    	afterUpdate(() => {
    		horizontalScrollHandler.update();
    	});

    	const writable_props = ['className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<HorizontalScroll> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => horizontalScrollHandler.scrollWithButton(SCROLLDIRECTION$1.left);
    	const click_handler_1 = () => horizontalScrollHandler.scrollWithButton(SCROLLDIRECTION$1.right);

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			scrollItemContainer = $$value;
    			$$invalidate(1, scrollItemContainer);
    		});
    	}

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			scrollContainer = $$value;
    			$$invalidate(0, scrollContainer);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('$$scope' in $$props) $$invalidate(10, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		afterUpdate,
    		onMount,
    		HorizontalScrollHandler: HorizontalScrollHandler$1,
    		SCROLLDIRECTION: SCROLLDIRECTION$1,
    		Button: Button$1,
    		Icon: Icon$1,
    		className,
    		baseClass,
    		scrollContainer,
    		scrollItemContainer,
    		horizontalScrollHandler,
    		cssClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('scrollContainer' in $$props) $$invalidate(0, scrollContainer = $$props.scrollContainer);
    		if ('scrollItemContainer' in $$props) $$invalidate(1, scrollItemContainer = $$props.scrollItemContainer);
    		if ('cssClass' in $$props) $$invalidate(2, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 16) {
    			$$invalidate(2, cssClass = className ? `${className} ${baseClass}` : baseClass);
    		}
    	};

    	return [
    		scrollContainer,
    		scrollItemContainer,
    		cssClass,
    		horizontalScrollHandler,
    		className,
    		slots,
    		click_handler,
    		click_handler_1,
    		div0_binding,
    		div1_binding,
    		$$scope
    	];
    }

    class HorizontalScroll extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$11, create_fragment$12, safe_not_equal, { className: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HorizontalScroll",
    			options,
    			id: create_fragment$12.name
    		});
    	}

    	get className() {
    		throw new Error("<HorizontalScroll>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<HorizontalScroll>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/articlelist/ArticleList.svelte generated by Svelte v3.53.1 */
    const file$10 = "src/components/articlelist/ArticleList.svelte";

    // (47:2) {:else}
    function create_else_block$h(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "articlelist articlelist--columns");
    			attr_dev(div, "data-items", /*$childrenLength*/ ctx[1]);
    			set_style(div, "--articlelist-columns", /*$childrenLength*/ ctx[1]);
    			add_location(div, file$10, 47, 4, 2007);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*$childrenLength*/ 2) {
    				attr_dev(div, "data-items", /*$childrenLength*/ ctx[1]);
    			}

    			if (!current || dirty & /*$childrenLength*/ 2) {
    				set_style(div, "--articlelist-columns", /*$childrenLength*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$h.name,
    		type: "else",
    		source: "(47:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (43:2) {#if $writableType === LISTTYPE.horizontal}
    function create_if_block$m(ctx) {
    	let horizontalscroll;
    	let current;

    	horizontalscroll = new HorizontalScroll({
    			props: {
    				$$slots: { default: [create_default_slot$A] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(horizontalscroll.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(horizontalscroll, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const horizontalscroll_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				horizontalscroll_changes.$$scope = { dirty, ctx };
    			}

    			horizontalscroll.$set(horizontalscroll_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(horizontalscroll.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(horizontalscroll.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(horizontalscroll, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(43:2) {#if $writableType === LISTTYPE.horizontal}",
    		ctx
    	});

    	return block;
    }

    // (44:4) <HorizontalScroll>
    function create_default_slot$A(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$A.name,
    		type: "slot",
    		source: "(44:4) <HorizontalScroll>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$11(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$m, create_else_block$h];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$writableType*/ ctx[5] === /*LISTTYPE*/ ctx[2].horizontal) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", /*className*/ ctx[0]);
    			set_style(div, "--card-mode--title", "var(--fs-" + /*titleFs*/ ctx[4] + ")");
    			add_location(div, file$10, 41, 0, 1779);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			/*div_binding*/ ctx[12](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			if (!current || dirty & /*className*/ 1) {
    				attr_dev(div, "class", /*className*/ ctx[0]);
    			}

    			if (!current || dirty & /*titleFs*/ 16) {
    				set_style(div, "--card-mode--title", "var(--fs-" + /*titleFs*/ ctx[4] + ")");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			/*div_binding*/ ctx[12](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$10($$self, $$props, $$invalidate) {
    	let $childrenLength;
    	let $writableType;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ArticleList', slots, ['default']);
    	var _a;
    	var LISTTYPE;

    	(function (LISTTYPE) {
    		LISTTYPE["columns"] = "columns";
    		LISTTYPE["horizontal"] = "horizontal";
    		LISTTYPE["vertical"] = "vertical";
    	})(LISTTYPE || (LISTTYPE = {}));

    	let { className = 'margin-l--tb' } = $$props;
    	let { fontsizes = ['xxlarge', 'xlarge', 'large'] } = $$props;
    	let { type = LISTTYPE.horizontal } = $$props;
    	const writableType = writable(type);
    	validate_store(writableType, 'writableType');
    	component_subscribe($$self, writableType, value => $$invalidate(5, $writableType = value));
    	const childrenLength = writable(0);
    	validate_store(childrenLength, 'childrenLength');
    	component_subscribe($$self, childrenLength, value => $$invalidate(1, $childrenLength = value));
    	let articleListContainer;
    	let itemWidth;

    	const getChildrenWidth = () => articleListContainer.querySelector('[data-horizontallist="horizontallist"]')
    	? articleListContainer.querySelector('[data-horizontallist="horizontallist"]').children[0].clientWidth
    	: articleListContainer.children[0].children[0].clientWidth;

    	const getChildrenCount = () => articleListContainer.querySelector('[data-horizontallist="horizontallist"]')
    	? articleListContainer.querySelector('[data-horizontallist="horizontallist"]').children.length
    	: articleListContainer.children[0].children.length;

    	function updateType() {
    		itemWidth = itemWidth !== null && itemWidth !== void 0
    		? itemWidth
    		: getChildrenWidth();

    		if ($childrenLength <= Math.round(articleListContainer.clientWidth / itemWidth) && type === LISTTYPE.horizontal) {
    			writableType.set(LISTTYPE.columns);
    		} else {
    			writableType.set(LISTTYPE.horizontal);
    		}
    	}

    	afterUpdate(() => {
    		const childrenCount = getChildrenCount();
    		childrenLength.set(childrenCount);
    		updateType();
    	});

    	let titleFs;
    	const writable_props = ['className', 'fontsizes', 'type'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArticleList> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			articleListContainer = $$value;
    			$$invalidate(3, articleListContainer);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(0, className = $$props.className);
    		if ('fontsizes' in $$props) $$invalidate(8, fontsizes = $$props.fontsizes);
    		if ('type' in $$props) $$invalidate(9, type = $$props.type);
    		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		_a,
    		afterUpdate,
    		writable,
    		HorizontalScroll,
    		LISTTYPE,
    		className,
    		fontsizes,
    		type,
    		writableType,
    		childrenLength,
    		articleListContainer,
    		itemWidth,
    		getChildrenWidth,
    		getChildrenCount,
    		updateType,
    		titleFs,
    		$childrenLength,
    		$writableType
    	});

    	$$self.$inject_state = $$props => {
    		if ('_a' in $$props) $$invalidate(10, _a = $$props._a);
    		if ('LISTTYPE' in $$props) $$invalidate(2, LISTTYPE = $$props.LISTTYPE);
    		if ('className' in $$props) $$invalidate(0, className = $$props.className);
    		if ('fontsizes' in $$props) $$invalidate(8, fontsizes = $$props.fontsizes);
    		if ('type' in $$props) $$invalidate(9, type = $$props.type);
    		if ('articleListContainer' in $$props) $$invalidate(3, articleListContainer = $$props.articleListContainer);
    		if ('itemWidth' in $$props) itemWidth = $$props.itemWidth;
    		if ('titleFs' in $$props) $$invalidate(4, titleFs = $$props.titleFs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*fontsizes, $childrenLength, _a*/ 1282) {
    			$$invalidate(4, titleFs = $$invalidate(10, _a = fontsizes[$childrenLength - 1]) !== null && _a !== void 0
    			? _a
    			: fontsizes[fontsizes.length - 1]);
    		}
    	};

    	return [
    		className,
    		$childrenLength,
    		LISTTYPE,
    		articleListContainer,
    		titleFs,
    		$writableType,
    		writableType,
    		childrenLength,
    		fontsizes,
    		type,
    		_a,
    		slots,
    		div_binding,
    		$$scope
    	];
    }

    class ArticleList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$10, create_fragment$11, safe_not_equal, { className: 0, fontsizes: 8, type: 9 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ArticleList",
    			options,
    			id: create_fragment$11.name
    		});
    	}

    	get className() {
    		throw new Error("<ArticleList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<ArticleList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fontsizes() {
    		throw new Error("<ArticleList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fontsizes(value) {
    		throw new Error("<ArticleList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<ArticleList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<ArticleList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/form-elements/Checkbox.svelte generated by Svelte v3.53.1 */
    const file$$ = "src/components/form-elements/Checkbox.svelte";

    // (20:4) {:else}
    function create_else_block$g(ctx) {
    	let icon0;
    	let t;
    	let icon1;
    	let current;

    	icon0 = new Icon$1({
    			props: {
    				className: "form-checkbox-toggle--on margin-s--l",
    				name: "check-circle",
    				width: "16"
    			},
    			$$inline: true
    		});

    	icon1 = new Icon$1({
    			props: {
    				className: "form-checkbox-toggle--off margin-s--l",
    				name: "circle",
    				width: "16"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon0.$$.fragment);
    			t = space();
    			create_component(icon1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(icon1, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon0.$$.fragment, local);
    			transition_in(icon1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon0.$$.fragment, local);
    			transition_out(icon1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(icon1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$g.name,
    		type: "else",
    		source: "(20:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (17:4) {#if inputtype === 'checkbox'}
    function create_if_block$l(ctx) {
    	let icon0;
    	let t;
    	let icon1;
    	let current;

    	icon0 = new Icon$1({
    			props: {
    				className: "form-checkbox-toggle--on margin-s--l",
    				name: "check-square",
    				width: "16"
    			},
    			$$inline: true
    		});

    	icon1 = new Icon$1({
    			props: {
    				className: "form-checkbox-toggle--off margin-s--l",
    				name: "square",
    				width: "16"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon0.$$.fragment);
    			t = space();
    			create_component(icon1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(icon1, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon0.$$.fragment, local);
    			transition_in(icon1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon0.$$.fragment, local);
    			transition_out(icon1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(icon1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(17:4) {#if inputtype === 'checkbox'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$10(ctx) {
    	let label_1;
    	let input;
    	let t0;
    	let span;
    	let t1;
    	let t2;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$l, create_else_block$g];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*inputtype*/ ctx[3] === 'checkbox') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			label_1 = element("label");
    			input = element("input");
    			t0 = space();
    			span = element("span");
    			t1 = text(/*label*/ ctx[2]);
    			t2 = space();
    			if_block.c();
    			attr_dev(input, "type", /*inputtype*/ ctx[3]);
    			attr_dev(input, "class", /*baseClass*/ ctx[5]);
    			attr_dev(input, "name", /*fieldName*/ ctx[0]);
    			attr_dev(input, "group", /*group*/ ctx[1]);
    			input.value = /*value*/ ctx[4];
    			add_location(input, file$$, 13, 2, 378);
    			attr_dev(span, "class", "flex form-label");
    			add_location(span, file$$, 14, 2, 458);
    			add_location(label_1, file$$, 12, 0, 368);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label_1, anchor);
    			append_dev(label_1, input);
    			append_dev(label_1, t0);
    			append_dev(label_1, span);
    			append_dev(span, t1);
    			append_dev(span, t2);
    			if_blocks[current_block_type_index].m(span, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*inputtype*/ 8) {
    				attr_dev(input, "type", /*inputtype*/ ctx[3]);
    			}

    			if (!current || dirty & /*baseClass*/ 32) {
    				attr_dev(input, "class", /*baseClass*/ ctx[5]);
    			}

    			if (!current || dirty & /*fieldName*/ 1) {
    				attr_dev(input, "name", /*fieldName*/ ctx[0]);
    			}

    			if (!current || dirty & /*group*/ 2) {
    				attr_dev(input, "group", /*group*/ ctx[1]);
    			}

    			if (!current || dirty & /*value*/ 16 && input.value !== /*value*/ ctx[4]) {
    				prop_dev(input, "value", /*value*/ ctx[4]);
    			}

    			if (!current || dirty & /*label*/ 4) set_data_dev(t1, /*label*/ ctx[2]);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(span, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label_1);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Checkbox', slots, []);
    	let { fieldName = undefined } = $$props;
    	let { group = undefined } = $$props;
    	let { label = undefined } = $$props;
    	let { inputtype = 'checkbox' } = $$props;
    	let { value = '' } = $$props;
    	let { className = undefined } = $$props;
    	let baseClass = `form-checkbox form-checkbox--icon`;
    	if (className) baseClass = `${className} ${baseClass}`;
    	const writable_props = ['fieldName', 'group', 'label', 'inputtype', 'value', 'className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Checkbox> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('fieldName' in $$props) $$invalidate(0, fieldName = $$props.fieldName);
    		if ('group' in $$props) $$invalidate(1, group = $$props.group);
    		if ('label' in $$props) $$invalidate(2, label = $$props.label);
    		if ('inputtype' in $$props) $$invalidate(3, inputtype = $$props.inputtype);
    		if ('value' in $$props) $$invalidate(4, value = $$props.value);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    	};

    	$$self.$capture_state = () => ({
    		Icon: Icon$1,
    		fieldName,
    		group,
    		label,
    		inputtype,
    		value,
    		className,
    		baseClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('fieldName' in $$props) $$invalidate(0, fieldName = $$props.fieldName);
    		if ('group' in $$props) $$invalidate(1, group = $$props.group);
    		if ('label' in $$props) $$invalidate(2, label = $$props.label);
    		if ('inputtype' in $$props) $$invalidate(3, inputtype = $$props.inputtype);
    		if ('value' in $$props) $$invalidate(4, value = $$props.value);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('baseClass' in $$props) $$invalidate(5, baseClass = $$props.baseClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [fieldName, group, label, inputtype, value, baseClass, className];
    }

    class Checkbox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$$, create_fragment$10, safe_not_equal, {
    			fieldName: 0,
    			group: 1,
    			label: 2,
    			inputtype: 3,
    			value: 4,
    			className: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Checkbox",
    			options,
    			id: create_fragment$10.name
    		});
    	}

    	get fieldName() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fieldName(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputtype() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputtype(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/form-elements/Select.svelte generated by Svelte v3.53.1 */

    const file$_ = "src/components/form-elements/Select.svelte";

    function create_fragment$$(ctx) {
    	let label_1;
    	let t0;
    	let t1;
    	let select;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			label_1 = element("label");
    			t0 = text(/*label*/ ctx[1]);
    			t1 = space();
    			select = element("select");
    			if (default_slot) default_slot.c();
    			attr_dev(label_1, "class", "form-label");
    			attr_dev(label_1, "for", "select");
    			add_location(label_1, file$_, 9, 0, 272);
    			attr_dev(select, "class", /*baseClass*/ ctx[2]);
    			attr_dev(select, "id", "select");
    			if (/*selected*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[7].call(select));
    			add_location(select, file$_, 10, 0, 327);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label_1, anchor);
    			append_dev(label_1, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, select, anchor);

    			if (default_slot) {
    				default_slot.m(select, null);
    			}

    			select_option(select, /*selected*/ ctx[0]);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(select, "change", /*select_change_handler*/ ctx[7]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*label*/ 2) set_data_dev(t0, /*label*/ ctx[1]);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*baseClass*/ 4) {
    				attr_dev(select, "class", /*baseClass*/ ctx[2]);
    			}

    			if (dirty & /*selected*/ 1) {
    				select_option(select, /*selected*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label_1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(select);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$_($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Select', slots, ['default']);
    	let { inputtype = 'text' } = $$props;
    	let { label = undefined } = $$props;
    	let { className = undefined } = $$props;
    	let { selected = undefined } = $$props;
    	let baseClass = `form-input form-input--${inputtype}`;
    	if (className) baseClass = `${className} ${baseClass}`;
    	const writable_props = ['inputtype', 'label', 'className', 'selected'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Select> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		selected = select_value(this);
    		$$invalidate(0, selected);
    	}

    	$$self.$$set = $$props => {
    		if ('inputtype' in $$props) $$invalidate(3, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		inputtype,
    		label,
    		className,
    		selected,
    		baseClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('inputtype' in $$props) $$invalidate(3, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('baseClass' in $$props) $$invalidate(2, baseClass = $$props.baseClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		selected,
    		label,
    		baseClass,
    		inputtype,
    		className,
    		$$scope,
    		slots,
    		select_change_handler
    	];
    }

    class Select extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$_, create_fragment$$, safe_not_equal, {
    			inputtype: 3,
    			label: 1,
    			className: 4,
    			selected: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select",
    			options,
    			id: create_fragment$$.name
    		});
    	}

    	get inputtype() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputtype(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/form-elements/TextArea.svelte generated by Svelte v3.53.1 */
    const file$Z = "src/components/form-elements/TextArea.svelte";

    // (28:2) {#if label}
    function create_if_block$k(ctx) {
    	let span;
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(/*label*/ ctx[0]);
    			t1 = text(":");
    			attr_dev(span, "class", "hidden");
    			add_location(span, file$Z, 28, 4, 998);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			/*span_binding*/ ctx[8](span);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 1) set_data_dev(t0, /*label*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			/*span_binding*/ ctx[8](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(28:2) {#if label}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$_(ctx) {
    	let div;
    	let t;
    	let textarea;
    	let div_class_value;
    	let mounted;
    	let dispose;
    	let if_block = /*label*/ ctx[0] && create_if_block$k(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			textarea = element("textarea");
    			attr_dev(textarea, "class", /*baseClass*/ ctx[4]);
    			attr_dev(textarea, "placeholder", /*label*/ ctx[0]);
    			add_location(textarea, file$Z, 30, 2, 1073);
    			attr_dev(div, "class", div_class_value = `form-input-container flex flex--column border-radius padding-m--rl ${/*size*/ ctx[1]}`);
    			add_location(div, file$Z, 26, 0, 889);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);
    			append_dev(div, textarea);
    			/*textarea_binding*/ ctx[9](textarea);

    			if (!mounted) {
    				dispose = listen_dev(textarea, "focus", /*focus_handler*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*label*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$k(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*baseClass*/ 16) {
    				attr_dev(textarea, "class", /*baseClass*/ ctx[4]);
    			}

    			if (dirty & /*label*/ 1) {
    				attr_dev(textarea, "placeholder", /*label*/ ctx[0]);
    			}

    			if (dirty & /*size*/ 2 && div_class_value !== (div_class_value = `form-input-container flex flex--column border-radius padding-m--rl ${/*size*/ ctx[1]}`)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			/*textarea_binding*/ ctx[9](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TextArea', slots, []);
    	let { inputtype = 'textarea' } = $$props;
    	let { label = undefined } = $$props;
    	let { className = undefined } = $$props;
    	let { size = 'padding-m--tb' } = $$props;
    	let textareaEl;
    	let textareaLabelEl;
    	let baseClass = `form-input form-input--${inputtype} width-1of1`;
    	if (className) baseClass = `${className} ${baseClass}`;

    	/* focus effect on form elements */
    	onMount(() => {
    		textareaEl.addEventListener('focus', () => {
    			textareaEl.parentElement.setAttribute('data-focus', 'true');
    			const inputLabel = textareaEl.previousElementSibling;
    			inputLabel.classList.remove('hidden');
    		});

    		textareaEl.addEventListener('focusout', () => {
    			textareaEl.parentElement.setAttribute('data-focus', 'false');

    			if (textareaEl.value.length === 0) {
    				textareaLabelEl.classList.add('hidden');
    			}
    		});
    	});

    	const writable_props = ['inputtype', 'label', 'className', 'size'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TextArea> was created with unknown prop '${key}'`);
    	});

    	function focus_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function span_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			textareaLabelEl = $$value;
    			$$invalidate(3, textareaLabelEl);
    		});
    	}

    	function textarea_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			textareaEl = $$value;
    			$$invalidate(2, textareaEl);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('inputtype' in $$props) $$invalidate(5, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(0, label = $$props.label);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		inputtype,
    		label,
    		className,
    		size,
    		textareaEl,
    		textareaLabelEl,
    		baseClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('inputtype' in $$props) $$invalidate(5, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(0, label = $$props.label);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    		if ('textareaEl' in $$props) $$invalidate(2, textareaEl = $$props.textareaEl);
    		if ('textareaLabelEl' in $$props) $$invalidate(3, textareaLabelEl = $$props.textareaLabelEl);
    		if ('baseClass' in $$props) $$invalidate(4, baseClass = $$props.baseClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		label,
    		size,
    		textareaEl,
    		textareaLabelEl,
    		baseClass,
    		inputtype,
    		className,
    		focus_handler,
    		span_binding,
    		textarea_binding
    	];
    }

    class TextArea extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$Z, create_fragment$_, safe_not_equal, {
    			inputtype: 5,
    			label: 0,
    			className: 6,
    			size: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TextArea",
    			options,
    			id: create_fragment$_.name
    		});
    	}

    	get inputtype() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputtype(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/form-elements/TextInput.svelte generated by Svelte v3.53.1 */
    const file$Y = "src/components/form-elements/TextInput.svelte";

    // (28:2) {#if label}
    function create_if_block$j(ctx) {
    	let span;
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(/*label*/ ctx[1]);
    			t1 = text(":");
    			attr_dev(span, "class", "hidden");
    			add_location(span, file$Y, 28, 4, 954);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			/*span_binding*/ ctx[8](span);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 2) set_data_dev(t0, /*label*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			/*span_binding*/ ctx[8](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(28:2) {#if label}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Z(ctx) {
    	let div;
    	let t;
    	let input;
    	let div_class_value;
    	let mounted;
    	let dispose;
    	let if_block = /*label*/ ctx[1] && create_if_block$j(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			input = element("input");
    			attr_dev(input, "type", /*inputtype*/ ctx[0]);
    			attr_dev(input, "placeholder", /*label*/ ctx[1]);
    			attr_dev(input, "class", /*baseClass*/ ctx[5]);
    			add_location(input, file$Y, 30, 2, 1026);
    			attr_dev(div, "class", div_class_value = `form-input-container flex border-radius padding-m--rl ${/*size*/ ctx[2]}`);
    			add_location(div, file$Y, 26, 0, 858);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);
    			append_dev(div, input);
    			/*input_binding*/ ctx[9](input);

    			if (!mounted) {
    				dispose = listen_dev(input, "focus", /*focus_handler*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*label*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$j(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*inputtype*/ 1) {
    				attr_dev(input, "type", /*inputtype*/ ctx[0]);
    			}

    			if (dirty & /*label*/ 2) {
    				attr_dev(input, "placeholder", /*label*/ ctx[1]);
    			}

    			if (dirty & /*baseClass*/ 32) {
    				attr_dev(input, "class", /*baseClass*/ ctx[5]);
    			}

    			if (dirty & /*size*/ 4 && div_class_value !== (div_class_value = `form-input-container flex border-radius padding-m--rl ${/*size*/ ctx[2]}`)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			/*input_binding*/ ctx[9](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TextInput', slots, []);
    	let { inputtype = 'text' } = $$props;
    	let { label = undefined } = $$props;
    	let { className = undefined } = $$props;
    	let { size = 'padding-m--tb' } = $$props;
    	let inputEl;
    	let inputLabelEl;
    	let baseClass = `form-input form-input--${inputtype} width-1of1`;
    	if (className) baseClass = `${className} ${baseClass}`;

    	/* focus effect on form elements */
    	onMount(() => {
    		inputEl.addEventListener('focus', () => {
    			inputEl.parentElement.setAttribute('data-focus', 'true');
    			const inputLabel = inputEl.previousElementSibling;
    			inputLabel.classList.remove('hidden');
    		});

    		inputEl.addEventListener('focusout', () => {
    			inputEl.parentElement.setAttribute('data-focus', 'false');

    			if (inputEl.value.length === 0) {
    				inputLabelEl.classList.add('hidden');
    			}
    		});
    	});

    	const writable_props = ['inputtype', 'label', 'className', 'size'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TextInput> was created with unknown prop '${key}'`);
    	});

    	function focus_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function span_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputLabelEl = $$value;
    			$$invalidate(4, inputLabelEl);
    		});
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(3, inputEl);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('inputtype' in $$props) $$invalidate(0, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('size' in $$props) $$invalidate(2, size = $$props.size);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		inputtype,
    		label,
    		className,
    		size,
    		inputEl,
    		inputLabelEl,
    		baseClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('inputtype' in $$props) $$invalidate(0, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('size' in $$props) $$invalidate(2, size = $$props.size);
    		if ('inputEl' in $$props) $$invalidate(3, inputEl = $$props.inputEl);
    		if ('inputLabelEl' in $$props) $$invalidate(4, inputLabelEl = $$props.inputLabelEl);
    		if ('baseClass' in $$props) $$invalidate(5, baseClass = $$props.baseClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		inputtype,
    		label,
    		size,
    		inputEl,
    		inputLabelEl,
    		baseClass,
    		className,
    		focus_handler,
    		span_binding,
    		input_binding
    	];
    }

    class TextInput extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$Y, create_fragment$Z, safe_not_equal, {
    			inputtype: 0,
    			label: 1,
    			className: 6,
    			size: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TextInput",
    			options,
    			id: create_fragment$Z.name
    		});
    	}

    	get inputtype() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputtype(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/form-elements/FormElement.svelte generated by Svelte v3.53.1 */
    const file$X = "src/components/form-elements/FormElement.svelte";

    // (42:2) <svelte:component this={component} class={className} {size} {label} {inputtype} {group} {value} name={fieldName}>
    function create_default_slot$z(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$z.name,
    		type: "slot",
    		source: "(42:2) <svelte:component this={component} class={className} {size} {label} {inputtype} {group} {value} name={fieldName}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Y(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	var switch_value = /*component*/ ctx[7];

    	function switch_props(ctx) {
    		return {
    			props: {
    				class: /*className*/ ctx[1],
    				size: /*size*/ ctx[0],
    				label: /*label*/ ctx[5],
    				inputtype: /*inputtype*/ ctx[4],
    				group: /*group*/ ctx[3],
    				value: /*value*/ ctx[6],
    				name: /*fieldName*/ ctx[2],
    				$$slots: { default: [create_default_slot$z] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "form-element margin-l--b");
    			add_location(div, file$X, 40, 0, 905);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (switch_instance) mount_component(switch_instance, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*className*/ 2) switch_instance_changes.class = /*className*/ ctx[1];
    			if (dirty & /*size*/ 1) switch_instance_changes.size = /*size*/ ctx[0];
    			if (dirty & /*label*/ 32) switch_instance_changes.label = /*label*/ ctx[5];
    			if (dirty & /*inputtype*/ 16) switch_instance_changes.inputtype = /*inputtype*/ ctx[4];
    			if (dirty & /*group*/ 8) switch_instance_changes.group = /*group*/ ctx[3];
    			if (dirty & /*value*/ 64) switch_instance_changes.value = /*value*/ ctx[6];
    			if (dirty & /*fieldName*/ 4) switch_instance_changes.name = /*fieldName*/ ctx[2];

    			if (dirty & /*$$scope*/ 512) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*component*/ ctx[7])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FormElement', slots, ['default']);
    	let { className = undefined } = $$props;
    	let { fieldName = undefined } = $$props;
    	let { group = undefined } = $$props;
    	let { inputtype = 'text' } = $$props;
    	let { label = undefined } = $$props;
    	let { value = '' } = $$props;
    	let { size = 'medium' } = $$props;
    	let component = TextInput;

    	switch (inputtype) {
    		case 'select':
    			component = Select;
    			break;
    		case 'checkbox':
    		case 'radio':
    			component = Checkbox;
    			break;
    		case 'textarea':
    			component = TextArea;
    			break;
    	}

    	switch (size) {
    		case 'small':
    			{
    				size = 'padding-s--tb';
    				break;
    			}
    		case 'medium':
    			{
    				size = 'padding-m--tb';
    				break;
    			}
    		case 'large':
    			{
    				size = 'padding-l--tb';
    				break;
    			}
    	}

    	const writable_props = ['className', 'fieldName', 'group', 'inputtype', 'label', 'value', 'size'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FormElement> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(1, className = $$props.className);
    		if ('fieldName' in $$props) $$invalidate(2, fieldName = $$props.fieldName);
    		if ('group' in $$props) $$invalidate(3, group = $$props.group);
    		if ('inputtype' in $$props) $$invalidate(4, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(5, label = $$props.label);
    		if ('value' in $$props) $$invalidate(6, value = $$props.value);
    		if ('size' in $$props) $$invalidate(0, size = $$props.size);
    		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Checkbox,
    		Select,
    		TextArea,
    		TextInput,
    		className,
    		fieldName,
    		group,
    		inputtype,
    		label,
    		value,
    		size,
    		component
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(1, className = $$props.className);
    		if ('fieldName' in $$props) $$invalidate(2, fieldName = $$props.fieldName);
    		if ('group' in $$props) $$invalidate(3, group = $$props.group);
    		if ('inputtype' in $$props) $$invalidate(4, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(5, label = $$props.label);
    		if ('value' in $$props) $$invalidate(6, value = $$props.value);
    		if ('size' in $$props) $$invalidate(0, size = $$props.size);
    		if ('component' in $$props) $$invalidate(7, component = $$props.component);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		size,
    		className,
    		fieldName,
    		group,
    		inputtype,
    		label,
    		value,
    		component,
    		slots,
    		$$scope
    	];
    }

    class FormElement extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$X, create_fragment$Y, safe_not_equal, {
    			className: 1,
    			fieldName: 2,
    			group: 3,
    			inputtype: 4,
    			label: 5,
    			value: 6,
    			size: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FormElement",
    			options,
    			id: create_fragment$Y.name
    		});
    	}

    	get className() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fieldName() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fieldName(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputtype() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputtype(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/spinner/Spinner.svelte generated by Svelte v3.53.1 */
    const file$W = "src/components/spinner/Spinner.svelte";

    // (5:0) {#if isLoading}
    function create_if_block$i(ctx) {
    	let div;
    	let icon0;
    	let t0;
    	let icon1;
    	let t1;
    	let icon2;
    	let current;

    	icon0 = new Icon$1({
    			props: {
    				className: "bounce bounce1",
    				name: "circle-solid",
    				style: "width: 18px; height: 18px;"
    			},
    			$$inline: true
    		});

    	icon1 = new Icon$1({
    			props: {
    				className: "bounce bounce2",
    				name: "circle-solid",
    				style: "width: 18px; height: 18px;"
    			},
    			$$inline: true
    		});

    	icon2 = new Icon$1({
    			props: {
    				className: "bounce bounce3",
    				name: "circle-solid",
    				style: "width: 18px; height: 18px;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(icon0.$$.fragment);
    			t0 = space();
    			create_component(icon1.$$.fragment);
    			t1 = space();
    			create_component(icon2.$$.fragment);
    			attr_dev(div, "class", "loader flex flex--center");
    			add_location(div, file$W, 5, 2, 117);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(icon0, div, null);
    			append_dev(div, t0);
    			mount_component(icon1, div, null);
    			append_dev(div, t1);
    			mount_component(icon2, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon0.$$.fragment, local);
    			transition_in(icon1.$$.fragment, local);
    			transition_in(icon2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon0.$$.fragment, local);
    			transition_out(icon1.$$.fragment, local);
    			transition_out(icon2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon0);
    			destroy_component(icon1);
    			destroy_component(icon2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(5:0) {#if isLoading}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$X(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*isLoading*/ ctx[0] && create_if_block$i(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isLoading*/ ctx[0]) {
    				if (if_block) {
    					if (dirty & /*isLoading*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$i(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Spinner', slots, []);
    	let { isLoading = false } = $$props;
    	const writable_props = ['isLoading'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Spinner> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('isLoading' in $$props) $$invalidate(0, isLoading = $$props.isLoading);
    	};

    	$$self.$capture_state = () => ({ Icon: Icon$1, isLoading });

    	$$self.$inject_state = $$props => {
    		if ('isLoading' in $$props) $$invalidate(0, isLoading = $$props.isLoading);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isLoading];
    }

    class Spinner extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$W, create_fragment$X, safe_not_equal, { isLoading: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Spinner",
    			options,
    			id: create_fragment$X.name
    		});
    	}

    	get isLoading() {
    		throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isLoading(value) {
    		throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/tabs/Tab.svelte generated by Svelte v3.53.1 */
    const file$V = "src/components/tabs/Tab.svelte";

    function create_fragment$W(ctx) {
    	let button_1;
    	let button_1_data_selected_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

    	const block = {
    		c: function create() {
    			button_1 = element("button");
    			if (default_slot) default_slot.c();
    			attr_dev(button_1, "class", /*cssClass*/ ctx[0]);
    			attr_dev(button_1, "data-selected", button_1_data_selected_value = /*$selectedButton*/ ctx[1] === /*button*/ ctx[2]);
    			add_location(button_1, file$V, 9, 0, 312);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button_1, anchor);

    			if (default_slot) {
    				default_slot.m(button_1, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button_1, "click", stop_propagation(/*click_handler*/ ctx[8]), false, false, true);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 1) {
    				attr_dev(button_1, "class", /*cssClass*/ ctx[0]);
    			}

    			if (!current || dirty & /*$selectedButton*/ 2 && button_1_data_selected_value !== (button_1_data_selected_value = /*$selectedButton*/ ctx[1] === /*button*/ ctx[2])) {
    				attr_dev(button_1, "data-selected", button_1_data_selected_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button_1);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let cssClass;
    	let $selectedButton;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tab', slots, ['default']);
    	const button = {};
    	const { registerTab, selectButton, selectedButton } = getContext('BUTTONS');
    	validate_store(selectedButton, 'selectedButton');
    	component_subscribe($$self, selectedButton, value => $$invalidate(1, $selectedButton = value));
    	registerTab(button);
    	let { className = undefined } = $$props;
    	const baseClass = `button`;
    	const writable_props = ['className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tab> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => selectButton(button);

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(5, className = $$props.className);
    		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		button,
    		registerTab,
    		selectButton,
    		selectedButton,
    		className,
    		baseClass,
    		cssClass,
    		$selectedButton
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(5, className = $$props.className);
    		if ('cssClass' in $$props) $$invalidate(0, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 32) {
    			$$invalidate(0, cssClass = className ? `${baseClass} ${className}` : baseClass);
    		}
    	};

    	return [
    		cssClass,
    		$selectedButton,
    		button,
    		selectButton,
    		selectedButton,
    		className,
    		$$scope,
    		slots,
    		click_handler
    	];
    }

    class Tab extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$V, create_fragment$W, safe_not_equal, { className: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tab",
    			options,
    			id: create_fragment$W.name
    		});
    	}

    	get className() {
    		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/tabs/TabContent.svelte generated by Svelte v3.53.1 */

    // (7:0) {#if $selectedPanel === panel}
    function create_if_block$h(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(7:0) {#if $selectedPanel === panel}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$V(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$selectedPanel*/ ctx[0] === /*panel*/ ctx[1] && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$selectedPanel*/ ctx[0] === /*panel*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$selectedPanel*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$h(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let $selectedPanel;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TabContent', slots, ['default']);
    	const panel = {};
    	const { registerPanel, selectedPanel } = getContext('BUTTONS');
    	validate_store(selectedPanel, 'selectedPanel');
    	component_subscribe($$self, selectedPanel, value => $$invalidate(0, $selectedPanel = value));
    	registerPanel(panel);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TabContent> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		panel,
    		registerPanel,
    		selectedPanel,
    		$selectedPanel
    	});

    	return [$selectedPanel, panel, selectedPanel, $$scope, slots];
    }

    class TabContent extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$U, create_fragment$V, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabContent",
    			options,
    			id: create_fragment$V.name
    		});
    	}
    }

    /* src/components/tabs/TabList.svelte generated by Svelte v3.53.1 */

    const file$U = "src/components/tabs/TabList.svelte";

    function create_fragment$U(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", /*cssClass*/ ctx[0]);
    			add_location(div, file$U, 14, 0, 357);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 1) {
    				attr_dev(div, "class", /*cssClass*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let cssClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TabList', slots, ['default']);
    	let { type = 'tabs' } = $$props;
    	let { className = undefined } = $$props;
    	let baseClass = '';

    	switch (type) {
    		case 'tabs':
    			baseClass = 'tabs';
    			break;
    		case 'pillnavigation':
    			baseClass = 'pillnavigation toggle toggle--buttons';
    			break;
    	}

    	const writable_props = ['type', 'className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TabList> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('type' in $$props) $$invalidate(1, type = $$props.type);
    		if ('className' in $$props) $$invalidate(2, className = $$props.className);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ type, className, baseClass, cssClass });

    	$$self.$inject_state = $$props => {
    		if ('type' in $$props) $$invalidate(1, type = $$props.type);
    		if ('className' in $$props) $$invalidate(2, className = $$props.className);
    		if ('baseClass' in $$props) $$invalidate(3, baseClass = $$props.baseClass);
    		if ('cssClass' in $$props) $$invalidate(0, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, baseClass*/ 12) {
    			$$invalidate(0, cssClass = className ? `${baseClass} ${className}` : baseClass);
    		}
    	};

    	return [cssClass, type, className, baseClass, $$scope, slots];
    }

    class TabList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$U, safe_not_equal, { type: 1, className: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabList",
    			options,
    			id: create_fragment$U.name
    		});
    	}

    	get type() {
    		throw new Error("<TabList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<TabList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<TabList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<TabList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/tabs/Tabs.svelte generated by Svelte v3.53.1 */
    const file$T = "src/components/tabs/Tabs.svelte";

    function create_fragment$T(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", /*className*/ ctx[0]);
    			add_location(div, file$T, 40, 0, 1341);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*className*/ 1) {
    				attr_dev(div, "class", /*className*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tabs', slots, ['default']);
    	const selectedId = writable(0);
    	const buttons = [];
    	const panels = [];
    	const selectedButton = writable(null);
    	const selectedPanel = writable(null);

    	selectedId.subscribe(i => {
    		selectedButton.set(buttons[i]);
    		selectedPanel.set(panels[i]);
    	});

    	setContext('BUTTONS', {
    		registerPanel: panel => {
    			panels.push(panel);
    			selectedPanel.update(current => current || panel);

    			onDestroy(() => {
    				const i = panels.indexOf(panel);
    				panels.splice(i, 1);

    				selectedPanel.update(current => current === panel
    				? panels[i] || panels[panels.length - 1]
    				: current);
    			});
    		},
    		registerTab: button => {
    			buttons.push(button);
    			selectedButton.update(current => current || button);

    			onDestroy(() => {
    				const i = buttons.indexOf(button);
    				buttons.splice(i, 1);

    				selectedButton.update(current => current === button
    				? buttons[i] || buttons[buttons.length - 1]
    				: current);
    			});
    		},
    		selectButton: button => {
    			const i = buttons.indexOf(button);
    			selectedId.set(i);
    		},
    		selectedButton,
    		selectedPanel
    	});

    	let { className = undefined } = $$props;
    	const writable_props = ['className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tabs> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(0, className = $$props.className);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onDestroy,
    		setContext,
    		SvelteComponent: SvelteComponentDev,
    		writable,
    		selectedId,
    		buttons,
    		panels,
    		selectedButton,
    		selectedPanel,
    		className
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(0, className = $$props.className);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [className, selectedId, $$scope, slots];
    }

    class Tabs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$T, safe_not_equal, { selectedId: 1, className: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabs",
    			options,
    			id: create_fragment$T.name
    		});
    	}

    	get selectedId() {
    		return this.$$.ctx[1];
    	}

    	set selectedId(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const lipsum = [
        'Lorem ipsum dolor sit amet, consectetur adipiscing elit.',
        'Fusce ullamcorper nibh quis dui consequat iaculis.',
        'Integer pretium dapibus orci quis sagittis.',
        'Maecenas non diam eu nibh lobortis vulputate.',
        'Fusce pharetra pretium convallis.',
        'Donec blandit purus sed orci ornare, a egestas justo sagittis.',
        'Maecenas in dui lacinia, consectetur lorem quis, semper lacus.',
        'Aenean ut iaculis neque. Etiam bibendum lacus ut commodo vehicula.',
        'Integer non venenatis ante. Pellentesque egestas venenatis nisl, quis blandit dui porttitor ut.',
        'Quisque dictum tortor sit amet ornare fringilla.',
        'Duis metus lectus, imperdiet consequat libero a, tristique pellentesque dolor.',
        'Fusce augue arcu, sagittis ut porttitor quis, tempor in velit.',
        'Integer pulvinar risus vitae tortor accumsan cursus. Integer in metus pulvinar, posuere urna a, scelerisque mi.',
        'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ultrices placerat auctor.',
        'Mauris molestie hendrerit libero, vitae ultrices elit efficitur nec.',
        'Curabitur non lectus sit amet magna eleifend sagittis. Suspendisse ac efficitur elit.',
        'Sed consectetur laoreet mollis. Quisque pulvinar pretium nisi.',
        'Mauris interdum eleifend risus, quis dapibus augue congue non.',
        'Ut quis efficitur urna. Fusce sem sapien, porta ac ultricies eget, ultrices dapibus lacus.',
        'Fusce vehicula, dui quis faucibus lobortis, mi mauris vestibulum dui, quis tempus mi elit ut orci.',
        'Vestibulum porta nisi nisi.',
        'Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Quisque ornare massa tellus, feugiat venenatis diam vehicula ornare.',
        'Nullam sit amet odio consectetur, egestas lorem eget, pellentesque odio.',
        'Quisque laoreet enim eros, eget commodo odio imperdiet non.',
        'Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae.',
        'Mauris fringilla sollicitudin lobortis. Nam sit amet aliquet sem, eu scelerisque metus.',
        'Interdum et malesuada fames ac ante ipsum primis in faucibus.',
        'Pellentesque ut lectus vitae odio interdum congue.',
        'Pellentesque posuere bibendum interdum.',
        'Proin quis neque efficitur, sollicitudin risus consectetur, sagittis ante.',
        'Nunc nulla metus, luctus sit amet fermentum quis, lacinia sed quam.',
        'Interdum et malesuada fames ac ante ipsum primis in faucibus.',
        'Lorem ipsum dolor sit amet, consectetur adipiscing elit.',
        'Duis nec magna metus. Ut hendrerit convallis metus quis dictum.',
        'Phasellus bibendum, ex a posuere rhoncus, mi velit fermentum mauris, id porttitor odio augue id justo.',
        'Nulla malesuada justo massa, in luctus diam suscipit at.',
        'Praesent commodo arcu in nisi eleifend auctor non et dui.',
        'Duis at tellus ac purus tincidunt condimentum.',
        'Sed id finibus nulla, sed ullamcorper neque.',
        'Mauris accumsan magna nec nisi tempor, eu consectetur tortor volutpat.',
        'Sed eget elementum odio.',
        'Aliquam luctus lectus at nunc vehicula, in malesuada est fermentum.',
        'Aliquam eget turpis nec dui luctus pretium.',
        'Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.',
        'Integer eu aliquam dolor.',
        'Maecenas et tellus nisi.',
        'Integer gravida finibus ex vel pretium.',
        'Cras ac orci eget magna aliquet cursus.',
        'Cras placerat, est sit amet sodales fringilla, nunc urna ornare neque, eget pharetra nunc odio vitae nulla.',
        'Aliquam euismod sodales elit ut sollicitudin.',
    ];
    const getSentence = () => lipsum[Math.floor(Math.random() * 50)];
    const getWord = () => lipsum[Math.floor(Math.random() * 50)].split(' ')[0];
    function rdmParagraphs(num = 3) {
        let returnData = '';
        for (let i = num; i--;) {
            returnData += `<p>${getSentence()}</p>`;
        }
        return returnData;
    }

    const localeSourceType = localStorage.getItem('sourceType');
    const sourceType = writable(localeSourceType || 'html');
    sourceType.subscribe((value) => {
        localStorage.setItem('sourceType', value);
    });

    /* docs_src/components/Accordion.svelte generated by Svelte v3.53.1 */
    const file$S = "docs_src/components/Accordion.svelte";

    // (16:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$8(ctx) {
    	let prism;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t13;
    	let td3;
    	let t14;
    	let span;
    	let t16;
    	let t17;
    	let tr2;
    	let th4;
    	let t19;
    	let tr3;
    	let td4;
    	let t21;
    	let td5;
    	let t23;
    	let td6;
    	let t24;
    	let td7;
    	let t25;
    	let tr4;
    	let td8;
    	let t27;
    	let td9;
    	let t29;
    	let td10;
    	let t30;
    	let td11;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_3$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "tabs";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "ITabsConfig[]";
    			t12 = space();
    			td2 = element("td");
    			t13 = space();
    			td3 = element("td");
    			t14 = text("Array of tab data. See ");
    			span = element("span");
    			span.textContent = "Tab";
    			t16 = text(" props below for details");
    			t17 = space();
    			tr2 = element("tr");
    			th4 = element("th");
    			th4.textContent = "Tab";
    			t19 = space();
    			tr3 = element("tr");
    			td4 = element("td");
    			td4.textContent = "content";
    			t21 = space();
    			td5 = element("td");
    			td5.textContent = "string / html";
    			t23 = space();
    			td6 = element("td");
    			t24 = space();
    			td7 = element("td");
    			t25 = space();
    			tr4 = element("tr");
    			td8 = element("td");
    			td8.textContent = "title";
    			t27 = space();
    			td9 = element("td");
    			td9.textContent = "string";
    			t29 = space();
    			td10 = element("td");
    			t30 = space();
    			td11 = element("td");
    			add_location(th0, file$S, 23, 8, 572);
    			add_location(th1, file$S, 24, 8, 599);
    			add_location(th2, file$S, 25, 8, 621);
    			add_location(th3, file$S, 26, 8, 652);
    			add_location(tr0, file$S, 22, 6, 559);
    			add_location(thead, file$S, 21, 4, 545);
    			add_location(td0, file$S, 31, 8, 729);
    			add_location(td1, file$S, 32, 8, 751);
    			add_location(td2, file$S, 33, 8, 782);
    			attr_dev(span, "class", "badge badge--small");
    			attr_dev(span, "data-type", "secondary");
    			add_location(span, file$S, 35, 34, 835);
    			add_location(td3, file$S, 34, 8, 797);
    			add_location(tr1, file$S, 30, 6, 716);
    			attr_dev(th4, "colspan", "4");
    			add_location(th4, file$S, 39, 8, 970);
    			add_location(tr2, file$S, 38, 6, 957);
    			add_location(td4, file$S, 42, 8, 1026);
    			add_location(td5, file$S, 43, 8, 1051);
    			add_location(td6, file$S, 44, 8, 1082);
    			add_location(td7, file$S, 45, 8, 1097);
    			add_location(tr3, file$S, 41, 6, 1013);
    			add_location(td8, file$S, 48, 8, 1135);
    			add_location(td9, file$S, 49, 8, 1158);
    			add_location(td10, file$S, 50, 8, 1182);
    			add_location(td11, file$S, 51, 8, 1197);
    			add_location(tr4, file$S, 47, 6, 1122);
    			add_location(tbody, file$S, 29, 4, 702);
    			attr_dev(table, "class", "table");
    			add_location(table, file$S, 20, 2, 519);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			append_dev(td3, t14);
    			append_dev(td3, span);
    			append_dev(td3, t16);
    			append_dev(tbody, t17);
    			append_dev(tbody, tr2);
    			append_dev(tr2, th4);
    			append_dev(tbody, t19);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td4);
    			append_dev(tr3, t21);
    			append_dev(tr3, td5);
    			append_dev(tr3, t23);
    			append_dev(tr3, td6);
    			append_dev(tr3, t24);
    			append_dev(tr3, td7);
    			append_dev(tbody, t25);
    			append_dev(tbody, tr4);
    			append_dev(tr4, td8);
    			append_dev(tr4, t27);
    			append_dev(tr4, td9);
    			append_dev(tr4, t29);
    			append_dev(tr4, td10);
    			append_dev(tr4, t30);
    			append_dev(tr4, td11);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(16:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (17:2) <Prism language="js">
    function create_default_slot_3$f(ctx) {
    	let t_value = `import { Accordion } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$f.name,
    		type: "slot",
    		source: "(17:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (64:0) {:else}
    function create_else_block$f(ctx) {
    	let prism0;
    	let t;
    	let prism1;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_1$r] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism0.$$.fragment);
    			t = space();
    			create_component(prism1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(prism1, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(prism1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$f.name,
    		type: "else",
    		source: "(64:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (60:0) {#if $sourceType === 'svelte'}
    function create_if_block$g(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$y] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(60:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (65:2) <Prism language="html">
    function create_default_slot_2$l(ctx) {
    	let t_value = `<div class="accordion card-mode padding-l ff-secondary width-1of1">
  <div class="accordion-tab margin-m--b">
    <div class="accordion-header flex flex-justify--between flex-align--center padding-m">
      <span class="fontweight-bold fontsize-medium">Tab 1</span>
      <svg viewBox="0 0 50 50">
        <use xlink:href="#angle-down"></use>
      </svg>
    </div>
    <div class="accordion-body padding-m padding-l--rl fontsize-small">
      Content 1
    </div>
  </div>
  <div class="accordion-tab margin-m--b">
    <div class="accordion-header flex flex-justify--between flex-align--center padding-m">
      <span class="fontweight-bold fontsize-medium">Tab 2</span>
      <svg viewBox="0 0 50 50">
        <use xlink:href="#angle-down"></use>
      </svg>
    </div>
    <div class="accordion-body padding-m padding-l--rl fontsize-small">
      Content 2
    </div>
  </div>
  <div class="accordion-tab margin-m--b">
    <div class="accordion-header flex flex-justify--between flex-align--center padding-m">
      <span class="fontweight-bold fontsize-medium">Tab 3</span>
      <svg viewBox="0 0 50 50">
        <use xlink:href="#angle-down"></use>
      </svg>
    </div>
    <div class="accordion-body padding-m padding-l--rl fontsize-small">
      Content 3
    </div>
  </div>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$l.name,
    		type: "slot",
    		source: "(65:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (103:2) <Prism language="js">
    function create_default_slot_1$r(ctx) {
    	let t_value = `const accordions = document.querySelectorAll(".accordion");
for (const accordion of accordions) {
  const tabs = accordion.querySelectorAll(".accordion-tab");
  for (const tab of tabs) {
    const head = tab.querySelector(".accordion-header");
    head.addEventListener('click', () => {
      for (const othertab of tabs) {
        if (othertab !== tab) {
          othertab.classList.remove('accordion-expanded');
        }
      }
      tab.classList.toggle('accordion-expanded');
    });
  }
}` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$r.name,
    		type: "slot",
    		source: "(103:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (61:2) <Prism language="html">
    function create_default_slot$y(ctx) {
    	let t_value = `<Accordion {tabs} />` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$y.name,
    		type: "slot",
    		source: "(61:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$S(ctx) {
    	let h1;
    	let t1;
    	let t2;
    	let accordion;
    	let t3;
    	let current_block_type_index;
    	let if_block1;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*$sourceType*/ ctx[0] === 'svelte' && create_if_block_1$8(ctx);

    	accordion = new Accordion({
    			props: { tabs: /*tabs*/ ctx[1] },
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block$g, create_else_block$f];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Accordion";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			create_component(accordion.$$.fragment);
    			t3 = space();
    			if_block1.c();
    			if_block1_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$S, 13, 0, 347);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(accordion, target, anchor);
    			insert_dev(target, t3, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$sourceType*/ ctx[0] === 'svelte') {
    				if (if_block0) {
    					if (dirty & /*$sourceType*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$8(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(accordion.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(accordion.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(accordion, detaching);
    			if (detaching) detach_dev(t3);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Accordion', slots, []);
    	const tabs = [];

    	for (let i = 0; i < 3; i++) {
    		tabs.push({
    			content: `<h2>Test af h2</h2>${rdmParagraphs()}`,
    			title: `Tab ${i + 1}`
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Accordion> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		Accordion,
    		rdmParagraphs,
    		sourceType,
    		tabs,
    		$sourceType
    	});

    	return [$sourceType, tabs];
    }

    class Accordion_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$S, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Accordion_1",
    			options,
    			id: create_fragment$S.name
    		});
    	}
    }

    function rdmArticleData(mediaWidth = 640, mediaHeight = 360) {
        const colorNamesForUse = [
            colorNames.breaking,
            colorNames.bruger,
            colorNames.eb,
            colorNames.flash,
            colorNames.forbrug,
            colorNames.livescore,
            colorNames.native,
            colorNames.nyheder,
            colorNames.sexsamliv,
            colorNames.sport,
            colorNames.underholdning,
        ];
        const article = {
            breaking: Math.random() < 0.1,
            colorName: colorNamesForUse[Math.floor(Math.random() * colorNamesForUse.length)],
            media: Math.random() < 0.7
                ? {
                    src: `https://loremflickr.com/${mediaWidth}/${mediaHeight}/city,people,nature,animal?random=${Math.random()}`,
                }
                : null,
            premium: Math.random() < 0.3,
            published: randomDate().toString(),
            saved: Math.random() < 0.5,
            section: getWord(),
            title: getSentence(),
            truncateTitle: false,
            update: Math.random() < 0.5,
            url: '',
            videoIcon: Math.random() < 0.3,
        };
        return article;
    }
    function randomDate() {
        const start = new Date(2019, 0, 1);
        const end = new Date();
        return new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
    }

    /* docs_src/components/ArticleCard.svelte generated by Svelte v3.53.1 */
    const file$R = "docs_src/components/ArticleCard.svelte";

    // (173:0) {:else}
    function create_else_block$e(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "ArticleCard er en ren Svelte component.";
    			add_location(p, file$R, 173, 2, 4385);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$e.name,
    		type: "else",
    		source: "(173:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (9:0) {#if $sourceType === 'svelte'}
    function create_if_block$f(ctx) {
    	let prism0;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t13;
    	let td3;
    	let t14;
    	let tr2;
    	let td4;
    	let t16;
    	let td5;
    	let t18;
    	let td6;
    	let t19;
    	let td7;
    	let t20;
    	let em;
    	let t22;
    	let tr3;
    	let td8;
    	let t24;
    	let td9;
    	let t26;
    	let td10;
    	let t27;
    	let td11;
    	let t29;
    	let tr4;
    	let td12;
    	let t31;
    	let td13;
    	let t33;
    	let td14;
    	let t35;
    	let td15;
    	let t37;
    	let tr5;
    	let td16;
    	let t39;
    	let td17;
    	let t41;
    	let td18;
    	let t43;
    	let td19;
    	let t45;
    	let tr6;
    	let td20;
    	let t47;
    	let td21;
    	let t49;
    	let td22;
    	let t51;
    	let td23;
    	let t52;
    	let tr7;
    	let td24;
    	let t54;
    	let td25;
    	let t56;
    	let td26;
    	let t58;
    	let td27;
    	let t60;
    	let tr8;
    	let td28;
    	let t62;
    	let td29;
    	let t64;
    	let td30;
    	let t66;
    	let td31;
    	let t68;
    	let tr9;
    	let td32;
    	let t70;
    	let td33;
    	let t72;
    	let td34;
    	let t74;
    	let td35;
    	let t75;
    	let code;
    	let t77;
    	let t78;
    	let tr10;
    	let td36;
    	let t80;
    	let td37;
    	let t82;
    	let td38;
    	let t83;
    	let td39;
    	let t84;
    	let span0;
    	let t86;
    	let t87;
    	let tr11;
    	let td40;
    	let t89;
    	let td41;
    	let t91;
    	let td42;
    	let t92;
    	let td43;
    	let t94;
    	let tr12;
    	let td44;
    	let t96;
    	let td45;
    	let t98;
    	let td46;
    	let t99;
    	let td47;
    	let t100;
    	let tr13;
    	let td48;
    	let t102;
    	let td49;
    	let t104;
    	let td50;
    	let t105;
    	let td51;
    	let t107;
    	let tr14;
    	let td52;
    	let t109;
    	let td53;
    	let t111;
    	let td54;
    	let t113;
    	let td55;
    	let t114;
    	let tr15;
    	let td56;
    	let t116;
    	let td57;
    	let t118;
    	let td58;
    	let t119;
    	let td59;
    	let t121;
    	let tr16;
    	let th4;
    	let t123;
    	let tr17;
    	let td60;
    	let t125;
    	let td61;
    	let t127;
    	let td62;
    	let t128;
    	let td63;
    	let t129;
    	let tr18;
    	let td64;
    	let t131;
    	let td65;
    	let t133;
    	let td66;
    	let t134;
    	let td67;
    	let t135;
    	let tr19;
    	let td68;
    	let t136;
    	let span1;
    	let t138;
    	let td69;
    	let t140;
    	let td70;
    	let t141;
    	let td71;
    	let t142;
    	let tr20;
    	let td72;
    	let t144;
    	let td73;
    	let t146;
    	let td74;
    	let t147;
    	let td75;
    	let t148;
    	let articlecard0;
    	let t149;
    	let prism1;
    	let t150;
    	let h30;
    	let t152;
    	let articlecard1;
    	let t153;
    	let articlecard2;
    	let t154;
    	let prism2;
    	let t155;
    	let h31;
    	let t157;
    	let articlecard3;
    	let t158;
    	let articlecard4;
    	let t159;
    	let articlecard5;
    	let t160;
    	let prism3;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_3$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const articlecard0_spread_levels = [rdmArticleData()];
    	let articlecard0_props = {};

    	for (let i = 0; i < articlecard0_spread_levels.length; i += 1) {
    		articlecard0_props = assign(articlecard0_props, articlecard0_spread_levels[i]);
    	}

    	articlecard0 = new ArticleCard({
    			props: articlecard0_props,
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const articlecard1_spread_levels = [
    		{ className: "margin-m--b" },
    		{ cardType: "small-media" },
    		rdmArticleData(250, 120)
    	];

    	let articlecard1_props = {};

    	for (let i = 0; i < articlecard1_spread_levels.length; i += 1) {
    		articlecard1_props = assign(articlecard1_props, articlecard1_spread_levels[i]);
    	}

    	articlecard1 = new ArticleCard({
    			props: articlecard1_props,
    			$$inline: true
    		});

    	const articlecard2_spread_levels = [{ cardType: "small-media--reverse" }, rdmArticleData(250, 120)];
    	let articlecard2_props = {};

    	for (let i = 0; i < articlecard2_spread_levels.length; i += 1) {
    		articlecard2_props = assign(articlecard2_props, articlecard2_spread_levels[i]);
    	}

    	articlecard2 = new ArticleCard({
    			props: articlecard2_props,
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	articlecard3 = new ArticleCard({
    			props: {
    				loading: true,
    				colorName: "graa7",
    				className: "margin-m--b"
    			},
    			$$inline: true
    		});

    	articlecard4 = new ArticleCard({
    			props: {
    				loading: true,
    				cardType: "small-media",
    				colorName: "graa7",
    				className: "margin-m--b"
    			},
    			$$inline: true
    		});

    	articlecard5 = new ArticleCard({
    			props: {
    				loading: true,
    				cardType: "small-media--reverse",
    				colorName: "graa7",
    				className: "margin-m--b"
    			},
    			$$inline: true
    		});

    	prism3 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$x] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism0.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "className";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "string";
    			t12 = space();
    			td2 = element("td");
    			t13 = space();
    			td3 = element("td");
    			t14 = space();
    			tr2 = element("tr");
    			td4 = element("td");
    			td4.textContent = "colorClass";
    			t16 = space();
    			td5 = element("td");
    			td5.textContent = "string";
    			t18 = space();
    			td6 = element("td");
    			t19 = space();
    			td7 = element("td");
    			t20 = text("EB color ");
    			em = element("em");
    			em.textContent = "(e.g. sport)";
    			t22 = space();
    			tr3 = element("tr");
    			td8 = element("td");
    			td8.textContent = "src";
    			t24 = space();
    			td9 = element("td");
    			td9.textContent = "string";
    			t26 = space();
    			td10 = element("td");
    			t27 = space();
    			td11 = element("td");
    			td11.textContent = "Converts the ArticleCard into a clickable link";
    			t29 = space();
    			tr4 = element("tr");
    			td12 = element("td");
    			td12.textContent = "breaking";
    			t31 = space();
    			td13 = element("td");
    			td13.textContent = "boolean";
    			t33 = space();
    			td14 = element("td");
    			td14.textContent = "false";
    			t35 = space();
    			td15 = element("td");
    			td15.textContent = "Force breaking color";
    			t37 = space();
    			tr5 = element("tr");
    			td16 = element("td");
    			td16.textContent = "update";
    			t39 = space();
    			td17 = element("td");
    			td17.textContent = "boolean";
    			t41 = space();
    			td18 = element("td");
    			td18.textContent = "false";
    			t43 = space();
    			td19 = element("td");
    			td19.textContent = "Add update icon to media";
    			t45 = space();
    			tr6 = element("tr");
    			td20 = element("td");
    			td20.textContent = "premium";
    			t47 = space();
    			td21 = element("td");
    			td21.textContent = "boolean";
    			t49 = space();
    			td22 = element("td");
    			td22.textContent = "false";
    			t51 = space();
    			td23 = element("td");
    			t52 = space();
    			tr7 = element("tr");
    			td24 = element("td");
    			td24.textContent = "videoIcon";
    			t54 = space();
    			td25 = element("td");
    			td25.textContent = "boolean";
    			t56 = space();
    			td26 = element("td");
    			td26.textContent = "false";
    			t58 = space();
    			td27 = element("td");
    			td27.textContent = "Shows a videoPlay icon on the articleCard inside the image container";
    			t60 = space();
    			tr8 = element("tr");
    			td28 = element("td");
    			td28.textContent = "loading";
    			t62 = space();
    			td29 = element("td");
    			td29.textContent = "boolean";
    			t64 = space();
    			td30 = element("td");
    			td30.textContent = "false";
    			t66 = space();
    			td31 = element("td");
    			td31.textContent = "Converts the ArticleCard into a loading placeholder";
    			t68 = space();
    			tr9 = element("tr");
    			td32 = element("td");
    			td32.textContent = "maxLines";
    			t70 = space();
    			td33 = element("td");
    			td33.textContent = "number";
    			t72 = space();
    			td34 = element("td");
    			td34.textContent = "4";
    			t74 = space();
    			td35 = element("td");
    			t75 = text("Sets the value of ");
    			code = element("code");
    			code.textContent = "--max-lines";
    			t77 = text(" if truncate is enabled");
    			t78 = space();
    			tr10 = element("tr");
    			td36 = element("td");
    			td36.textContent = "media";
    			t80 = space();
    			td37 = element("td");
    			td37.textContent = "IMediaOptions";
    			t82 = space();
    			td38 = element("td");
    			t83 = space();
    			td39 = element("td");
    			t84 = text("Adds a image, see ");
    			span0 = element("span");
    			span0.textContent = "Media";
    			t86 = text(" props below for details");
    			t87 = space();
    			tr11 = element("tr");
    			td40 = element("td");
    			td40.textContent = "section";
    			t89 = space();
    			td41 = element("td");
    			td41.textContent = "string";
    			t91 = space();
    			td42 = element("td");
    			t92 = space();
    			td43 = element("td");
    			td43.textContent = "Displays the section meta with a tag icon";
    			t94 = space();
    			tr12 = element("tr");
    			td44 = element("td");
    			td44.textContent = "style";
    			t96 = space();
    			td45 = element("td");
    			td45.textContent = "string";
    			t98 = space();
    			td46 = element("td");
    			t99 = space();
    			td47 = element("td");
    			t100 = space();
    			tr13 = element("tr");
    			td48 = element("td");
    			td48.textContent = "published";
    			t102 = space();
    			td49 = element("td");
    			td49.textContent = "date string";
    			t104 = space();
    			td50 = element("td");
    			t105 = space();
    			td51 = element("td");
    			td51.textContent = "Displays relative time meta with a icon";
    			t107 = space();
    			tr14 = element("tr");
    			td52 = element("td");
    			td52.textContent = "truncateTitle";
    			t109 = space();
    			td53 = element("td");
    			td53.textContent = "boolean";
    			t111 = space();
    			td54 = element("td");
    			td54.textContent = "false";
    			t113 = space();
    			td55 = element("td");
    			t114 = space();
    			tr15 = element("tr");
    			td56 = element("td");
    			td56.textContent = "cardType";
    			t116 = space();
    			td57 = element("td");
    			td57.textContent = "'mode' | 'small-media' | 'small-media--reverse'";
    			t118 = space();
    			td58 = element("td");
    			t119 = space();
    			td59 = element("td");
    			td59.textContent = "Display types. See examples below";
    			t121 = space();
    			tr16 = element("tr");
    			th4 = element("th");
    			th4.textContent = "Media";
    			t123 = space();
    			tr17 = element("tr");
    			td60 = element("td");
    			td60.textContent = "className";
    			t125 = space();
    			td61 = element("td");
    			td61.textContent = "string";
    			t127 = space();
    			td62 = element("td");
    			t128 = space();
    			td63 = element("td");
    			t129 = space();
    			tr18 = element("tr");
    			td64 = element("td");
    			td64.textContent = "height";
    			t131 = space();
    			td65 = element("td");
    			td65.textContent = "string";
    			t133 = space();
    			td66 = element("td");
    			t134 = space();
    			td67 = element("td");
    			t135 = space();
    			tr19 = element("tr");
    			td68 = element("td");
    			t136 = text("src ");
    			span1 = element("span");
    			span1.textContent = "required";
    			t138 = space();
    			td69 = element("td");
    			td69.textContent = "string";
    			t140 = space();
    			td70 = element("td");
    			t141 = space();
    			td71 = element("td");
    			t142 = space();
    			tr20 = element("tr");
    			td72 = element("td");
    			td72.textContent = "width";
    			t144 = space();
    			td73 = element("td");
    			td73.textContent = "string";
    			t146 = space();
    			td74 = element("td");
    			t147 = space();
    			td75 = element("td");
    			t148 = space();
    			create_component(articlecard0.$$.fragment);
    			t149 = space();
    			create_component(prism1.$$.fragment);
    			t150 = space();
    			h30 = element("h3");
    			h30.textContent = "Small-media";
    			t152 = space();
    			create_component(articlecard1.$$.fragment);
    			t153 = space();
    			create_component(articlecard2.$$.fragment);
    			t154 = space();
    			create_component(prism2.$$.fragment);
    			t155 = space();
    			h31 = element("h3");
    			h31.textContent = "Loading placeholder";
    			t157 = space();
    			create_component(articlecard3.$$.fragment);
    			t158 = space();
    			create_component(articlecard4.$$.fragment);
    			t159 = space();
    			create_component(articlecard5.$$.fragment);
    			t160 = space();
    			create_component(prism3.$$.fragment);
    			add_location(th0, file$R, 16, 8, 416);
    			add_location(th1, file$R, 17, 8, 443);
    			add_location(th2, file$R, 18, 8, 465);
    			add_location(th3, file$R, 19, 8, 496);
    			add_location(tr0, file$R, 15, 6, 403);
    			add_location(thead, file$R, 14, 4, 389);
    			add_location(td0, file$R, 24, 8, 573);
    			add_location(td1, file$R, 25, 8, 600);
    			add_location(td2, file$R, 26, 8, 624);
    			add_location(td3, file$R, 27, 8, 639);
    			add_location(tr1, file$R, 23, 6, 560);
    			add_location(td4, file$R, 30, 8, 677);
    			add_location(td5, file$R, 31, 8, 705);
    			add_location(td6, file$R, 32, 8, 729);
    			add_location(em, file$R, 33, 21, 757);
    			add_location(td7, file$R, 33, 8, 744);
    			add_location(tr2, file$R, 29, 6, 664);
    			add_location(td8, file$R, 36, 8, 815);
    			add_location(td9, file$R, 37, 8, 836);
    			add_location(td10, file$R, 38, 8, 860);
    			add_location(td11, file$R, 39, 8, 875);
    			add_location(tr3, file$R, 35, 6, 802);
    			add_location(td12, file$R, 42, 8, 962);
    			add_location(td13, file$R, 43, 8, 988);
    			add_location(td14, file$R, 44, 8, 1013);
    			add_location(td15, file$R, 45, 8, 1036);
    			add_location(tr4, file$R, 41, 6, 949);
    			add_location(td16, file$R, 48, 8, 1097);
    			add_location(td17, file$R, 49, 8, 1121);
    			add_location(td18, file$R, 50, 8, 1146);
    			add_location(td19, file$R, 51, 8, 1169);
    			add_location(tr5, file$R, 47, 6, 1084);
    			add_location(td20, file$R, 54, 8, 1234);
    			add_location(td21, file$R, 55, 8, 1259);
    			add_location(td22, file$R, 56, 8, 1284);
    			add_location(td23, file$R, 57, 8, 1307);
    			add_location(tr6, file$R, 53, 6, 1221);
    			add_location(td24, file$R, 60, 8, 1345);
    			add_location(td25, file$R, 61, 8, 1372);
    			add_location(td26, file$R, 62, 8, 1397);
    			add_location(td27, file$R, 63, 8, 1420);
    			add_location(tr7, file$R, 59, 6, 1332);
    			add_location(td28, file$R, 66, 8, 1529);
    			add_location(td29, file$R, 67, 8, 1554);
    			add_location(td30, file$R, 68, 8, 1579);
    			add_location(td31, file$R, 69, 8, 1602);
    			add_location(tr8, file$R, 65, 6, 1516);
    			add_location(td32, file$R, 72, 8, 1694);
    			add_location(td33, file$R, 73, 8, 1720);
    			add_location(td34, file$R, 74, 8, 1744);
    			add_location(code, file$R, 75, 30, 1785);
    			add_location(td35, file$R, 75, 8, 1763);
    			add_location(tr9, file$R, 71, 6, 1681);
    			add_location(td36, file$R, 78, 8, 1869);
    			add_location(td37, file$R, 79, 8, 1892);
    			add_location(td38, file$R, 80, 8, 1923);
    			attr_dev(span0, "class", "badge badge--small");
    			attr_dev(span0, "data-type", "secondary");
    			add_location(span0, file$R, 82, 29, 1971);
    			add_location(td39, file$R, 81, 8, 1938);
    			add_location(tr10, file$R, 77, 6, 1856);
    			add_location(td40, file$R, 86, 8, 2108);
    			add_location(td41, file$R, 87, 8, 2133);
    			add_location(td42, file$R, 88, 8, 2157);
    			add_location(td43, file$R, 89, 8, 2172);
    			add_location(tr11, file$R, 85, 6, 2095);
    			add_location(td44, file$R, 92, 8, 2254);
    			add_location(td45, file$R, 93, 8, 2277);
    			add_location(td46, file$R, 94, 8, 2301);
    			add_location(td47, file$R, 95, 8, 2316);
    			add_location(tr12, file$R, 91, 6, 2241);
    			add_location(td48, file$R, 98, 8, 2354);
    			add_location(td49, file$R, 99, 8, 2381);
    			add_location(td50, file$R, 100, 8, 2410);
    			add_location(td51, file$R, 101, 8, 2425);
    			add_location(tr13, file$R, 97, 6, 2341);
    			add_location(td52, file$R, 104, 8, 2505);
    			add_location(td53, file$R, 105, 8, 2536);
    			add_location(td54, file$R, 106, 8, 2561);
    			add_location(td55, file$R, 107, 8, 2584);
    			add_location(tr14, file$R, 103, 6, 2492);
    			add_location(td56, file$R, 110, 8, 2622);
    			add_location(td57, file$R, 111, 8, 2648);
    			add_location(td58, file$R, 112, 8, 2713);
    			add_location(td59, file$R, 113, 8, 2728);
    			add_location(tr15, file$R, 109, 6, 2609);
    			attr_dev(th4, "colspan", "4");
    			add_location(th4, file$R, 116, 8, 2802);
    			add_location(tr16, file$R, 115, 6, 2789);
    			add_location(td60, file$R, 119, 8, 2860);
    			add_location(td61, file$R, 120, 8, 2887);
    			add_location(td62, file$R, 121, 8, 2911);
    			add_location(td63, file$R, 122, 8, 2926);
    			add_location(tr17, file$R, 118, 6, 2847);
    			add_location(td64, file$R, 125, 8, 2964);
    			add_location(td65, file$R, 126, 8, 2988);
    			add_location(td66, file$R, 127, 8, 3012);
    			add_location(td67, file$R, 128, 8, 3027);
    			add_location(tr18, file$R, 124, 6, 2951);
    			attr_dev(span1, "class", "badge badge--small");
    			attr_dev(span1, "data-type", "primary");
    			add_location(span1, file$R, 131, 16, 3073);
    			add_location(td68, file$R, 131, 8, 3065);
    			add_location(td69, file$R, 132, 8, 3155);
    			add_location(td70, file$R, 133, 8, 3179);
    			add_location(td71, file$R, 134, 8, 3194);
    			add_location(tr19, file$R, 130, 6, 3052);
    			add_location(td72, file$R, 137, 8, 3232);
    			add_location(td73, file$R, 138, 8, 3255);
    			add_location(td74, file$R, 139, 8, 3279);
    			add_location(td75, file$R, 140, 8, 3294);
    			add_location(tr20, file$R, 136, 6, 3219);
    			add_location(tbody, file$R, 22, 4, 546);
    			attr_dev(table, "class", "table");
    			add_location(table, file$R, 13, 2, 363);
    			add_location(h30, file$R, 151, 2, 3456);
    			add_location(h31, file$R, 161, 2, 3817);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			append_dev(tbody, t14);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td4);
    			append_dev(tr2, t16);
    			append_dev(tr2, td5);
    			append_dev(tr2, t18);
    			append_dev(tr2, td6);
    			append_dev(tr2, t19);
    			append_dev(tr2, td7);
    			append_dev(td7, t20);
    			append_dev(td7, em);
    			append_dev(tbody, t22);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td8);
    			append_dev(tr3, t24);
    			append_dev(tr3, td9);
    			append_dev(tr3, t26);
    			append_dev(tr3, td10);
    			append_dev(tr3, t27);
    			append_dev(tr3, td11);
    			append_dev(tbody, t29);
    			append_dev(tbody, tr4);
    			append_dev(tr4, td12);
    			append_dev(tr4, t31);
    			append_dev(tr4, td13);
    			append_dev(tr4, t33);
    			append_dev(tr4, td14);
    			append_dev(tr4, t35);
    			append_dev(tr4, td15);
    			append_dev(tbody, t37);
    			append_dev(tbody, tr5);
    			append_dev(tr5, td16);
    			append_dev(tr5, t39);
    			append_dev(tr5, td17);
    			append_dev(tr5, t41);
    			append_dev(tr5, td18);
    			append_dev(tr5, t43);
    			append_dev(tr5, td19);
    			append_dev(tbody, t45);
    			append_dev(tbody, tr6);
    			append_dev(tr6, td20);
    			append_dev(tr6, t47);
    			append_dev(tr6, td21);
    			append_dev(tr6, t49);
    			append_dev(tr6, td22);
    			append_dev(tr6, t51);
    			append_dev(tr6, td23);
    			append_dev(tbody, t52);
    			append_dev(tbody, tr7);
    			append_dev(tr7, td24);
    			append_dev(tr7, t54);
    			append_dev(tr7, td25);
    			append_dev(tr7, t56);
    			append_dev(tr7, td26);
    			append_dev(tr7, t58);
    			append_dev(tr7, td27);
    			append_dev(tbody, t60);
    			append_dev(tbody, tr8);
    			append_dev(tr8, td28);
    			append_dev(tr8, t62);
    			append_dev(tr8, td29);
    			append_dev(tr8, t64);
    			append_dev(tr8, td30);
    			append_dev(tr8, t66);
    			append_dev(tr8, td31);
    			append_dev(tbody, t68);
    			append_dev(tbody, tr9);
    			append_dev(tr9, td32);
    			append_dev(tr9, t70);
    			append_dev(tr9, td33);
    			append_dev(tr9, t72);
    			append_dev(tr9, td34);
    			append_dev(tr9, t74);
    			append_dev(tr9, td35);
    			append_dev(td35, t75);
    			append_dev(td35, code);
    			append_dev(td35, t77);
    			append_dev(tbody, t78);
    			append_dev(tbody, tr10);
    			append_dev(tr10, td36);
    			append_dev(tr10, t80);
    			append_dev(tr10, td37);
    			append_dev(tr10, t82);
    			append_dev(tr10, td38);
    			append_dev(tr10, t83);
    			append_dev(tr10, td39);
    			append_dev(td39, t84);
    			append_dev(td39, span0);
    			append_dev(td39, t86);
    			append_dev(tbody, t87);
    			append_dev(tbody, tr11);
    			append_dev(tr11, td40);
    			append_dev(tr11, t89);
    			append_dev(tr11, td41);
    			append_dev(tr11, t91);
    			append_dev(tr11, td42);
    			append_dev(tr11, t92);
    			append_dev(tr11, td43);
    			append_dev(tbody, t94);
    			append_dev(tbody, tr12);
    			append_dev(tr12, td44);
    			append_dev(tr12, t96);
    			append_dev(tr12, td45);
    			append_dev(tr12, t98);
    			append_dev(tr12, td46);
    			append_dev(tr12, t99);
    			append_dev(tr12, td47);
    			append_dev(tbody, t100);
    			append_dev(tbody, tr13);
    			append_dev(tr13, td48);
    			append_dev(tr13, t102);
    			append_dev(tr13, td49);
    			append_dev(tr13, t104);
    			append_dev(tr13, td50);
    			append_dev(tr13, t105);
    			append_dev(tr13, td51);
    			append_dev(tbody, t107);
    			append_dev(tbody, tr14);
    			append_dev(tr14, td52);
    			append_dev(tr14, t109);
    			append_dev(tr14, td53);
    			append_dev(tr14, t111);
    			append_dev(tr14, td54);
    			append_dev(tr14, t113);
    			append_dev(tr14, td55);
    			append_dev(tbody, t114);
    			append_dev(tbody, tr15);
    			append_dev(tr15, td56);
    			append_dev(tr15, t116);
    			append_dev(tr15, td57);
    			append_dev(tr15, t118);
    			append_dev(tr15, td58);
    			append_dev(tr15, t119);
    			append_dev(tr15, td59);
    			append_dev(tbody, t121);
    			append_dev(tbody, tr16);
    			append_dev(tr16, th4);
    			append_dev(tbody, t123);
    			append_dev(tbody, tr17);
    			append_dev(tr17, td60);
    			append_dev(tr17, t125);
    			append_dev(tr17, td61);
    			append_dev(tr17, t127);
    			append_dev(tr17, td62);
    			append_dev(tr17, t128);
    			append_dev(tr17, td63);
    			append_dev(tbody, t129);
    			append_dev(tbody, tr18);
    			append_dev(tr18, td64);
    			append_dev(tr18, t131);
    			append_dev(tr18, td65);
    			append_dev(tr18, t133);
    			append_dev(tr18, td66);
    			append_dev(tr18, t134);
    			append_dev(tr18, td67);
    			append_dev(tbody, t135);
    			append_dev(tbody, tr19);
    			append_dev(tr19, td68);
    			append_dev(td68, t136);
    			append_dev(td68, span1);
    			append_dev(tr19, t138);
    			append_dev(tr19, td69);
    			append_dev(tr19, t140);
    			append_dev(tr19, td70);
    			append_dev(tr19, t141);
    			append_dev(tr19, td71);
    			append_dev(tbody, t142);
    			append_dev(tbody, tr20);
    			append_dev(tr20, td72);
    			append_dev(tr20, t144);
    			append_dev(tr20, td73);
    			append_dev(tr20, t146);
    			append_dev(tr20, td74);
    			append_dev(tr20, t147);
    			append_dev(tr20, td75);
    			insert_dev(target, t148, anchor);
    			mount_component(articlecard0, target, anchor);
    			insert_dev(target, t149, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t150, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t152, anchor);
    			mount_component(articlecard1, target, anchor);
    			insert_dev(target, t153, anchor);
    			mount_component(articlecard2, target, anchor);
    			insert_dev(target, t154, anchor);
    			mount_component(prism2, target, anchor);
    			insert_dev(target, t155, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t157, anchor);
    			mount_component(articlecard3, target, anchor);
    			insert_dev(target, t158, anchor);
    			mount_component(articlecard4, target, anchor);
    			insert_dev(target, t159, anchor);
    			mount_component(articlecard5, target, anchor);
    			insert_dev(target, t160, anchor);
    			mount_component(prism3, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);

    			const articlecard0_changes = (dirty & /*rdmArticleData*/ 0)
    			? get_spread_update(articlecard0_spread_levels, [get_spread_object(rdmArticleData())])
    			: {};

    			articlecard0.$set(articlecard0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);

    			const articlecard1_changes = (dirty & /*rdmArticleData*/ 0)
    			? get_spread_update(articlecard1_spread_levels, [
    					articlecard1_spread_levels[0],
    					articlecard1_spread_levels[1],
    					get_spread_object(rdmArticleData(250, 120))
    				])
    			: {};

    			articlecard1.$set(articlecard1_changes);

    			const articlecard2_changes = (dirty & /*rdmArticleData*/ 0)
    			? get_spread_update(articlecard2_spread_levels, [
    					articlecard2_spread_levels[0],
    					get_spread_object(rdmArticleData(250, 120))
    				])
    			: {};

    			articlecard2.$set(articlecard2_changes);
    			const prism2_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				prism2_changes.$$scope = { dirty, ctx };
    			}

    			prism2.$set(prism2_changes);
    			const prism3_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				prism3_changes.$$scope = { dirty, ctx };
    			}

    			prism3.$set(prism3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(articlecard0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(articlecard1.$$.fragment, local);
    			transition_in(articlecard2.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			transition_in(articlecard3.$$.fragment, local);
    			transition_in(articlecard4.$$.fragment, local);
    			transition_in(articlecard5.$$.fragment, local);
    			transition_in(prism3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(articlecard0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(articlecard1.$$.fragment, local);
    			transition_out(articlecard2.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			transition_out(articlecard3.$$.fragment, local);
    			transition_out(articlecard4.$$.fragment, local);
    			transition_out(articlecard5.$$.fragment, local);
    			transition_out(prism3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    			if (detaching) detach_dev(t148);
    			destroy_component(articlecard0, detaching);
    			if (detaching) detach_dev(t149);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t150);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t152);
    			destroy_component(articlecard1, detaching);
    			if (detaching) detach_dev(t153);
    			destroy_component(articlecard2, detaching);
    			if (detaching) detach_dev(t154);
    			destroy_component(prism2, detaching);
    			if (detaching) detach_dev(t155);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t157);
    			destroy_component(articlecard3, detaching);
    			if (detaching) detach_dev(t158);
    			destroy_component(articlecard4, detaching);
    			if (detaching) detach_dev(t159);
    			destroy_component(articlecard5, detaching);
    			if (detaching) detach_dev(t160);
    			destroy_component(prism3, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(9:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (10:2) <Prism language="js">
    function create_default_slot_3$e(ctx) {
    	let t_value = `import { ArticleCard } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$e.name,
    		type: "slot",
    		source: "(10:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (148:2) <Prism language="html">
    function create_default_slot_2$k(ctx) {
    	let t_value = `<ArticleCard {...article} />` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$k.name,
    		type: "slot",
    		source: "(148:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (157:2) <Prism language="html">
    function create_default_slot_1$q(ctx) {
    	let t_value = `<ArticleCard className="small-media" {...article} />
<ArticleCard className="small-media--reverse" {...article} />` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$q.name,
    		type: "slot",
    		source: "(157:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (168:2) <Prism language="html">
    function create_default_slot$x(ctx) {
    	let t_value = `<ArticleCard loading={true} colorName="graa7" />
<ArticleCard loading={true} cardType="small-media" colorName="graa7" />
<ArticleCard loading={true} cardType="small-media--reverse" colorName="graa7" />` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$x.name,
    		type: "slot",
    		source: "(168:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$R(ctx) {
    	let h1;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$f, create_else_block$e];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Article Card";
    			t1 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$R, 6, 0, 186);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ArticleCard', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArticleCard> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		ArticleCard,
    		rdmArticleData,
    		sourceType,
    		$sourceType
    	});

    	return [$sourceType];
    }

    class ArticleCard_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$R, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ArticleCard_1",
    			options,
    			id: create_fragment$R.name
    		});
    	}
    }

    /* docs_src/components/ArticleList.svelte generated by Svelte v3.53.1 */
    const file$Q = "docs_src/components/ArticleList.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    function get_each_context_3$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    function get_each_context_5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (44:4) {#each $articles as article}
    function create_each_block_5(ctx) {
    	let articlecard;
    	let current;
    	const articlecard_spread_levels = [/*article*/ ctx[9], { width: "240px" }, { truncateTitle: true }];
    	let articlecard_props = {};

    	for (let i = 0; i < articlecard_spread_levels.length; i += 1) {
    		articlecard_props = assign(articlecard_props, articlecard_spread_levels[i]);
    	}

    	articlecard = new ArticleCard({ props: articlecard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(articlecard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(articlecard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const articlecard_changes = (dirty & /*$articles*/ 1)
    			? get_spread_update(articlecard_spread_levels, [
    					get_spread_object(/*article*/ ctx[9]),
    					articlecard_spread_levels[1],
    					articlecard_spread_levels[2]
    				])
    			: {};

    			articlecard.$set(articlecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(articlecard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5.name,
    		type: "each",
    		source: "(44:4) {#each $articles as article}",
    		ctx
    	});

    	return block;
    }

    // (43:2) <ArticleList>
    function create_default_slot_5$b(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_5 = /*$articles*/ ctx[0];
    	validate_each_argument(each_value_5);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$articles*/ 1) {
    				each_value_5 = /*$articles*/ ctx[0];
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5(ctx, each_value_5, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_5.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_5.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$b.name,
    		type: "slot",
    		source: "(43:2) <ArticleList>",
    		ctx
    	});

    	return block;
    }

    // (52:4) {#each singleArt as article}
    function create_each_block_4(ctx) {
    	let articlecard;
    	let current;
    	const articlecard_spread_levels = [/*article*/ ctx[9], { width: "240px" }, { truncateTitle: true }];
    	let articlecard_props = {};

    	for (let i = 0; i < articlecard_spread_levels.length; i += 1) {
    		articlecard_props = assign(articlecard_props, articlecard_spread_levels[i]);
    	}

    	articlecard = new ArticleCard({ props: articlecard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(articlecard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(articlecard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const articlecard_changes = (dirty & /*singleArt*/ 2)
    			? get_spread_update(articlecard_spread_levels, [
    					get_spread_object(/*article*/ ctx[9]),
    					articlecard_spread_levels[1],
    					articlecard_spread_levels[2]
    				])
    			: {};

    			articlecard.$set(articlecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(articlecard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(52:4) {#each singleArt as article}",
    		ctx
    	});

    	return block;
    }

    // (51:2) <ArticleList>
    function create_default_slot_4$c(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_4 = /*singleArt*/ ctx[1];
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*singleArt*/ 2) {
    				each_value_4 = /*singleArt*/ ctx[1];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_4.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_4.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$c.name,
    		type: "slot",
    		source: "(51:2) <ArticleList>",
    		ctx
    	});

    	return block;
    }

    // (58:5) {#each doubleArt as article}
    function create_each_block_3$1(ctx) {
    	let articlecard;
    	let current;
    	const articlecard_spread_levels = [/*article*/ ctx[9], { width: "240px" }, { truncateTitle: true }];
    	let articlecard_props = {};

    	for (let i = 0; i < articlecard_spread_levels.length; i += 1) {
    		articlecard_props = assign(articlecard_props, articlecard_spread_levels[i]);
    	}

    	articlecard = new ArticleCard({ props: articlecard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(articlecard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(articlecard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const articlecard_changes = (dirty & /*doubleArt*/ 4)
    			? get_spread_update(articlecard_spread_levels, [
    					get_spread_object(/*article*/ ctx[9]),
    					articlecard_spread_levels[1],
    					articlecard_spread_levels[2]
    				])
    			: {};

    			articlecard.$set(articlecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(articlecard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$1.name,
    		type: "each",
    		source: "(58:5) {#each doubleArt as article}",
    		ctx
    	});

    	return block;
    }

    // (57:2) <ArticleList     >
    function create_default_slot_3$d(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_3 = /*doubleArt*/ ctx[2];
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*doubleArt*/ 4) {
    				each_value_3 = /*doubleArt*/ ctx[2];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$d.name,
    		type: "slot",
    		source: "(57:2) <ArticleList     >",
    		ctx
    	});

    	return block;
    }

    // (64:5) {#each threeArt as article}
    function create_each_block_2$2(ctx) {
    	let articlecard;
    	let current;
    	const articlecard_spread_levels = [/*article*/ ctx[9], { width: "240px" }, { truncateTitle: true }];
    	let articlecard_props = {};

    	for (let i = 0; i < articlecard_spread_levels.length; i += 1) {
    		articlecard_props = assign(articlecard_props, articlecard_spread_levels[i]);
    	}

    	articlecard = new ArticleCard({ props: articlecard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(articlecard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(articlecard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const articlecard_changes = (dirty & /*threeArt*/ 8)
    			? get_spread_update(articlecard_spread_levels, [
    					get_spread_object(/*article*/ ctx[9]),
    					articlecard_spread_levels[1],
    					articlecard_spread_levels[2]
    				])
    			: {};

    			articlecard.$set(articlecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(articlecard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$2.name,
    		type: "each",
    		source: "(64:5) {#each threeArt as article}",
    		ctx
    	});

    	return block;
    }

    // (63:2) <ArticleList     >
    function create_default_slot_2$j(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_2 = /*threeArt*/ ctx[3];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*threeArt*/ 8) {
    				each_value_2 = /*threeArt*/ ctx[3];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$j.name,
    		type: "slot",
    		source: "(63:2) <ArticleList     >",
    		ctx
    	});

    	return block;
    }

    // (70:5) {#each fourArt as article}
    function create_each_block_1$3(ctx) {
    	let div;
    	let articlecard;
    	let t;
    	let current;
    	const articlecard_spread_levels = [/*article*/ ctx[9], { width: "240px" }, { truncateTitle: false }];
    	let articlecard_props = {};

    	for (let i = 0; i < articlecard_spread_levels.length; i += 1) {
    		articlecard_props = assign(articlecard_props, articlecard_spread_levels[i]);
    	}

    	articlecard = new ArticleCard({ props: articlecard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(articlecard.$$.fragment);
    			t = space();
    			add_location(div, file$Q, 70, 6, 2144);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(articlecard, div, null);
    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const articlecard_changes = (dirty & /*fourArt*/ 16)
    			? get_spread_update(articlecard_spread_levels, [
    					get_spread_object(/*article*/ ctx[9]),
    					articlecard_spread_levels[1],
    					articlecard_spread_levels[2]
    				])
    			: {};

    			articlecard.$set(articlecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(articlecard);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(70:5) {#each fourArt as article}",
    		ctx
    	});

    	return block;
    }

    // (69:2) <ArticleList     >
    function create_default_slot_1$p(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*fourArt*/ ctx[4];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fourArt*/ 16) {
    				each_value_1 = /*fourArt*/ ctx[4];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$p.name,
    		type: "slot",
    		source: "(69:2) <ArticleList     >",
    		ctx
    	});

    	return block;
    }

    // (78:5) {#each fiveArt as article}
    function create_each_block$8(ctx) {
    	let articlecard;
    	let current;
    	const articlecard_spread_levels = [/*article*/ ctx[9], { width: "240px" }, { truncateTitle: true }];
    	let articlecard_props = {};

    	for (let i = 0; i < articlecard_spread_levels.length; i += 1) {
    		articlecard_props = assign(articlecard_props, articlecard_spread_levels[i]);
    	}

    	articlecard = new ArticleCard({ props: articlecard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(articlecard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(articlecard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const articlecard_changes = (dirty & /*fiveArt*/ 32)
    			? get_spread_update(articlecard_spread_levels, [
    					get_spread_object(/*article*/ ctx[9]),
    					articlecard_spread_levels[1],
    					articlecard_spread_levels[2]
    				])
    			: {};

    			articlecard.$set(articlecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(articlecard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(78:5) {#each fiveArt as article}",
    		ctx
    	});

    	return block;
    }

    // (77:2) <ArticleList     >
    function create_default_slot$w(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*fiveArt*/ ctx[5];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fiveArt*/ 32) {
    				each_value = /*fiveArt*/ ctx[5];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$w.name,
    		type: "slot",
    		source: "(77:2) <ArticleList     >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Q(ctx) {
    	let div;
    	let h1;
    	let t1;
    	let p0;
    	let t3;
    	let p1;
    	let t5;
    	let t6_value = /*$articles*/ ctx[0].length + "";
    	let t6;
    	let t7;
    	let articlelist0;
    	let t8;
    	let h3;
    	let t10;
    	let h40;
    	let t12;
    	let articlelist1;
    	let t13;
    	let h41;
    	let t15;
    	let articlelist2;
    	let t16;
    	let h42;
    	let t18;
    	let articlelist3;
    	let t19;
    	let h43;
    	let t21;
    	let articlelist4;
    	let t22;
    	let h44;
    	let t24;
    	let articlelist5;
    	let current;

    	articlelist0 = new ArticleList({
    			props: {
    				$$slots: { default: [create_default_slot_5$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	articlelist1 = new ArticleList({
    			props: {
    				$$slots: { default: [create_default_slot_4$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	articlelist2 = new ArticleList({
    			props: {
    				$$slots: { default: [create_default_slot_3$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	articlelist3 = new ArticleList({
    			props: {
    				$$slots: { default: [create_default_slot_2$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	articlelist4 = new ArticleList({
    			props: {
    				$$slots: { default: [create_default_slot_1$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	articlelist5 = new ArticleList({
    			props: {
    				$$slots: { default: [create_default_slot$w] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			h1 = element("h1");
    			h1.textContent = "Article list";
    			t1 = space();
    			p0 = element("p");
    			p0.textContent = "The idea of the article list component, is that it can act based on the amount of articles added to the view.";
    			t3 = space();
    			p1 = element("p");
    			p1.textContent = "Currently it makes the most sense when using HorizontalScroll";
    			t5 = text("\n  Updating articles in list - Items in list: ");
    			t6 = text(t6_value);
    			t7 = space();
    			create_component(articlelist0.$$.fragment);
    			t8 = space();
    			h3 = element("h3");
    			h3.textContent = "Different amounts of items in list";
    			t10 = space();
    			h40 = element("h4");
    			h40.textContent = "1";
    			t12 = space();
    			create_component(articlelist1.$$.fragment);
    			t13 = space();
    			h41 = element("h4");
    			h41.textContent = "2";
    			t15 = space();
    			create_component(articlelist2.$$.fragment);
    			t16 = space();
    			h42 = element("h4");
    			h42.textContent = "3";
    			t18 = space();
    			create_component(articlelist3.$$.fragment);
    			t19 = space();
    			h43 = element("h4");
    			h43.textContent = "4";
    			t21 = space();
    			create_component(articlelist4.$$.fragment);
    			t22 = space();
    			h44 = element("h4");
    			h44.textContent = "5";
    			t24 = space();
    			create_component(articlelist5.$$.fragment);
    			add_location(h1, file$Q, 37, 2, 1124);
    			add_location(p0, file$Q, 38, 2, 1148);
    			add_location(p1, file$Q, 39, 2, 1267);
    			add_location(h3, file$Q, 48, 2, 1552);
    			add_location(h40, file$Q, 49, 2, 1598);
    			add_location(h41, file$Q, 55, 2, 1759);
    			add_location(h42, file$Q, 61, 2, 1920);
    			add_location(h43, file$Q, 67, 2, 2080);
    			add_location(h44, file$Q, 75, 2, 2267);
    			attr_dev(div, "class", "grid-width--xlarge");
    			set_style(div, "overflow", "hidden");
    			add_location(div, file$Q, 36, 0, 1064);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h1);
    			append_dev(div, t1);
    			append_dev(div, p0);
    			append_dev(div, t3);
    			append_dev(div, p1);
    			append_dev(div, t5);
    			append_dev(div, t6);
    			append_dev(div, t7);
    			mount_component(articlelist0, div, null);
    			append_dev(div, t8);
    			append_dev(div, h3);
    			append_dev(div, t10);
    			append_dev(div, h40);
    			append_dev(div, t12);
    			mount_component(articlelist1, div, null);
    			append_dev(div, t13);
    			append_dev(div, h41);
    			append_dev(div, t15);
    			mount_component(articlelist2, div, null);
    			append_dev(div, t16);
    			append_dev(div, h42);
    			append_dev(div, t18);
    			mount_component(articlelist3, div, null);
    			append_dev(div, t19);
    			append_dev(div, h43);
    			append_dev(div, t21);
    			mount_component(articlelist4, div, null);
    			append_dev(div, t22);
    			append_dev(div, h44);
    			append_dev(div, t24);
    			mount_component(articlelist5, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$articles*/ 1) && t6_value !== (t6_value = /*$articles*/ ctx[0].length + "")) set_data_dev(t6, t6_value);
    			const articlelist0_changes = {};

    			if (dirty & /*$$scope, $articles*/ 4194305) {
    				articlelist0_changes.$$scope = { dirty, ctx };
    			}

    			articlelist0.$set(articlelist0_changes);
    			const articlelist1_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				articlelist1_changes.$$scope = { dirty, ctx };
    			}

    			articlelist1.$set(articlelist1_changes);
    			const articlelist2_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				articlelist2_changes.$$scope = { dirty, ctx };
    			}

    			articlelist2.$set(articlelist2_changes);
    			const articlelist3_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				articlelist3_changes.$$scope = { dirty, ctx };
    			}

    			articlelist3.$set(articlelist3_changes);
    			const articlelist4_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				articlelist4_changes.$$scope = { dirty, ctx };
    			}

    			articlelist4.$set(articlelist4_changes);
    			const articlelist5_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				articlelist5_changes.$$scope = { dirty, ctx };
    			}

    			articlelist5.$set(articlelist5_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlelist0.$$.fragment, local);
    			transition_in(articlelist1.$$.fragment, local);
    			transition_in(articlelist2.$$.fragment, local);
    			transition_in(articlelist3.$$.fragment, local);
    			transition_in(articlelist4.$$.fragment, local);
    			transition_in(articlelist5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlelist0.$$.fragment, local);
    			transition_out(articlelist1.$$.fragment, local);
    			transition_out(articlelist2.$$.fragment, local);
    			transition_out(articlelist3.$$.fragment, local);
    			transition_out(articlelist4.$$.fragment, local);
    			transition_out(articlelist5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(articlelist0);
    			destroy_component(articlelist1);
    			destroy_component(articlelist2);
    			destroy_component(articlelist3);
    			destroy_component(articlelist4);
    			destroy_component(articlelist5);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$2 = 11;

    function instance$P($$self, $$props, $$invalidate) {
    	let $articles;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ArticleList', slots, []);
    	const singleArt = [rdmArticleData(640, 360)];
    	const doubleArt = [rdmArticleData(640, 360), rdmArticleData(640, 360)];
    	const threeArt = [rdmArticleData(640, 360), rdmArticleData(640, 360), rdmArticleData(640, 360)];

    	const fourArt = [
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360)
    	];

    	const fiveArt = [
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360)
    	];

    	const articles = writable([rdmArticleData(640, 360)]);
    	validate_store(articles, 'articles');
    	component_subscribe($$self, articles, value => $$invalidate(0, $articles = value));
    	let count = $articles.length;

    	const addingInterval = setInterval(
    		() => {
    			if (count < max$2) {
    				articles.update(art => {
    					art.push(rdmArticleData(640, 360));
    					return art;
    				});
    			} else {
    				clearInterval(addingInterval);
    			}

    			count++;
    		},
    		3000
    	);

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArticleList> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		writable,
    		ArticleCard,
    		ArticleList,
    		rdmArticleData,
    		singleArt,
    		doubleArt,
    		threeArt,
    		fourArt,
    		fiveArt,
    		articles,
    		max: max$2,
    		count,
    		addingInterval,
    		$articles
    	});

    	$$self.$inject_state = $$props => {
    		if ('count' in $$props) count = $$props.count;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$articles, singleArt, doubleArt, threeArt, fourArt, fiveArt, articles];
    }

    class ArticleList_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$Q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ArticleList_1",
    			options,
    			id: create_fragment$Q.name
    		});
    	}
    }

    /* docs_src/components/Badge.svelte generated by Svelte v3.53.1 */
    const file$P = "docs_src/components/Badge.svelte";

    // (10:0) {:else}
    function create_else_block$d(ctx) {
    	let p;
    	let t1;
    	let h30;
    	let t3;
    	let div0;
    	let span0;
    	let t5;
    	let prism0;
    	let t6;
    	let h31;
    	let t8;
    	let div1;
    	let span1;
    	let t10;
    	let span2;
    	let t12;
    	let span3;
    	let t14;
    	let span4;
    	let t16;
    	let prism1;
    	let t17;
    	let h32;
    	let t19;
    	let div2;
    	let span5;
    	let t21;
    	let span6;
    	let t23;
    	let span7;
    	let t25;
    	let prism2;
    	let t26;
    	let h33;
    	let t28;
    	let div3;
    	let span8;
    	let icon;
    	let t29;
    	let t30;
    	let prism3;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_3$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	icon = new Icon$1({
    			props: {
    				name: "lightning",
    				className: "bg--white color--flash border-radius-s padding-s margin-s--r",
    				style: "margin-left: -1px;",
    				width: "15"
    			},
    			$$inline: true
    		});

    	prism3 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$v] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Badges are used as tags. The size can be set through font-size.";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Default";
    			t3 = space();
    			div0 = element("div");
    			span0 = element("span");
    			span0.textContent = "Badge";
    			t5 = space();
    			create_component(prism0.$$.fragment);
    			t6 = space();
    			h31 = element("h3");
    			h31.textContent = "Variations";
    			t8 = space();
    			div1 = element("div");
    			span1 = element("span");
    			span1.textContent = "Primary";
    			t10 = space();
    			span2 = element("span");
    			span2.textContent = "Secondary";
    			t12 = space();
    			span3 = element("span");
    			span3.textContent = "Success";
    			t14 = space();
    			span4 = element("span");
    			span4.textContent = "Danger";
    			t16 = space();
    			create_component(prism1.$$.fragment);
    			t17 = space();
    			h32 = element("h3");
    			h32.textContent = "Color examples from eb-colors";
    			t19 = space();
    			div2 = element("div");
    			span5 = element("span");
    			span5.textContent = "bg-bluedark";
    			t21 = space();
    			span6 = element("span");
    			span6.textContent = "bg-green";
    			t23 = space();
    			span7 = element("span");
    			span7.textContent = "bg-greendark";
    			t25 = space();
    			create_component(prism2.$$.fragment);
    			t26 = space();
    			h33 = element("h3");
    			h33.textContent = "Advanced examples";
    			t28 = space();
    			div3 = element("div");
    			span8 = element("span");
    			create_component(icon.$$.fragment);
    			t29 = text("\n      UPDATE");
    			t30 = space();
    			create_component(prism3.$$.fragment);
    			add_location(p, file$P, 10, 2, 259);
    			add_location(h30, file$P, 12, 2, 333);
    			attr_dev(span0, "class", "badge");
    			add_location(span0, file$P, 15, 4, 376);
    			attr_dev(div0, "class", "flex");
    			add_location(div0, file$P, 14, 2, 353);
    			add_location(h31, file$P, 22, 2, 495);
    			attr_dev(span1, "class", "badge margin-s");
    			attr_dev(span1, "data-type", "primary");
    			add_location(span1, file$P, 25, 4, 541);
    			attr_dev(span2, "class", "badge margin-s");
    			attr_dev(span2, "data-type", "secondary");
    			add_location(span2, file$P, 26, 4, 609);
    			attr_dev(span3, "class", "badge margin-s");
    			attr_dev(span3, "data-type", "success");
    			add_location(span3, file$P, 27, 4, 681);
    			attr_dev(span4, "class", "badge margin-s");
    			attr_dev(span4, "data-type", "danger");
    			add_location(span4, file$P, 28, 4, 749);
    			attr_dev(div1, "class", "flex");
    			add_location(div1, file$P, 24, 2, 518);
    			add_location(h32, file$P, 38, 2, 1062);
    			attr_dev(span5, "class", "badge bg--bluedark margin-s");
    			add_location(span5, file$P, 41, 4, 1127);
    			attr_dev(span6, "class", "badge bg--green margin-s");
    			add_location(span6, file$P, 42, 4, 1192);
    			attr_dev(span7, "class", "badge bg--greendark margin-s");
    			add_location(span7, file$P, 43, 4, 1251);
    			attr_dev(div2, "class", "flex");
    			add_location(div2, file$P, 40, 2, 1104);
    			add_location(h33, file$P, 52, 2, 1493);
    			attr_dev(span8, "class", "badge margin-s padding-none padding-s--r card--shadow bg--black fontsize-small");
    			add_location(span8, file$P, 55, 4, 1546);
    			attr_dev(div3, "class", "flex");
    			add_location(div3, file$P, 54, 2, 1523);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div0, anchor);
    			append_dev(div0, span0);
    			insert_dev(target, t5, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span1);
    			append_dev(div1, t10);
    			append_dev(div1, span2);
    			append_dev(div1, t12);
    			append_dev(div1, span3);
    			append_dev(div1, t14);
    			append_dev(div1, span4);
    			insert_dev(target, t16, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t19, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, span5);
    			append_dev(div2, t21);
    			append_dev(div2, span6);
    			append_dev(div2, t23);
    			append_dev(div2, span7);
    			insert_dev(target, t25, anchor);
    			mount_component(prism2, target, anchor);
    			insert_dev(target, t26, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t28, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, span8);
    			mount_component(icon, span8, null);
    			append_dev(span8, t29);
    			insert_dev(target, t30, anchor);
    			mount_component(prism3, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			transition_in(icon.$$.fragment, local);
    			transition_in(prism3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			transition_out(icon.$$.fragment, local);
    			transition_out(prism3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t5);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t16);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t19);
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t25);
    			destroy_component(prism2, detaching);
    			if (detaching) detach_dev(t26);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t28);
    			if (detaching) detach_dev(div3);
    			destroy_component(icon);
    			if (detaching) detach_dev(t30);
    			destroy_component(prism3, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$d.name,
    		type: "else",
    		source: "(10:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (8:0) {#if $sourceType === 'svelte'}
    function create_if_block$e(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Only valid as a HTML-standard element";
    			add_location(p, file$P, 8, 2, 204);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(8:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (19:2) <Prism language="html">
    function create_default_slot_3$c(ctx) {
    	let t_value = `<span class="badge"></span>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$c.name,
    		type: "slot",
    		source: "(19:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (32:2) <Prism language="html">
    function create_default_slot_2$i(ctx) {
    	let t_value = `<span class="badge" data-type="primary"></span>
<span class="badge" data-type="secondary"></span>
<span class="badge" data-type="success"></span>
<span class="badge" data-type="danger"></span>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$i.name,
    		type: "slot",
    		source: "(32:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (47:2) <Prism language="html">
    function create_default_slot_1$o(ctx) {
    	let t_value = `<span class="badge bg--bluedark"></span>
<span class="badge bg--green"></span>
<span class="badge bg--greendark"></span>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$o.name,
    		type: "slot",
    		source: "(47:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (67:2) <Prism language="html">
    function create_default_slot$v(ctx) {
    	let t_value = `<span class="badge margin-s padding-none padding-s--r card--shadow bg--black fontsize-small">
  <svg viewBox="0 0 10 16"
    className="icon-svg bg--white color--flash border-radius-s padding-s margin-s--r"
    style="margin-left: -1px; width: 15px; height: 15px;"/>
    <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#lightning"></use>
  </svg>
  UPDATE
</span>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$v.name,
    		type: "slot",
    		source: "(67:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$P(ctx) {
    	let h1;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$e, create_else_block$d];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Badge";
    			t1 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$P, 5, 0, 137);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Badge', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Badge> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1, sourceType, Icon: Icon$1, $sourceType });
    	return [$sourceType];
    }

    class Badge extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$P, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Badge",
    			options,
    			id: create_fragment$P.name
    		});
    	}
    }

    /* docs_src/components/Button.svelte generated by Svelte v3.53.1 */
    const file$O = "docs_src/components/Button.svelte";

    // (8:0) {#if $sourceType === 'svelte'}
    function create_if_block_5$1(ctx) {
    	let prism;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t13;
    	let td3;
    	let t14;
    	let tr2;
    	let td4;
    	let t16;
    	let td5;
    	let t18;
    	let td6;
    	let t20;
    	let td7;
    	let t21;
    	let tr3;
    	let td8;
    	let t23;
    	let td9;
    	let t25;
    	let td10;
    	let t26;
    	let td11;
    	let t27;
    	let tr4;
    	let td12;
    	let t29;
    	let td13;
    	let t31;
    	let td14;
    	let t32;
    	let td15;
    	let t34;
    	let tr5;
    	let td16;
    	let t36;
    	let td17;
    	let t38;
    	let td18;
    	let t39;
    	let td19;
    	let t40;
    	let tr6;
    	let td20;
    	let t42;
    	let td21;
    	let t44;
    	let td22;
    	let t45;
    	let td23;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_22$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "className";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "string";
    			t12 = space();
    			td2 = element("td");
    			t13 = space();
    			td3 = element("td");
    			t14 = space();
    			tr2 = element("tr");
    			td4 = element("td");
    			td4.textContent = "disabled";
    			t16 = space();
    			td5 = element("td");
    			td5.textContent = "boolean";
    			t18 = space();
    			td6 = element("td");
    			td6.textContent = "false";
    			t20 = space();
    			td7 = element("td");
    			t21 = space();
    			tr3 = element("tr");
    			td8 = element("td");
    			td8.textContent = "extension";
    			t23 = space();
    			td9 = element("td");
    			td9.textContent = "'icon' | 'link' | 'solid' | 'icon link' | 'icon solid'";
    			t25 = space();
    			td10 = element("td");
    			t26 = space();
    			td11 = element("td");
    			t27 = space();
    			tr4 = element("tr");
    			td12 = element("td");
    			td12.textContent = "href";
    			t29 = space();
    			td13 = element("td");
    			td13.textContent = "string";
    			t31 = space();
    			td14 = element("td");
    			t32 = space();
    			td15 = element("td");
    			td15.textContent = "Coverts the Button into a clickable link";
    			t34 = space();
    			tr5 = element("tr");
    			td16 = element("td");
    			td16.textContent = "size";
    			t36 = space();
    			td17 = element("td");
    			td17.textContent = "'big' | 'small'";
    			t38 = space();
    			td18 = element("td");
    			t39 = space();
    			td19 = element("td");
    			t40 = space();
    			tr6 = element("tr");
    			td20 = element("td");
    			td20.textContent = "type";
    			t42 = space();
    			td21 = element("td");
    			td21.textContent = "'accept' | 'cancel' | 'primary' | 'secondary'";
    			t44 = space();
    			td22 = element("td");
    			t45 = space();
    			td23 = element("td");
    			add_location(th0, file$O, 15, 8, 365);
    			add_location(th1, file$O, 16, 8, 392);
    			add_location(th2, file$O, 17, 8, 414);
    			add_location(th3, file$O, 18, 8, 445);
    			add_location(tr0, file$O, 14, 6, 352);
    			add_location(thead, file$O, 13, 4, 338);
    			add_location(td0, file$O, 23, 8, 522);
    			add_location(td1, file$O, 24, 8, 549);
    			add_location(td2, file$O, 25, 8, 573);
    			add_location(td3, file$O, 26, 8, 588);
    			add_location(tr1, file$O, 22, 6, 509);
    			add_location(td4, file$O, 29, 8, 626);
    			add_location(td5, file$O, 30, 8, 652);
    			add_location(td6, file$O, 31, 8, 677);
    			add_location(td7, file$O, 32, 8, 700);
    			add_location(tr2, file$O, 28, 6, 613);
    			add_location(td8, file$O, 35, 8, 738);
    			add_location(td9, file$O, 36, 8, 765);
    			add_location(td10, file$O, 37, 8, 837);
    			add_location(td11, file$O, 38, 8, 852);
    			add_location(tr3, file$O, 34, 6, 725);
    			add_location(td12, file$O, 41, 8, 890);
    			add_location(td13, file$O, 42, 8, 912);
    			add_location(td14, file$O, 43, 8, 936);
    			add_location(td15, file$O, 44, 8, 951);
    			add_location(tr4, file$O, 40, 6, 877);
    			add_location(td16, file$O, 47, 8, 1032);
    			add_location(td17, file$O, 48, 8, 1054);
    			add_location(td18, file$O, 49, 8, 1087);
    			add_location(td19, file$O, 50, 8, 1102);
    			add_location(tr5, file$O, 46, 6, 1019);
    			add_location(td20, file$O, 53, 8, 1140);
    			add_location(td21, file$O, 54, 8, 1162);
    			add_location(td22, file$O, 55, 8, 1225);
    			add_location(td23, file$O, 56, 8, 1240);
    			add_location(tr6, file$O, 52, 6, 1127);
    			add_location(tbody, file$O, 21, 4, 495);
    			attr_dev(table, "class", "table");
    			add_location(table, file$O, 12, 2, 312);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			append_dev(tbody, t14);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td4);
    			append_dev(tr2, t16);
    			append_dev(tr2, td5);
    			append_dev(tr2, t18);
    			append_dev(tr2, td6);
    			append_dev(tr2, t20);
    			append_dev(tr2, td7);
    			append_dev(tbody, t21);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td8);
    			append_dev(tr3, t23);
    			append_dev(tr3, td9);
    			append_dev(tr3, t25);
    			append_dev(tr3, td10);
    			append_dev(tr3, t26);
    			append_dev(tr3, td11);
    			append_dev(tbody, t27);
    			append_dev(tbody, tr4);
    			append_dev(tr4, td12);
    			append_dev(tr4, t29);
    			append_dev(tr4, td13);
    			append_dev(tr4, t31);
    			append_dev(tr4, td14);
    			append_dev(tr4, t32);
    			append_dev(tr4, td15);
    			append_dev(tbody, t34);
    			append_dev(tbody, tr5);
    			append_dev(tr5, td16);
    			append_dev(tr5, t36);
    			append_dev(tr5, td17);
    			append_dev(tr5, t38);
    			append_dev(tr5, td18);
    			append_dev(tr5, t39);
    			append_dev(tr5, td19);
    			append_dev(tbody, t40);
    			append_dev(tbody, tr6);
    			append_dev(tr6, td20);
    			append_dev(tr6, t42);
    			append_dev(tr6, td21);
    			append_dev(tr6, t44);
    			append_dev(tr6, td22);
    			append_dev(tr6, t45);
    			append_dev(tr6, td23);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(8:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (9:2) <Prism language="js">
    function create_default_slot_22$1(ctx) {
    	let t_value = `import { Button } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$1.name,
    		type: "slot",
    		source: "(9:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (65:0) <Button>
    function create_default_slot_21$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$1.name,
    		type: "slot",
    		source: "(65:0) <Button>",
    		ctx
    	});

    	return block;
    }

    // (71:0) {:else}
    function create_else_block_4$1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_20$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4$1.name,
    		type: "else",
    		source: "(71:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (67:0) {#if $sourceType === 'svelte'}
    function create_if_block_4$3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_19$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(67:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (72:2) <Prism language="html">
    function create_default_slot_20$1(ctx) {
    	let t_value = `<button class="button"></button>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$1.name,
    		type: "slot",
    		source: "(72:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (68:2) <Prism language="html">
    function create_default_slot_19$1(ctx) {
    	let t_value = `<Button></Button>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$1.name,
    		type: "slot",
    		source: "(68:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (79:0) <Button className="margin-m" extension="solid">
    function create_default_slot_18$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Solid");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$2.name,
    		type: "slot",
    		source: "(79:0) <Button className=\\\"margin-m\\\" extension=\\\"solid\\\">",
    		ctx
    	});

    	return block;
    }

    // (80:0) <Button className="margin-m" extension="link">
    function create_default_slot_17$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Link");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$2.name,
    		type: "slot",
    		source: "(80:0) <Button className=\\\"margin-m\\\" extension=\\\"link\\\">",
    		ctx
    	});

    	return block;
    }

    // (81:0) <Button className="margin-m" extension="icon">
    function create_default_slot_16$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "";
    			set_style(span, "font-size", "30px");
    			add_location(span, file$O, 81, 2, 1721);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$2.name,
    		type: "slot",
    		source: "(81:0) <Button className=\\\"margin-m\\\" extension=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (93:0) {:else}
    function create_else_block_3$3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_15$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3$3.name,
    		type: "else",
    		source: "(93:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (85:0) {#if $sourceType === 'svelte'}
    function create_if_block_3$3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_14$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(85:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (94:2) <Prism language="html">
    function create_default_slot_15$2(ctx) {
    	let t_value = `<button class="button button--solid"></button>
<button class="button button--link"></button>
<button class="button button--icon">
  <span style="font-size: 30px;">&times;</span>
</button>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$2.name,
    		type: "slot",
    		source: "(94:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (86:2) <Prism language="html">
    function create_default_slot_14$2(ctx) {
    	let t_value = `<Button extension="solid"></Button>
<Button extension="link"></Button>
<Button extension="icon">
  <span style="font-size: 30px">&times;</span>
</Button>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$2.name,
    		type: "slot",
    		source: "(86:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (106:0) <Button className="margin-m" size="big">
    function create_default_slot_13$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Big");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$2.name,
    		type: "slot",
    		source: "(106:0) <Button className=\\\"margin-m\\\" size=\\\"big\\\">",
    		ctx
    	});

    	return block;
    }

    // (107:0) <Button className="margin-m" size="small">
    function create_default_slot_12$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Small");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$2.name,
    		type: "slot",
    		source: "(107:0) <Button className=\\\"margin-m\\\" size=\\\"small\\\">",
    		ctx
    	});

    	return block;
    }

    // (114:0) {:else}
    function create_else_block_2$3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_11$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$3.name,
    		type: "else",
    		source: "(114:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (109:0) {#if $sourceType === 'svelte'}
    function create_if_block_2$4(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_10$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(109:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (115:2) <Prism language="html">
    function create_default_slot_11$3(ctx) {
    	let t_value = `<button class="button button--big"></button>
<button class="button button--small"></button>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$3.name,
    		type: "slot",
    		source: "(115:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (110:2) <Prism language="html">
    function create_default_slot_10$3(ctx) {
    	let t_value = `<Button size="big"></Button>
<Button size="small"></Button>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$3.name,
    		type: "slot",
    		source: "(110:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (123:0) <Button className="margin-m" type="primary">
    function create_default_slot_9$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Primary");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$4.name,
    		type: "slot",
    		source: "(123:0) <Button className=\\\"margin-m\\\" type=\\\"primary\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:0) <Button className="margin-m" type="secondary">
    function create_default_slot_8$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Secondary");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$7.name,
    		type: "slot",
    		source: "(124:0) <Button className=\\\"margin-m\\\" type=\\\"secondary\\\">",
    		ctx
    	});

    	return block;
    }

    // (125:0) <Button className="margin-m" type="accept">
    function create_default_slot_7$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Accept");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$8.name,
    		type: "slot",
    		source: "(125:0) <Button className=\\\"margin-m\\\" type=\\\"accept\\\">",
    		ctx
    	});

    	return block;
    }

    // (126:0) <Button className="margin-m" type="cancel">
    function create_default_slot_6$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Cancel");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$9.name,
    		type: "slot",
    		source: "(126:0) <Button className=\\\"margin-m\\\" type=\\\"cancel\\\">",
    		ctx
    	});

    	return block;
    }

    // (135:0) {:else}
    function create_else_block_1$5(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_5$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$5.name,
    		type: "else",
    		source: "(135:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (128:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$7(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_4$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(128:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (136:2) <Prism language="html">
    function create_default_slot_5$a(ctx) {
    	let t_value = `<button class="button button--primary"></button>
<button class="button button--secondary"></button>
<button class="button button--accept"></button>
<button class="button button--cancel"></button>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$a.name,
    		type: "slot",
    		source: "(136:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (129:2) <Prism language="html">
    function create_default_slot_4$b(ctx) {
    	let t_value = `<Button type="primary"></Button>
<Button type="secondary"></Button>
<Button type="accept"></Button>
<Button type="cancel"></Button>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$b.name,
    		type: "slot",
    		source: "(129:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (146:0) <Button className="margin-m">
    function create_default_slot_3$b(ctx) {
    	let span;
    	let t1;
    	let icon;
    	let current;

    	icon = new Icon$1({
    			props: {
    				className: "icon",
    				name: "angle-right",
    				width: "20"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Icon to the right";
    			t1 = space();
    			create_component(icon.$$.fragment);
    			add_location(span, file$O, 146, 2, 3544);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t1);
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$b.name,
    		type: "slot",
    		source: "(146:0) <Button className=\\\"margin-m\\\">",
    		ctx
    	});

    	return block;
    }

    // (150:0) <Button className="margin-m">
    function create_default_slot_2$h(ctx) {
    	let icon;
    	let t0;
    	let span;
    	let current;

    	icon = new Icon$1({
    			props: {
    				className: "icon",
    				name: "angle-left",
    				width: "20"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    			t0 = space();
    			span = element("span");
    			span.textContent = "Icon to the left";
    			add_location(span, file$O, 151, 2, 3732);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$h.name,
    		type: "slot",
    		source: "(150:0) <Button className=\\\"margin-m\\\">",
    		ctx
    	});

    	return block;
    }

    // (166:0) {:else}
    function create_else_block$c(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$c.name,
    		type: "else",
    		source: "(166:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (155:0) {#if $sourceType === 'svelte'}
    function create_if_block$d(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$u] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(155:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (167:2) <Prism language="html">
    function create_default_slot_1$n(ctx) {
    	let t_value = `<button class="button">
  <span></span>
  <svg viewBox="0 0 50 50">
    <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#angle_right"></use>
  </svg>
</button>
<button class="button">
  <svg viewBox="0 0 50 50">
    <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#angle_left"></use>
  </svg>
  <span></span>
</button>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$n.name,
    		type: "slot",
    		source: "(167:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (156:2) <Prism language="html">
    function create_default_slot$u(ctx) {
    	let t_value = `<Button>
  <span></span>
  <Icon className="icon" name="angle-right" width="20" />
</Button>
<Button>
  <Icon className="icon" name="angle-left" width="20" />
  <span></span>
</Button>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$u.name,
    		type: "slot",
    		source: "(156:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$O(ctx) {
    	let h1;
    	let t1;
    	let t2;
    	let h30;
    	let t4;
    	let button0;
    	let t5;
    	let current_block_type_index;
    	let if_block1;
    	let t6;
    	let h31;
    	let t8;
    	let button1;
    	let t9;
    	let button2;
    	let t10;
    	let button3;
    	let t11;
    	let current_block_type_index_1;
    	let if_block2;
    	let t12;
    	let h32;
    	let t14;
    	let p;
    	let b0;
    	let t16;
    	let b1;
    	let t18;
    	let t19;
    	let button4;
    	let t20;
    	let button5;
    	let t21;
    	let current_block_type_index_2;
    	let if_block3;
    	let t22;
    	let h33;
    	let t24;
    	let button6;
    	let t25;
    	let button7;
    	let t26;
    	let button8;
    	let t27;
    	let button9;
    	let t28;
    	let current_block_type_index_3;
    	let if_block4;
    	let t29;
    	let h34;
    	let t31;
    	let button10;
    	let t32;
    	let button11;
    	let t33;
    	let current_block_type_index_4;
    	let if_block5;
    	let if_block5_anchor;
    	let current;
    	let if_block0 = /*$sourceType*/ ctx[0] === 'svelte' && create_if_block_5$1(ctx);

    	button0 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_21$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block_4$3, create_else_block_4$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	button1 = new Button$1({
    			props: {
    				className: "margin-m",
    				extension: "solid",
    				$$slots: { default: [create_default_slot_18$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new Button$1({
    			props: {
    				className: "margin-m",
    				extension: "link",
    				$$slots: { default: [create_default_slot_17$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button3 = new Button$1({
    			props: {
    				className: "margin-m",
    				extension: "icon",
    				$$slots: { default: [create_default_slot_16$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_1 = [create_if_block_3$3, create_else_block_3$3];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	button4 = new Button$1({
    			props: {
    				className: "margin-m",
    				size: "big",
    				$$slots: { default: [create_default_slot_13$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button5 = new Button$1({
    			props: {
    				className: "margin-m",
    				size: "small",
    				$$slots: { default: [create_default_slot_12$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_2 = [create_if_block_2$4, create_else_block_2$3];
    	const if_blocks_2 = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_2 = select_block_type_2(ctx);
    	if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

    	button6 = new Button$1({
    			props: {
    				className: "margin-m",
    				type: "primary",
    				$$slots: { default: [create_default_slot_9$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button7 = new Button$1({
    			props: {
    				className: "margin-m",
    				type: "secondary",
    				$$slots: { default: [create_default_slot_8$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button8 = new Button$1({
    			props: {
    				className: "margin-m",
    				type: "accept",
    				$$slots: { default: [create_default_slot_7$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button9 = new Button$1({
    			props: {
    				className: "margin-m",
    				type: "cancel",
    				$$slots: { default: [create_default_slot_6$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_3 = [create_if_block_1$7, create_else_block_1$5];
    	const if_blocks_3 = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_3 = select_block_type_3(ctx);
    	if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);

    	button10 = new Button$1({
    			props: {
    				className: "margin-m",
    				$$slots: { default: [create_default_slot_3$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button11 = new Button$1({
    			props: {
    				className: "margin-m",
    				$$slots: { default: [create_default_slot_2$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_4 = [create_if_block$d, create_else_block$c];
    	const if_blocks_4 = [];

    	function select_block_type_4(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_4 = select_block_type_4(ctx);
    	if_block5 = if_blocks_4[current_block_type_index_4] = if_block_creators_4[current_block_type_index_4](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Buttons";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			h30 = element("h3");
    			h30.textContent = "Default";
    			t4 = space();
    			create_component(button0.$$.fragment);
    			t5 = space();
    			if_block1.c();
    			t6 = space();
    			h31 = element("h3");
    			h31.textContent = "Extension attribute";
    			t8 = space();
    			create_component(button1.$$.fragment);
    			t9 = space();
    			create_component(button2.$$.fragment);
    			t10 = space();
    			create_component(button3.$$.fragment);
    			t11 = space();
    			if_block2.c();
    			t12 = space();
    			h32 = element("h3");
    			h32.textContent = "Size attribute";
    			t14 = space();
    			p = element("p");
    			b0 = element("b");
    			b0.textContent = "big";
    			t16 = text(" and ");
    			b1 = element("b");
    			b1.textContent = "small";
    			t18 = text(" can be combined with the other three extensions");
    			t19 = space();
    			create_component(button4.$$.fragment);
    			t20 = space();
    			create_component(button5.$$.fragment);
    			t21 = space();
    			if_block3.c();
    			t22 = space();
    			h33 = element("h3");
    			h33.textContent = "Variations";
    			t24 = space();
    			create_component(button6.$$.fragment);
    			t25 = space();
    			create_component(button7.$$.fragment);
    			t26 = space();
    			create_component(button8.$$.fragment);
    			t27 = space();
    			create_component(button9.$$.fragment);
    			t28 = space();
    			if_block4.c();
    			t29 = space();
    			h34 = element("h3");
    			h34.textContent = "With Icon";
    			t31 = space();
    			create_component(button10.$$.fragment);
    			t32 = space();
    			create_component(button11.$$.fragment);
    			t33 = space();
    			if_block5.c();
    			if_block5_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$O, 5, 0, 145);
    			add_location(h30, file$O, 62, 0, 1290);
    			add_location(h31, file$O, 76, 0, 1520);
    			add_location(h32, file$O, 102, 0, 2255);
    			add_location(b0, file$O, 103, 3, 2282);
    			add_location(b1, file$O, 103, 18, 2297);
    			add_location(p, file$O, 103, 0, 2279);
    			add_location(h33, file$O, 120, 0, 2762);
    			add_location(h34, file$O, 143, 0, 3492);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(button0, target, anchor);
    			insert_dev(target, t5, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t9, anchor);
    			mount_component(button2, target, anchor);
    			insert_dev(target, t10, anchor);
    			mount_component(button3, target, anchor);
    			insert_dev(target, t11, anchor);
    			if_blocks_1[current_block_type_index_1].m(target, anchor);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, b0);
    			append_dev(p, t16);
    			append_dev(p, b1);
    			append_dev(p, t18);
    			insert_dev(target, t19, anchor);
    			mount_component(button4, target, anchor);
    			insert_dev(target, t20, anchor);
    			mount_component(button5, target, anchor);
    			insert_dev(target, t21, anchor);
    			if_blocks_2[current_block_type_index_2].m(target, anchor);
    			insert_dev(target, t22, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t24, anchor);
    			mount_component(button6, target, anchor);
    			insert_dev(target, t25, anchor);
    			mount_component(button7, target, anchor);
    			insert_dev(target, t26, anchor);
    			mount_component(button8, target, anchor);
    			insert_dev(target, t27, anchor);
    			mount_component(button9, target, anchor);
    			insert_dev(target, t28, anchor);
    			if_blocks_3[current_block_type_index_3].m(target, anchor);
    			insert_dev(target, t29, anchor);
    			insert_dev(target, h34, anchor);
    			insert_dev(target, t31, anchor);
    			mount_component(button10, target, anchor);
    			insert_dev(target, t32, anchor);
    			mount_component(button11, target, anchor);
    			insert_dev(target, t33, anchor);
    			if_blocks_4[current_block_type_index_4].m(target, anchor);
    			insert_dev(target, if_block5_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$sourceType*/ ctx[0] === 'svelte') {
    				if (if_block0) {
    					if (dirty & /*$sourceType*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(t6.parentNode, t6);
    			}

    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    			const button3_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button3_changes.$$scope = { dirty, ctx };
    			}

    			button3.$set(button3_changes);
    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks_1[current_block_type_index_1];

    				if (!if_block2) {
    					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(t12.parentNode, t12);
    			}

    			const button4_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button4_changes.$$scope = { dirty, ctx };
    			}

    			button4.$set(button4_changes);
    			const button5_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button5_changes.$$scope = { dirty, ctx };
    			}

    			button5.$set(button5_changes);
    			let previous_block_index_2 = current_block_type_index_2;
    			current_block_type_index_2 = select_block_type_2(ctx);

    			if (current_block_type_index_2 !== previous_block_index_2) {
    				group_outros();

    				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
    					if_blocks_2[previous_block_index_2] = null;
    				});

    				check_outros();
    				if_block3 = if_blocks_2[current_block_type_index_2];

    				if (!if_block3) {
    					if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
    					if_block3.c();
    				}

    				transition_in(if_block3, 1);
    				if_block3.m(t22.parentNode, t22);
    			}

    			const button6_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button6_changes.$$scope = { dirty, ctx };
    			}

    			button6.$set(button6_changes);
    			const button7_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button7_changes.$$scope = { dirty, ctx };
    			}

    			button7.$set(button7_changes);
    			const button8_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button8_changes.$$scope = { dirty, ctx };
    			}

    			button8.$set(button8_changes);
    			const button9_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button9_changes.$$scope = { dirty, ctx };
    			}

    			button9.$set(button9_changes);
    			let previous_block_index_3 = current_block_type_index_3;
    			current_block_type_index_3 = select_block_type_3(ctx);

    			if (current_block_type_index_3 !== previous_block_index_3) {
    				group_outros();

    				transition_out(if_blocks_3[previous_block_index_3], 1, 1, () => {
    					if_blocks_3[previous_block_index_3] = null;
    				});

    				check_outros();
    				if_block4 = if_blocks_3[current_block_type_index_3];

    				if (!if_block4) {
    					if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);
    					if_block4.c();
    				}

    				transition_in(if_block4, 1);
    				if_block4.m(t29.parentNode, t29);
    			}

    			const button10_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button10_changes.$$scope = { dirty, ctx };
    			}

    			button10.$set(button10_changes);
    			const button11_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button11_changes.$$scope = { dirty, ctx };
    			}

    			button11.$set(button11_changes);
    			let previous_block_index_4 = current_block_type_index_4;
    			current_block_type_index_4 = select_block_type_4(ctx);

    			if (current_block_type_index_4 !== previous_block_index_4) {
    				group_outros();

    				transition_out(if_blocks_4[previous_block_index_4], 1, 1, () => {
    					if_blocks_4[previous_block_index_4] = null;
    				});

    				check_outros();
    				if_block5 = if_blocks_4[current_block_type_index_4];

    				if (!if_block5) {
    					if_block5 = if_blocks_4[current_block_type_index_4] = if_block_creators_4[current_block_type_index_4](ctx);
    					if_block5.c();
    				}

    				transition_in(if_block5, 1);
    				if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(button0.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			transition_in(button3.$$.fragment, local);
    			transition_in(if_block2);
    			transition_in(button4.$$.fragment, local);
    			transition_in(button5.$$.fragment, local);
    			transition_in(if_block3);
    			transition_in(button6.$$.fragment, local);
    			transition_in(button7.$$.fragment, local);
    			transition_in(button8.$$.fragment, local);
    			transition_in(button9.$$.fragment, local);
    			transition_in(if_block4);
    			transition_in(button10.$$.fragment, local);
    			transition_in(button11.$$.fragment, local);
    			transition_in(if_block5);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(button0.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			transition_out(button3.$$.fragment, local);
    			transition_out(if_block2);
    			transition_out(button4.$$.fragment, local);
    			transition_out(button5.$$.fragment, local);
    			transition_out(if_block3);
    			transition_out(button6.$$.fragment, local);
    			transition_out(button7.$$.fragment, local);
    			transition_out(button8.$$.fragment, local);
    			transition_out(button9.$$.fragment, local);
    			transition_out(if_block4);
    			transition_out(button10.$$.fragment, local);
    			transition_out(button11.$$.fragment, local);
    			transition_out(if_block5);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t4);
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t5);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t8);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t9);
    			destroy_component(button2, detaching);
    			if (detaching) detach_dev(t10);
    			destroy_component(button3, detaching);
    			if (detaching) detach_dev(t11);
    			if_blocks_1[current_block_type_index_1].d(detaching);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t19);
    			destroy_component(button4, detaching);
    			if (detaching) detach_dev(t20);
    			destroy_component(button5, detaching);
    			if (detaching) detach_dev(t21);
    			if_blocks_2[current_block_type_index_2].d(detaching);
    			if (detaching) detach_dev(t22);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t24);
    			destroy_component(button6, detaching);
    			if (detaching) detach_dev(t25);
    			destroy_component(button7, detaching);
    			if (detaching) detach_dev(t26);
    			destroy_component(button8, detaching);
    			if (detaching) detach_dev(t27);
    			destroy_component(button9, detaching);
    			if (detaching) detach_dev(t28);
    			if_blocks_3[current_block_type_index_3].d(detaching);
    			if (detaching) detach_dev(t29);
    			if (detaching) detach_dev(h34);
    			if (detaching) detach_dev(t31);
    			destroy_component(button10, detaching);
    			if (detaching) detach_dev(t32);
    			destroy_component(button11, detaching);
    			if (detaching) detach_dev(t33);
    			if_blocks_4[current_block_type_index_4].d(detaching);
    			if (detaching) detach_dev(if_block5_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Button> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		sourceType,
    		Button: Button$1,
    		Icon: Icon$1,
    		$sourceType
    	});

    	return [$sourceType];
    }

    class Button_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$O, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button_1",
    			options,
    			id: create_fragment$O.name
    		});
    	}
    }

    /* docs_src/components/ButtonGroup.svelte generated by Svelte v3.53.1 */
    const file$N = "docs_src/components/ButtonGroup.svelte";

    // (9:0) {#if $sourceType === 'svelte'}
    function create_if_block_4$2(ctx) {
    	let prism;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t13;
    	let td3;
    	let t14;
    	let tr2;
    	let td4;
    	let t16;
    	let td5;
    	let t18;
    	let td6;
    	let t19;
    	let td7;
    	let t20;
    	let tr3;
    	let td8;
    	let t22;
    	let td9;
    	let t24;
    	let td10;
    	let t25;
    	let td11;
    	let t26;
    	let tr4;
    	let td12;
    	let t28;
    	let td13;
    	let t30;
    	let td14;
    	let t31;
    	let td15;
    	let t32;
    	let tr5;
    	let td16;
    	let t34;
    	let td17;
    	let t36;
    	let td18;
    	let t38;
    	let td19;
    	let t39;
    	let tr6;
    	let td20;
    	let t41;
    	let td21;
    	let t43;
    	let td22;
    	let t45;
    	let td23;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_36] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "className";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "string";
    			t12 = space();
    			td2 = element("td");
    			t13 = space();
    			td3 = element("td");
    			t14 = space();
    			tr2 = element("tr");
    			td4 = element("td");
    			td4.textContent = "type";
    			t16 = space();
    			td5 = element("td");
    			td5.textContent = "'accept' | 'cancel' | 'primary' | 'secondary'";
    			t18 = space();
    			td6 = element("td");
    			t19 = space();
    			td7 = element("td");
    			t20 = space();
    			tr3 = element("tr");
    			td8 = element("td");
    			td8.textContent = "color";
    			t22 = space();
    			td9 = element("td");
    			td9.textContent = "EB Background color variable";
    			t24 = space();
    			td10 = element("td");
    			t25 = space();
    			td11 = element("td");
    			t26 = space();
    			tr4 = element("tr");
    			td12 = element("td");
    			td12.textContent = "colorHover";
    			t28 = space();
    			td13 = element("td");
    			td13.textContent = "EB Background color variable";
    			t30 = space();
    			td14 = element("td");
    			t31 = space();
    			td15 = element("td");
    			t32 = space();
    			tr5 = element("tr");
    			td16 = element("td");
    			td16.textContent = "solid";
    			t34 = space();
    			td17 = element("td");
    			td17.textContent = "boolean";
    			t36 = space();
    			td18 = element("td");
    			td18.textContent = "false";
    			t38 = space();
    			td19 = element("td");
    			t39 = space();
    			tr6 = element("tr");
    			td20 = element("td");
    			td20.textContent = "selectedId";
    			t41 = space();
    			td21 = element("td");
    			td21.textContent = "Writable - number";
    			t43 = space();
    			td22 = element("td");
    			td22.textContent = "0 (first button)";
    			t45 = space();
    			td23 = element("td");
    			td23.textContent = "Can be set onMount";
    			add_location(th0, file$N, 16, 8, 407);
    			add_location(th1, file$N, 17, 8, 434);
    			add_location(th2, file$N, 18, 8, 456);
    			add_location(th3, file$N, 19, 8, 487);
    			add_location(tr0, file$N, 15, 6, 394);
    			add_location(thead, file$N, 14, 4, 380);
    			add_location(td0, file$N, 24, 8, 564);
    			add_location(td1, file$N, 25, 8, 591);
    			add_location(td2, file$N, 26, 8, 615);
    			add_location(td3, file$N, 27, 8, 630);
    			add_location(tr1, file$N, 23, 6, 551);
    			add_location(td4, file$N, 30, 8, 668);
    			add_location(td5, file$N, 31, 8, 690);
    			add_location(td6, file$N, 32, 8, 753);
    			add_location(td7, file$N, 33, 8, 768);
    			add_location(tr2, file$N, 29, 6, 655);
    			add_location(td8, file$N, 36, 8, 806);
    			add_location(td9, file$N, 37, 8, 829);
    			add_location(td10, file$N, 38, 8, 875);
    			add_location(td11, file$N, 39, 8, 890);
    			add_location(tr3, file$N, 35, 6, 793);
    			add_location(td12, file$N, 42, 8, 928);
    			add_location(td13, file$N, 43, 8, 956);
    			add_location(td14, file$N, 44, 8, 1002);
    			add_location(td15, file$N, 45, 8, 1017);
    			add_location(tr4, file$N, 41, 6, 915);
    			add_location(td16, file$N, 48, 8, 1055);
    			add_location(td17, file$N, 49, 8, 1078);
    			add_location(td18, file$N, 50, 8, 1103);
    			add_location(td19, file$N, 51, 8, 1126);
    			add_location(tr5, file$N, 47, 6, 1042);
    			add_location(td20, file$N, 54, 8, 1164);
    			add_location(td21, file$N, 55, 8, 1192);
    			add_location(td22, file$N, 56, 8, 1227);
    			add_location(td23, file$N, 57, 8, 1261);
    			add_location(tr6, file$N, 53, 6, 1151);
    			add_location(tbody, file$N, 22, 4, 537);
    			attr_dev(table, "class", "table");
    			add_location(table, file$N, 13, 2, 354);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			append_dev(tbody, t14);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td4);
    			append_dev(tr2, t16);
    			append_dev(tr2, td5);
    			append_dev(tr2, t18);
    			append_dev(tr2, td6);
    			append_dev(tr2, t19);
    			append_dev(tr2, td7);
    			append_dev(tbody, t20);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td8);
    			append_dev(tr3, t22);
    			append_dev(tr3, td9);
    			append_dev(tr3, t24);
    			append_dev(tr3, td10);
    			append_dev(tr3, t25);
    			append_dev(tr3, td11);
    			append_dev(tbody, t26);
    			append_dev(tbody, tr4);
    			append_dev(tr4, td12);
    			append_dev(tr4, t28);
    			append_dev(tr4, td13);
    			append_dev(tr4, t30);
    			append_dev(tr4, td14);
    			append_dev(tr4, t31);
    			append_dev(tr4, td15);
    			append_dev(tbody, t32);
    			append_dev(tbody, tr5);
    			append_dev(tr5, td16);
    			append_dev(tr5, t34);
    			append_dev(tr5, td17);
    			append_dev(tr5, t36);
    			append_dev(tr5, td18);
    			append_dev(tr5, t38);
    			append_dev(tr5, td19);
    			append_dev(tbody, t39);
    			append_dev(tbody, tr6);
    			append_dev(tr6, td20);
    			append_dev(tr6, t41);
    			append_dev(tr6, td21);
    			append_dev(tr6, t43);
    			append_dev(tr6, td22);
    			append_dev(tr6, t45);
    			append_dev(tr6, td23);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(9:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (10:2) <Prism language="js">
    function create_default_slot_36(ctx) {
    	let t_value = `import { Button, ButtonGroup } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_36.name,
    		type: "slot",
    		source: "(10:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (68:2) <Button>
    function create_default_slot_35(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 1");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_35.name,
    		type: "slot",
    		source: "(68:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (69:2) <Button>
    function create_default_slot_34(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_34.name,
    		type: "slot",
    		source: "(69:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (70:2) <Button>
    function create_default_slot_33(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 3");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_33.name,
    		type: "slot",
    		source: "(70:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (67:0) <ButtonGroup className="margin-l--b" bind:selectedId>
    function create_default_slot_32(ctx) {
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let button2;
    	let current;

    	button0 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_35] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_34] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_33] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			create_component(button2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(button2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_32.name,
    		type: "slot",
    		source: "(67:0) <ButtonGroup className=\\\"margin-l--b\\\" bind:selectedId>",
    		ctx
    	});

    	return block;
    }

    // (81:0) {:else}
    function create_else_block_3$2(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_31] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3$2.name,
    		type: "else",
    		source: "(81:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (73:0) {#if $sourceType === 'svelte'}
    function create_if_block_3$2(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_30] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(73:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (82:2) <Prism language="html">
    function create_default_slot_31(ctx) {
    	let t_value = `<div class="buttongroup">
  <button class="button"></button>
  <button class="button"></button>
  <button class="button"></button>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_31.name,
    		type: "slot",
    		source: "(82:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (74:2) <Prism language="html">
    function create_default_slot_30(ctx) {
    	let t_value = `<ButtonGroup bind:selectedId>
  <Button></Button>
  <Button></Button>
  <Button></Button>
</ButtonGroup>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_30.name,
    		type: "slot",
    		source: "(74:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (94:2) <Button>
    function create_default_slot_29(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Primary");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_29.name,
    		type: "slot",
    		source: "(94:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (95:2) <Button>
    function create_default_slot_28(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_28.name,
    		type: "slot",
    		source: "(95:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (96:2) <Button>
    function create_default_slot_27(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 3");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_27.name,
    		type: "slot",
    		source: "(96:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (93:0) <ButtonGroup type="primary" className="margin-m--b">
    function create_default_slot_26(ctx) {
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let button2;
    	let current;

    	button0 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_29] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_28] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_27] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			create_component(button2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(button2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_26.name,
    		type: "slot",
    		source: "(93:0) <ButtonGroup type=\\\"primary\\\" className=\\\"margin-m--b\\\">",
    		ctx
    	});

    	return block;
    }

    // (100:2) <Button>
    function create_default_slot_25(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Secondary");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_25.name,
    		type: "slot",
    		source: "(100:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (101:2) <Button>
    function create_default_slot_24(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_24.name,
    		type: "slot",
    		source: "(101:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (102:2) <Button>
    function create_default_slot_23(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 3");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23.name,
    		type: "slot",
    		source: "(102:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (99:0) <ButtonGroup type="secondary" className="margin-m--b">
    function create_default_slot_22(ctx) {
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let button2;
    	let current;

    	button0 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_25] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_24] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_23] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			create_component(button2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(button2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22.name,
    		type: "slot",
    		source: "(99:0) <ButtonGroup type=\\\"secondary\\\" className=\\\"margin-m--b\\\">",
    		ctx
    	});

    	return block;
    }

    // (106:2) <Button>
    function create_default_slot_21(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Accept");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21.name,
    		type: "slot",
    		source: "(106:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (107:2) <Button>
    function create_default_slot_20(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20.name,
    		type: "slot",
    		source: "(107:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (108:2) <Button>
    function create_default_slot_19(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 3");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19.name,
    		type: "slot",
    		source: "(108:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (105:0) <ButtonGroup type="accept" className="margin-m--b">
    function create_default_slot_18$1(ctx) {
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let button2;
    	let current;

    	button0 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_21] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_20] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_19] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			create_component(button2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(button2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$1.name,
    		type: "slot",
    		source: "(105:0) <ButtonGroup type=\\\"accept\\\" className=\\\"margin-m--b\\\">",
    		ctx
    	});

    	return block;
    }

    // (112:2) <Button>
    function create_default_slot_17$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Cancel");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$1.name,
    		type: "slot",
    		source: "(112:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (113:2) <Button>
    function create_default_slot_16$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$1.name,
    		type: "slot",
    		source: "(113:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (114:2) <Button>
    function create_default_slot_15$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 3");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$1.name,
    		type: "slot",
    		source: "(114:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (111:0) <ButtonGroup type="cancel" className="margin-l--b">
    function create_default_slot_14$1(ctx) {
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let button2;
    	let current;

    	button0 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_17$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_16$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_15$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			create_component(button2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(button2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$1.name,
    		type: "slot",
    		source: "(111:0) <ButtonGroup type=\\\"cancel\\\" className=\\\"margin-l--b\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:0) {:else}
    function create_else_block_2$2(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_13$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$2.name,
    		type: "else",
    		source: "(124:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (117:0) {#if $sourceType === 'svelte'}
    function create_if_block_2$3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_12$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(117:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (125:2) <Prism language="html">
    function create_default_slot_13$1(ctx) {
    	let t_value = `<div class="buttongroup buttongroup--primary">...</div>
<div class="buttongroup buttongroup--secondary">...</div>
<div class="buttongroup buttongroup--accept">...</div>
<div class="buttongroup buttongroup--cancel">...</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$1.name,
    		type: "slot",
    		source: "(125:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (118:2) <Prism language="html">
    function create_default_slot_12$1(ctx) {
    	let t_value = `<ButtonGroup type="primary">...</ButtonGroup>
<ButtonGroup type="secondary">...</ButtonGroup>
<ButtonGroup type="accept">...</ButtonGroup>
<ButtonGroup type="cancel">...</ButtonGroup>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$1.name,
    		type: "slot",
    		source: "(118:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (136:2) <Button>
    function create_default_slot_11$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 1");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$2.name,
    		type: "slot",
    		source: "(136:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (137:2) <Button>
    function create_default_slot_10$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$2.name,
    		type: "slot",
    		source: "(137:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (138:2) <Button>
    function create_default_slot_9$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 3");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$3.name,
    		type: "slot",
    		source: "(138:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (135:0) <ButtonGroup color="Bordeaux" className="margin-l--b">
    function create_default_slot_8$6(ctx) {
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let button2;
    	let current;

    	button0 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_11$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_10$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_9$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			create_component(button2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(button2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$6.name,
    		type: "slot",
    		source: "(135:0) <ButtonGroup color=\\\"Bordeaux\\\" className=\\\"margin-l--b\\\">",
    		ctx
    	});

    	return block;
    }

    // (145:0) {:else}
    function create_else_block_1$4(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_7$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$4.name,
    		type: "else",
    		source: "(145:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (141:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$6(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_6$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(141:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (146:2) <Prism language="html">
    function create_default_slot_7$7(ctx) {
    	let t_value = `<div class="buttongroup" style="
  --buttongroup-color: #8a0c36;
  --buttongroup-fgcolor: #fff;
  --buttongroup-color--hover: #8a0c36;
  --buttongroup-fgcolor--hover: #fff;
">...</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$7.name,
    		type: "slot",
    		source: "(146:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (142:2) <Prism language="html">
    function create_default_slot_6$8(ctx) {
    	let t_value = `<ButtonGroup color="Bordeaux">...</ButtonGroup>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$8.name,
    		type: "slot",
    		source: "(142:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (159:2) <Button>
    function create_default_slot_5$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 1");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$9.name,
    		type: "slot",
    		source: "(159:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (160:2) <Button>
    function create_default_slot_4$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$a.name,
    		type: "slot",
    		source: "(160:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (161:2) <Button>
    function create_default_slot_3$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 3");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$a.name,
    		type: "slot",
    		source: "(161:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (158:0) <ButtonGroup solid={true} color="Black" colorHover="Red" className="margin-l--b">
    function create_default_slot_2$g(ctx) {
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let button2;
    	let current;

    	button0 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_5$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_4$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_3$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			create_component(button2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(button2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$g.name,
    		type: "slot",
    		source: "(158:0) <ButtonGroup solid={true} color=\\\"Black\\\" colorHover=\\\"Red\\\" className=\\\"margin-l--b\\\">",
    		ctx
    	});

    	return block;
    }

    // (168:0) {:else}
    function create_else_block$b(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(168:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (164:0) {#if $sourceType === 'svelte'}
    function create_if_block$c(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$t] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(164:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (169:2) <Prism language="html">
    function create_default_slot_1$m(ctx) {
    	let t_value = `<div class="buttongroup buttongroup--solid" style="
  --buttongroup-color: #000;
  --buttongroup-fgcolor: #fff;
  --buttongroup-color--hover: #bd1118;
  --buttongroup-fgcolor--hover: #fff;
">...</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$m.name,
    		type: "slot",
    		source: "(169:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (165:2) <Prism language="html">
    function create_default_slot$t(ctx) {
    	let t_value = `<ButtonGroup solid={true} color="Black" colorHover="Red">...</ButtonGroup>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$t.name,
    		type: "slot",
    		source: "(165:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$N(ctx) {
    	let h1;
    	let t1;
    	let t2;
    	let h30;
    	let t4;
    	let p;
    	let t5;
    	let t6;
    	let t7;
    	let buttongroup0;
    	let updating_selectedId;
    	let t8;
    	let current_block_type_index;
    	let if_block1;
    	let t9;
    	let h31;
    	let t11;
    	let buttongroup1;
    	let t12;
    	let buttongroup2;
    	let t13;
    	let buttongroup3;
    	let t14;
    	let buttongroup4;
    	let t15;
    	let current_block_type_index_1;
    	let if_block2;
    	let t16;
    	let h32;
    	let t18;
    	let buttongroup5;
    	let t19;
    	let current_block_type_index_2;
    	let if_block3;
    	let t20;
    	let h33;
    	let t22;
    	let buttongroup6;
    	let t23;
    	let current_block_type_index_3;
    	let if_block4;
    	let if_block4_anchor;
    	let current;
    	let if_block0 = /*$sourceType*/ ctx[1] === 'svelte' && create_if_block_4$2(ctx);

    	function buttongroup0_selectedId_binding(value) {
    		/*buttongroup0_selectedId_binding*/ ctx[3](value);
    	}

    	let buttongroup0_props = {
    		className: "margin-l--b",
    		$$slots: { default: [create_default_slot_32] },
    		$$scope: { ctx }
    	};

    	if (/*selectedId*/ ctx[0] !== void 0) {
    		buttongroup0_props.selectedId = /*selectedId*/ ctx[0];
    	}

    	buttongroup0 = new ButtonGroup({
    			props: buttongroup0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(buttongroup0, 'selectedId', buttongroup0_selectedId_binding));
    	const if_block_creators = [create_if_block_3$2, create_else_block_3$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[1] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	buttongroup1 = new ButtonGroup({
    			props: {
    				type: "primary",
    				className: "margin-m--b",
    				$$slots: { default: [create_default_slot_26] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	buttongroup2 = new ButtonGroup({
    			props: {
    				type: "secondary",
    				className: "margin-m--b",
    				$$slots: { default: [create_default_slot_22] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	buttongroup3 = new ButtonGroup({
    			props: {
    				type: "accept",
    				className: "margin-m--b",
    				$$slots: { default: [create_default_slot_18$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	buttongroup4 = new ButtonGroup({
    			props: {
    				type: "cancel",
    				className: "margin-l--b",
    				$$slots: { default: [create_default_slot_14$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_1 = [create_if_block_2$3, create_else_block_2$2];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$sourceType*/ ctx[1] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	buttongroup5 = new ButtonGroup({
    			props: {
    				color: "Bordeaux",
    				className: "margin-l--b",
    				$$slots: { default: [create_default_slot_8$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_2 = [create_if_block_1$6, create_else_block_1$4];
    	const if_blocks_2 = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$sourceType*/ ctx[1] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_2 = select_block_type_2(ctx);
    	if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

    	buttongroup6 = new ButtonGroup({
    			props: {
    				solid: true,
    				color: "Black",
    				colorHover: "Red",
    				className: "margin-l--b",
    				$$slots: { default: [create_default_slot_2$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_3 = [create_if_block$c, create_else_block$b];
    	const if_blocks_3 = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*$sourceType*/ ctx[1] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_3 = select_block_type_3(ctx);
    	if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Button groups";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			h30 = element("h3");
    			h30.textContent = "Default";
    			t4 = space();
    			p = element("p");
    			t5 = text("Button-index selected: ");
    			t6 = text(/*$selectedId*/ ctx[2]);
    			t7 = space();
    			create_component(buttongroup0.$$.fragment);
    			t8 = space();
    			if_block1.c();
    			t9 = space();
    			h31 = element("h3");
    			h31.textContent = "Variations";
    			t11 = space();
    			create_component(buttongroup1.$$.fragment);
    			t12 = space();
    			create_component(buttongroup2.$$.fragment);
    			t13 = space();
    			create_component(buttongroup3.$$.fragment);
    			t14 = space();
    			create_component(buttongroup4.$$.fragment);
    			t15 = space();
    			if_block2.c();
    			t16 = space();
    			h32 = element("h3");
    			h32.textContent = "Farve muligheder fra eb-colors";
    			t18 = space();
    			create_component(buttongroup5.$$.fragment);
    			t19 = space();
    			if_block3.c();
    			t20 = space();
    			h33 = element("h3");
    			h33.textContent = "Solid button group";
    			t22 = space();
    			create_component(buttongroup6.$$.fragment);
    			t23 = space();
    			if_block4.c();
    			if_block4_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$N, 6, 0, 168);
    			add_location(h30, file$N, 63, 0, 1332);
    			add_location(p, file$N, 64, 0, 1349);
    			add_location(h31, file$N, 90, 0, 1927);
    			add_location(h32, file$N, 132, 0, 3100);
    			add_location(h33, file$N, 155, 0, 3665);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t5);
    			append_dev(p, t6);
    			insert_dev(target, t7, anchor);
    			mount_component(buttongroup0, target, anchor);
    			insert_dev(target, t8, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t11, anchor);
    			mount_component(buttongroup1, target, anchor);
    			insert_dev(target, t12, anchor);
    			mount_component(buttongroup2, target, anchor);
    			insert_dev(target, t13, anchor);
    			mount_component(buttongroup3, target, anchor);
    			insert_dev(target, t14, anchor);
    			mount_component(buttongroup4, target, anchor);
    			insert_dev(target, t15, anchor);
    			if_blocks_1[current_block_type_index_1].m(target, anchor);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t18, anchor);
    			mount_component(buttongroup5, target, anchor);
    			insert_dev(target, t19, anchor);
    			if_blocks_2[current_block_type_index_2].m(target, anchor);
    			insert_dev(target, t20, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t22, anchor);
    			mount_component(buttongroup6, target, anchor);
    			insert_dev(target, t23, anchor);
    			if_blocks_3[current_block_type_index_3].m(target, anchor);
    			insert_dev(target, if_block4_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$sourceType*/ ctx[1] === 'svelte') {
    				if (if_block0) {
    					if (dirty & /*$sourceType*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*$selectedId*/ 4) set_data_dev(t6, /*$selectedId*/ ctx[2]);
    			const buttongroup0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				buttongroup0_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_selectedId && dirty & /*selectedId*/ 1) {
    				updating_selectedId = true;
    				buttongroup0_changes.selectedId = /*selectedId*/ ctx[0];
    				add_flush_callback(() => updating_selectedId = false);
    			}

    			buttongroup0.$set(buttongroup0_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(t9.parentNode, t9);
    			}

    			const buttongroup1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				buttongroup1_changes.$$scope = { dirty, ctx };
    			}

    			buttongroup1.$set(buttongroup1_changes);
    			const buttongroup2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				buttongroup2_changes.$$scope = { dirty, ctx };
    			}

    			buttongroup2.$set(buttongroup2_changes);
    			const buttongroup3_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				buttongroup3_changes.$$scope = { dirty, ctx };
    			}

    			buttongroup3.$set(buttongroup3_changes);
    			const buttongroup4_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				buttongroup4_changes.$$scope = { dirty, ctx };
    			}

    			buttongroup4.$set(buttongroup4_changes);
    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks_1[current_block_type_index_1];

    				if (!if_block2) {
    					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(t16.parentNode, t16);
    			}

    			const buttongroup5_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				buttongroup5_changes.$$scope = { dirty, ctx };
    			}

    			buttongroup5.$set(buttongroup5_changes);
    			let previous_block_index_2 = current_block_type_index_2;
    			current_block_type_index_2 = select_block_type_2(ctx);

    			if (current_block_type_index_2 !== previous_block_index_2) {
    				group_outros();

    				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
    					if_blocks_2[previous_block_index_2] = null;
    				});

    				check_outros();
    				if_block3 = if_blocks_2[current_block_type_index_2];

    				if (!if_block3) {
    					if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
    					if_block3.c();
    				}

    				transition_in(if_block3, 1);
    				if_block3.m(t20.parentNode, t20);
    			}

    			const buttongroup6_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				buttongroup6_changes.$$scope = { dirty, ctx };
    			}

    			buttongroup6.$set(buttongroup6_changes);
    			let previous_block_index_3 = current_block_type_index_3;
    			current_block_type_index_3 = select_block_type_3(ctx);

    			if (current_block_type_index_3 !== previous_block_index_3) {
    				group_outros();

    				transition_out(if_blocks_3[previous_block_index_3], 1, 1, () => {
    					if_blocks_3[previous_block_index_3] = null;
    				});

    				check_outros();
    				if_block4 = if_blocks_3[current_block_type_index_3];

    				if (!if_block4) {
    					if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);
    					if_block4.c();
    				}

    				transition_in(if_block4, 1);
    				if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(buttongroup0.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(buttongroup1.$$.fragment, local);
    			transition_in(buttongroup2.$$.fragment, local);
    			transition_in(buttongroup3.$$.fragment, local);
    			transition_in(buttongroup4.$$.fragment, local);
    			transition_in(if_block2);
    			transition_in(buttongroup5.$$.fragment, local);
    			transition_in(if_block3);
    			transition_in(buttongroup6.$$.fragment, local);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(buttongroup0.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(buttongroup1.$$.fragment, local);
    			transition_out(buttongroup2.$$.fragment, local);
    			transition_out(buttongroup3.$$.fragment, local);
    			transition_out(buttongroup4.$$.fragment, local);
    			transition_out(if_block2);
    			transition_out(buttongroup5.$$.fragment, local);
    			transition_out(if_block3);
    			transition_out(buttongroup6.$$.fragment, local);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t7);
    			destroy_component(buttongroup0, detaching);
    			if (detaching) detach_dev(t8);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t11);
    			destroy_component(buttongroup1, detaching);
    			if (detaching) detach_dev(t12);
    			destroy_component(buttongroup2, detaching);
    			if (detaching) detach_dev(t13);
    			destroy_component(buttongroup3, detaching);
    			if (detaching) detach_dev(t14);
    			destroy_component(buttongroup4, detaching);
    			if (detaching) detach_dev(t15);
    			if_blocks_1[current_block_type_index_1].d(detaching);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t18);
    			destroy_component(buttongroup5, detaching);
    			if (detaching) detach_dev(t19);
    			if_blocks_2[current_block_type_index_2].d(detaching);
    			if (detaching) detach_dev(t20);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t22);
    			destroy_component(buttongroup6, detaching);
    			if (detaching) detach_dev(t23);
    			if_blocks_3[current_block_type_index_3].d(detaching);
    			if (detaching) detach_dev(if_block4_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let $sourceType;

    	let $selectedId,
    		$$unsubscribe_selectedId = noop,
    		$$subscribe_selectedId = () => ($$unsubscribe_selectedId(), $$unsubscribe_selectedId = subscribe(selectedId, $$value => $$invalidate(2, $selectedId = $$value)), selectedId);

    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(1, $sourceType = $$value));
    	$$self.$$.on_destroy.push(() => $$unsubscribe_selectedId());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ButtonGroup', slots, []);
    	let selectedId;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ButtonGroup> was created with unknown prop '${key}'`);
    	});

    	function buttongroup0_selectedId_binding(value) {
    		selectedId = value;
    		$$subscribe_selectedId($$invalidate(0, selectedId));
    	}

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		sourceType,
    		Button: Button$1,
    		ButtonGroup,
    		selectedId,
    		$sourceType,
    		$selectedId
    	});

    	$$self.$inject_state = $$props => {
    		if ('selectedId' in $$props) $$subscribe_selectedId($$invalidate(0, selectedId = $$props.selectedId));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [selectedId, $sourceType, $selectedId, buttongroup0_selectedId_binding];
    }

    class ButtonGroup_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$N, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ButtonGroup_1",
    			options,
    			id: create_fragment$N.name
    		});
    	}
    }

    /* docs_src/components/Card.svelte generated by Svelte v3.53.1 */
    const file$M = "docs_src/components/Card.svelte";

    // (9:0) {:else}
    function create_else_block$a(ctx) {
    	let h30;
    	let t1;
    	let div4;
    	let div0;
    	let t3;
    	let div1;
    	let img0;
    	let img0_src_value;
    	let t4;
    	let div2;
    	let t6;
    	let div3;
    	let t8;
    	let prism0;
    	let t9;
    	let h31;
    	let t11;
    	let div7;
    	let div5;
    	let img1;
    	let img1_src_value;
    	let t12;
    	let div6;
    	let t14;
    	let prism1;
    	let t15;
    	let h32;
    	let t17;
    	let p;
    	let t18;
    	let em;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$s] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h30 = element("h3");
    			h30.textContent = "Card slots";
    			t1 = space();
    			div4 = element("div");
    			div0 = element("div");
    			div0.textContent = "Header";
    			t3 = space();
    			div1 = element("div");
    			img0 = element("img");
    			t4 = space();
    			div2 = element("div");
    			div2.textContent = "Content";
    			t6 = space();
    			div3 = element("div");
    			div3.textContent = "Footer";
    			t8 = space();
    			create_component(prism0.$$.fragment);
    			t9 = space();
    			h31 = element("h3");
    			h31.textContent = "Small media card";
    			t11 = space();
    			div7 = element("div");
    			div5 = element("div");
    			img1 = element("img");
    			t12 = space();
    			div6 = element("div");
    			div6.textContent = "Content";
    			t14 = space();
    			create_component(prism1.$$.fragment);
    			t15 = space();
    			h32 = element("h3");
    			h32.textContent = "Force landscape image";
    			t17 = space();
    			p = element("p");
    			t18 = text("To force the image in a card to landscape view, use class ");
    			em = element("em");
    			em.textContent = "card-media--landscape";
    			add_location(h30, file$M, 9, 2, 224);
    			attr_dev(div0, "class", "card-header");
    			add_location(div0, file$M, 11, 4, 281);
    			if (!src_url_equal(img0.src, img0_src_value = "https://loremflickr.com/1280/400/cat")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "");
    			add_location(img0, file$M, 13, 6, 354);
    			attr_dev(div1, "class", "card-media");
    			add_location(div1, file$M, 12, 4, 323);
    			attr_dev(div2, "class", "card-content");
    			add_location(div2, file$M, 15, 4, 427);
    			attr_dev(div3, "class", "card-footer");
    			add_location(div3, file$M, 16, 4, 471);
    			attr_dev(div4, "class", "card margin-l--b");
    			add_location(div4, file$M, 10, 2, 246);
    			add_location(h31, file$M, 30, 2, 757);
    			if (!src_url_equal(img1.src, img1_src_value = "https://loremflickr.com/250/120/dog")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "");
    			add_location(img1, file$M, 34, 6, 870);
    			attr_dev(div5, "class", "card-media");
    			add_location(div5, file$M, 33, 4, 839);
    			attr_dev(div6, "class", "card-content");
    			add_location(div6, file$M, 36, 4, 942);
    			attr_dev(div7, "class", "card card--small-media margin-l--b");
    			add_location(div7, file$M, 32, 2, 786);
    			add_location(h32, file$M, 48, 2, 1181);
    			add_location(em, file$M, 49, 63, 1275);
    			add_location(p, file$M, 49, 2, 1214);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div4, t3);
    			append_dev(div4, div1);
    			append_dev(div1, img0);
    			append_dev(div4, t4);
    			append_dev(div4, div2);
    			append_dev(div4, t6);
    			append_dev(div4, div3);
    			insert_dev(target, t8, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div5);
    			append_dev(div5, img1);
    			append_dev(div7, t12);
    			append_dev(div7, div6);
    			insert_dev(target, t14, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t15, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t18);
    			append_dev(p, em);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div4);
    			if (detaching) detach_dev(t8);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(div7);
    			if (detaching) detach_dev(t14);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t15);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(9:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (7:0) {#if $sourceType === 'svelte'}
    function create_if_block$b(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Only valid as a HTML-standard element";
    			add_location(p, file$M, 7, 2, 169);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(7:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (20:2) <Prism language="html">
    function create_default_slot_1$l(ctx) {
    	let t_value = `<div class="card">
  <div class="card-header"></div>
  <div class="card-media">
    <img src="" alt="">
  </div>
   <div class="card-content"></div>
  <div class="card-footer"></div>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$l.name,
    		type: "slot",
    		source: "(20:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (40:2) <Prism language="html">
    function create_default_slot$s(ctx) {
    	let t_value = `<div class="card card--small-media">
  <div class="card-media">
    <img src="" alt="" />
  </div>
  <div class="card-content"></div>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$s.name,
    		type: "slot",
    		source: "(40:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let h1;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$b, create_else_block$a];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Card";
    			t1 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$M, 4, 0, 103);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Card', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Card> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1, sourceType, $sourceType });
    	return [$sourceType];
    }

    class Card extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Card",
    			options,
    			id: create_fragment$M.name
    		});
    	}
    }

    /* docs_src/components/FormElement.svelte generated by Svelte v3.53.1 */
    const file$L = "docs_src/components/FormElement.svelte";

    // (8:0) {#if $sourceType === 'svelte'}
    function create_if_block_5(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_11$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(8:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (9:2) <Prism language="js">
    function create_default_slot_11$1(ctx) {
    	let t_value = `import { FormElement } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$1.name,
    		type: "slot",
    		source: "(9:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (26:0) {:else}
    function create_else_block_4(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_10$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4.name,
    		type: "else",
    		source: "(26:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (20:0) {#if $sourceType === 'svelte'}
    function create_if_block_4$1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_9$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(20:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (27:2) <Prism language="html">
    function create_default_slot_10$1(ctx) {
    	let t_value = `FormElement er ikke blevet opdateret til HTML endnu` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$1.name,
    		type: "slot",
    		source: "(27:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (21:2) <Prism language="html">
    function create_default_slot_9$2(ctx) {
    	let t_value = `<FormElement inputtype="text" size="small" label="" />
<FormElement inputtype="text" label="" />
<FormElement inputtype="text" size="large" label="" />` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$2.name,
    		type: "slot",
    		source: "(21:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (40:0) {:else}
    function create_else_block_3$1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_8$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3$1.name,
    		type: "else",
    		source: "(40:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (36:0) {#if $sourceType === 'svelte'}
    function create_if_block_3$1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_7$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(36:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (41:2) <Prism language="html">
    function create_default_slot_8$5(ctx) {
    	let t_value = `FormElement er ikke blevet opdateret til HTML endnu` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$5.name,
    		type: "slot",
    		source: "(41:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (37:2) <Prism language="html">
    function create_default_slot_7$6(ctx) {
    	let t_value = `<FormElement inputtype="number" label="" />` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$6.name,
    		type: "slot",
    		source: "(37:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (48:0) <FormElement inputtype="select" label="Select">
    function create_default_slot_6$7(ctx) {
    	let option0;
    	let t1;
    	let option1;

    	const block = {
    		c: function create() {
    			option0 = element("option");
    			option0.textContent = "Option 1";
    			t1 = space();
    			option1 = element("option");
    			option1.textContent = "Option 2";
    			option0.__value = "option1";
    			option0.value = option0.__value;
    			add_location(option0, file$L, 48, 2, 1287);
    			option1.__value = "option2";
    			option1.value = option1.__value;
    			add_location(option1, file$L, 49, 2, 1331);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, option1, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(option1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$7.name,
    		type: "slot",
    		source: "(48:0) <FormElement inputtype=\\\"select\\\" label=\\\"Select\\\">",
    		ctx
    	});

    	return block;
    }

    // (60:0) {:else}
    function create_else_block_2$1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_5$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(60:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (53:0) {#if $sourceType === 'svelte'}
    function create_if_block_2$2(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_4$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(53:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (61:2) <Prism language="html">
    function create_default_slot_5$8(ctx) {
    	let t_value = `FormElement er ikke blevet opdateret til HTML endnu` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$8.name,
    		type: "slot",
    		source: "(61:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (54:2) <Prism language="html">
    function create_default_slot_4$9(ctx) {
    	let t_value = `<FormElement inputtype="select" label="">
  <option value="option1"></option>
  <option value="option2"></option>
</FormElement>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$9.name,
    		type: "slot",
    		source: "(54:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (76:0) {:else}
    function create_else_block_1$3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_3$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(76:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (71:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$5(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(71:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (77:2) <Prism language="html">
    function create_default_slot_3$9(ctx) {
    	let t_value = `FormElement er ikke blevet opdateret til HTML endnu` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$9.name,
    		type: "slot",
    		source: "(77:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (72:2) <Prism language="html">
    function create_default_slot_2$f(ctx) {
    	let t_value = `<FormElement inputtype="checkbox" label="" />
<FormElement inputtype="radio" label="" bind:group={group} value={1} />` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$f.name,
    		type: "slot",
    		source: "(72:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (90:0) {:else}
    function create_else_block$9(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(90:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (86:0) {#if $sourceType === 'svelte'}
    function create_if_block$a(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$r] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(86:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (91:2) <Prism language="html">
    function create_default_slot_1$k(ctx) {
    	let t_value = `FormElement er ikke blevet opdateret til HTML endnu` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$k.name,
    		type: "slot",
    		source: "(91:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (87:2) <Prism language="html">
    function create_default_slot$r(ctx) {
    	let t_value = `<FormElement inputtype="textarea" label="" />` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$r.name,
    		type: "slot",
    		source: "(87:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$L(ctx) {
    	let h1;
    	let t1;
    	let t2;
    	let h30;
    	let t4;
    	let formelement0;
    	let t5;
    	let formelement1;
    	let t6;
    	let formelement2;
    	let t7;
    	let current_block_type_index;
    	let if_block1;
    	let t8;
    	let h31;
    	let t10;
    	let formelement3;
    	let t11;
    	let current_block_type_index_1;
    	let if_block2;
    	let t12;
    	let h32;
    	let t14;
    	let formelement4;
    	let t15;
    	let current_block_type_index_2;
    	let if_block3;
    	let t16;
    	let h33;
    	let t18;
    	let formelement5;
    	let t19;
    	let formelement6;
    	let t20;
    	let current_block_type_index_3;
    	let if_block4;
    	let t21;
    	let h34;
    	let t23;
    	let formelement7;
    	let t24;
    	let current_block_type_index_4;
    	let if_block5;
    	let if_block5_anchor;
    	let current;
    	let if_block0 = /*$sourceType*/ ctx[0] === 'svelte' && create_if_block_5(ctx);

    	formelement0 = new FormElement({
    			props: {
    				inputtype: "text",
    				size: "small",
    				label: "input size small"
    			},
    			$$inline: true
    		});

    	formelement1 = new FormElement({
    			props: {
    				inputtype: "text",
    				label: "input size medium (standard)"
    			},
    			$$inline: true
    		});

    	formelement2 = new FormElement({
    			props: {
    				inputtype: "text",
    				size: "large",
    				label: "input size large"
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block_4$1, create_else_block_4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	formelement3 = new FormElement({
    			props: {
    				inputtype: "number",
    				label: "Noget tal indhold her"
    			},
    			$$inline: true
    		});

    	const if_block_creators_1 = [create_if_block_3$1, create_else_block_3$1];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	formelement4 = new FormElement({
    			props: {
    				inputtype: "select",
    				label: "Select",
    				$$slots: { default: [create_default_slot_6$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_2 = [create_if_block_2$2, create_else_block_2$1];
    	const if_blocks_2 = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_2 = select_block_type_2(ctx);
    	if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

    	formelement5 = new FormElement({
    			props: { inputtype: "checkbox", label: "Checkbox" },
    			$$inline: true
    		});

    	formelement6 = new FormElement({
    			props: {
    				inputtype: "radio",
    				label: "Radio",
    				value: 1
    			},
    			$$inline: true
    		});

    	const if_block_creators_3 = [create_if_block_1$5, create_else_block_1$3];
    	const if_blocks_3 = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_3 = select_block_type_3(ctx);
    	if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);

    	formelement7 = new FormElement({
    			props: { inputtype: "textarea", label: "Textarea" },
    			$$inline: true
    		});

    	const if_block_creators_4 = [create_if_block$a, create_else_block$9];
    	const if_blocks_4 = [];

    	function select_block_type_4(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_4 = select_block_type_4(ctx);
    	if_block5 = if_blocks_4[current_block_type_index_4] = if_block_creators_4[current_block_type_index_4](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Form Element";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			h30 = element("h3");
    			h30.textContent = "Text input";
    			t4 = space();
    			create_component(formelement0.$$.fragment);
    			t5 = space();
    			create_component(formelement1.$$.fragment);
    			t6 = space();
    			create_component(formelement2.$$.fragment);
    			t7 = space();
    			if_block1.c();
    			t8 = space();
    			h31 = element("h3");
    			h31.textContent = "Number input";
    			t10 = space();
    			create_component(formelement3.$$.fragment);
    			t11 = space();
    			if_block2.c();
    			t12 = space();
    			h32 = element("h3");
    			h32.textContent = "Select";
    			t14 = space();
    			create_component(formelement4.$$.fragment);
    			t15 = space();
    			if_block3.c();
    			t16 = space();
    			h33 = element("h3");
    			h33.textContent = "Checkbox and radio";
    			t18 = space();
    			create_component(formelement5.$$.fragment);
    			t19 = space();
    			create_component(formelement6.$$.fragment);
    			t20 = space();
    			if_block4.c();
    			t21 = space();
    			h34 = element("h3");
    			h34.textContent = "Textarea";
    			t23 = space();
    			create_component(formelement7.$$.fragment);
    			t24 = space();
    			if_block5.c();
    			if_block5_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$L, 5, 0, 144);
    			add_location(h30, file$L, 13, 0, 325);
    			add_location(h31, file$L, 31, 0, 899);
    			add_location(h32, file$L, 45, 0, 1220);
    			add_location(h33, file$L, 65, 0, 1706);
    			add_location(h34, file$L, 81, 0, 2154);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(formelement0, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(formelement1, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(formelement2, target, anchor);
    			insert_dev(target, t7, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t10, anchor);
    			mount_component(formelement3, target, anchor);
    			insert_dev(target, t11, anchor);
    			if_blocks_1[current_block_type_index_1].m(target, anchor);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t14, anchor);
    			mount_component(formelement4, target, anchor);
    			insert_dev(target, t15, anchor);
    			if_blocks_2[current_block_type_index_2].m(target, anchor);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t18, anchor);
    			mount_component(formelement5, target, anchor);
    			insert_dev(target, t19, anchor);
    			mount_component(formelement6, target, anchor);
    			insert_dev(target, t20, anchor);
    			if_blocks_3[current_block_type_index_3].m(target, anchor);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, h34, anchor);
    			insert_dev(target, t23, anchor);
    			mount_component(formelement7, target, anchor);
    			insert_dev(target, t24, anchor);
    			if_blocks_4[current_block_type_index_4].m(target, anchor);
    			insert_dev(target, if_block5_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$sourceType*/ ctx[0] === 'svelte') {
    				if (if_block0) {
    					if (dirty & /*$sourceType*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(t8.parentNode, t8);
    			}

    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks_1[current_block_type_index_1];

    				if (!if_block2) {
    					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(t12.parentNode, t12);
    			}

    			const formelement4_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				formelement4_changes.$$scope = { dirty, ctx };
    			}

    			formelement4.$set(formelement4_changes);
    			let previous_block_index_2 = current_block_type_index_2;
    			current_block_type_index_2 = select_block_type_2(ctx);

    			if (current_block_type_index_2 !== previous_block_index_2) {
    				group_outros();

    				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
    					if_blocks_2[previous_block_index_2] = null;
    				});

    				check_outros();
    				if_block3 = if_blocks_2[current_block_type_index_2];

    				if (!if_block3) {
    					if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
    					if_block3.c();
    				}

    				transition_in(if_block3, 1);
    				if_block3.m(t16.parentNode, t16);
    			}

    			let previous_block_index_3 = current_block_type_index_3;
    			current_block_type_index_3 = select_block_type_3(ctx);

    			if (current_block_type_index_3 !== previous_block_index_3) {
    				group_outros();

    				transition_out(if_blocks_3[previous_block_index_3], 1, 1, () => {
    					if_blocks_3[previous_block_index_3] = null;
    				});

    				check_outros();
    				if_block4 = if_blocks_3[current_block_type_index_3];

    				if (!if_block4) {
    					if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);
    					if_block4.c();
    				}

    				transition_in(if_block4, 1);
    				if_block4.m(t21.parentNode, t21);
    			}

    			let previous_block_index_4 = current_block_type_index_4;
    			current_block_type_index_4 = select_block_type_4(ctx);

    			if (current_block_type_index_4 !== previous_block_index_4) {
    				group_outros();

    				transition_out(if_blocks_4[previous_block_index_4], 1, 1, () => {
    					if_blocks_4[previous_block_index_4] = null;
    				});

    				check_outros();
    				if_block5 = if_blocks_4[current_block_type_index_4];

    				if (!if_block5) {
    					if_block5 = if_blocks_4[current_block_type_index_4] = if_block_creators_4[current_block_type_index_4](ctx);
    					if_block5.c();
    				}

    				transition_in(if_block5, 1);
    				if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(formelement0.$$.fragment, local);
    			transition_in(formelement1.$$.fragment, local);
    			transition_in(formelement2.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(formelement3.$$.fragment, local);
    			transition_in(if_block2);
    			transition_in(formelement4.$$.fragment, local);
    			transition_in(if_block3);
    			transition_in(formelement5.$$.fragment, local);
    			transition_in(formelement6.$$.fragment, local);
    			transition_in(if_block4);
    			transition_in(formelement7.$$.fragment, local);
    			transition_in(if_block5);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(formelement0.$$.fragment, local);
    			transition_out(formelement1.$$.fragment, local);
    			transition_out(formelement2.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(formelement3.$$.fragment, local);
    			transition_out(if_block2);
    			transition_out(formelement4.$$.fragment, local);
    			transition_out(if_block3);
    			transition_out(formelement5.$$.fragment, local);
    			transition_out(formelement6.$$.fragment, local);
    			transition_out(if_block4);
    			transition_out(formelement7.$$.fragment, local);
    			transition_out(if_block5);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t4);
    			destroy_component(formelement0, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(formelement1, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(formelement2, detaching);
    			if (detaching) detach_dev(t7);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t10);
    			destroy_component(formelement3, detaching);
    			if (detaching) detach_dev(t11);
    			if_blocks_1[current_block_type_index_1].d(detaching);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t14);
    			destroy_component(formelement4, detaching);
    			if (detaching) detach_dev(t15);
    			if_blocks_2[current_block_type_index_2].d(detaching);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t18);
    			destroy_component(formelement5, detaching);
    			if (detaching) detach_dev(t19);
    			destroy_component(formelement6, detaching);
    			if (detaching) detach_dev(t20);
    			if_blocks_3[current_block_type_index_3].d(detaching);
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(h34);
    			if (detaching) detach_dev(t23);
    			destroy_component(formelement7, detaching);
    			if (detaching) detach_dev(t24);
    			if_blocks_4[current_block_type_index_4].d(detaching);
    			if (detaching) detach_dev(if_block5_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FormElement', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FormElement> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		FormElement,
    		sourceType,
    		$sourceType
    	});

    	return [$sourceType];
    }

    class FormElement_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FormElement_1",
    			options,
    			id: create_fragment$L.name
    		});
    	}
    }

    /* docs_src/components/HorizontalScroll.svelte generated by Svelte v3.53.1 */
    const file$K = "docs_src/components/HorizontalScroll.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (64:0) {:else}
    function create_else_block_1$2(ctx) {
    	let p;
    	let t1;
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_8$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "HorizontalScroll krver javascript som findes under list-v2 p eb";
    			t1 = space();
    			create_component(prism.$$.fragment);
    			add_location(p, file$K, 64, 2, 1740);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t1);
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(64:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (41:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$4(ctx) {
    	let prism;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t13;
    	let td3;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_7$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "className";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "string";
    			t12 = space();
    			td2 = element("td");
    			t13 = space();
    			td3 = element("td");
    			add_location(th0, file$K, 48, 8, 1464);
    			add_location(th1, file$K, 49, 8, 1491);
    			add_location(th2, file$K, 50, 8, 1513);
    			add_location(th3, file$K, 51, 8, 1544);
    			add_location(tr0, file$K, 47, 6, 1451);
    			add_location(thead, file$K, 46, 4, 1437);
    			add_location(td0, file$K, 56, 8, 1621);
    			add_location(td1, file$K, 57, 8, 1648);
    			add_location(td2, file$K, 58, 8, 1672);
    			add_location(td3, file$K, 59, 8, 1687);
    			add_location(tr1, file$K, 55, 6, 1608);
    			add_location(tbody, file$K, 54, 4, 1594);
    			attr_dev(table, "class", "table");
    			add_location(table, file$K, 45, 2, 1411);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(41:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (66:2) <Prism language="html">
    function create_default_slot_8$4(ctx) {
    	let t_value = `ekstrabladet/ekstrabladet-publication/src/main/webapp/WEB-INF/jsp/components/list-v2/horizontalscroll.ts` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$4.name,
    		type: "slot",
    		source: "(66:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (42:2) <Prism language="js">
    function create_default_slot_7$5(ctx) {
    	let t_value = `import { HorizontalScroll } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$5.name,
    		type: "slot",
    		source: "(42:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (72:2) {#each multipleArt as article}
    function create_each_block_3(ctx) {
    	let articlecard;
    	let current;
    	const articlecard_spread_levels = [/*article*/ ctx[9], { width: "350px" }];
    	let articlecard_props = {};

    	for (let i = 0; i < articlecard_spread_levels.length; i += 1) {
    		articlecard_props = assign(articlecard_props, articlecard_spread_levels[i]);
    	}

    	articlecard = new ArticleCard({ props: articlecard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(articlecard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(articlecard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const articlecard_changes = (dirty & /*multipleArt*/ 64)
    			? get_spread_update(articlecard_spread_levels, [get_spread_object(/*article*/ ctx[9]), articlecard_spread_levels[1]])
    			: {};

    			articlecard.$set(articlecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(articlecard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(72:2) {#each multipleArt as article}",
    		ctx
    	});

    	return block;
    }

    // (71:0) <HorizontalScroll className="margin-m--b">
    function create_default_slot_6$6(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_3 = /*multipleArt*/ ctx[6];
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*multipleArt*/ 64) {
    				each_value_3 = /*multipleArt*/ ctx[6];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$6.name,
    		type: "slot",
    		source: "(71:0) <HorizontalScroll className=\\\"margin-m--b\\\">",
    		ctx
    	});

    	return block;
    }

    // (78:2) {#each threeArt as article}
    function create_each_block_2$1(ctx) {
    	let articlecard;
    	let current;
    	const articlecard_spread_levels = [/*article*/ ctx[9], { width: "215px" }];
    	let articlecard_props = {};

    	for (let i = 0; i < articlecard_spread_levels.length; i += 1) {
    		articlecard_props = assign(articlecard_props, articlecard_spread_levels[i]);
    	}

    	articlecard = new ArticleCard({ props: articlecard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(articlecard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(articlecard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const articlecard_changes = (dirty & /*threeArt*/ 32)
    			? get_spread_update(articlecard_spread_levels, [get_spread_object(/*article*/ ctx[9]), articlecard_spread_levels[1]])
    			: {};

    			articlecard.$set(articlecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(articlecard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(78:2) {#each threeArt as article}",
    		ctx
    	});

    	return block;
    }

    // (77:0) <HorizontalScroll className="margin-m--b">
    function create_default_slot_5$7(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_2 = /*threeArt*/ ctx[5];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*threeArt*/ 32) {
    				each_value_2 = /*threeArt*/ ctx[5];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$7.name,
    		type: "slot",
    		source: "(77:0) <HorizontalScroll className=\\\"margin-m--b\\\">",
    		ctx
    	});

    	return block;
    }

    // (84:2) {#each doubleArt as article}
    function create_each_block_1$2(ctx) {
    	let articlecard;
    	let current;
    	const articlecard_spread_levels = [/*article*/ ctx[9], { width: "215px" }];
    	let articlecard_props = {};

    	for (let i = 0; i < articlecard_spread_levels.length; i += 1) {
    		articlecard_props = assign(articlecard_props, articlecard_spread_levels[i]);
    	}

    	articlecard = new ArticleCard({ props: articlecard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(articlecard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(articlecard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const articlecard_changes = (dirty & /*doubleArt*/ 16)
    			? get_spread_update(articlecard_spread_levels, [get_spread_object(/*article*/ ctx[9]), articlecard_spread_levels[1]])
    			: {};

    			articlecard.$set(articlecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(articlecard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(84:2) {#each doubleArt as article}",
    		ctx
    	});

    	return block;
    }

    // (83:0) <HorizontalScroll className="margin-m--b">
    function create_default_slot_4$8(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*doubleArt*/ ctx[4];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*doubleArt*/ 16) {
    				each_value_1 = /*doubleArt*/ ctx[4];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$8.name,
    		type: "slot",
    		source: "(83:0) <HorizontalScroll className=\\\"margin-m--b\\\">",
    		ctx
    	});

    	return block;
    }

    // (89:0) <HorizontalScroll className="margin-m--b">
    function create_default_slot_3$8(ctx) {
    	let articlecard;
    	let current;
    	const articlecard_spread_levels = [/*singleArt*/ ctx[3], { width: "215px" }];
    	let articlecard_props = {};

    	for (let i = 0; i < articlecard_spread_levels.length; i += 1) {
    		articlecard_props = assign(articlecard_props, articlecard_spread_levels[i]);
    	}

    	articlecard = new ArticleCard({ props: articlecard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(articlecard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(articlecard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const articlecard_changes = (dirty & /*singleArt*/ 8)
    			? get_spread_update(articlecard_spread_levels, [get_spread_object(/*singleArt*/ ctx[3]), articlecard_spread_levels[1]])
    			: {};

    			articlecard.$set(articlecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(articlecard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$8.name,
    		type: "slot",
    		source: "(89:0) <HorizontalScroll className=\\\"margin-m--b\\\">",
    		ctx
    	});

    	return block;
    }

    // (94:2) {#each $articles as article}
    function create_each_block$7(ctx) {
    	let articlecard;
    	let current;
    	const articlecard_spread_levels = [/*article*/ ctx[9], { width: "215px" }];
    	let articlecard_props = {};

    	for (let i = 0; i < articlecard_spread_levels.length; i += 1) {
    		articlecard_props = assign(articlecard_props, articlecard_spread_levels[i]);
    	}

    	articlecard = new ArticleCard({ props: articlecard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(articlecard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(articlecard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const articlecard_changes = (dirty & /*$articles*/ 2)
    			? get_spread_update(articlecard_spread_levels, [get_spread_object(/*article*/ ctx[9]), articlecard_spread_levels[1]])
    			: {};

    			articlecard.$set(articlecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(articlecard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(94:2) {#each $articles as article}",
    		ctx
    	});

    	return block;
    }

    // (93:0) <HorizontalScroll className="margin-m--b">
    function create_default_slot_2$e(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*$articles*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$articles*/ 2) {
    				each_value = /*$articles*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$e.name,
    		type: "slot",
    		source: "(93:0) <HorizontalScroll className=\\\"margin-m--b\\\">",
    		ctx
    	});

    	return block;
    }

    // (105:0) {:else}
    function create_else_block$8(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(105:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (99:0) {#if $sourceType === 'svelte'}
    function create_if_block$9(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(99:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (106:2) <Prism language="html">
    function create_default_slot_1$j(ctx) {
    	let t_value = `<div id="example-id" class="horizontal-scroll-container position-relative">
  <button data-horizontallist="button-prev" class="horizontal-scroll-nav">
    <svg viewBox="0 0 50 50">
      <use xlink:href="#angle-left"></use>
    </svg>
  </button>
  <button data-horizontallist="button-next" class="horizontal-scroll-nav">
    <svg viewBox="0 0 50 50">
      <use xlink:href="#angle-left"></use>
    </svg>
  </button>
  <div data-horizontallist="itemcontainer" class="horizontal-scroll-items flex">
    ...
  </div>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$j.name,
    		type: "slot",
    		source: "(106:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (100:2) <Prism language="html">
    function create_default_slot$q(ctx) {
    	let t_value = `<HorizontalScroll>
  ...
</HorizontalScroll>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$q.name,
    		type: "slot",
    		source: "(100:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let h1;
    	let t1;
    	let current_block_type_index;
    	let if_block0;
    	let t2;
    	let horizontalscroll0;
    	let t3;
    	let horizontalscroll1;
    	let t4;
    	let horizontalscroll2;
    	let t5;
    	let horizontalscroll3;
    	let t6;
    	let horizontalscroll4;
    	let t7;
    	let current_block_type_index_1;
    	let if_block1;
    	let if_block1_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$4, create_else_block_1$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	horizontalscroll0 = new HorizontalScroll({
    			props: {
    				className: "margin-m--b",
    				$$slots: { default: [create_default_slot_6$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	horizontalscroll1 = new HorizontalScroll({
    			props: {
    				className: "margin-m--b",
    				$$slots: { default: [create_default_slot_5$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	horizontalscroll2 = new HorizontalScroll({
    			props: {
    				className: "margin-m--b",
    				$$slots: { default: [create_default_slot_4$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	horizontalscroll3 = new HorizontalScroll({
    			props: {
    				className: "margin-m--b",
    				$$slots: { default: [create_default_slot_3$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	horizontalscroll4 = new HorizontalScroll({
    			props: {
    				className: "margin-m--b",
    				$$slots: { default: [create_default_slot_2$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_1 = [create_if_block$9, create_else_block$8];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Horizontal Scroll";
    			t1 = space();
    			if_block0.c();
    			t2 = space();
    			create_component(horizontalscroll0.$$.fragment);
    			t3 = space();
    			create_component(horizontalscroll1.$$.fragment);
    			t4 = space();
    			create_component(horizontalscroll2.$$.fragment);
    			t5 = space();
    			create_component(horizontalscroll3.$$.fragment);
    			t6 = space();
    			create_component(horizontalscroll4.$$.fragment);
    			t7 = space();
    			if_block1.c();
    			if_block1_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$K, 39, 0, 1225);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(horizontalscroll0, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(horizontalscroll1, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(horizontalscroll2, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(horizontalscroll3, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(horizontalscroll4, target, anchor);
    			insert_dev(target, t7, anchor);
    			if_blocks_1[current_block_type_index_1].m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(t2.parentNode, t2);
    			}

    			const horizontalscroll0_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				horizontalscroll0_changes.$$scope = { dirty, ctx };
    			}

    			horizontalscroll0.$set(horizontalscroll0_changes);
    			const horizontalscroll1_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				horizontalscroll1_changes.$$scope = { dirty, ctx };
    			}

    			horizontalscroll1.$set(horizontalscroll1_changes);
    			const horizontalscroll2_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				horizontalscroll2_changes.$$scope = { dirty, ctx };
    			}

    			horizontalscroll2.$set(horizontalscroll2_changes);
    			const horizontalscroll3_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				horizontalscroll3_changes.$$scope = { dirty, ctx };
    			}

    			horizontalscroll3.$set(horizontalscroll3_changes);
    			const horizontalscroll4_changes = {};

    			if (dirty & /*$$scope, $articles*/ 262146) {
    				horizontalscroll4_changes.$$scope = { dirty, ctx };
    			}

    			horizontalscroll4.$set(horizontalscroll4_changes);
    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks_1[current_block_type_index_1];

    				if (!if_block1) {
    					if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(horizontalscroll0.$$.fragment, local);
    			transition_in(horizontalscroll1.$$.fragment, local);
    			transition_in(horizontalscroll2.$$.fragment, local);
    			transition_in(horizontalscroll3.$$.fragment, local);
    			transition_in(horizontalscroll4.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(horizontalscroll0.$$.fragment, local);
    			transition_out(horizontalscroll1.$$.fragment, local);
    			transition_out(horizontalscroll2.$$.fragment, local);
    			transition_out(horizontalscroll3.$$.fragment, local);
    			transition_out(horizontalscroll4.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(horizontalscroll0, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(horizontalscroll1, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(horizontalscroll2, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(horizontalscroll3, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(horizontalscroll4, detaching);
    			if (detaching) detach_dev(t7);
    			if_blocks_1[current_block_type_index_1].d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max$1 = 20;

    function instance$J($$self, $$props, $$invalidate) {
    	let $sourceType;
    	let $articles;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('HorizontalScroll', slots, []);
    	const articles = writable([rdmArticleData(640, 360), rdmArticleData(640, 360)]);
    	validate_store(articles, 'articles');
    	component_subscribe($$self, articles, value => $$invalidate(1, $articles = value));
    	let count = 2;

    	const addingInterval = setInterval(
    		() => {
    			if (count < max$1) {
    				articles.update(art => {
    					art.push(rdmArticleData(640, 360));
    					return art;
    				});
    			} else {
    				clearInterval(addingInterval);
    			}

    			count++;
    		},
    		3000
    	);

    	const singleArt = rdmArticleData(640, 360);
    	const doubleArt = [rdmArticleData(640, 360), rdmArticleData(640, 360)];
    	const threeArt = [rdmArticleData(640, 360), rdmArticleData(640, 360), rdmArticleData(640, 360)];

    	const multipleArt = [
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360)
    	];

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<HorizontalScroll> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		writable,
    		rdmArticleData,
    		sourceType,
    		ArticleCard,
    		HorizontalScroll,
    		articles,
    		max: max$1,
    		count,
    		addingInterval,
    		singleArt,
    		doubleArt,
    		threeArt,
    		multipleArt,
    		$sourceType,
    		$articles
    	});

    	$$self.$inject_state = $$props => {
    		if ('count' in $$props) count = $$props.count;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$sourceType, $articles, articles, singleArt, doubleArt, threeArt, multipleArt];
    }

    class HorizontalScroll_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HorizontalScroll_1",
    			options,
    			id: create_fragment$K.name
    		});
    	}
    }

    /* docs_src/assets/dredition/DrEditionSVGs.svelte generated by Svelte v3.53.1 */

    const file$J = "docs_src/assets/dredition/DrEditionSVGs.svelte";

    function create_fragment$J(ctx) {
    	let div1;
    	let div0;
    	let i0;
    	let t1;
    	let table0;
    	let tr0;
    	let th0;
    	let t3;
    	let th1;
    	let t5;
    	let th2;
    	let t7;
    	let tr1;
    	let td0;
    	let t9;
    	let td1;
    	let t11;
    	let td2;
    	let img0;
    	let img0_src_value;
    	let t12;
    	let tr2;
    	let td3;
    	let t14;
    	let td4;
    	let t16;
    	let td5;
    	let img1;
    	let img1_src_value;
    	let t17;
    	let tr3;
    	let td6;
    	let t19;
    	let td7;
    	let t21;
    	let td8;
    	let img2;
    	let img2_src_value;
    	let t22;
    	let tr4;
    	let td9;
    	let t24;
    	let td10;
    	let t26;
    	let td11;
    	let img3;
    	let img3_src_value;
    	let t27;
    	let tr5;
    	let td12;
    	let t29;
    	let td13;
    	let t31;
    	let td14;
    	let img4;
    	let img4_src_value;
    	let t32;
    	let tr6;
    	let td15;
    	let t34;
    	let td16;
    	let t36;
    	let td17;
    	let img5;
    	let img5_src_value;
    	let t37;
    	let tr7;
    	let td18;
    	let t39;
    	let td19;
    	let t41;
    	let td20;
    	let img6;
    	let img6_src_value;
    	let t42;
    	let tr8;
    	let td21;
    	let t44;
    	let td22;
    	let t46;
    	let td23;
    	let img7;
    	let img7_src_value;
    	let t47;
    	let tr9;
    	let td24;
    	let t49;
    	let td25;
    	let t51;
    	let td26;
    	let img8;
    	let img8_src_value;
    	let t52;
    	let tr10;
    	let td27;
    	let t54;
    	let td28;
    	let t56;
    	let td29;
    	let img9;
    	let img9_src_value;
    	let t57;
    	let tr11;
    	let td30;
    	let t59;
    	let td31;
    	let t61;
    	let td32;
    	let img10;
    	let img10_src_value;
    	let t62;
    	let tr12;
    	let td33;
    	let t64;
    	let td34;
    	let t66;
    	let td35;
    	let img11;
    	let img11_src_value;
    	let t67;
    	let tr13;
    	let td36;
    	let t69;
    	let td37;
    	let t71;
    	let td38;
    	let img12;
    	let img12_src_value;
    	let t72;
    	let tr14;
    	let td39;
    	let t74;
    	let td40;
    	let t76;
    	let td41;
    	let img13;
    	let img13_src_value;
    	let t77;
    	let i1;
    	let t79;
    	let table1;
    	let tr15;
    	let th3;
    	let t81;
    	let th4;
    	let t83;
    	let th5;
    	let t85;
    	let tr16;
    	let td42;
    	let t87;
    	let td43;
    	let t89;
    	let td44;
    	let img14;
    	let img14_src_value;
    	let t90;
    	let tr17;
    	let td45;
    	let t92;
    	let td46;
    	let t94;
    	let td47;
    	let img15;
    	let img15_src_value;
    	let t95;
    	let tr18;
    	let td48;
    	let t97;
    	let td49;
    	let t99;
    	let td50;
    	let img16;
    	let img16_src_value;
    	let t100;
    	let tr19;
    	let td51;
    	let t102;
    	let td52;
    	let t104;
    	let td53;
    	let img17;
    	let img17_src_value;
    	let t105;
    	let tr20;
    	let td54;
    	let t107;
    	let td55;
    	let t109;
    	let td56;
    	let img18;
    	let img18_src_value;
    	let t110;
    	let tr21;
    	let td57;
    	let t112;
    	let td58;
    	let t114;
    	let td59;
    	let img19;
    	let img19_src_value;
    	let t115;
    	let tr22;
    	let td60;
    	let t117;
    	let td61;
    	let t119;
    	let td62;
    	let img20;
    	let img20_src_value;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			i0 = element("i");
    			i0.textContent = "Icons left on the article card";
    			t1 = space();
    			table0 = element("table");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Name in DrEdition";
    			t3 = space();
    			th1 = element("th");
    			th1.textContent = "Filename";
    			t5 = space();
    			th2 = element("th");
    			th2.textContent = "Icon";
    			t7 = space();
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "Hvidt plus med sort skygge (Kan bruges p alle baggrunde, der ikke er rde)";
    			t9 = space();
    			td1 = element("td");
    			td1.textContent = "eb-plus-white-onblack-anim.svg";
    			t11 = space();
    			td2 = element("td");
    			img0 = element("img");
    			t12 = space();
    			tr2 = element("tr");
    			td3 = element("td");
    			td3.textContent = "Hvidt plus med rd skygge (Kan bruges p rd baggrund)";
    			t14 = space();
    			td4 = element("td");
    			td4.textContent = "eb-plus-white-onred-anim.svg";
    			t16 = space();
    			td5 = element("td");
    			img1 = element("img");
    			t17 = space();
    			tr3 = element("tr");
    			td6 = element("td");
    			td6.textContent = "Sort plus med hvid skygge (Kan bruges p hvid baggrund)";
    			t19 = space();
    			td7 = element("td");
    			td7.textContent = "eb-plus-black-anim.svg";
    			t21 = space();
    			td8 = element("td");
    			img2 = element("img");
    			t22 = space();
    			tr4 = element("tr");
    			td9 = element("td");
    			td9.textContent = "Lige nu";
    			t24 = space();
    			td10 = element("td");
    			td10.textContent = "ligenu.svg";
    			t26 = space();
    			td11 = element("td");
    			img3 = element("img");
    			t27 = space();
    			tr5 = element("tr");
    			td12 = element("td");
    			td12.textContent = "Breaking";
    			t29 = space();
    			td13 = element("td");
    			td13.textContent = "breaking.svg";
    			t31 = space();
    			td14 = element("td");
    			img4 = element("img");
    			t32 = space();
    			tr6 = element("tr");
    			td15 = element("td");
    			td15.textContent = "Breaking swipe";
    			t34 = space();
    			td16 = element("td");
    			td16.textContent = "breaking-swipe.svg";
    			t36 = space();
    			td17 = element("td");
    			img5 = element("img");
    			t37 = space();
    			tr7 = element("tr");
    			td18 = element("td");
    			td18.textContent = "Af$lring swipe";
    			t39 = space();
    			td19 = element("td");
    			td19.textContent = "afsloering-swipe.svg";
    			t41 = space();
    			td20 = element("td");
    			img6 = element("img");
    			t42 = space();
    			tr8 = element("tr");
    			td21 = element("td");
    			td21.textContent = "AMA live";
    			t44 = space();
    			td22 = element("td");
    			td22.textContent = "ama-live.svg";
    			t46 = space();
    			td23 = element("td");
    			img7 = element("img");
    			t47 = space();
    			tr9 = element("tr");
    			td24 = element("td");
    			td24.textContent = "AMA live opaque";
    			t49 = space();
    			td25 = element("td");
    			td25.textContent = "ama-live-opaque.svg";
    			t51 = space();
    			td26 = element("td");
    			img8 = element("img");
    			t52 = space();
    			tr10 = element("tr");
    			td27 = element("td");
    			td27.textContent = "Liveblog";
    			t54 = space();
    			td28 = element("td");
    			td28.textContent = "liveblog.svg";
    			t56 = space();
    			td29 = element("td");
    			img9 = element("img");
    			t57 = space();
    			tr11 = element("tr");
    			td30 = element("td");
    			td30.textContent = "Liveblog opaque";
    			t59 = space();
    			td31 = element("td");
    			td31.textContent = "liveblog-opaque.svg";
    			t61 = space();
    			td32 = element("td");
    			img10 = element("img");
    			t62 = space();
    			tr12 = element("tr");
    			td33 = element("td");
    			td33.textContent = "live video";
    			t64 = space();
    			td34 = element("td");
    			td34.textContent = "live-video.svg";
    			t66 = space();
    			td35 = element("td");
    			img11 = element("img");
    			t67 = space();
    			tr13 = element("tr");
    			td36 = element("td");
    			td36.textContent = "live video opaque";
    			t69 = space();
    			td37 = element("td");
    			td37.textContent = "live-video-opaque.svg";
    			t71 = space();
    			td38 = element("td");
    			img12 = element("img");
    			t72 = space();
    			tr14 = element("tr");
    			td39 = element("td");
    			td39.textContent = "radar";
    			t74 = space();
    			td40 = element("td");
    			td40.textContent = "radar.svg";
    			t76 = space();
    			td41 = element("td");
    			img13 = element("img");
    			t77 = space();
    			i1 = element("i");
    			i1.textContent = "Icons right on the article card";
    			t79 = space();
    			table1 = element("table");
    			tr15 = element("tr");
    			th3 = element("th");
    			th3.textContent = "Name in DrEdition";
    			t81 = space();
    			th4 = element("th");
    			th4.textContent = "Filename";
    			t83 = space();
    			th5 = element("th");
    			th5.textContent = "Icon";
    			t85 = space();
    			tr16 = element("tr");
    			td42 = element("td");
    			td42.textContent = "ama";
    			t87 = space();
    			td43 = element("td");
    			td43.textContent = "ama-static.svg";
    			t89 = space();
    			td44 = element("td");
    			img14 = element("img");
    			t90 = space();
    			tr17 = element("tr");
    			td45 = element("td");
    			td45.textContent = "Audio";
    			t92 = space();
    			td46 = element("td");
    			td46.textContent = "audio.svg";
    			t94 = space();
    			td47 = element("td");
    			img15 = element("img");
    			t95 = space();
    			tr18 = element("tr");
    			td48 = element("td");
    			td48.textContent = "Plus";
    			t97 = space();
    			td49 = element("td");
    			td49.textContent = "eb-plus.svg";
    			t99 = space();
    			td50 = element("td");
    			img16 = element("img");
    			t100 = space();
    			tr19 = element("tr");
    			td51 = element("td");
    			td51.textContent = "updating";
    			t102 = space();
    			td52 = element("td");
    			td52.textContent = "updating.svg";
    			t104 = space();
    			td53 = element("td");
    			img17 = element("img");
    			t105 = space();
    			tr20 = element("tr");
    			td54 = element("td");
    			td54.textContent = "Updating static";
    			t107 = space();
    			td55 = element("td");
    			td55.textContent = "updating-static.svg";
    			t109 = space();
    			td56 = element("td");
    			img18 = element("img");
    			t110 = space();
    			tr21 = element("tr");
    			td57 = element("td");
    			td57.textContent = "Video";
    			t112 = space();
    			td58 = element("td");
    			td58.textContent = "video.svg";
    			t114 = space();
    			td59 = element("td");
    			img19 = element("img");
    			t115 = space();
    			tr22 = element("tr");
    			td60 = element("td");
    			td60.textContent = "Soccerball";
    			t117 = space();
    			td61 = element("td");
    			td61.textContent = "soccerball.svg";
    			t119 = space();
    			td62 = element("td");
    			img20 = element("img");
    			attr_dev(i0, "class", "margin-m--b");
    			add_location(i0, file$J, 6, 4, 167);
    			attr_dev(th0, "width", "300");
    			attr_dev(th0, "class", "svelte-t5agju");
    			add_location(th0, file$J, 9, 8, 286);
    			attr_dev(th1, "width", "300");
    			attr_dev(th1, "class", "svelte-t5agju");
    			add_location(th1, file$J, 10, 8, 333);
    			attr_dev(th2, "width", "300");
    			attr_dev(th2, "class", "svelte-t5agju");
    			add_location(th2, file$J, 11, 8, 371);
    			add_location(tr0, file$J, 8, 6, 273);
    			attr_dev(td0, "class", "svelte-t5agju");
    			add_location(td0, file$J, 14, 8, 428);
    			attr_dev(td1, "class", "svelte-t5agju");
    			add_location(td1, file$J, 15, 8, 521);
    			attr_dev(img0, "alt", "");
    			if (!src_url_equal(img0.src, img0_src_value = "./svg/dredition/eb-plus-white-onblack-anim.svg")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "height", "50");
    			add_location(img0, file$J, 17, 10, 616);
    			set_style(td2, "background-color", "black");
    			attr_dev(td2, "class", "svelte-t5agju");
    			add_location(td2, file$J, 16, 8, 569);
    			add_location(tr1, file$J, 13, 6, 415);
    			attr_dev(td3, "class", "svelte-t5agju");
    			add_location(td3, file$J, 21, 8, 741);
    			attr_dev(td4, "class", "svelte-t5agju");
    			add_location(td4, file$J, 22, 8, 813);
    			attr_dev(img1, "alt", "");
    			if (!src_url_equal(img1.src, img1_src_value = "./svg/dredition/eb-plus-white-onred-anim.svg")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "height", "50");
    			add_location(img1, file$J, 24, 10, 908);
    			set_style(td5, "background-color", "darkred");
    			attr_dev(td5, "class", "svelte-t5agju");
    			add_location(td5, file$J, 23, 8, 859);
    			add_location(tr2, file$J, 20, 6, 728);
    			attr_dev(td6, "class", "svelte-t5agju");
    			add_location(td6, file$J, 28, 8, 1031);
    			attr_dev(td7, "class", "svelte-t5agju");
    			add_location(td7, file$J, 29, 8, 1104);
    			attr_dev(img2, "alt", "");
    			if (!src_url_equal(img2.src, img2_src_value = "./svg/dredition/eb-plus-black-anim.svg")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "height", "50");
    			add_location(img2, file$J, 31, 10, 1191);
    			set_style(td8, "background-color", "white");
    			attr_dev(td8, "class", "svelte-t5agju");
    			add_location(td8, file$J, 30, 8, 1144);
    			add_location(tr3, file$J, 27, 6, 1018);
    			attr_dev(td9, "class", "svelte-t5agju");
    			add_location(td9, file$J, 35, 8, 1308);
    			attr_dev(td10, "class", "svelte-t5agju");
    			add_location(td10, file$J, 36, 8, 1333);
    			attr_dev(img3, "alt", "");
    			if (!src_url_equal(img3.src, img3_src_value = "./svg/dredition/ligenu.svg")) attr_dev(img3, "src", img3_src_value);
    			add_location(img3, file$J, 38, 10, 1376);
    			attr_dev(td11, "class", "svelte-t5agju");
    			add_location(td11, file$J, 37, 8, 1361);
    			add_location(tr4, file$J, 34, 6, 1295);
    			attr_dev(td12, "class", "svelte-t5agju");
    			add_location(td12, file$J, 42, 8, 1469);
    			attr_dev(td13, "class", "svelte-t5agju");
    			add_location(td13, file$J, 43, 8, 1495);
    			attr_dev(img4, "alt", "");
    			if (!src_url_equal(img4.src, img4_src_value = "./svg/dredition/breaking.svg")) attr_dev(img4, "src", img4_src_value);
    			add_location(img4, file$J, 45, 10, 1540);
    			attr_dev(td14, "class", "svelte-t5agju");
    			add_location(td14, file$J, 44, 8, 1525);
    			add_location(tr5, file$J, 41, 6, 1456);
    			attr_dev(td15, "class", "svelte-t5agju");
    			add_location(td15, file$J, 49, 8, 1635);
    			attr_dev(td16, "class", "svelte-t5agju");
    			add_location(td16, file$J, 50, 8, 1667);
    			attr_dev(img5, "alt", "");
    			if (!src_url_equal(img5.src, img5_src_value = "./svg/dredition/breaking-swipe.svg")) attr_dev(img5, "src", img5_src_value);
    			add_location(img5, file$J, 52, 10, 1718);
    			attr_dev(td17, "class", "svelte-t5agju");
    			add_location(td17, file$J, 51, 8, 1703);
    			add_location(tr6, file$J, 48, 6, 1622);
    			attr_dev(td18, "class", "svelte-t5agju");
    			add_location(td18, file$J, 56, 8, 1819);
    			attr_dev(td19, "class", "svelte-t5agju");
    			add_location(td19, file$J, 57, 8, 1852);
    			attr_dev(img6, "alt", "");
    			if (!src_url_equal(img6.src, img6_src_value = "./svg/dredition/afsloering-swipe.svg")) attr_dev(img6, "src", img6_src_value);
    			add_location(img6, file$J, 59, 10, 1905);
    			attr_dev(td20, "class", "svelte-t5agju");
    			add_location(td20, file$J, 58, 8, 1890);
    			add_location(tr7, file$J, 55, 6, 1806);
    			attr_dev(td21, "class", "svelte-t5agju");
    			add_location(td21, file$J, 63, 8, 2008);
    			attr_dev(td22, "class", "svelte-t5agju");
    			add_location(td22, file$J, 64, 8, 2034);
    			attr_dev(img7, "alt", "");
    			if (!src_url_equal(img7.src, img7_src_value = "./svg/dredition/ama-live.svg")) attr_dev(img7, "src", img7_src_value);
    			add_location(img7, file$J, 66, 10, 2079);
    			attr_dev(td23, "class", "svelte-t5agju");
    			add_location(td23, file$J, 65, 8, 2064);
    			add_location(tr8, file$J, 62, 6, 1995);
    			attr_dev(td24, "class", "svelte-t5agju");
    			add_location(td24, file$J, 70, 8, 2174);
    			attr_dev(td25, "class", "svelte-t5agju");
    			add_location(td25, file$J, 71, 8, 2207);
    			attr_dev(img8, "alt", "");
    			if (!src_url_equal(img8.src, img8_src_value = "./svg/dredition/ama-live-opaque.svg")) attr_dev(img8, "src", img8_src_value);
    			add_location(img8, file$J, 73, 10, 2259);
    			attr_dev(td26, "class", "svelte-t5agju");
    			add_location(td26, file$J, 72, 8, 2244);
    			add_location(tr9, file$J, 69, 6, 2161);
    			attr_dev(td27, "class", "svelte-t5agju");
    			add_location(td27, file$J, 77, 8, 2361);
    			attr_dev(td28, "class", "svelte-t5agju");
    			add_location(td28, file$J, 78, 8, 2387);
    			attr_dev(img9, "alt", "");
    			if (!src_url_equal(img9.src, img9_src_value = "./svg/dredition/liveblog.svg")) attr_dev(img9, "src", img9_src_value);
    			add_location(img9, file$J, 80, 10, 2432);
    			attr_dev(td29, "class", "svelte-t5agju");
    			add_location(td29, file$J, 79, 8, 2417);
    			add_location(tr10, file$J, 76, 6, 2348);
    			attr_dev(td30, "class", "svelte-t5agju");
    			add_location(td30, file$J, 84, 8, 2527);
    			attr_dev(td31, "class", "svelte-t5agju");
    			add_location(td31, file$J, 85, 8, 2560);
    			attr_dev(img10, "alt", "");
    			if (!src_url_equal(img10.src, img10_src_value = "./svg/dredition/liveblog-opaque.svg")) attr_dev(img10, "src", img10_src_value);
    			add_location(img10, file$J, 87, 10, 2612);
    			attr_dev(td32, "class", "svelte-t5agju");
    			add_location(td32, file$J, 86, 8, 2597);
    			add_location(tr11, file$J, 83, 6, 2514);
    			attr_dev(td33, "class", "svelte-t5agju");
    			add_location(td33, file$J, 91, 8, 2714);
    			attr_dev(td34, "class", "svelte-t5agju");
    			add_location(td34, file$J, 92, 8, 2742);
    			attr_dev(img11, "alt", "");
    			if (!src_url_equal(img11.src, img11_src_value = "./svg/dredition/live-video.svg")) attr_dev(img11, "src", img11_src_value);
    			add_location(img11, file$J, 94, 10, 2789);
    			attr_dev(td35, "class", "svelte-t5agju");
    			add_location(td35, file$J, 93, 8, 2774);
    			add_location(tr12, file$J, 90, 6, 2701);
    			attr_dev(td36, "class", "svelte-t5agju");
    			add_location(td36, file$J, 98, 8, 2886);
    			attr_dev(td37, "class", "svelte-t5agju");
    			add_location(td37, file$J, 99, 8, 2921);
    			attr_dev(img12, "alt", "");
    			if (!src_url_equal(img12.src, img12_src_value = "./svg/dredition/live-video-opaque.svg")) attr_dev(img12, "src", img12_src_value);
    			add_location(img12, file$J, 101, 10, 2975);
    			attr_dev(td38, "class", "svelte-t5agju");
    			add_location(td38, file$J, 100, 8, 2960);
    			add_location(tr13, file$J, 97, 6, 2873);
    			attr_dev(td39, "class", "svelte-t5agju");
    			add_location(td39, file$J, 105, 8, 3079);
    			attr_dev(td40, "class", "svelte-t5agju");
    			add_location(td40, file$J, 106, 8, 3102);
    			attr_dev(img13, "alt", "");
    			if (!src_url_equal(img13.src, img13_src_value = "./svg/dredition/radar.svg")) attr_dev(img13, "src", img13_src_value);
    			add_location(img13, file$J, 108, 10, 3144);
    			attr_dev(td41, "class", "svelte-t5agju");
    			add_location(td41, file$J, 107, 8, 3129);
    			add_location(tr14, file$J, 104, 6, 3066);
    			attr_dev(table0, "class", "dredition-table-icons svelte-t5agju");
    			add_location(table0, file$J, 7, 4, 229);
    			attr_dev(i1, "class", "margin-m--b margin-l--t");
    			add_location(i1, file$J, 113, 4, 3235);
    			attr_dev(th3, "width", "300");
    			attr_dev(th3, "class", "svelte-t5agju");
    			add_location(th3, file$J, 117, 8, 3368);
    			attr_dev(th4, "width", "300");
    			attr_dev(th4, "class", "svelte-t5agju");
    			add_location(th4, file$J, 118, 8, 3415);
    			attr_dev(th5, "width", "300");
    			attr_dev(th5, "class", "svelte-t5agju");
    			add_location(th5, file$J, 119, 8, 3453);
    			add_location(tr15, file$J, 116, 6, 3355);
    			attr_dev(td42, "class", "svelte-t5agju");
    			add_location(td42, file$J, 122, 8, 3510);
    			attr_dev(td43, "class", "svelte-t5agju");
    			add_location(td43, file$J, 123, 8, 3531);
    			attr_dev(img14, "alt", "");
    			if (!src_url_equal(img14.src, img14_src_value = "./svg/dredition/ama-static.svg")) attr_dev(img14, "src", img14_src_value);
    			add_location(img14, file$J, 125, 10, 3578);
    			attr_dev(td44, "class", "svelte-t5agju");
    			add_location(td44, file$J, 124, 8, 3563);
    			add_location(tr16, file$J, 121, 6, 3497);
    			attr_dev(td45, "class", "svelte-t5agju");
    			add_location(td45, file$J, 129, 8, 3675);
    			attr_dev(td46, "class", "svelte-t5agju");
    			add_location(td46, file$J, 130, 8, 3698);
    			attr_dev(img15, "alt", "");
    			if (!src_url_equal(img15.src, img15_src_value = "./svg/dredition/audio.svg")) attr_dev(img15, "src", img15_src_value);
    			add_location(img15, file$J, 132, 10, 3740);
    			attr_dev(td47, "class", "svelte-t5agju");
    			add_location(td47, file$J, 131, 8, 3725);
    			add_location(tr17, file$J, 128, 6, 3662);
    			attr_dev(td48, "class", "svelte-t5agju");
    			add_location(td48, file$J, 136, 8, 3832);
    			attr_dev(td49, "class", "svelte-t5agju");
    			add_location(td49, file$J, 137, 8, 3854);
    			attr_dev(img16, "alt", "");
    			if (!src_url_equal(img16.src, img16_src_value = "./svg/dredition/eb-plus.svg")) attr_dev(img16, "src", img16_src_value);
    			add_location(img16, file$J, 139, 10, 3898);
    			attr_dev(td50, "class", "svelte-t5agju");
    			add_location(td50, file$J, 138, 8, 3883);
    			add_location(tr18, file$J, 135, 6, 3819);
    			attr_dev(td51, "class", "svelte-t5agju");
    			add_location(td51, file$J, 143, 8, 3992);
    			attr_dev(td52, "class", "svelte-t5agju");
    			add_location(td52, file$J, 144, 8, 4018);
    			attr_dev(img17, "alt", "");
    			if (!src_url_equal(img17.src, img17_src_value = "./svg/dredition/updating.svg")) attr_dev(img17, "src", img17_src_value);
    			add_location(img17, file$J, 146, 10, 4063);
    			attr_dev(td53, "class", "svelte-t5agju");
    			add_location(td53, file$J, 145, 8, 4048);
    			add_location(tr19, file$J, 142, 6, 3979);
    			attr_dev(td54, "class", "svelte-t5agju");
    			add_location(td54, file$J, 150, 8, 4158);
    			attr_dev(td55, "class", "svelte-t5agju");
    			add_location(td55, file$J, 151, 8, 4191);
    			attr_dev(img18, "alt", "");
    			if (!src_url_equal(img18.src, img18_src_value = "./svg/dredition/updating-static.svg")) attr_dev(img18, "src", img18_src_value);
    			add_location(img18, file$J, 153, 10, 4243);
    			attr_dev(td56, "class", "svelte-t5agju");
    			add_location(td56, file$J, 152, 8, 4228);
    			add_location(tr20, file$J, 149, 6, 4145);
    			attr_dev(td57, "class", "svelte-t5agju");
    			add_location(td57, file$J, 157, 8, 4345);
    			attr_dev(td58, "class", "svelte-t5agju");
    			add_location(td58, file$J, 158, 8, 4368);
    			attr_dev(img19, "alt", "");
    			if (!src_url_equal(img19.src, img19_src_value = "./svg/dredition/video.svg")) attr_dev(img19, "src", img19_src_value);
    			add_location(img19, file$J, 160, 10, 4410);
    			attr_dev(td59, "class", "svelte-t5agju");
    			add_location(td59, file$J, 159, 8, 4395);
    			add_location(tr21, file$J, 156, 6, 4332);
    			attr_dev(td60, "class", "svelte-t5agju");
    			add_location(td60, file$J, 164, 8, 4502);
    			attr_dev(td61, "class", "svelte-t5agju");
    			add_location(td61, file$J, 165, 8, 4530);
    			attr_dev(img20, "alt", "");
    			if (!src_url_equal(img20.src, img20_src_value = "./svg/dredition/soccerball.svg")) attr_dev(img20, "src", img20_src_value);
    			add_location(img20, file$J, 167, 10, 4577);
    			attr_dev(td62, "class", "svelte-t5agju");
    			add_location(td62, file$J, 166, 8, 4562);
    			add_location(tr22, file$J, 163, 6, 4489);
    			attr_dev(table1, "class", "dredition-table-icons svelte-t5agju");
    			add_location(table1, file$J, 115, 4, 3311);
    			attr_dev(div0, "class", "flex flex--column margin-l--b");
    			add_location(div0, file$J, 5, 2, 119);
    			attr_dev(div1, "class", "grid-width--medium");
    			add_location(div1, file$J, 4, 0, 84);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, i0);
    			append_dev(div0, t1);
    			append_dev(div0, table0);
    			append_dev(table0, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t3);
    			append_dev(tr0, th1);
    			append_dev(tr0, t5);
    			append_dev(tr0, th2);
    			append_dev(table0, t7);
    			append_dev(table0, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t9);
    			append_dev(tr1, td1);
    			append_dev(tr1, t11);
    			append_dev(tr1, td2);
    			append_dev(td2, img0);
    			append_dev(table0, t12);
    			append_dev(table0, tr2);
    			append_dev(tr2, td3);
    			append_dev(tr2, t14);
    			append_dev(tr2, td4);
    			append_dev(tr2, t16);
    			append_dev(tr2, td5);
    			append_dev(td5, img1);
    			append_dev(table0, t17);
    			append_dev(table0, tr3);
    			append_dev(tr3, td6);
    			append_dev(tr3, t19);
    			append_dev(tr3, td7);
    			append_dev(tr3, t21);
    			append_dev(tr3, td8);
    			append_dev(td8, img2);
    			append_dev(table0, t22);
    			append_dev(table0, tr4);
    			append_dev(tr4, td9);
    			append_dev(tr4, t24);
    			append_dev(tr4, td10);
    			append_dev(tr4, t26);
    			append_dev(tr4, td11);
    			append_dev(td11, img3);
    			append_dev(table0, t27);
    			append_dev(table0, tr5);
    			append_dev(tr5, td12);
    			append_dev(tr5, t29);
    			append_dev(tr5, td13);
    			append_dev(tr5, t31);
    			append_dev(tr5, td14);
    			append_dev(td14, img4);
    			append_dev(table0, t32);
    			append_dev(table0, tr6);
    			append_dev(tr6, td15);
    			append_dev(tr6, t34);
    			append_dev(tr6, td16);
    			append_dev(tr6, t36);
    			append_dev(tr6, td17);
    			append_dev(td17, img5);
    			append_dev(table0, t37);
    			append_dev(table0, tr7);
    			append_dev(tr7, td18);
    			append_dev(tr7, t39);
    			append_dev(tr7, td19);
    			append_dev(tr7, t41);
    			append_dev(tr7, td20);
    			append_dev(td20, img6);
    			append_dev(table0, t42);
    			append_dev(table0, tr8);
    			append_dev(tr8, td21);
    			append_dev(tr8, t44);
    			append_dev(tr8, td22);
    			append_dev(tr8, t46);
    			append_dev(tr8, td23);
    			append_dev(td23, img7);
    			append_dev(table0, t47);
    			append_dev(table0, tr9);
    			append_dev(tr9, td24);
    			append_dev(tr9, t49);
    			append_dev(tr9, td25);
    			append_dev(tr9, t51);
    			append_dev(tr9, td26);
    			append_dev(td26, img8);
    			append_dev(table0, t52);
    			append_dev(table0, tr10);
    			append_dev(tr10, td27);
    			append_dev(tr10, t54);
    			append_dev(tr10, td28);
    			append_dev(tr10, t56);
    			append_dev(tr10, td29);
    			append_dev(td29, img9);
    			append_dev(table0, t57);
    			append_dev(table0, tr11);
    			append_dev(tr11, td30);
    			append_dev(tr11, t59);
    			append_dev(tr11, td31);
    			append_dev(tr11, t61);
    			append_dev(tr11, td32);
    			append_dev(td32, img10);
    			append_dev(table0, t62);
    			append_dev(table0, tr12);
    			append_dev(tr12, td33);
    			append_dev(tr12, t64);
    			append_dev(tr12, td34);
    			append_dev(tr12, t66);
    			append_dev(tr12, td35);
    			append_dev(td35, img11);
    			append_dev(table0, t67);
    			append_dev(table0, tr13);
    			append_dev(tr13, td36);
    			append_dev(tr13, t69);
    			append_dev(tr13, td37);
    			append_dev(tr13, t71);
    			append_dev(tr13, td38);
    			append_dev(td38, img12);
    			append_dev(table0, t72);
    			append_dev(table0, tr14);
    			append_dev(tr14, td39);
    			append_dev(tr14, t74);
    			append_dev(tr14, td40);
    			append_dev(tr14, t76);
    			append_dev(tr14, td41);
    			append_dev(td41, img13);
    			append_dev(div0, t77);
    			append_dev(div0, i1);
    			append_dev(div0, t79);
    			append_dev(div0, table1);
    			append_dev(table1, tr15);
    			append_dev(tr15, th3);
    			append_dev(tr15, t81);
    			append_dev(tr15, th4);
    			append_dev(tr15, t83);
    			append_dev(tr15, th5);
    			append_dev(table1, t85);
    			append_dev(table1, tr16);
    			append_dev(tr16, td42);
    			append_dev(tr16, t87);
    			append_dev(tr16, td43);
    			append_dev(tr16, t89);
    			append_dev(tr16, td44);
    			append_dev(td44, img14);
    			append_dev(table1, t90);
    			append_dev(table1, tr17);
    			append_dev(tr17, td45);
    			append_dev(tr17, t92);
    			append_dev(tr17, td46);
    			append_dev(tr17, t94);
    			append_dev(tr17, td47);
    			append_dev(td47, img15);
    			append_dev(table1, t95);
    			append_dev(table1, tr18);
    			append_dev(tr18, td48);
    			append_dev(tr18, t97);
    			append_dev(tr18, td49);
    			append_dev(tr18, t99);
    			append_dev(tr18, td50);
    			append_dev(td50, img16);
    			append_dev(table1, t100);
    			append_dev(table1, tr19);
    			append_dev(tr19, td51);
    			append_dev(tr19, t102);
    			append_dev(tr19, td52);
    			append_dev(tr19, t104);
    			append_dev(tr19, td53);
    			append_dev(td53, img17);
    			append_dev(table1, t105);
    			append_dev(table1, tr20);
    			append_dev(tr20, td54);
    			append_dev(tr20, t107);
    			append_dev(tr20, td55);
    			append_dev(tr20, t109);
    			append_dev(tr20, td56);
    			append_dev(td56, img18);
    			append_dev(table1, t110);
    			append_dev(table1, tr21);
    			append_dev(tr21, td57);
    			append_dev(tr21, t112);
    			append_dev(tr21, td58);
    			append_dev(tr21, t114);
    			append_dev(tr21, td59);
    			append_dev(td59, img19);
    			append_dev(table1, t115);
    			append_dev(table1, tr22);
    			append_dev(tr22, td60);
    			append_dev(tr22, t117);
    			append_dev(tr22, td61);
    			append_dev(tr22, t119);
    			append_dev(tr22, td62);
    			append_dev(td62, img20);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DrEditionSVGs', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DrEditionSVGs> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class DrEditionSVGs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$J, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DrEditionSVGs",
    			options,
    			id: create_fragment$J.name
    		});
    	}
    }

    const graphicnameshtml = ['ebplus-black', 'ebplus-white-blackshadow', 'ebplus-white', 'ekstrabladet', 'figcaption-pin', 'video-graphic'];

    const iconnameshtml = ['angle-down', 'angle-left', 'angle-right', 'angle-up', 'arrow-down', 'arrow-left', 'arrow-right', 'arrow-up', 'article', 'at', 'bell', 'bookmark-solid', 'bookmark', 'calendar', 'camera-solid', 'camera', 'chart-bar', 'check-circle-solid', 'check-circle', 'check-square-solid', 'check-square', 'check', 'circle-notch', 'circle-solid', 'circle', 'clock', 'cog-solid', 'cog', 'comment-solid', 'comment', 'comments-solid', 'creditcard-solid', 'creditcard', 'desktop', 'dot-circle', 'ebplus-circle-solid', 'ebplus', 'edit', 'envelope', 'exclamation-circle-solid', 'exclamation-circle', 'exclamation-triangle-solid', 'exclamation-triangle', 'expand', 'external-link', 'facebook', 'filter-solid', 'futbol', 'gallery', 'headphones', 'headset', 'heart-half-solid', 'heart-solid', 'heart', 'history', 'info-circle-solid', 'info-circle', 'instagram', 'lightning', 'linkedin', 'list-ol', 'lock', 'mappin-solid', 'medielogin', 'menubars-solid', 'menubars', 'miteb-solid', 'miteb', 'newspaper', 'pause-circle', 'phone', 'pin-solid', 'play-circle', 'question-circle', 'rss-symbol', 'rss', 'search', 'smartphone', 'square', 'star-half-solid', 'star-solid', 'star', 'sync', 'tablet', 'tag-solid', 'tag', 'tags-solid', 'tags', 'times-circle-solid', 'times-circle', 'times', 'toggle-off', 'toggle-on', 'trash-solid', 'trash', 'twitter', 'user-circle-solid', 'user-circle', 'user-solid', 'users', 'video', 'volume-muted-solid', 'volume-up-solid', 'youtube'];

    /* svelte/components/icon/Icon.svelte generated by Svelte v3.53.1 */

    const file$I = "svelte/components/icon/Icon.svelte";

    // (10:0) {#if name}
    function create_if_block$8(ctx) {
    	let svg;
    	let use;
    	let use_xlink_href_value;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			use = svg_element("use");
    			xlink_attr(use, "xlink:href", use_xlink_href_value = "#" + /*name*/ ctx[0]);
    			add_location(use, file$I, 11, 4, 412);
    			attr_dev(svg, "style", /*styleAttr*/ ctx[1]);
    			attr_dev(svg, "class", /*baseClass*/ ctx[2]);
    			attr_dev(svg, "viewBox", "0 0 14 14");
    			add_location(svg, file$I, 10, 2, 346);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, use);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*name*/ 1 && use_xlink_href_value !== (use_xlink_href_value = "#" + /*name*/ ctx[0])) {
    				xlink_attr(use, "xlink:href", use_xlink_href_value);
    			}

    			if (dirty & /*styleAttr*/ 2) {
    				attr_dev(svg, "style", /*styleAttr*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(10:0) {#if name}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let if_block_anchor;
    	let if_block = /*name*/ ctx[0] && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*name*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let cssWidth;
    	let styleAttr;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Icon', slots, []);
    	let { className = undefined } = $$props;
    	let { name = undefined } = $$props;
    	let { width = undefined } = $$props;
    	let { style = undefined } = $$props;
    	const baseClass = className ? `icon-svg ${className}` : 'icon-svg';
    	const writable_props = ['className', 'name', 'width', 'style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Icon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(3, className = $$props.className);
    		if ('name' in $$props) $$invalidate(0, name = $$props.name);
    		if ('width' in $$props) $$invalidate(4, width = $$props.width);
    		if ('style' in $$props) $$invalidate(5, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		name,
    		width,
    		style,
    		baseClass,
    		cssWidth,
    		styleAttr
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(3, className = $$props.className);
    		if ('name' in $$props) $$invalidate(0, name = $$props.name);
    		if ('width' in $$props) $$invalidate(4, width = $$props.width);
    		if ('style' in $$props) $$invalidate(5, style = $$props.style);
    		if ('cssWidth' in $$props) $$invalidate(6, cssWidth = $$props.cssWidth);
    		if ('styleAttr' in $$props) $$invalidate(1, styleAttr = $$props.styleAttr);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*width*/ 16) {
    			$$invalidate(6, cssWidth = width ? `--icon-size: ${width}px;` : '');
    		}

    		if ($$self.$$.dirty & /*style, cssWidth*/ 96) {
    			$$invalidate(1, styleAttr = style ? `${cssWidth} ${style}` : cssWidth);
    		}
    	};

    	return [name, styleAttr, baseClass, className, width, style, cssWidth];
    }

    class Icon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$H, create_fragment$I, safe_not_equal, {
    			className: 3,
    			name: 0,
    			width: 4,
    			style: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon",
    			options,
    			id: create_fragment$I.name
    		});
    	}

    	get className() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var SCROLLDIRECTION;
    (function (SCROLLDIRECTION) {
        SCROLLDIRECTION[SCROLLDIRECTION["left"] = 0] = "left";
        SCROLLDIRECTION[SCROLLDIRECTION["right"] = 1] = "right";
    })(SCROLLDIRECTION || (SCROLLDIRECTION = {}));
    var BLOCKING;
    (function (BLOCKING) {
        BLOCKING[BLOCKING["disabled"] = 0] = "disabled";
        BLOCKING[BLOCKING["enabled"] = 1] = "enabled";
    })(BLOCKING || (BLOCKING = {}));
    var SCROLLPOS;
    (function (SCROLLPOS) {
        SCROLLPOS[SCROLLPOS["disabled"] = 0] = "disabled";
        SCROLLPOS[SCROLLPOS["end"] = 1] = "end";
        SCROLLPOS[SCROLLPOS["neutral"] = 2] = "neutral";
        SCROLLPOS[SCROLLPOS["start"] = 3] = "start";
        SCROLLPOS[SCROLLPOS["unset"] = 4] = "unset";
    })(SCROLLPOS || (SCROLLPOS = {}));

    /* svelte/components/buttongroup/ButtonGroup.svelte generated by Svelte v3.53.1 */

    const BUTTONS = {};

    /* svelte/components/button/Button.svelte generated by Svelte v3.53.1 */
    const file$H = "svelte/components/button/Button.svelte";

    // (53:0) {:else}
    function create_else_block$7(ctx) {
    	let button;
    	let button_data_selected_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();
    			attr_dev(button, "class", /*cssClass*/ ctx[5]);
    			button.disabled = /*disabled*/ ctx[0];
    			attr_dev(button, "data-selected", button_data_selected_value = /*$selectedButton*/ ctx[6] === /*contextButton*/ ctx[3]);
    			add_location(button, file$H, 53, 2, 1522);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			/*button_binding*/ ctx[18](button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[16], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 32) {
    				attr_dev(button, "class", /*cssClass*/ ctx[5]);
    			}

    			if (!current || dirty & /*disabled*/ 1) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[0]);
    			}

    			if (!current || dirty & /*$selectedButton, contextButton*/ 72 && button_data_selected_value !== (button_data_selected_value = /*$selectedButton*/ ctx[6] === /*contextButton*/ ctx[3])) {
    				attr_dev(button, "data-selected", button_data_selected_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			/*button_binding*/ ctx[18](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(53:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (49:0) {#if href}
    function create_if_block$7(ctx) {
    	let a;
    	let a_data_selected_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			attr_dev(a, "href", /*href*/ ctx[1]);
    			attr_dev(a, "class", /*cssClass*/ ctx[5]);
    			attr_dev(a, "disabled", /*disabled*/ ctx[0]);
    			attr_dev(a, "data-selected", a_data_selected_value = /*$selectedButton*/ ctx[6] === /*contextButton*/ ctx[3]);
    			add_location(a, file$H, 49, 2, 1373);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			/*a_binding*/ ctx[17](a);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[15], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*href*/ 2) {
    				attr_dev(a, "href", /*href*/ ctx[1]);
    			}

    			if (!current || dirty & /*cssClass*/ 32) {
    				attr_dev(a, "class", /*cssClass*/ ctx[5]);
    			}

    			if (!current || dirty & /*disabled*/ 1) {
    				attr_dev(a, "disabled", /*disabled*/ ctx[0]);
    			}

    			if (!current || dirty & /*$selectedButton, contextButton*/ 72 && a_data_selected_value !== (a_data_selected_value = /*$selectedButton*/ ctx[6] === /*contextButton*/ ctx[3])) {
    				attr_dev(a, "data-selected", a_data_selected_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			/*a_binding*/ ctx[17](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(49:0) {#if href}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$7, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*href*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let cssClass;

    	let $selectedButton,
    		$$unsubscribe_selectedButton = noop,
    		$$subscribe_selectedButton = () => ($$unsubscribe_selectedButton(), $$unsubscribe_selectedButton = subscribe(selectedButton, $$value => $$invalidate(6, $selectedButton = $$value)), selectedButton);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_selectedButton());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, ['default']);
    	let { className = undefined } = $$props;
    	let { disabled = false } = $$props;
    	let { extension = undefined } = $$props;
    	let { href = undefined } = $$props;
    	let { size = undefined } = $$props;
    	let { type = undefined } = $$props;
    	let baseClass = 'button';

    	if (extension) {
    		const extSplit = extension.split(' ');

    		extSplit.forEach(extClass => {
    			$$invalidate(12, baseClass = `${baseClass} button--${extClass}`);
    		});
    	}

    	if (size) {
    		baseClass = `${baseClass} button--${size}`;
    	}

    	if (type) {
    		baseClass = `${baseClass} button--${type}`;
    	}

    	let buttonEl;
    	let { initial = false } = $$props;
    	let contextButton;
    	let selectButton;
    	let selectedButton;
    	const contextButtons = getContext(BUTTONS);

    	if (contextButtons) {
    		const registerButton = contextButtons.registerButton;
    		contextButton = contextButtons.createContextButton();
    		selectButton = contextButtons.selectButton;
    		$$subscribe_selectedButton(selectedButton = contextButtons.selectedButton);
    		registerButton(contextButton);

    		if (initial) {
    			selectButton(contextButton);
    		}
    	}

    	onMount(() => {
    		if (typeof selectButton !== 'undefined') {
    			buttonEl.addEventListener('click', () => selectButton(contextButton));
    		}
    	});

    	const writable_props = ['className', 'disabled', 'extension', 'href', 'size', 'type', 'initial'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Button> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			buttonEl = $$value;
    			$$invalidate(2, buttonEl);
    		});
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			buttonEl = $$value;
    			$$invalidate(2, buttonEl);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(7, className = $$props.className);
    		if ('disabled' in $$props) $$invalidate(0, disabled = $$props.disabled);
    		if ('extension' in $$props) $$invalidate(8, extension = $$props.extension);
    		if ('href' in $$props) $$invalidate(1, href = $$props.href);
    		if ('size' in $$props) $$invalidate(9, size = $$props.size);
    		if ('type' in $$props) $$invalidate(10, type = $$props.type);
    		if ('initial' in $$props) $$invalidate(11, initial = $$props.initial);
    		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		disabled,
    		extension,
    		href,
    		size,
    		type,
    		baseClass,
    		buttonEl,
    		getContext,
    		onMount,
    		BUTTONS,
    		initial,
    		contextButton,
    		selectButton,
    		selectedButton,
    		contextButtons,
    		cssClass,
    		$selectedButton
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(7, className = $$props.className);
    		if ('disabled' in $$props) $$invalidate(0, disabled = $$props.disabled);
    		if ('extension' in $$props) $$invalidate(8, extension = $$props.extension);
    		if ('href' in $$props) $$invalidate(1, href = $$props.href);
    		if ('size' in $$props) $$invalidate(9, size = $$props.size);
    		if ('type' in $$props) $$invalidate(10, type = $$props.type);
    		if ('baseClass' in $$props) $$invalidate(12, baseClass = $$props.baseClass);
    		if ('buttonEl' in $$props) $$invalidate(2, buttonEl = $$props.buttonEl);
    		if ('initial' in $$props) $$invalidate(11, initial = $$props.initial);
    		if ('contextButton' in $$props) $$invalidate(3, contextButton = $$props.contextButton);
    		if ('selectButton' in $$props) selectButton = $$props.selectButton;
    		if ('selectedButton' in $$props) $$subscribe_selectedButton($$invalidate(4, selectedButton = $$props.selectedButton));
    		if ('cssClass' in $$props) $$invalidate(5, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, baseClass*/ 4224) {
    			$$invalidate(5, cssClass = className ? `${baseClass} ${className}` : baseClass);
    		}
    	};

    	return [
    		disabled,
    		href,
    		buttonEl,
    		contextButton,
    		selectedButton,
    		cssClass,
    		$selectedButton,
    		className,
    		extension,
    		size,
    		type,
    		initial,
    		baseClass,
    		$$scope,
    		slots,
    		click_handler,
    		click_handler_1,
    		a_binding,
    		button_binding
    	];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$G, create_fragment$H, safe_not_equal, {
    			className: 7,
    			disabled: 0,
    			extension: 8,
    			href: 1,
    			size: 9,
    			type: 10,
    			initial: 11
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$H.name
    		});
    	}

    	get className() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get extension() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set extension(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get initial() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set initial(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* docs_src/components/Icon.svelte generated by Svelte v3.53.1 */

    const { Object: Object_1 } = globals;
    const file$G = "docs_src/components/Icon.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (20:0) {#if $sourceType === 'svelte'}
    function create_if_block_2$1(ctx) {
    	let prism;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t13;
    	let td3;
    	let t15;
    	let tr2;
    	let td4;
    	let t16;
    	let span;
    	let t18;
    	let td5;
    	let t20;
    	let td6;
    	let t21;
    	let td7;
    	let t23;
    	let tr3;
    	let td8;
    	let t25;
    	let td9;
    	let t27;
    	let td10;
    	let t29;
    	let td11;
    	let t31;
    	let tr4;
    	let td12;
    	let t33;
    	let td13;
    	let t35;
    	let td14;
    	let t37;
    	let td15;
    	let t39;
    	let tr5;
    	let td16;
    	let t41;
    	let td17;
    	let t43;
    	let td18;
    	let t44;
    	let td19;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_6$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "className";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "string";
    			t12 = space();
    			td2 = element("td");
    			t13 = space();
    			td3 = element("td");
    			td3.textContent = "Custom class names";
    			t15 = space();
    			tr2 = element("tr");
    			td4 = element("td");
    			t16 = text("name ");
    			span = element("span");
    			span.textContent = "required";
    			t18 = space();
    			td5 = element("td");
    			td5.textContent = "IconTypes";
    			t20 = space();
    			td6 = element("td");
    			t21 = space();
    			td7 = element("td");
    			td7.textContent = "Only names listed beneath are valid";
    			t23 = space();
    			tr3 = element("tr");
    			td8 = element("td");
    			td8.textContent = "type";
    			t25 = space();
    			td9 = element("td");
    			td9.textContent = "'svg'";
    			t27 = space();
    			td10 = element("td");
    			td10.textContent = "svg";
    			t29 = space();
    			td11 = element("td");
    			td11.textContent = "Use EB svg icons";
    			t31 = space();
    			tr4 = element("tr");
    			td12 = element("td");
    			td12.textContent = "width";
    			t33 = space();
    			td13 = element("td");
    			td13.textContent = "number";
    			t35 = space();
    			td14 = element("td");
    			td14.textContent = "36";
    			t37 = space();
    			td15 = element("td");
    			td15.textContent = "The width of the icon in pixels";
    			t39 = space();
    			tr5 = element("tr");
    			td16 = element("td");
    			td16.textContent = "style";
    			t41 = space();
    			td17 = element("td");
    			td17.textContent = "string";
    			t43 = space();
    			td18 = element("td");
    			t44 = space();
    			td19 = element("td");
    			td19.textContent = "Custom styling";
    			add_location(th0, file$G, 27, 8, 796);
    			add_location(th1, file$G, 28, 8, 823);
    			add_location(th2, file$G, 29, 8, 845);
    			add_location(th3, file$G, 30, 8, 876);
    			add_location(tr0, file$G, 26, 6, 783);
    			add_location(thead, file$G, 25, 4, 769);
    			add_location(td0, file$G, 35, 8, 953);
    			add_location(td1, file$G, 36, 8, 980);
    			add_location(td2, file$G, 37, 8, 1004);
    			add_location(td3, file$G, 38, 8, 1019);
    			add_location(tr1, file$G, 34, 6, 940);
    			attr_dev(span, "class", "badge badge--small");
    			attr_dev(span, "data-type", "primary");
    			add_location(span, file$G, 41, 17, 1087);
    			add_location(td4, file$G, 41, 8, 1078);
    			add_location(td5, file$G, 42, 8, 1169);
    			add_location(td6, file$G, 43, 8, 1196);
    			add_location(td7, file$G, 44, 8, 1211);
    			add_location(tr2, file$G, 40, 6, 1065);
    			add_location(td8, file$G, 47, 8, 1287);
    			add_location(td9, file$G, 48, 8, 1309);
    			add_location(td10, file$G, 49, 8, 1332);
    			add_location(td11, file$G, 50, 8, 1353);
    			add_location(tr3, file$G, 46, 6, 1274);
    			add_location(td12, file$G, 53, 8, 1410);
    			add_location(td13, file$G, 54, 8, 1433);
    			add_location(td14, file$G, 55, 8, 1457);
    			add_location(td15, file$G, 56, 8, 1477);
    			add_location(tr4, file$G, 52, 6, 1397);
    			add_location(td16, file$G, 59, 8, 1549);
    			add_location(td17, file$G, 60, 8, 1572);
    			add_location(td18, file$G, 61, 8, 1596);
    			add_location(td19, file$G, 62, 8, 1611);
    			add_location(tr5, file$G, 58, 6, 1536);
    			add_location(tbody, file$G, 33, 4, 926);
    			attr_dev(table, "class", "table");
    			add_location(table, file$G, 24, 2, 743);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			append_dev(tbody, t15);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td4);
    			append_dev(td4, t16);
    			append_dev(td4, span);
    			append_dev(tr2, t18);
    			append_dev(tr2, td5);
    			append_dev(tr2, t20);
    			append_dev(tr2, td6);
    			append_dev(tr2, t21);
    			append_dev(tr2, td7);
    			append_dev(tbody, t23);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td8);
    			append_dev(tr3, t25);
    			append_dev(tr3, td9);
    			append_dev(tr3, t27);
    			append_dev(tr3, td10);
    			append_dev(tr3, t29);
    			append_dev(tr3, td11);
    			append_dev(tbody, t31);
    			append_dev(tbody, tr4);
    			append_dev(tr4, td12);
    			append_dev(tr4, t33);
    			append_dev(tr4, td13);
    			append_dev(tr4, t35);
    			append_dev(tr4, td14);
    			append_dev(tr4, t37);
    			append_dev(tr4, td15);
    			append_dev(tbody, t39);
    			append_dev(tbody, tr5);
    			append_dev(tr5, td16);
    			append_dev(tr5, t41);
    			append_dev(tr5, td17);
    			append_dev(tr5, t43);
    			append_dev(tr5, td18);
    			append_dev(tr5, t44);
    			append_dev(tr5, td19);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(20:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (21:2) <Prism language="js">
    function create_default_slot_6$5(ctx) {
    	let t_value = `import { Icon } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$5.name,
    		type: "slot",
    		source: "(21:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (86:6) {#each Object.keys(colorNames) as colorName}
    function create_each_block_2(ctx) {
    	let option;
    	let t_value = /*colorName*/ ctx[11] + "";
    	let t;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = /*colorName*/ ctx[11];
    			option.value = option.__value;
    			add_location(option, file$G, 86, 8, 2505);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(86:6) {#each Object.keys(colorNames) as colorName}",
    		ctx
    	});

    	return block;
    }

    // (91:2) <Button className="margin-m--r" type="cancel" on:click={decrement}>
    function create_default_slot_5$6(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: { name: "angle-left", width: 18 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$6.name,
    		type: "slot",
    		source: "(91:2) <Button className=\\\"margin-m--r\\\" type=\\\"cancel\\\" on:click={decrement}>",
    		ctx
    	});

    	return block;
    }

    // (95:2) <Button className="margin-m--l" type="cancel" on:click={increment}>
    function create_default_slot_4$7(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: { name: "angle-right", width: 18 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$7.name,
    		type: "slot",
    		source: "(95:2) <Button className=\\\"margin-m--l\\\" type=\\\"cancel\\\" on:click={increment}>",
    		ctx
    	});

    	return block;
    }

    // (100:2) {#each iconnameshtml as name, i}
    function create_each_block_1$1(ctx) {
    	let div;
    	let icon;
    	let t0;
    	let small;
    	let t1_value = iconnameshtml[/*i*/ ctx[9]] + "";
    	let t1;
    	let t2;
    	let current;

    	icon = new Icon({
    			props: {
    				name: /*name*/ ctx[7],
    				className: "margin-s",
    				width: /*size*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(icon.$$.fragment);
    			t0 = space();
    			small = element("small");
    			t1 = text(t1_value);
    			t2 = space();
    			add_location(small, file$G, 102, 6, 3179);
    			attr_dev(div, "class", "card flex-align--center flex-justify--center margin-s padding-m bg--graa6");
    			add_location(div, file$G, 100, 4, 3029);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(icon, div, null);
    			append_dev(div, t0);
    			append_dev(div, small);
    			append_dev(small, t1);
    			append_dev(div, t2);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};
    			if (dirty & /*size*/ 2) icon_changes.width = /*size*/ ctx[1];
    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(100:2) {#each iconnameshtml as name, i}",
    		ctx
    	});

    	return block;
    }

    // (112:0) {:else}
    function create_else_block_1$1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_3$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(112:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (108:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(108:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (113:2) <Prism language="html">
    function create_default_slot_3$7(ctx) {
    	let t_value = `<svg class="icon-svg" viewBox="0 0 50 50">
  <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#icon-name"></use>
</svg>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$7.name,
    		type: "slot",
    		source: "(113:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (109:2) <Prism language="html">
    function create_default_slot_2$d(ctx) {
    	let t_value = `<Icon name="iconname" />` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$d.name,
    		type: "slot",
    		source: "(109:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:2) {#each graphicnameshtml as name, i}
    function create_each_block$6(ctx) {
    	let div;
    	let icon;
    	let t0;
    	let small;
    	let t1_value = graphicnameshtml[/*i*/ ctx[9]] + "";
    	let t1;
    	let t2;
    	let current;

    	icon = new Icon({
    			props: {
    				name: /*name*/ ctx[7],
    				className: "margin-s",
    				width: 86
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(icon.$$.fragment);
    			t0 = space();
    			small = element("small");
    			t1 = text(t1_value);
    			t2 = space();
    			add_location(small, file$G, 126, 6, 3870);
    			attr_dev(div, "class", "card flex-align--center flex-justify--center margin-s padding-m bg--graa6");
    			add_location(div, file$G, 124, 4, 3722);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(icon, div, null);
    			append_dev(div, t0);
    			append_dev(div, small);
    			append_dev(small, t1);
    			append_dev(div, t2);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(124:2) {#each graphicnameshtml as name, i}",
    		ctx
    	});

    	return block;
    }

    // (136:0) {:else}
    function create_else_block$6(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(136:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (132:0) {#if $sourceType === 'svelte'}
    function create_if_block$6(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(132:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (137:2) <Prism language="html">
    function create_default_slot_1$i(ctx) {
    	let t_value = `<svg class="icon-svg" viewBox="0 0 50 50">
  <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#icon-name"></use>
</svg>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$i.name,
    		type: "slot",
    		source: "(137:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (133:2) <Prism language="html">
    function create_default_slot$p(ctx) {
    	let t_value = `<Icon name="iconname" />` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$p.name,
    		type: "slot",
    		source: "(133:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let h1;
    	let t1;
    	let t2;
    	let h30;
    	let t4;
    	let p0;
    	let t5;
    	let em0;
    	let t7;
    	let em1;
    	let t9;
    	let em2;
    	let t11;
    	let t12;
    	let p1;
    	let t14;
    	let p2;
    	let t15;
    	let a;
    	let t17;
    	let b0;
    	let t19;
    	let b1;
    	let t21;
    	let t22;
    	let div1;
    	let div0;
    	let t23;
    	let select;
    	let option;
    	let t25;
    	let button0;
    	let t26;
    	let p3;
    	let t27;
    	let input;
    	let t28;
    	let t29;
    	let button1;
    	let t30;
    	let div2;
    	let t31;
    	let current_block_type_index;
    	let if_block1;
    	let t32;
    	let h31;
    	let t34;
    	let p4;
    	let t36;
    	let div3;
    	let t37;
    	let current_block_type_index_1;
    	let if_block2;
    	let t38;
    	let h32;
    	let t40;
    	let p5;
    	let t41;
    	let em3;
    	let t43;
    	let div5;
    	let div4;
    	let icon;
    	let t44;
    	let small;
    	let t46;
    	let h33;
    	let t48;
    	let p6;
    	let t50;
    	let dreditionsvgs;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*$sourceType*/ ctx[2] === 'svelte' && create_if_block_2$1(ctx);
    	let each_value_2 = Object.keys(colorNames);
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_2[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	button0 = new Button({
    			props: {
    				className: "margin-m--r",
    				type: "cancel",
    				$$slots: { default: [create_default_slot_5$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*decrement*/ ctx[3]);

    	button1 = new Button({
    			props: {
    				className: "margin-m--l",
    				type: "cancel",
    				$$slots: { default: [create_default_slot_4$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*increment*/ ctx[4]);
    	let each_value_1 = iconnameshtml;
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	const if_block_creators = [create_if_block_1$3, create_else_block_1$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[2] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let each_value = graphicnameshtml;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const if_block_creators_1 = [create_if_block$6, create_else_block$6];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$sourceType*/ ctx[2] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	icon = new Icon({
    			props: {
    				name: "figcaption-pin",
    				className: "margin-s",
    				width: 36
    			},
    			$$inline: true
    		});

    	dreditionsvgs = new DrEditionSVGs({ $$inline: true });

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Icon library";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			h30 = element("h3");
    			h30.textContent = "Icons";
    			t4 = space();
    			p0 = element("p");
    			t5 = text("Icons are simple and dynamic only made with fill. When using the class ");
    			em0 = element("em");
    			em0.textContent = "icon-svg";
    			t7 = text(", fill is set to the css\n  variable ");
    			em1 = element("em");
    			em1.textContent = "--icon-fill";
    			t9 = text(" which defaults to ");
    			em2 = element("em");
    			em2.textContent = "currentColor";
    			t11 = text(". This means that the icon will inherit the color\n  from the nearest parent where color is defined.");
    			t12 = space();
    			p1 = element("p");
    			p1.textContent = "But by changing the css variable, the color can be handled separately from any set color.";
    			t14 = space();
    			p2 = element("p");
    			t15 = text("Most icons are derived from ");
    			a = element("a");
    			a.textContent = "FontAwesome";
    			t17 = text(" using\n  only the\n  ");
    			b0 = element("b");
    			b0.textContent = "light";
    			t19 = text("\n  or ");
    			b1 = element("b");
    			b1.textContent = "solid";
    			t21 = text(" library!");
    			t22 = space();
    			div1 = element("div");
    			div0 = element("div");
    			t23 = text("Change icon color ");
    			select = element("select");
    			option = element("option");
    			option.textContent = "black";

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t25 = space();
    			create_component(button0.$$.fragment);
    			t26 = space();
    			p3 = element("p");
    			t27 = text("Size: ");
    			input = element("input");
    			t28 = text("px");
    			t29 = space();
    			create_component(button1.$$.fragment);
    			t30 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t31 = space();
    			if_block1.c();
    			t32 = space();
    			h31 = element("h3");
    			h31.textContent = "Graphics";
    			t34 = space();
    			p4 = element("p");
    			p4.textContent = "Graphics are capable of containing more layers i.e static colors on stroke and fill.";
    			t36 = space();
    			div3 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t37 = space();
    			if_block2.c();
    			t38 = space();
    			h32 = element("h3");
    			h32.textContent = "* Figcaption pin background";
    			t40 = space();
    			p5 = element("p");
    			t41 = text("The \"background\" of figcaption-pin can be changed through the css variable ");
    			em3 = element("em");
    			em3.textContent = "--ebds-figcaption-bg";
    			t43 = space();
    			div5 = element("div");
    			div4 = element("div");
    			create_component(icon.$$.fragment);
    			t44 = space();
    			small = element("small");
    			small.textContent = "figcaption-pin";
    			t46 = space();
    			h33 = element("h3");
    			h33.textContent = "DrEdition";
    			t48 = space();
    			p6 = element("p");
    			p6.textContent = "Animated and static icons used in DrEdition i.e ekstrabladet.dk frontpage cards";
    			t50 = space();
    			create_component(dreditionsvgs.$$.fragment);
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$G, 17, 0, 573);
    			add_location(h30, file$G, 68, 0, 1678);
    			add_location(em0, file$G, 70, 73, 1770);
    			add_location(em1, file$G, 71, 11, 1823);
    			add_location(em2, file$G, 71, 50, 1862);
    			add_location(p0, file$G, 69, 0, 1693);
    			add_location(p1, file$G, 74, 0, 1988);
    			attr_dev(a, "href", "https://fontawesome.com/");
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noreferrer");
    			add_location(a, file$G, 76, 30, 2119);
    			add_location(b0, file$G, 78, 2, 2222);
    			add_location(b1, file$G, 79, 5, 2240);
    			add_location(p2, file$G, 75, 0, 2085);
    			option.__value = "black";
    			option.value = option.__value;
    			add_location(option, file$G, 84, 6, 2423);
    			if (/*iconColor*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[5].call(select));
    			add_location(select, file$G, 83, 22, 2385);
    			attr_dev(div0, "class", "margin-m--r");
    			add_location(div0, file$G, 82, 2, 2337);
    			attr_dev(input, "type", "number");
    			set_style(input, "width", "45px");
    			add_location(input, file$G, 93, 11, 2706);
    			add_location(p3, file$G, 93, 2, 2697);
    			attr_dev(div1, "class", "flex flex-row flex-justify--center flex-align--center");
    			add_location(div1, file$G, 81, 0, 2267);
    			attr_dev(div2, "class", "flex flex-wrap--wrap");
    			set_style(div2, "--icon-fill", "var(--color--" + /*iconColor*/ ctx[0] + ")");
    			add_location(div2, file$G, 98, 0, 2907);
    			add_location(h31, file$G, 119, 0, 3534);
    			add_location(p4, file$G, 120, 0, 3552);
    			attr_dev(div3, "class", "flex flex-wrap--wrap");
    			add_location(div3, file$G, 122, 0, 3645);
    			add_location(h32, file$G, 143, 0, 4228);
    			add_location(em3, file$G, 145, 78, 4344);
    			add_location(p5, file$G, 145, 0, 4266);
    			add_location(small, file$G, 149, 4, 4574);
    			attr_dev(div4, "class", "card flex-align--center flex-justify--center margin-s padding-m bg--graa6");
    			add_location(div4, file$G, 147, 2, 4415);
    			attr_dev(div5, "class", "flex flex-wrap--wrap");
    			add_location(div5, file$G, 146, 0, 4378);
    			add_location(h33, file$G, 153, 0, 4621);
    			add_location(p6, file$G, 154, 0, 4640);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, p0, anchor);
    			append_dev(p0, t5);
    			append_dev(p0, em0);
    			append_dev(p0, t7);
    			append_dev(p0, em1);
    			append_dev(p0, t9);
    			append_dev(p0, em2);
    			append_dev(p0, t11);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, p2, anchor);
    			append_dev(p2, t15);
    			append_dev(p2, a);
    			append_dev(p2, t17);
    			append_dev(p2, b0);
    			append_dev(p2, t19);
    			append_dev(p2, b1);
    			append_dev(p2, t21);
    			insert_dev(target, t22, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t23);
    			append_dev(div0, select);
    			append_dev(select, option);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(select, null);
    			}

    			select_option(select, /*iconColor*/ ctx[0]);
    			append_dev(div1, t25);
    			mount_component(button0, div1, null);
    			append_dev(div1, t26);
    			append_dev(div1, p3);
    			append_dev(p3, t27);
    			append_dev(p3, input);
    			set_input_value(input, /*size*/ ctx[1]);
    			append_dev(p3, t28);
    			append_dev(div1, t29);
    			mount_component(button1, div1, null);
    			insert_dev(target, t30, anchor);
    			insert_dev(target, div2, anchor);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div2, null);
    			}

    			insert_dev(target, t31, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t32, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t34, anchor);
    			insert_dev(target, p4, anchor);
    			insert_dev(target, t36, anchor);
    			insert_dev(target, div3, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div3, null);
    			}

    			insert_dev(target, t37, anchor);
    			if_blocks_1[current_block_type_index_1].m(target, anchor);
    			insert_dev(target, t38, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t40, anchor);
    			insert_dev(target, p5, anchor);
    			append_dev(p5, t41);
    			append_dev(p5, em3);
    			insert_dev(target, t43, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			mount_component(icon, div4, null);
    			append_dev(div4, t44);
    			append_dev(div4, small);
    			insert_dev(target, t46, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t48, anchor);
    			insert_dev(target, p6, anchor);
    			insert_dev(target, t50, anchor);
    			mount_component(dreditionsvgs, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*select_change_handler*/ ctx[5]),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$sourceType*/ ctx[2] === 'svelte') {
    				if (if_block0) {
    					if (dirty & /*$sourceType*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*Object, colorNames*/ 0) {
    				each_value_2 = Object.keys(colorNames);
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_2(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_2.length;
    			}

    			if (dirty & /*iconColor, Object, colorNames*/ 1) {
    				select_option(select, /*iconColor*/ ctx[0]);
    			}

    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);

    			if (dirty & /*size*/ 2 && to_number(input.value) !== /*size*/ ctx[1]) {
    				set_input_value(input, /*size*/ ctx[1]);
    			}

    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);

    			if (dirty & /*iconnameshtml, size*/ 2) {
    				each_value_1 = iconnameshtml;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_1$1(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(div2, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*iconColor*/ 1) {
    				set_style(div2, "--icon-fill", "var(--color--" + /*iconColor*/ ctx[0] + ")");
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(t32.parentNode, t32);
    			}

    			if (dirty & /*graphicnameshtml*/ 0) {
    				each_value = graphicnameshtml;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div3, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}

    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks_1[current_block_type_index_1];

    				if (!if_block2) {
    					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(t38.parentNode, t38);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			transition_in(if_block1);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block2);
    			transition_in(icon.$$.fragment, local);
    			transition_in(dreditionsvgs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			transition_out(if_block1);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block2);
    			transition_out(icon.$$.fragment, local);
    			transition_out(dreditionsvgs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t22);
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks_2, detaching);
    			destroy_component(button0);
    			destroy_component(button1);
    			if (detaching) detach_dev(t30);
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks_1, detaching);
    			if (detaching) detach_dev(t31);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t32);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t34);
    			if (detaching) detach_dev(p4);
    			if (detaching) detach_dev(t36);
    			if (detaching) detach_dev(div3);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t37);
    			if_blocks_1[current_block_type_index_1].d(detaching);
    			if (detaching) detach_dev(t38);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t40);
    			if (detaching) detach_dev(p5);
    			if (detaching) detach_dev(t43);
    			if (detaching) detach_dev(div5);
    			destroy_component(icon);
    			if (detaching) detach_dev(t46);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t48);
    			if (detaching) detach_dev(p6);
    			if (detaching) detach_dev(t50);
    			destroy_component(dreditionsvgs, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(2, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Icon', slots, []);
    	let iconColor = 'black';
    	let size = 14;

    	const decrement = () => {
    		return $$invalidate(1, --size);
    	};

    	const increment = () => {
    		return $$invalidate(1, ++size);
    	};

    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Icon> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		iconColor = select_value(this);
    		$$invalidate(0, iconColor);
    	}

    	function input_input_handler() {
    		size = to_number(this.value);
    		$$invalidate(1, size);
    	}

    	$$self.$capture_state = () => ({
    		colorNames,
    		Prism: Prism$1,
    		DrEditionSVGs,
    		graphicnameshtml,
    		iconnameshtml,
    		sourceType,
    		Button,
    		Icon,
    		iconColor,
    		size,
    		decrement,
    		increment,
    		$sourceType
    	});

    	$$self.$inject_state = $$props => {
    		if ('iconColor' in $$props) $$invalidate(0, iconColor = $$props.iconColor);
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		iconColor,
    		size,
    		$sourceType,
    		decrement,
    		increment,
    		select_change_handler,
    		input_input_handler
    	];
    }

    class Icon_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$G, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon_1",
    			options,
    			id: create_fragment$G.name
    		});
    	}
    }

    /* docs_src/components/Spinner.svelte generated by Svelte v3.53.1 */
    const file$F = "docs_src/components/Spinner.svelte";

    // (8:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$2(ctx) {
    	let prism;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t14;
    	let td3;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_2$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "isLoading";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "boolean";
    			t12 = space();
    			td2 = element("td");
    			td2.textContent = "false";
    			t14 = space();
    			td3 = element("td");
    			td3.textContent = "Will only show if set to 'true'";
    			add_location(th0, file$F, 15, 8, 361);
    			add_location(th1, file$F, 16, 8, 388);
    			add_location(th2, file$F, 17, 8, 410);
    			add_location(th3, file$F, 18, 8, 441);
    			add_location(tr0, file$F, 14, 6, 348);
    			add_location(thead, file$F, 13, 4, 334);
    			add_location(td0, file$F, 23, 8, 518);
    			add_location(td1, file$F, 24, 8, 545);
    			add_location(td2, file$F, 25, 8, 570);
    			add_location(td3, file$F, 26, 8, 593);
    			add_location(tr1, file$F, 22, 6, 505);
    			add_location(tbody, file$F, 21, 4, 491);
    			attr_dev(table, "class", "table");
    			add_location(table, file$F, 12, 2, 308);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t14);
    			append_dev(tr1, td3);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(8:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (9:2) <Prism language="js">
    function create_default_slot_2$c(ctx) {
    	let t_value = `import { Spinner } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$c.name,
    		type: "slot",
    		source: "(9:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (41:0) {:else}
    function create_else_block$5(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(41:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (37:0) {#if $sourceType === 'svelte'}
    function create_if_block$5(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(37:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (42:2) <Prism language="html">
    function create_default_slot_1$h(ctx) {
    	let t_value = `<div class="loader flex flex--center">
    <svg viewBox="0 0 18 18" class="bounce bounce1">
      <use xlink:href="#circle-solid"></use>
    </svg>
    <svg viewBox="0 0 18 18" class="bounce bounce2">
      <use xlink:href="#circle-solid"></use>
    </svg>
    <svg viewBox="0 0 18 18" class="bounce bounce3">
      <use xlink:href="#circle-solid"></use>
    </svg>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$h.name,
    		type: "slot",
    		source: "(42:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (38:2) <Prism language="html">
    function create_default_slot$o(ctx) {
    	let t_value = `<Spinner isLoading={true}/>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$o.name,
    		type: "slot",
    		source: "(38:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let h1;
    	let t1;
    	let t2;
    	let div;
    	let spinner;
    	let t3;
    	let current_block_type_index;
    	let if_block1;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*$sourceType*/ ctx[0] === 'svelte' && create_if_block_1$2(ctx);

    	spinner = new Spinner({
    			props: { isLoading: true },
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block$5, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Spinner";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			div = element("div");
    			create_component(spinner.$$.fragment);
    			t3 = space();
    			if_block1.c();
    			if_block1_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$F, 5, 0, 140);
    			attr_dev(div, "class", "padding-l");
    			add_location(div, file$F, 32, 0, 677);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(spinner, div, null);
    			insert_dev(target, t3, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$sourceType*/ ctx[0] === 'svelte') {
    				if (if_block0) {
    					if (dirty & /*$sourceType*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(spinner.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(spinner.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div);
    			destroy_component(spinner);
    			if (detaching) detach_dev(t3);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Spinner', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Spinner> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1, sourceType, Spinner, $sourceType });
    	return [$sourceType];
    }

    class Spinner_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$F, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Spinner_1",
    			options,
    			id: create_fragment$F.name
    		});
    	}
    }

    /* docs_src/components/Tabs.svelte generated by Svelte v3.53.1 */
    const file$E = "docs_src/components/Tabs.svelte";

    // (110:0) {:else}
    function create_else_block$4(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Tabs er en ren Svelte component.";
    			add_location(p, file$E, 110, 2, 2630);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(110:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (12:0) {#if $sourceType === 'svelte'}
    function create_if_block$4(ctx) {
    	let prism0;
    	let t0;
    	let h20;
    	let t2;
    	let tabs0;
    	let t3;
    	let prism1;
    	let t4;
    	let h21;
    	let t6;
    	let tabs1;
    	let t7;
    	let prism2;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_18] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabs0 = new Tabs({
    			props: {
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_9$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabs1 = new Tabs({
    			props: {
    				$$slots: { default: [create_default_slot_1$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism0.$$.fragment);
    			t0 = space();
    			h20 = element("h2");
    			h20.textContent = "Style: Tabs";
    			t2 = space();
    			create_component(tabs0.$$.fragment);
    			t3 = space();
    			create_component(prism1.$$.fragment);
    			t4 = space();
    			h21 = element("h2");
    			h21.textContent = "Style: Pillnavigation";
    			t6 = space();
    			create_component(tabs1.$$.fragment);
    			t7 = space();
    			create_component(prism2.$$.fragment);
    			attr_dev(h20, "class", "margin-xl--t margin-m--b");
    			add_location(h20, file$E, 16, 2, 490);
    			attr_dev(h21, "class", "margin-xl--t margin-m--b");
    			add_location(h21, file$E, 63, 2, 1456);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, h20, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(tabs0, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, h21, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(tabs1, target, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(prism2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const tabs0_changes = {};

    			if (dirty & /*$$scope, content3, content2, content1*/ 135) {
    				tabs0_changes.$$scope = { dirty, ctx };
    			}

    			tabs0.$set(tabs0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    			const tabs1_changes = {};

    			if (dirty & /*$$scope, content3, content2, content1*/ 135) {
    				tabs1_changes.$$scope = { dirty, ctx };
    			}

    			tabs1.$set(tabs1_changes);
    			const prism2_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				prism2_changes.$$scope = { dirty, ctx };
    			}

    			prism2.$set(prism2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(tabs0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(tabs1.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(tabs0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(tabs1.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(h20);
    			if (detaching) detach_dev(t2);
    			destroy_component(tabs0, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(h21);
    			if (detaching) detach_dev(t6);
    			destroy_component(tabs1, detaching);
    			if (detaching) detach_dev(t7);
    			destroy_component(prism2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(12:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (13:2) <Prism language="js">
    function create_default_slot_18(ctx) {
    	let t_value = `import { Tabs, Tab, TabContent, TabList } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18.name,
    		type: "slot",
    		source: "(13:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (21:6) <Tab>
    function create_default_slot_17(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Tab 1");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17.name,
    		type: "slot",
    		source: "(21:6) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (22:6) <Tab>
    function create_default_slot_16(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Tab 2 Long Text Bla Bla");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16.name,
    		type: "slot",
    		source: "(22:6) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (23:6) <Tab>
    function create_default_slot_15(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Tab 3 Long Text Bla Bla");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15.name,
    		type: "slot",
    		source: "(23:6) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (20:4) <TabList>
    function create_default_slot_14(ctx) {
    	let tab0;
    	let t0;
    	let tab1;
    	let t1;
    	let tab2;
    	let current;

    	tab0 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_17] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tab1 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_16] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tab2 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_15] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tab0.$$.fragment);
    			t0 = space();
    			create_component(tab1.$$.fragment);
    			t1 = space();
    			create_component(tab2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tab0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tab1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tab2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tab0_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				tab0_changes.$$scope = { dirty, ctx };
    			}

    			tab0.$set(tab0_changes);
    			const tab1_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				tab1_changes.$$scope = { dirty, ctx };
    			}

    			tab1.$set(tab1_changes);
    			const tab2_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				tab2_changes.$$scope = { dirty, ctx };
    			}

    			tab2.$set(tab2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab0.$$.fragment, local);
    			transition_in(tab1.$$.fragment, local);
    			transition_in(tab2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab0.$$.fragment, local);
    			transition_out(tab1.$$.fragment, local);
    			transition_out(tab2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tab0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tab1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tab2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14.name,
    		type: "slot",
    		source: "(20:4) <TabList>",
    		ctx
    	});

    	return block;
    }

    // (25:4) <TabContent>
    function create_default_slot_13(ctx) {
    	let div;
    	let h2;
    	let t1;
    	let html_tag;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h2 = element("h2");
    			h2.textContent = "Content 1";
    			t1 = space();
    			html_tag = new HtmlTag(false);
    			attr_dev(h2, "class", "card-header");
    			add_location(h2, file$E, 26, 8, 750);
    			html_tag.a = null;
    			attr_dev(div, "class", "card margin-m--t");
    			add_location(div, file$E, 25, 6, 711);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h2);
    			append_dev(div, t1);
    			html_tag.m(/*content1*/ ctx[0], div);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content1*/ 1) html_tag.p(/*content1*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13.name,
    		type: "slot",
    		source: "(25:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (31:4) <TabContent>
    function create_default_slot_12(ctx) {
    	let div;
    	let h2;
    	let t1;
    	let html_tag;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h2 = element("h2");
    			h2.textContent = "Content 2";
    			t1 = space();
    			html_tag = new HtmlTag(false);
    			attr_dev(h2, "class", "card-header");
    			add_location(h2, file$E, 32, 8, 907);
    			html_tag.a = null;
    			attr_dev(div, "class", "card margin-m--t");
    			add_location(div, file$E, 31, 6, 868);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h2);
    			append_dev(div, t1);
    			html_tag.m(/*content2*/ ctx[1], div);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content2*/ 2) html_tag.p(/*content2*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12.name,
    		type: "slot",
    		source: "(31:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (37:4) <TabContent>
    function create_default_slot_11(ctx) {
    	let div;
    	let h2;
    	let t1;
    	let html_tag;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h2 = element("h2");
    			h2.textContent = "Content 3";
    			t1 = space();
    			html_tag = new HtmlTag(false);
    			attr_dev(h2, "class", "card-header");
    			add_location(h2, file$E, 38, 8, 1064);
    			html_tag.a = null;
    			attr_dev(div, "class", "card margin-m--t");
    			add_location(div, file$E, 37, 6, 1025);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h2);
    			append_dev(div, t1);
    			html_tag.m(/*content3*/ ctx[2], div);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content3*/ 4) html_tag.p(/*content3*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(37:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (19:2) <Tabs>
    function create_default_slot_10(ctx) {
    	let tablist;
    	let t0;
    	let tabcontent0;
    	let t1;
    	let tabcontent1;
    	let t2;
    	let tabcontent2;
    	let current;

    	tablist = new TabList({
    			props: {
    				$$slots: { default: [create_default_slot_14] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent0 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_13] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent1 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_12] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent2 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tablist.$$.fragment);
    			t0 = space();
    			create_component(tabcontent0.$$.fragment);
    			t1 = space();
    			create_component(tabcontent1.$$.fragment);
    			t2 = space();
    			create_component(tabcontent2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tablist, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tabcontent0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tabcontent1, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(tabcontent2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tablist_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				tablist_changes.$$scope = { dirty, ctx };
    			}

    			tablist.$set(tablist_changes);
    			const tabcontent0_changes = {};

    			if (dirty & /*$$scope, content1*/ 129) {
    				tabcontent0_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent0.$set(tabcontent0_changes);
    			const tabcontent1_changes = {};

    			if (dirty & /*$$scope, content2*/ 130) {
    				tabcontent1_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent1.$set(tabcontent1_changes);
    			const tabcontent2_changes = {};

    			if (dirty & /*$$scope, content3*/ 132) {
    				tabcontent2_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent2.$set(tabcontent2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tablist.$$.fragment, local);
    			transition_in(tabcontent0.$$.fragment, local);
    			transition_in(tabcontent1.$$.fragment, local);
    			transition_in(tabcontent2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tablist.$$.fragment, local);
    			transition_out(tabcontent0.$$.fragment, local);
    			transition_out(tabcontent1.$$.fragment, local);
    			transition_out(tabcontent2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tablist, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tabcontent0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tabcontent1, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(tabcontent2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(19:2) <Tabs>",
    		ctx
    	});

    	return block;
    }

    // (45:2) <Prism language="html">
    function create_default_slot_9$1(ctx) {
    	let t_value = `<Tabs>
  <TabList>
    <Tab>Tab 1</Tab>
    <Tab>Tab 2</Tab>
    <Tab>Tab 3</Tab>
  </TabList>
  <TabContent>
    Content 1
  </TabContent>
  <TabContent>
    Content 2
  </TabContent>
  <TabContent>
    Content 3
  </TabContent>
</Tabs>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$1.name,
    		type: "slot",
    		source: "(45:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (68:6) <Tab>
    function create_default_slot_8$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Tab 1");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$3.name,
    		type: "slot",
    		source: "(68:6) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (69:6) <Tab>
    function create_default_slot_7$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Tab 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$4.name,
    		type: "slot",
    		source: "(69:6) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (70:6) <Tab>
    function create_default_slot_6$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Tab 3");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$4.name,
    		type: "slot",
    		source: "(70:6) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (67:4) <TabList type="pillnavigation">
    function create_default_slot_5$5(ctx) {
    	let tab0;
    	let t0;
    	let tab1;
    	let t1;
    	let tab2;
    	let current;

    	tab0 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_8$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tab1 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_7$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tab2 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_6$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tab0.$$.fragment);
    			t0 = space();
    			create_component(tab1.$$.fragment);
    			t1 = space();
    			create_component(tab2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tab0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tab1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tab2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tab0_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				tab0_changes.$$scope = { dirty, ctx };
    			}

    			tab0.$set(tab0_changes);
    			const tab1_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				tab1_changes.$$scope = { dirty, ctx };
    			}

    			tab1.$set(tab1_changes);
    			const tab2_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				tab2_changes.$$scope = { dirty, ctx };
    			}

    			tab2.$set(tab2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab0.$$.fragment, local);
    			transition_in(tab1.$$.fragment, local);
    			transition_in(tab2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab0.$$.fragment, local);
    			transition_out(tab1.$$.fragment, local);
    			transition_out(tab2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tab0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tab1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tab2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$5.name,
    		type: "slot",
    		source: "(67:4) <TabList type=\\\"pillnavigation\\\">",
    		ctx
    	});

    	return block;
    }

    // (72:4) <TabContent>
    function create_default_slot_4$6(ctx) {
    	let div1;
    	let h2;
    	let t1;
    	let div0;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Content 1";
    			t1 = space();
    			div0 = element("div");
    			attr_dev(h2, "class", "card-header");
    			add_location(h2, file$E, 73, 8, 1712);
    			attr_dev(div0, "class", "card-content");
    			attr_dev(div0, "contenteditable", "true");
    			if (/*content1*/ ctx[0] === void 0) add_render_callback(() => /*div0_input_handler*/ ctx[4].call(div0));
    			add_location(div0, file$E, 74, 8, 1759);
    			attr_dev(div1, "class", "card margin-m--t");
    			add_location(div1, file$E, 72, 6, 1673);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h2);
    			append_dev(div1, t1);
    			append_dev(div1, div0);

    			if (/*content1*/ ctx[0] !== void 0) {
    				div0.innerHTML = /*content1*/ ctx[0];
    			}

    			if (!mounted) {
    				dispose = listen_dev(div0, "input", /*div0_input_handler*/ ctx[4]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content1*/ 1 && /*content1*/ ctx[0] !== div0.innerHTML) {
    				div0.innerHTML = /*content1*/ ctx[0];
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$6.name,
    		type: "slot",
    		source: "(72:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (78:4) <TabContent>
    function create_default_slot_3$6(ctx) {
    	let div1;
    	let h2;
    	let t1;
    	let div0;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Content 2";
    			t1 = space();
    			div0 = element("div");
    			attr_dev(h2, "class", "card-header");
    			add_location(h2, file$E, 79, 8, 1930);
    			attr_dev(div0, "class", "card-content");
    			attr_dev(div0, "contenteditable", "true");
    			if (/*content2*/ ctx[1] === void 0) add_render_callback(() => /*div0_input_handler_1*/ ctx[5].call(div0));
    			add_location(div0, file$E, 80, 8, 1977);
    			attr_dev(div1, "class", "card margin-m--t");
    			add_location(div1, file$E, 78, 6, 1891);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h2);
    			append_dev(div1, t1);
    			append_dev(div1, div0);

    			if (/*content2*/ ctx[1] !== void 0) {
    				div0.innerHTML = /*content2*/ ctx[1];
    			}

    			if (!mounted) {
    				dispose = listen_dev(div0, "input", /*div0_input_handler_1*/ ctx[5]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content2*/ 2 && /*content2*/ ctx[1] !== div0.innerHTML) {
    				div0.innerHTML = /*content2*/ ctx[1];
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$6.name,
    		type: "slot",
    		source: "(78:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (84:4) <TabContent>
    function create_default_slot_2$b(ctx) {
    	let div1;
    	let h2;
    	let t1;
    	let div0;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Content 3";
    			t1 = space();
    			div0 = element("div");
    			attr_dev(h2, "class", "card-header");
    			add_location(h2, file$E, 85, 8, 2148);
    			attr_dev(div0, "class", "card-content");
    			attr_dev(div0, "contenteditable", "true");
    			if (/*content3*/ ctx[2] === void 0) add_render_callback(() => /*div0_input_handler_2*/ ctx[6].call(div0));
    			add_location(div0, file$E, 86, 8, 2195);
    			attr_dev(div1, "class", "card margin-m--t");
    			add_location(div1, file$E, 84, 6, 2109);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h2);
    			append_dev(div1, t1);
    			append_dev(div1, div0);

    			if (/*content3*/ ctx[2] !== void 0) {
    				div0.innerHTML = /*content3*/ ctx[2];
    			}

    			if (!mounted) {
    				dispose = listen_dev(div0, "input", /*div0_input_handler_2*/ ctx[6]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content3*/ 4 && /*content3*/ ctx[2] !== div0.innerHTML) {
    				div0.innerHTML = /*content3*/ ctx[2];
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$b.name,
    		type: "slot",
    		source: "(84:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (66:2) <Tabs>
    function create_default_slot_1$g(ctx) {
    	let tablist;
    	let t0;
    	let tabcontent0;
    	let t1;
    	let tabcontent1;
    	let t2;
    	let tabcontent2;
    	let current;

    	tablist = new TabList({
    			props: {
    				type: "pillnavigation",
    				$$slots: { default: [create_default_slot_5$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent0 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_4$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent1 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_3$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent2 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_2$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tablist.$$.fragment);
    			t0 = space();
    			create_component(tabcontent0.$$.fragment);
    			t1 = space();
    			create_component(tabcontent1.$$.fragment);
    			t2 = space();
    			create_component(tabcontent2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tablist, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tabcontent0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tabcontent1, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(tabcontent2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tablist_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				tablist_changes.$$scope = { dirty, ctx };
    			}

    			tablist.$set(tablist_changes);
    			const tabcontent0_changes = {};

    			if (dirty & /*$$scope, content1*/ 129) {
    				tabcontent0_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent0.$set(tabcontent0_changes);
    			const tabcontent1_changes = {};

    			if (dirty & /*$$scope, content2*/ 130) {
    				tabcontent1_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent1.$set(tabcontent1_changes);
    			const tabcontent2_changes = {};

    			if (dirty & /*$$scope, content3*/ 132) {
    				tabcontent2_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent2.$set(tabcontent2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tablist.$$.fragment, local);
    			transition_in(tabcontent0.$$.fragment, local);
    			transition_in(tabcontent1.$$.fragment, local);
    			transition_in(tabcontent2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tablist.$$.fragment, local);
    			transition_out(tabcontent0.$$.fragment, local);
    			transition_out(tabcontent1.$$.fragment, local);
    			transition_out(tabcontent2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tablist, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tabcontent0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tabcontent1, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(tabcontent2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$g.name,
    		type: "slot",
    		source: "(66:2) <Tabs>",
    		ctx
    	});

    	return block;
    }

    // (92:2) <Prism language="html">
    function create_default_slot$n(ctx) {
    	let t_value = `<Tabs>
  <TabList type="pillnavigation">
    <Tab>Tab 1</Tab>
    <Tab>Tab 2</Tab>
    <Tab>Tab 3</Tab>
  </TabList>
  <TabContent>
    Content 1
  </TabContent>
  <TabContent>
    Content 2
  </TabContent>
  <TabContent>
    Content 3
  </TabContent>
</Tabs>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$n.name,
    		type: "slot",
    		source: "(92:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let h1;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$4, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[3] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Tabs";
    			t1 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$E, 9, 0, 302);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(3, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tabs', slots, []);
    	let content1 = rdmParagraphs();
    	let content2 = rdmParagraphs();
    	let content3 = rdmParagraphs();
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tabs> was created with unknown prop '${key}'`);
    	});

    	function div0_input_handler() {
    		content1 = this.innerHTML;
    		$$invalidate(0, content1);
    	}

    	function div0_input_handler_1() {
    		content2 = this.innerHTML;
    		$$invalidate(1, content2);
    	}

    	function div0_input_handler_2() {
    		content3 = this.innerHTML;
    		$$invalidate(2, content3);
    	}

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		rdmParagraphs,
    		sourceType,
    		Tab,
    		TabContent,
    		TabList,
    		Tabs,
    		content1,
    		content2,
    		content3,
    		$sourceType
    	});

    	$$self.$inject_state = $$props => {
    		if ('content1' in $$props) $$invalidate(0, content1 = $$props.content1);
    		if ('content2' in $$props) $$invalidate(1, content2 = $$props.content2);
    		if ('content3' in $$props) $$invalidate(2, content3 = $$props.content3);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		content1,
    		content2,
    		content3,
    		$sourceType,
    		div0_input_handler,
    		div0_input_handler_1,
    		div0_input_handler_2
    	];
    }

    class Tabs_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$E, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabs_1",
    			options,
    			id: create_fragment$E.name
    		});
    	}
    }

    /* docs_src/components/Toggler.svelte generated by Svelte v3.53.1 */
    const file$D = "docs_src/components/Toggler.svelte";
    const get_default_slot_changes_7 = dirty => ({});
    const get_default_slot_context_7 = ctx => ({ slot: "on" });
    const get_default_slot_changes_6 = dirty => ({});
    const get_default_slot_context_6 = ctx => ({ slot: "off" });
    const get_default_slot_changes_5 = dirty => ({});
    const get_default_slot_context_5 = ctx => ({ slot: "on" });
    const get_default_slot_changes_4 = dirty => ({});
    const get_default_slot_context_4 = ctx => ({ slot: "off" });
    const get_default_slot_changes_3 = dirty => ({});
    const get_default_slot_context_3 = ctx => ({ slot: "on" });
    const get_default_slot_changes_2 = dirty => ({});
    const get_default_slot_context_2 = ctx => ({ slot: "off" });
    const get_default_slot_changes_1 = dirty => ({});
    const get_default_slot_context_1 = ctx => ({ slot: "on" });
    const get_default_slot_changes = dirty => ({});
    const get_default_slot_context = ctx => ({ slot: "off" });

    // (8:0) {#if $sourceType === 'svelte'}
    function create_if_block_4(ctx) {
    	let prism;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t13;
    	let td3;
    	let t14;
    	let tr2;
    	let td4;
    	let t16;
    	let td5;
    	let t18;
    	let td6;
    	let t20;
    	let td7;
    	let t22;
    	let tr3;
    	let td8;
    	let t24;
    	let td9;
    	let t26;
    	let td10;
    	let t28;
    	let td11;
    	let t30;
    	let tr4;
    	let td12;
    	let t32;
    	let td13;
    	let t34;
    	let td14;
    	let t36;
    	let td15;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_8$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "className";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "string";
    			t12 = space();
    			td2 = element("td");
    			t13 = space();
    			td3 = element("td");
    			t14 = space();
    			tr2 = element("tr");
    			td4 = element("td");
    			td4.textContent = "defaultState";
    			t16 = space();
    			td5 = element("td");
    			td5.textContent = "boolean";
    			t18 = space();
    			td6 = element("td");
    			td6.textContent = "true";
    			t20 = space();
    			td7 = element("td");
    			td7.textContent = "Should the toggler be on or of on mount";
    			t22 = space();
    			tr3 = element("tr");
    			td8 = element("td");
    			td8.textContent = "isSwitch";
    			t24 = space();
    			td9 = element("td");
    			td9.textContent = "boolean";
    			t26 = space();
    			td10 = element("td");
    			td10.textContent = "false";
    			t28 = space();
    			td11 = element("td");
    			td11.textContent = "Convents into a swicth, see example further down";
    			t30 = space();
    			tr4 = element("tr");
    			td12 = element("td");
    			td12.textContent = "disabled";
    			t32 = space();
    			td13 = element("td");
    			td13.textContent = "boolean";
    			t34 = space();
    			td14 = element("td");
    			td14.textContent = "false";
    			t36 = space();
    			td15 = element("td");
    			td15.textContent = "Disable the toggle";
    			add_location(th0, file$D, 15, 8, 367);
    			add_location(th1, file$D, 16, 8, 394);
    			add_location(th2, file$D, 17, 8, 416);
    			add_location(th3, file$D, 18, 8, 447);
    			add_location(tr0, file$D, 14, 6, 354);
    			add_location(thead, file$D, 13, 4, 340);
    			add_location(td0, file$D, 23, 8, 524);
    			add_location(td1, file$D, 24, 8, 551);
    			add_location(td2, file$D, 25, 8, 575);
    			add_location(td3, file$D, 26, 8, 590);
    			add_location(tr1, file$D, 22, 6, 511);
    			add_location(td4, file$D, 29, 8, 628);
    			add_location(td5, file$D, 30, 8, 658);
    			add_location(td6, file$D, 31, 8, 683);
    			add_location(td7, file$D, 32, 8, 705);
    			add_location(tr2, file$D, 28, 6, 615);
    			add_location(td8, file$D, 35, 8, 785);
    			add_location(td9, file$D, 36, 8, 811);
    			add_location(td10, file$D, 37, 8, 836);
    			add_location(td11, file$D, 38, 8, 859);
    			add_location(tr3, file$D, 34, 6, 772);
    			add_location(td12, file$D, 41, 8, 948);
    			add_location(td13, file$D, 42, 8, 974);
    			add_location(td14, file$D, 43, 8, 999);
    			add_location(td15, file$D, 44, 8, 1022);
    			add_location(tr4, file$D, 40, 6, 935);
    			add_location(tbody, file$D, 21, 4, 497);
    			attr_dev(table, "class", "table");
    			add_location(table, file$D, 12, 2, 314);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			append_dev(tbody, t14);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td4);
    			append_dev(tr2, t16);
    			append_dev(tr2, td5);
    			append_dev(tr2, t18);
    			append_dev(tr2, td6);
    			append_dev(tr2, t20);
    			append_dev(tr2, td7);
    			append_dev(tbody, t22);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td8);
    			append_dev(tr3, t24);
    			append_dev(tr3, td9);
    			append_dev(tr3, t26);
    			append_dev(tr3, td10);
    			append_dev(tr3, t28);
    			append_dev(tr3, td11);
    			append_dev(tbody, t30);
    			append_dev(tbody, tr4);
    			append_dev(tr4, td12);
    			append_dev(tr4, t32);
    			append_dev(tr4, td13);
    			append_dev(tr4, t34);
    			append_dev(tr4, td14);
    			append_dev(tr4, t36);
    			append_dev(tr4, td15);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(8:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (9:2) <Prism language="js">
    function create_default_slot_8$2(ctx) {
    	let t_value = `import { Toggler } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$2.name,
    		type: "slot",
    		source: "(9:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (54:18) on
    function fallback_block_7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("on");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_7.name,
    		type: "fallback",
    		source: "(54:18) on",
    		ctx
    	});

    	return block;
    }

    // (54:2) 
    function create_on_slot_3(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context_1);
    	const default_slot_or_fallback = default_slot || fallback_block_7(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, get_default_slot_changes_1),
    						get_default_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_on_slot_3.name,
    		type: "slot",
    		source: "(54:2) ",
    		ctx
    	});

    	return block;
    }

    // (55:19) off
    function fallback_block_6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("off");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_6.name,
    		type: "fallback",
    		source: "(55:19) off",
    		ctx
    	});

    	return block;
    }

    // (55:2) 
    function create_off_slot_3(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context);
    	const default_slot_or_fallback = default_slot || fallback_block_6(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, get_default_slot_changes),
    						get_default_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_off_slot_3.name,
    		type: "slot",
    		source: "(55:2) ",
    		ctx
    	});

    	return block;
    }

    // (65:0) {:else}
    function create_else_block_3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_7$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(65:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (58:0) {#if $sourceType === 'svelte'}
    function create_if_block_3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_6$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(58:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (66:2) <Prism language="html">
    function create_default_slot_7$3(ctx) {
    	let t_value = `<label class="toggle">
  <input type="checkbox" hidden class="toggle-input" />
  <span class="toggle toggle-on">on</span>
  <span class="toggle toggle-off">off</span>
</label>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$3.name,
    		type: "slot",
    		source: "(66:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (59:2) <Prism language="html">
    function create_default_slot_6$3(ctx) {
    	let t_value = `<Toggler>
  <slot slot="on">on</slot>
  <slot slot="off">off</slot>
</Toggler>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$3.name,
    		type: "slot",
    		source: "(59:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (78:18)      
    function fallback_block_5(ctx) {
    	let icon;
    	let current;

    	icon = new Icon$1({
    			props: {
    				name: "angle-down",
    				style: "width: 24px; height: 24px;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_5.name,
    		type: "fallback",
    		source: "(78:18)      ",
    		ctx
    	});

    	return block;
    }

    // (78:2) 
    function create_on_slot_2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context_3);
    	const default_slot_or_fallback = default_slot || fallback_block_5(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, get_default_slot_changes_3),
    						get_default_slot_context_3
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_on_slot_2.name,
    		type: "slot",
    		source: "(78:2) ",
    		ctx
    	});

    	return block;
    }

    // (81:19)      
    function fallback_block_4(ctx) {
    	let icon;
    	let current;

    	icon = new Icon$1({
    			props: {
    				name: "angle-up",
    				style: "width: 24px; height: 24px;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_4.name,
    		type: "fallback",
    		source: "(81:19)      ",
    		ctx
    	});

    	return block;
    }

    // (81:2) 
    function create_off_slot_2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context_2);
    	const default_slot_or_fallback = default_slot || fallback_block_4(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, get_default_slot_changes_2),
    						get_default_slot_context_2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_off_slot_2.name,
    		type: "slot",
    		source: "(81:2) ",
    		ctx
    	});

    	return block;
    }

    // (97:0) {:else}
    function create_else_block_2(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_5$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(97:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (86:0) {#if $sourceType === 'svelte'}
    function create_if_block_2(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_4$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(86:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (98:2) <Prism language="html">
    function create_default_slot_5$4(ctx) {
    	let t_value = `<label class="toggle">
  <input type="checkbox" hidden class="toggle-input" />
  <svg viewBox="0 0 18 18" class="toggle toggle-on">
    <use xlink:href="#angle-down"></use>
  </svg>
  <svg viewBox="0 0 18 18" class="toggle toggle-off">
    <use xlink:href="#angle-up"></use>
  </svg>
</label>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$4.name,
    		type: "slot",
    		source: "(98:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (87:2) <Prism language="html">
    function create_default_slot_4$5(ctx) {
    	let t_value = `<Toggler>
  <slot slot="on">
    <Icon name="angle-down" style="width: 24px; height: 24px;" />
  </slot>
  <slot slot="off">
    <Icon name="angle-up" style="width: 24px; height: 24px;" />
  </slot>
</Toggler>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$5.name,
    		type: "slot",
    		source: "(87:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (114:18) on
    function fallback_block_3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("on");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_3.name,
    		type: "fallback",
    		source: "(114:18) on",
    		ctx
    	});

    	return block;
    }

    // (114:2) 
    function create_on_slot_1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context_5);
    	const default_slot_or_fallback = default_slot || fallback_block_3(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, get_default_slot_changes_5),
    						get_default_slot_context_5
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_on_slot_1.name,
    		type: "slot",
    		source: "(114:2) ",
    		ctx
    	});

    	return block;
    }

    // (115:19) off
    function fallback_block_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("off");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_2.name,
    		type: "fallback",
    		source: "(115:19) off",
    		ctx
    	});

    	return block;
    }

    // (115:2) 
    function create_off_slot_1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context_4);
    	const default_slot_or_fallback = default_slot || fallback_block_2(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, get_default_slot_changes_4),
    						get_default_slot_context_4
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_off_slot_1.name,
    		type: "slot",
    		source: "(115:2) ",
    		ctx
    	});

    	return block;
    }

    // (125:0) {:else}
    function create_else_block_1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_3$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(125:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (118:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(118:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (126:2) <Prism language="html">
    function create_default_slot_3$5(ctx) {
    	let t_value = `Sadly, Svelte only` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$5.name,
    		type: "slot",
    		source: "(126:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (119:2) <Prism language="html">
    function create_default_slot_2$a(ctx) {
    	let t_value = `<Toggler isSwitch={true}>
  <slot slot="on">on</slot>
  <slot slot="off">off</slot>
</Toggler>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$a.name,
    		type: "slot",
    		source: "(119:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (134:18) on
    function fallback_block_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("on");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1.name,
    		type: "fallback",
    		source: "(134:18) on",
    		ctx
    	});

    	return block;
    }

    // (134:2) 
    function create_on_slot(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context_7);
    	const default_slot_or_fallback = default_slot || fallback_block_1(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, get_default_slot_changes_7),
    						get_default_slot_context_7
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_on_slot.name,
    		type: "slot",
    		source: "(134:2) ",
    		ctx
    	});

    	return block;
    }

    // (135:19) off
    function fallback_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("off");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(135:19) off",
    		ctx
    	});

    	return block;
    }

    // (135:2) 
    function create_off_slot(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context_6);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, get_default_slot_changes_6),
    						get_default_slot_context_6
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_off_slot.name,
    		type: "slot",
    		source: "(135:2) ",
    		ctx
    	});

    	return block;
    }

    // (145:0) {:else}
    function create_else_block$3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(145:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (138:0) {#if $sourceType === 'svelte'}
    function create_if_block$3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(138:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (146:2) <Prism language="html">
    function create_default_slot_1$f(ctx) {
    	let t_value = `Sadly, Svelte only` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$f.name,
    		type: "slot",
    		source: "(146:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (139:2) <Prism language="html">
    function create_default_slot$m(ctx) {
    	let t_value = `<Toggler defaultState={false}>
  <slot slot="on">on</slot>
  <slot slot="off">off</slot>
</Toggler>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$m.name,
    		type: "slot",
    		source: "(139:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let h1;
    	let t1;
    	let t2;
    	let h30;
    	let t4;
    	let toggler0;
    	let t5;
    	let current_block_type_index;
    	let if_block1;
    	let t6;
    	let h31;
    	let t8;
    	let toggler1;
    	let t9;
    	let current_block_type_index_1;
    	let if_block2;
    	let t10;
    	let h32;
    	let t12;
    	let toggler2;
    	let t13;
    	let current_block_type_index_2;
    	let if_block3;
    	let t14;
    	let h33;
    	let t16;
    	let toggler3;
    	let t17;
    	let current_block_type_index_3;
    	let if_block4;
    	let if_block4_anchor;
    	let current;
    	let if_block0 = /*$sourceType*/ ctx[0] === 'svelte' && create_if_block_4(ctx);

    	toggler0 = new Toggler({
    			props: {
    				$$slots: {
    					off: [create_off_slot_3],
    					on: [create_on_slot_3]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block_3, create_else_block_3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	toggler1 = new Toggler({
    			props: {
    				$$slots: {
    					off: [create_off_slot_2],
    					on: [create_on_slot_2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_1 = [create_if_block_2, create_else_block_2];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	toggler2 = new Toggler({
    			props: {
    				isSwitch: true,
    				$$slots: {
    					off: [create_off_slot_1],
    					on: [create_on_slot_1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_2 = [create_if_block_1$1, create_else_block_1];
    	const if_blocks_2 = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_2 = select_block_type_2(ctx);
    	if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

    	toggler3 = new Toggler({
    			props: {
    				defaultState: false,
    				$$slots: {
    					off: [create_off_slot],
    					on: [create_on_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_3 = [create_if_block$3, create_else_block$3];
    	const if_blocks_3 = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_3 = select_block_type_3(ctx);
    	if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Toggler";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			h30 = element("h3");
    			h30.textContent = "Toggler with text";
    			t4 = space();
    			create_component(toggler0.$$.fragment);
    			t5 = space();
    			if_block1.c();
    			t6 = space();
    			h31 = element("h3");
    			h31.textContent = "Toggler with icon";
    			t8 = space();
    			create_component(toggler1.$$.fragment);
    			t9 = space();
    			if_block2.c();
    			t10 = space();
    			h32 = element("h3");
    			h32.textContent = "Toggle as switch";
    			t12 = space();
    			create_component(toggler2.$$.fragment);
    			t13 = space();
    			if_block3.c();
    			t14 = space();
    			h33 = element("h3");
    			h33.textContent = "Set default state to off";
    			t16 = space();
    			create_component(toggler3.$$.fragment);
    			t17 = space();
    			if_block4.c();
    			if_block4_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$D, 5, 0, 146);
    			add_location(h30, file$D, 50, 0, 1093);
    			add_location(h31, file$D, 74, 0, 1592);
    			add_location(h32, file$D, 110, 0, 2470);
    			add_location(h33, file$D, 130, 0, 2843);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(toggler0, target, anchor);
    			insert_dev(target, t5, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(toggler1, target, anchor);
    			insert_dev(target, t9, anchor);
    			if_blocks_1[current_block_type_index_1].m(target, anchor);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t12, anchor);
    			mount_component(toggler2, target, anchor);
    			insert_dev(target, t13, anchor);
    			if_blocks_2[current_block_type_index_2].m(target, anchor);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t16, anchor);
    			mount_component(toggler3, target, anchor);
    			insert_dev(target, t17, anchor);
    			if_blocks_3[current_block_type_index_3].m(target, anchor);
    			insert_dev(target, if_block4_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$sourceType*/ ctx[0] === 'svelte') {
    				if (if_block0) {
    					if (dirty & /*$sourceType*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const toggler0_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				toggler0_changes.$$scope = { dirty, ctx };
    			}

    			toggler0.$set(toggler0_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(t6.parentNode, t6);
    			}

    			const toggler1_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				toggler1_changes.$$scope = { dirty, ctx };
    			}

    			toggler1.$set(toggler1_changes);
    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks_1[current_block_type_index_1];

    				if (!if_block2) {
    					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(t10.parentNode, t10);
    			}

    			const toggler2_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				toggler2_changes.$$scope = { dirty, ctx };
    			}

    			toggler2.$set(toggler2_changes);
    			let previous_block_index_2 = current_block_type_index_2;
    			current_block_type_index_2 = select_block_type_2(ctx);

    			if (current_block_type_index_2 !== previous_block_index_2) {
    				group_outros();

    				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
    					if_blocks_2[previous_block_index_2] = null;
    				});

    				check_outros();
    				if_block3 = if_blocks_2[current_block_type_index_2];

    				if (!if_block3) {
    					if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
    					if_block3.c();
    				}

    				transition_in(if_block3, 1);
    				if_block3.m(t14.parentNode, t14);
    			}

    			const toggler3_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				toggler3_changes.$$scope = { dirty, ctx };
    			}

    			toggler3.$set(toggler3_changes);
    			let previous_block_index_3 = current_block_type_index_3;
    			current_block_type_index_3 = select_block_type_3(ctx);

    			if (current_block_type_index_3 !== previous_block_index_3) {
    				group_outros();

    				transition_out(if_blocks_3[previous_block_index_3], 1, 1, () => {
    					if_blocks_3[previous_block_index_3] = null;
    				});

    				check_outros();
    				if_block4 = if_blocks_3[current_block_type_index_3];

    				if (!if_block4) {
    					if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);
    					if_block4.c();
    				}

    				transition_in(if_block4, 1);
    				if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(toggler0.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(toggler1.$$.fragment, local);
    			transition_in(if_block2);
    			transition_in(toggler2.$$.fragment, local);
    			transition_in(if_block3);
    			transition_in(toggler3.$$.fragment, local);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(toggler0.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(toggler1.$$.fragment, local);
    			transition_out(if_block2);
    			transition_out(toggler2.$$.fragment, local);
    			transition_out(if_block3);
    			transition_out(toggler3.$$.fragment, local);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t4);
    			destroy_component(toggler0, detaching);
    			if (detaching) detach_dev(t5);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t8);
    			destroy_component(toggler1, detaching);
    			if (detaching) detach_dev(t9);
    			if_blocks_1[current_block_type_index_1].d(detaching);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t12);
    			destroy_component(toggler2, detaching);
    			if (detaching) detach_dev(t13);
    			if_blocks_2[current_block_type_index_2].d(detaching);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t16);
    			destroy_component(toggler3, detaching);
    			if (detaching) detach_dev(t17);
    			if_blocks_3[current_block_type_index_3].d(detaching);
    			if (detaching) detach_dev(if_block4_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Toggler', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Toggler> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		sourceType,
    		Icon: Icon$1,
    		Toggler,
    		$sourceType
    	});

    	return [$sourceType, slots, $$scope];
    }

    class Toggler_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Toggler_1",
    			options,
    			id: create_fragment$D.name
    		});
    	}
    }

    const components = {
        href: '/components',
        routes: [
            {
                component: Accordion_1,
                href: '/components/accordion',
                title: 'Accordion',
            },
            {
                component: ArticleCard_1,
                href: '/components/articlecard',
                title: 'Article card',
            },
            {
                component: ArticleList_1,
                href: '/components/articlelist',
                title: 'Article list',
            },
            {
                component: Badge,
                href: '/components/badge',
                title: 'Badge',
            },
            {
                component: Button_1,
                href: '/components/button',
                title: 'Button',
            },
            {
                component: ButtonGroup_1,
                href: '/components/buttongroup',
                title: 'Button group',
            },
            {
                component: Card,
                href: '/components/card',
                title: 'Card',
            },
            {
                component: FormElement_1,
                href: '/components/form-elements',
                title: 'Form elements',
            },
            {
                component: Icon_1,
                href: '/components/icon',
                title: 'Icon',
            },
            {
                component: HorizontalScroll_1,
                href: '/components/horizontalscroll',
                title: 'Horizontal scroll',
            },
            {
                component: Tabs_1,
                href: '/components/tabs',
                title: 'Tabs',
            },
            {
                component: Spinner_1,
                href: '/components/spinner',
                title: 'Spinner',
            },
            {
                component: Toggler_1,
                href: '/components/toggler',
                title: 'Toggler',
            },
        ],
        title: 'Components',
    };

    /* docs_src/assets/icons/code.svg.rollup-plugin.svelte generated by Svelte v3.53.1 */

    const file$C = "docs_src/assets/icons/code.svg.rollup-plugin.svelte";

    function create_fragment$C(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "code" },
    		{ class: "svg-inline--fa fa-code fa-w-18" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M228.5 511.8l-25-7.1c-3.2-.9-5-4.2-4.1-7.4L340.1 4.4c.9-3.2 4.2-5 7.4-4.1l25 7.1c3.2.9 5 4.2 4.1 7.4L235.9 507.6c-.9 3.2-4.3 5.1-7.4 4.2zm-75.6-125.3l18.5-20.9c1.9-2.1 1.6-5.3-.5-7.1L49.9 256l121-102.5c2.1-1.8 2.4-5 .5-7.1l-18.5-20.9c-1.8-2.1-5-2.3-7.1-.4L1.7 252.3c-2.3 2-2.3 5.5 0 7.5L145.8 387c2.1 1.8 5.3 1.6 7.1-.5zm277.3.4l144.1-127.2c2.3-2 2.3-5.5 0-7.5L430.2 125.1c-2.1-1.8-5.2-1.6-7.1.4l-18.5 20.9c-1.9 2.1-1.6 5.3.5 7.1l121 102.5-121 102.5c-2.1 1.8-2.4 5-.5 7.1l18.5 20.9c1.8 2.1 5 2.3 7.1.4z");
    			add_location(path, file$C, 0, 198, 198);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$C, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "code" },
    				{ class: "svg-inline--fa fa-code fa-w-18" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Code_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Code_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$C, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Code_svg_rollup_plugin",
    			options,
    			id: create_fragment$C.name
    		});
    	}
    }

    /* docs_src/assets/icons/components.svg.rollup-plugin.svelte generated by Svelte v3.53.1 */

    const file$B = "docs_src/assets/icons/components.svg.rollup-plugin.svelte";

    function create_fragment$B(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "cubes" },
    		{ class: "svg-inline--fa fa-cubes fa-w-16" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M488.6 256.7L388 219V107.9c0-15-9.3-28.4-23.4-33.7l-96-36c-8.1-3.1-17.1-3.1-25.3 0l-96 36c-14.1 5.3-23.4 18.7-23.4 33.7V219L23.4 256.7C9.3 262 0 275.4 0 290.4v101.3c0 13.6 7.7 26.1 19.9 32.2l96 48c10.1 5.1 22.1 5.1 32.2 0L256 418l107.9 54c10.1 5.1 22.1 5.1 32.2 0l96-48c12.2-6.1 19.9-18.6 19.9-32.2V290.4c0-15-9.3-28.4-23.4-33.7zM16.5 403.8V295.1l107.2 46.5v115.8zm231 0l-107.2 53.6V341.6l107.2-46.5zm0-126.7l-115.5 50-115.5-50v-.2L131 234l107.6 39.6 8.9 3.3zm.3-19.7L195 239.6l-54.5-20.4V112.5L247.8 159zM140.5 94.5v-.1L256 51l115.5 43.3v.2l-115.5 50zM264.2 159l107.2-46.5v106.7L317 239.6l-52.8 17.8zm107.6 298.4l-107.2-53.6V295.1l107.2 46.5zm123.7-53.6l-107.2 53.6V341.6l107.2-46.5zm0-126.7l-115.5 50L264.5 277v-.2l8.9-3.3L381 234l114.5 42.9z");
    			add_location(path, file$B, 0, 200, 200);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$B, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "cubes" },
    				{ class: "svg-inline--fa fa-cubes fa-w-16" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Components_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Components_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$B, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Components_svg_rollup_plugin",
    			options,
    			id: create_fragment$B.name
    		});
    	}
    }

    /* docs_src/utilities/Animation.svelte generated by Svelte v3.53.1 */
    const file$A = "docs_src/utilities/Animation.svelte";

    // (29:8) <Tab>
    function create_default_slot_5$3(ctx) {
    	let componentsicon;
    	let current;
    	componentsicon = new Components_svg_rollup_plugin({ props: { width: 16 }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(componentsicon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(componentsicon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(componentsicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(componentsicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(componentsicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$3.name,
    		type: "slot",
    		source: "(29:8) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (30:8) <Tab>
    function create_default_slot_4$4(ctx) {
    	let codeicon;
    	let current;
    	codeicon = new Code_svg_rollup_plugin({ props: { width: 16 }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(codeicon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(codeicon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(codeicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(codeicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(codeicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$4.name,
    		type: "slot",
    		source: "(30:8) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (28:6) <TabList>
    function create_default_slot_3$4(ctx) {
    	let tab0;
    	let t;
    	let tab1;
    	let current;

    	tab0 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_5$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tab1 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_4$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tab0.$$.fragment);
    			t = space();
    			create_component(tab1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tab0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(tab1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tab0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				tab0_changes.$$scope = { dirty, ctx };
    			}

    			tab0.$set(tab0_changes);
    			const tab1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				tab1_changes.$$scope = { dirty, ctx };
    			}

    			tab1.$set(tab1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab0.$$.fragment, local);
    			transition_in(tab1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab0.$$.fragment, local);
    			transition_out(tab1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tab0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(tab1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$4.name,
    		type: "slot",
    		source: "(28:6) <TabList>",
    		ctx
    	});

    	return block;
    }

    // (33:4) <TabContent>
    function create_default_slot_2$9(ctx) {
    	let div0;
    	let articlecard;
    	let t0;
    	let div1;
    	let a0;
    	let t2;
    	let a1;
    	let t4;
    	let a2;
    	let current;

    	articlecard = new ArticleCard({
    			props: {
    				className: "animation-fogwave",
    				media: {
    					src: 'https://via.placeholder.com/610x343&text=610x343'
    				},
    				published: /*article*/ ctx[0].timestamp,
    				section: /*article*/ ctx[0].section,
    				title: /*article*/ ctx[0].title,
    				url: /*article*/ ctx[0].href
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(articlecard.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			a0 = element("a");
    			a0.textContent = "Bandekriminialitet";
    			t2 = space();
    			a1 = element("a");
    			a1.textContent = "Sport";
    			t4 = space();
    			a2 = element("a");
    			a2.textContent = "Nicklas Bendtner";
    			attr_dev(div0, "class", "flex grid-width--small");
    			add_location(div0, file$A, 33, 6, 1148);
    			attr_dev(a0, "href", "#/utilities/animation");
    			attr_dev(a0, "class", "badge margin-s bg--bluedark animation-fogwave");
    			add_location(a0, file$A, 44, 8, 1536);
    			attr_dev(a1, "href", "#/utilities/animation");
    			attr_dev(a1, "class", "badge margin-s bg--green animation-fogwave");
    			add_location(a1, file$A, 45, 8, 1653);
    			attr_dev(a2, "href", "#/utilities/animation");
    			attr_dev(a2, "class", "badge margin-s bg--greendark animation-fogwave");
    			add_location(a2, file$A, 46, 8, 1754);
    			attr_dev(div1, "class", "flex grid-width--small");
    			add_location(div1, file$A, 43, 6, 1491);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(articlecard, div0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, a0);
    			append_dev(div1, t2);
    			append_dev(div1, a1);
    			append_dev(div1, t4);
    			append_dev(div1, a2);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(articlecard);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$9.name,
    		type: "slot",
    		source: "(33:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (50:4) <TabContent>
    function create_default_slot_1$e(ctx) {
    	let prism0;
    	let t;
    	let prism1;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				source: `<ArticleCard
          className="animation-fogwave"
          href="{article.href}"
          media="{{src:'https://via.placeholder.com/610x343&text=610x343'}}"
          section="{article.section}"
          timestamp="{article.timestamp}"
          title="{article.title}"
          />`
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				source: `<a href="#" class="badge badge--primary animation-fogwave margin-s--r">Bandekriminialitet</a>`
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism0.$$.fragment);
    			t = space();
    			create_component(prism1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(prism1, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(prism1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$e.name,
    		type: "slot",
    		source: "(50:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (26:2) <Tabs>
    function create_default_slot$l(ctx) {
    	let div;
    	let tablist;
    	let t0;
    	let tabcontent0;
    	let t1;
    	let tabcontent1;
    	let current;

    	tablist = new TabList({
    			props: {
    				$$slots: { default: [create_default_slot_3$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent0 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_2$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent1 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_1$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tablist.$$.fragment);
    			t0 = space();
    			create_component(tabcontent0.$$.fragment);
    			t1 = space();
    			create_component(tabcontent1.$$.fragment);
    			attr_dev(div, "class", "flex flex-justify--end width-1of1");
    			add_location(div, file$A, 26, 4, 941);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tablist, div, null);
    			insert_dev(target, t0, anchor);
    			mount_component(tabcontent0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tabcontent1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tablist_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				tablist_changes.$$scope = { dirty, ctx };
    			}

    			tablist.$set(tablist_changes);
    			const tabcontent0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				tabcontent0_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent0.$set(tabcontent0_changes);
    			const tabcontent1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				tabcontent1_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent1.$set(tabcontent1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tablist.$$.fragment, local);
    			transition_in(tabcontent0.$$.fragment, local);
    			transition_in(tabcontent1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tablist.$$.fragment, local);
    			transition_out(tabcontent0.$$.fragment, local);
    			transition_out(tabcontent1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tablist);
    			if (detaching) detach_dev(t0);
    			destroy_component(tabcontent0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tabcontent1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$l.name,
    		type: "slot",
    		source: "(26:2) <Tabs>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let div7;
    	let h1;
    	let t1;
    	let h30;
    	let t3;
    	let p0;
    	let t4;
    	let code0;
    	let t6;
    	let p1;
    	let t8;
    	let p2;
    	let b;
    	let t10;
    	let code1;
    	let t12;
    	let h31;
    	let t14;
    	let tabs;
    	let t15;
    	let h32;
    	let t17;
    	let div6;
    	let div2;
    	let div0;
    	let t19;
    	let div1;
    	let t21;
    	let div5;
    	let div3;
    	let t23;
    	let div4;
    	let prism;
    	let current;

    	tabs = new Tabs({
    			props: {
    				$$slots: { default: [create_default_slot$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				source: `<component className="animation-fogwave"/></component>`
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Animation";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Anvendelse af animationer";
    			t3 = space();
    			p0 = element("p");
    			t4 = text("Animationer anvendes ved tilfjelse af class: ");
    			code0 = element("code");
    			code0.textContent = "className=\"animation-navnPAnimation\"";
    			t6 = space();
    			p1 = element("p");
    			p1.textContent = "Denne class kan anvendes p tvrs af vores komponenter";
    			t8 = space();
    			p2 = element("p");
    			b = element("b");
    			b.textContent = "OBS:";
    			t10 = text(" anvendes en animation direkte p et html-element skal det anvendes p flgende mde:\n    ");
    			code1 = element("code");
    			code1.textContent = "class=\"animation-navnPAnimation\"";
    			t12 = space();
    			h31 = element("h3");
    			h31.textContent = "Eksempler p animationer";
    			t14 = space();
    			create_component(tabs.$$.fragment);
    			t15 = space();
    			h32 = element("h3");
    			h32.textContent = "Overblik over animationer";
    			t17 = space();
    			div6 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "Class";
    			t19 = space();
    			div1 = element("div");
    			div1.textContent = "Use case";
    			t21 = space();
    			div5 = element("div");
    			div3 = element("div");
    			div3.textContent = "animation-fogwave";
    			t23 = space();
    			div4 = element("div");
    			create_component(prism.$$.fragment);
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$A, 16, 2, 483);
    			add_location(h30, file$A, 17, 2, 522);
    			add_location(code0, file$A, 18, 51, 608);
    			add_location(p0, file$A, 18, 2, 559);
    			add_location(p1, file$A, 19, 2, 665);
    			add_location(b, file$A, 21, 4, 737);
    			add_location(code1, file$A, 22, 4, 838);
    			add_location(p2, file$A, 20, 2, 729);
    			add_location(h31, file$A, 24, 2, 894);
    			add_location(h32, file$A, 68, 2, 2454);
    			attr_dev(div0, "class", "width-1of3 padding-m fontweight-bold");
    			add_location(div0, file$A, 71, 6, 2632);
    			attr_dev(div1, "class", "width-1of3 padding-m fontweight-bold");
    			add_location(div1, file$A, 72, 6, 2700);
    			attr_dev(div2, "class", "flex flex-item--center bg--graa7");
    			set_style(div2, "border-bottom", "1px solid rgba(0, 0, 0, .1)");
    			add_location(div2, file$A, 70, 4, 2527);
    			attr_dev(div3, "class", "flex-item--center width-1of3 padding-m");
    			add_location(div3, file$A, 75, 6, 2867);
    			attr_dev(div4, "class", "flex-item--center width-2of3 padding-m");
    			add_location(div4, file$A, 76, 6, 2949);
    			attr_dev(div5, "class", "flex bg--graa7");
    			set_style(div5, "border-bottom", "1px solid rgba(0, 0, 0, .1)");
    			add_location(div5, file$A, 74, 4, 2780);
    			attr_dev(div6, "class", "grid-width--large");
    			add_location(div6, file$A, 69, 2, 2491);
    			attr_dev(div7, "class", "grid-width--large");
    			add_location(div7, file$A, 15, 0, 449);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, h1);
    			append_dev(div7, t1);
    			append_dev(div7, h30);
    			append_dev(div7, t3);
    			append_dev(div7, p0);
    			append_dev(p0, t4);
    			append_dev(p0, code0);
    			append_dev(div7, t6);
    			append_dev(div7, p1);
    			append_dev(div7, t8);
    			append_dev(div7, p2);
    			append_dev(p2, b);
    			append_dev(p2, t10);
    			append_dev(p2, code1);
    			append_dev(div7, t12);
    			append_dev(div7, h31);
    			append_dev(div7, t14);
    			mount_component(tabs, div7, null);
    			append_dev(div7, t15);
    			append_dev(div7, h32);
    			append_dev(div7, t17);
    			append_dev(div7, div6);
    			append_dev(div6, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t19);
    			append_dev(div2, div1);
    			append_dev(div6, t21);
    			append_dev(div6, div5);
    			append_dev(div5, div3);
    			append_dev(div5, t23);
    			append_dev(div5, div4);
    			mount_component(prism, div4, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tabs_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				tabs_changes.$$scope = { dirty, ctx };
    			}

    			tabs.$set(tabs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabs.$$.fragment, local);
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabs.$$.fragment, local);
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_component(tabs);
    			destroy_component(prism);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Animation', slots, []);

    	const article = {
    		href: '#',
    		media: {
    			src: 'https://via.placeholder.com/610x343&text=610x343'
    		},
    		section: 'Sport',
    		timestamp: '2 timer siden',
    		title: 'List element'
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Animation> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		CodeIcon: Code_svg_rollup_plugin,
    		ComponentsIcon: Components_svg_rollup_plugin,
    		ArticleCard,
    		Tab,
    		TabContent,
    		TabList,
    		Tabs,
    		article
    	});

    	return [article];
    }

    class Animation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$A, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Animation",
    			options,
    			id: create_fragment$A.name
    		});
    	}
    }

    /* docs_src/utilities/Border.svelte generated by Svelte v3.53.1 */
    const file$z = "docs_src/utilities/Border.svelte";

    // (18:0) <Prism language="html">
    function create_default_slot_2$8(ctx) {
    	let t_value = `<div class="border"></div>
<div class="border--t"></div>
<div class="border--b"></div>
<div class="border--l"></div>
<div class="border--r"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$8.name,
    		type: "slot",
    		source: "(18:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (39:0) <Prism language="html">
    function create_default_slot_1$d(ctx) {
    	let t_value = `<div class="border-radius"></div>
<div class="border-radius-s"></div>
<div class="border-radius--t"></div>
<div class="border-radius-s--t"></div>
<div class="border-radius--b"></div>
<div class="border-radius-s--b"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$d.name,
    		type: "slot",
    		source: "(39:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (65:0) <Prism language="html">
    function create_default_slot$k(ctx) {
    	let t_value = `<div class="border border--black"></div>
<div class="border border--graa1"></div>
<div class="border border--graa2"></div>
<div class="border border--graa3"></div>
<div class="border border--graa4"></div>
<div class="border border--graa5"></div>
<div class="border border--graa6"></div>
<div class="border border--graa7"></div>
<div class="border border--white"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$k.name,
    		type: "slot",
    		source: "(65:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let h1;
    	let t1;
    	let h30;
    	let t3;
    	let div6;
    	let div5;
    	let div0;
    	let t5;
    	let div1;
    	let t7;
    	let div2;
    	let t9;
    	let div3;
    	let t11;
    	let div4;
    	let t13;
    	let prism0;
    	let t14;
    	let h31;
    	let t16;
    	let div14;
    	let div13;
    	let div7;
    	let t18;
    	let div8;
    	let t20;
    	let div9;
    	let t22;
    	let div10;
    	let t24;
    	let div11;
    	let t26;
    	let div12;
    	let t28;
    	let prism1;
    	let t29;
    	let h32;
    	let t31;
    	let p;
    	let t33;
    	let div25;
    	let div24;
    	let div15;
    	let t35;
    	let div16;
    	let t37;
    	let div17;
    	let t39;
    	let div18;
    	let t41;
    	let div19;
    	let t43;
    	let div20;
    	let t45;
    	let div21;
    	let t47;
    	let div22;
    	let t49;
    	let div23;
    	let t51;
    	let prism2;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Border";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Border";
    			t3 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			div0.textContent = "border";
    			t5 = space();
    			div1 = element("div");
    			div1.textContent = "border--t";
    			t7 = space();
    			div2 = element("div");
    			div2.textContent = "border--b";
    			t9 = space();
    			div3 = element("div");
    			div3.textContent = "border--l";
    			t11 = space();
    			div4 = element("div");
    			div4.textContent = "border--r";
    			t13 = space();
    			create_component(prism0.$$.fragment);
    			t14 = space();
    			h31 = element("h3");
    			h31.textContent = "Border-radius";
    			t16 = space();
    			div14 = element("div");
    			div13 = element("div");
    			div7 = element("div");
    			div7.textContent = "border-radius";
    			t18 = space();
    			div8 = element("div");
    			div8.textContent = "border-radius-s";
    			t20 = space();
    			div9 = element("div");
    			div9.textContent = "border-radius--t";
    			t22 = space();
    			div10 = element("div");
    			div10.textContent = "border-radius-s--t";
    			t24 = space();
    			div11 = element("div");
    			div11.textContent = "border-radius--b";
    			t26 = space();
    			div12 = element("div");
    			div12.textContent = "border-radius-s--b";
    			t28 = space();
    			create_component(prism1.$$.fragment);
    			t29 = space();
    			h32 = element("h3");
    			h32.textContent = "Border colors";
    			t31 = space();
    			p = element("p");
    			p.textContent = "All border colors available";
    			t33 = space();
    			div25 = element("div");
    			div24 = element("div");
    			div15 = element("div");
    			div15.textContent = "border--black";
    			t35 = space();
    			div16 = element("div");
    			div16.textContent = "border--graa1";
    			t37 = space();
    			div17 = element("div");
    			div17.textContent = "border--graa2";
    			t39 = space();
    			div18 = element("div");
    			div18.textContent = "border--graa3";
    			t41 = space();
    			div19 = element("div");
    			div19.textContent = "border--graa4";
    			t43 = space();
    			div20 = element("div");
    			div20.textContent = "border--graa5";
    			t45 = space();
    			div21 = element("div");
    			div21.textContent = "border--graa6";
    			t47 = space();
    			div22 = element("div");
    			div22.textContent = "border--graa7";
    			t49 = space();
    			div23 = element("div");
    			div23.textContent = "border--white";
    			t51 = space();
    			create_component(prism2.$$.fragment);
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$z, 3, 0, 63);
    			add_location(h30, file$z, 5, 0, 98);
    			attr_dev(div0, "class", "border border--black width-1of3 padding-xl margin-l bg--eb");
    			add_location(div0, file$z, 9, 4, 220);
    			attr_dev(div1, "class", "border--t border--black width-1of3 padding-xl margin-l bg--eb");
    			add_location(div1, file$z, 10, 4, 309);
    			attr_dev(div2, "class", "border--b border--black width-1of3 padding-xl margin-l bg--eb");
    			add_location(div2, file$z, 11, 4, 404);
    			attr_dev(div3, "class", "border--l border--black width-1of3 padding-xl margin-l bg--eb");
    			add_location(div3, file$z, 12, 4, 499);
    			attr_dev(div4, "class", "border--r border--black width-1of3 padding-xl margin-l bg--eb");
    			add_location(div4, file$z, 13, 4, 594);
    			attr_dev(div5, "class", "card-content flex flex-justify--between flex-wrap--wrap");
    			add_location(div5, file$z, 8, 2, 146);
    			attr_dev(div6, "class", "card bg--graa7");
    			add_location(div6, file$z, 7, 0, 115);
    			add_location(h31, file$z, 25, 0, 889);
    			attr_dev(div7, "class", "border-radius padding-xl width-1of3 margin-l bg--eb");
    			add_location(div7, file$z, 29, 4, 1018);
    			attr_dev(div8, "class", "border-radius-s padding-xl width-1of3 margin-l bg--eb");
    			add_location(div8, file$z, 30, 4, 1107);
    			attr_dev(div9, "class", "border-radius--t padding-xl width-1of3 margin-l bg--eb");
    			add_location(div9, file$z, 31, 4, 1200);
    			attr_dev(div10, "class", "border-radius-s--t padding-xl width-1of3 margin-l bg--eb");
    			add_location(div10, file$z, 32, 4, 1295);
    			attr_dev(div11, "class", "border-radius--b padding-xl width-1of3 margin-l bg--eb");
    			add_location(div11, file$z, 33, 4, 1394);
    			attr_dev(div12, "class", "border-radius-s--b padding-xl width-1of3 margin-l bg--eb");
    			add_location(div12, file$z, 34, 4, 1489);
    			attr_dev(div13, "class", "card-content flex flex-justify--between flex-wrap--wrap");
    			add_location(div13, file$z, 28, 2, 944);
    			attr_dev(div14, "class", "card bg--graa7");
    			add_location(div14, file$z, 27, 0, 913);
    			add_location(h32, file$z, 47, 0, 1863);
    			add_location(p, file$z, 48, 0, 1886);
    			attr_dev(div15, "class", "flex flex-align--center border border--black padding-xl width-1of3 margin-l");
    			add_location(div15, file$z, 52, 4, 2027);
    			attr_dev(div16, "class", "flex flex-align--center border border--graa1 padding-xl width-1of3 margin-l");
    			add_location(div16, file$z, 53, 4, 2140);
    			attr_dev(div17, "class", "flex flex-align--center border border--graa2 padding-xl width-1of3 margin-l");
    			add_location(div17, file$z, 54, 4, 2253);
    			attr_dev(div18, "class", "flex flex-align--center border border--graa3 padding-xl width-1of3 margin-l");
    			add_location(div18, file$z, 55, 4, 2366);
    			attr_dev(div19, "class", "flex flex-align--center border border--graa4 padding-xl width-1of3 margin-l");
    			add_location(div19, file$z, 56, 4, 2479);
    			attr_dev(div20, "class", "flex flex-align--center border border--graa5 padding-xl width-1of3 margin-l");
    			add_location(div20, file$z, 57, 4, 2592);
    			attr_dev(div21, "class", "flex flex-align--center border border--graa6 padding-xl width-1of3 margin-l");
    			add_location(div21, file$z, 58, 4, 2705);
    			attr_dev(div22, "class", "flex flex-align--center border border--graa7 padding-xl width-1of3 margin-l");
    			add_location(div22, file$z, 59, 4, 2818);
    			attr_dev(div23, "class", "flex flex-align--center border border--white padding-xl width-1of3 margin-l");
    			add_location(div23, file$z, 60, 4, 2931);
    			attr_dev(div24, "class", "card-content flex flex-justify--between flex-wrap--wrap");
    			add_location(div24, file$z, 51, 2, 1953);
    			attr_dev(div25, "class", "card bg--graa7");
    			add_location(div25, file$z, 50, 0, 1922);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			append_dev(div5, t5);
    			append_dev(div5, div1);
    			append_dev(div5, t7);
    			append_dev(div5, div2);
    			append_dev(div5, t9);
    			append_dev(div5, div3);
    			append_dev(div5, t11);
    			append_dev(div5, div4);
    			insert_dev(target, t13, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, div14, anchor);
    			append_dev(div14, div13);
    			append_dev(div13, div7);
    			append_dev(div13, t18);
    			append_dev(div13, div8);
    			append_dev(div13, t20);
    			append_dev(div13, div9);
    			append_dev(div13, t22);
    			append_dev(div13, div10);
    			append_dev(div13, t24);
    			append_dev(div13, div11);
    			append_dev(div13, t26);
    			append_dev(div13, div12);
    			insert_dev(target, t28, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t29, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t31, anchor);
    			insert_dev(target, p, anchor);
    			insert_dev(target, t33, anchor);
    			insert_dev(target, div25, anchor);
    			append_dev(div25, div24);
    			append_dev(div24, div15);
    			append_dev(div24, t35);
    			append_dev(div24, div16);
    			append_dev(div24, t37);
    			append_dev(div24, div17);
    			append_dev(div24, t39);
    			append_dev(div24, div18);
    			append_dev(div24, t41);
    			append_dev(div24, div19);
    			append_dev(div24, t43);
    			append_dev(div24, div20);
    			append_dev(div24, t45);
    			append_dev(div24, div21);
    			append_dev(div24, t47);
    			append_dev(div24, div22);
    			append_dev(div24, t49);
    			append_dev(div24, div23);
    			insert_dev(target, t51, anchor);
    			mount_component(prism2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    			const prism2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism2_changes.$$scope = { dirty, ctx };
    			}

    			prism2.$set(prism2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div6);
    			if (detaching) detach_dev(t13);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(div14);
    			if (detaching) detach_dev(t28);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t29);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t31);
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t33);
    			if (detaching) detach_dev(div25);
    			if (detaching) detach_dev(t51);
    			destroy_component(prism2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Border', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Border> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1 });
    	return [];
    }

    class Border extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Border",
    			options,
    			id: create_fragment$z.name
    		});
    	}
    }

    /* docs_src/utilities/Color.svelte generated by Svelte v3.53.1 */
    const file$y = "docs_src/utilities/Color.svelte";

    // (29:0) <Prism language="html">
    function create_default_slot_1$c(ctx) {
    	let t_value = `<div class="color--black"></div>
<div class="color--white"></div>
<div class="color--blue"></div>
<div class="color--sport"></div>
<div class="color--orangedark"></div>
<div class="color--nyheder"></div>
<div class="color--section"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$c.name,
    		type: "slot",
    		source: "(29:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (59:0) <Prism language="html">
    function create_default_slot$j(ctx) {
    	let t_value = `<div class="bg--black"></div>
<div class="bg--white"></div>
<div class="bg--underholdning"></div>
<div class="bg--eb"></div>
<div class="bg--orangedark"></div>
<div class="bg--nyheder"></div>
<div class="bg--section"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$j.name,
    		type: "slot",
    		source: "(59:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let h1;
    	let t1;
    	let h30;
    	let t3;
    	let button0;
    	let t5;
    	let div8;
    	let div7;
    	let div0;
    	let t7;
    	let div1;
    	let t9;
    	let div2;
    	let t11;
    	let div3;
    	let t13;
    	let div4;
    	let t15;
    	let div5;
    	let t17;
    	let div6;
    	let t18;
    	let em0;
    	let t20;
    	let prism0;
    	let t21;
    	let h31;
    	let t23;
    	let button1;
    	let t25;
    	let div17;
    	let div16;
    	let div9;
    	let t27;
    	let div10;
    	let t29;
    	let div11;
    	let t31;
    	let div12;
    	let t33;
    	let div13;
    	let t35;
    	let div14;
    	let t37;
    	let div15;
    	let t38;
    	let em1;
    	let t40;
    	let prism1;
    	let t41;
    	let h32;
    	let t43;
    	let object;
    	let t44;
    	let a;
    	let current;
    	let mounted;
    	let dispose;

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Color";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Text color";
    			t3 = space();
    			button0 = element("button");
    			button0.textContent = "View all colors available";
    			t5 = space();
    			div8 = element("div");
    			div7 = element("div");
    			div0 = element("div");
    			div0.textContent = "color--black";
    			t7 = space();
    			div1 = element("div");
    			div1.textContent = "color--white";
    			t9 = space();
    			div2 = element("div");
    			div2.textContent = "color--sport";
    			t11 = space();
    			div3 = element("div");
    			div3.textContent = "color--eb";
    			t13 = space();
    			div4 = element("div");
    			div4.textContent = "color--orangedark";
    			t15 = space();
    			div5 = element("div");
    			div5.textContent = "color--nyheder";
    			t17 = space();
    			div6 = element("div");
    			t18 = text("color--section\n      ");
    			em0 = element("em");
    			em0.textContent = "(inherit the color of the section i.e sport)";
    			t20 = space();
    			create_component(prism0.$$.fragment);
    			t21 = space();
    			h31 = element("h3");
    			h31.textContent = "Background color";
    			t23 = space();
    			button1 = element("button");
    			button1.textContent = "View all colors available";
    			t25 = space();
    			div17 = element("div");
    			div16 = element("div");
    			div9 = element("div");
    			div9.textContent = "bg--black";
    			t27 = space();
    			div10 = element("div");
    			div10.textContent = "bg--white";
    			t29 = space();
    			div11 = element("div");
    			div11.textContent = "bg--underholdning";
    			t31 = space();
    			div12 = element("div");
    			div12.textContent = "bg--eb";
    			t33 = space();
    			div13 = element("div");
    			div13.textContent = "bg--orangedark";
    			t35 = space();
    			div14 = element("div");
    			div14.textContent = "bg--nyheder";
    			t37 = space();
    			div15 = element("div");
    			t38 = text("bg--section\n      ");
    			em1 = element("em");
    			em1.textContent = "(inherit the color of the section i.e sport)";
    			t40 = space();
    			create_component(prism1.$$.fragment);
    			t41 = space();
    			h32 = element("h3");
    			h32.textContent = "All colors available on ekstrabladet";
    			t43 = space();
    			object = element("object");
    			t44 = text("Error: Embedded data could not be displayed. Visit this link instead: ");
    			a = element("a");
    			a.textContent = "eb-colors";
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$y, 6, 0, 162);
    			add_location(h30, file$y, 8, 0, 196);
    			attr_dev(button0, "class", "button button--cancel margin-m--b");
    			set_style(button0, "cursor", "pointer");
    			add_location(button0, file$y, 9, 0, 216);
    			attr_dev(div0, "class", "flex flex--column padding-xl width-1of3 margin-l bg--white color--black");
    			add_location(div0, file$y, 15, 4, 463);
    			attr_dev(div1, "class", "flex flex--column padding-xl width-1of3 margin-l bg--black color--white");
    			add_location(div1, file$y, 16, 4, 571);
    			attr_dev(div2, "class", "flex flex--column padding-xl width-1of3 margin-l bg--white color--sport");
    			add_location(div2, file$y, 17, 4, 679);
    			attr_dev(div3, "class", "flex flex--column padding-xl width-1of3 margin-l bg--white color--eb");
    			add_location(div3, file$y, 18, 4, 787);
    			attr_dev(div4, "class", "flex flex--column padding-xl width-1of3 margin-l bg--white color--orangedark");
    			add_location(div4, file$y, 19, 4, 889);
    			attr_dev(div5, "class", "flex flex--column padding-xl width-1of3 margin-l bg--white color--nyheder");
    			add_location(div5, file$y, 20, 4, 1007);
    			add_location(em0, file$y, 23, 6, 1234);
    			attr_dev(div6, "class", "flex flex--column padding-xl width-1of3 margin-l bg--white color--section");
    			add_location(div6, file$y, 21, 4, 1119);
    			attr_dev(div7, "class", "card-content flex flex-justify--between flex-wrap--wrap");
    			add_location(div7, file$y, 14, 2, 389);
    			attr_dev(div8, "class", "card bg--graa7");
    			add_location(div8, file$y, 13, 0, 358);
    			add_location(h31, file$y, 38, 0, 1595);
    			attr_dev(button1, "class", "button button--cancel margin-m--b");
    			set_style(button1, "cursor", "pointer");
    			add_location(button1, file$y, 39, 0, 1621);
    			attr_dev(div9, "class", "flex flex--column padding-xl width-1of3 margin-l bg--black");
    			add_location(div9, file$y, 45, 4, 1868);
    			attr_dev(div10, "class", "flex flex--column padding-xl width-1of3 margin-l bg--white color--black");
    			add_location(div10, file$y, 46, 4, 1960);
    			attr_dev(div11, "class", "flex flex--column padding-xl width-1of3 margin-l bg--underholdning");
    			add_location(div11, file$y, 47, 4, 2065);
    			attr_dev(div12, "class", "flex flex--column padding-xl width-1of3 margin-l bg--eb");
    			add_location(div12, file$y, 48, 4, 2173);
    			attr_dev(div13, "class", "flex flex--column padding-xl width-1of3 margin-l bg--orangedark");
    			add_location(div13, file$y, 49, 4, 2259);
    			attr_dev(div14, "class", "flex flex--column padding-xl width-1of3 margin-l bg--nyheder");
    			add_location(div14, file$y, 50, 4, 2361);
    			add_location(em1, file$y, 53, 6, 2569);
    			attr_dev(div15, "class", "flex flex--column padding-xl width-1of3 margin-l bg--white color--section");
    			add_location(div15, file$y, 51, 4, 2457);
    			attr_dev(div16, "class", "card-content flex flex-justify--between flex-wrap--wrap");
    			add_location(div16, file$y, 44, 2, 1794);
    			attr_dev(div17, "class", "card bg--graa7");
    			add_location(div17, file$y, 43, 0, 1763);
    			attr_dev(h32, "id", "all-colors-section");
    			add_location(h32, file$y, 68, 0, 2915);
    			attr_dev(a, "href", "https://ekstrabladetudvikling.github.io/eb-colors/");
    			add_location(a, file$y, 71, 72, 3169);
    			attr_dev(object, "data", "https://ekstrabladetudvikling.github.io/eb-colors/");
    			attr_dev(object, "width", "100%");
    			attr_dev(object, "height", "500");
    			attr_dev(object, "title", "eb-colors");
    			add_location(object, file$y, 70, 0, 2986);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, button0, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div7);
    			append_dev(div7, div0);
    			append_dev(div7, t7);
    			append_dev(div7, div1);
    			append_dev(div7, t9);
    			append_dev(div7, div2);
    			append_dev(div7, t11);
    			append_dev(div7, div3);
    			append_dev(div7, t13);
    			append_dev(div7, div4);
    			append_dev(div7, t15);
    			append_dev(div7, div5);
    			append_dev(div7, t17);
    			append_dev(div7, div6);
    			append_dev(div6, t18);
    			append_dev(div6, em0);
    			insert_dev(target, t20, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t23, anchor);
    			insert_dev(target, button1, anchor);
    			insert_dev(target, t25, anchor);
    			insert_dev(target, div17, anchor);
    			append_dev(div17, div16);
    			append_dev(div16, div9);
    			append_dev(div16, t27);
    			append_dev(div16, div10);
    			append_dev(div16, t29);
    			append_dev(div16, div11);
    			append_dev(div16, t31);
    			append_dev(div16, div12);
    			append_dev(div16, t33);
    			append_dev(div16, div13);
    			append_dev(div16, t35);
    			append_dev(div16, div14);
    			append_dev(div16, t37);
    			append_dev(div16, div15);
    			append_dev(div15, t38);
    			append_dev(div15, em1);
    			insert_dev(target, t40, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t41, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t43, anchor);
    			insert_dev(target, object, anchor);
    			append_dev(object, t44);
    			append_dev(object, a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", moveToAllColors, false, false, false),
    					listen_dev(button1, "click", moveToAllColors, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div8);
    			if (detaching) detach_dev(t20);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t23);
    			if (detaching) detach_dev(button1);
    			if (detaching) detach_dev(t25);
    			if (detaching) detach_dev(div17);
    			if (detaching) detach_dev(t40);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t41);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t43);
    			if (detaching) detach_dev(object);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function moveToAllColors() {
    	document.getElementById('all-colors-section').scrollIntoView();
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Color', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Color> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1, moveToAllColors });
    	return [];
    }

    class Color extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Color",
    			options,
    			id: create_fragment$y.name
    		});
    	}
    }

    /* docs_src/utilities/Flex.svelte generated by Svelte v3.53.1 */
    const file$x = "docs_src/utilities/Flex.svelte";

    // (8:0) <Prism language="html">
    function create_default_slot_7$2(ctx) {
    	let t_value = `<div class="flex"></div>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$2.name,
    		type: "slot",
    		source: "(8:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (48:0) <Prism language="html">
    function create_default_slot_6$2(ctx) {
    	let t_value = `<div class="flex flex-justify--start"></div>
<div class="flex flex-justify--end"></div>
<div class="flex flex-justify--center"></div>
<div class="flex flex-justify--around"></div>
<div class="flex flex-justify--between"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$2.name,
    		type: "slot",
    		source: "(48:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (86:0) <Prism language="html">
    function create_default_slot_5$2(ctx) {
    	let t_value = `<div class="flex flex-align--start"></div>
<div class="flex flex-align--end"></div>
<div class="flex flex-align--center"></div>
<div class="flex flex-align--stretch"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(86:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (104:0) <Prism language="html">
    function create_default_slot_4$3(ctx) {
    	let t_value = `<div class="flex flex--center"></div>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$3.name,
    		type: "slot",
    		source: "(104:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (138:0) <Prism language="html">
    function create_default_slot_3$3(ctx) {
    	let t_value = `<div class="flex flex--column"></div>
<div class="flex flex--column--reverse"></div>
<div class="flex"></div>
<div class="flex flex-row--reverse"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(138:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (168:0) <Prism language="html">
    function create_default_slot_2$7(ctx) {
    	let t_value = `<div class="flex"></div>
<div class="flex flex-wrap--wrap"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$7.name,
    		type: "slot",
    		source: "(168:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (186:0) <Prism language="html">
    function create_default_slot_1$b(ctx) {
    	let t_value = `<div class="flex">
  <div class="flex-item--start"></div>
  <div class="flex-item--end"></div>
  <div class="flex-item--center"></div>
  <div class="flex-item--stretch"></div>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$b.name,
    		type: "slot",
    		source: "(186:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (216:0) <Prism language="html">
    function create_default_slot$i(ctx) {
    	let t_value = `<div class="flex">
  <div class="flex-item--grow"></div>
  <div class="flex-item--noshrink"></div>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$i.name,
    		type: "slot",
    		source: "(216:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let h1;
    	let t1;
    	let h30;
    	let t3;
    	let prism0;
    	let t4;
    	let h31;
    	let t6;
    	let p0;
    	let t7;
    	let i0;
    	let t9;
    	let t10;
    	let div20;
    	let strong0;
    	let t12;
    	let div3;
    	let div0;
    	let t14;
    	let div1;
    	let t16;
    	let div2;
    	let t18;
    	let strong1;
    	let t20;
    	let div7;
    	let div4;
    	let t22;
    	let div5;
    	let t24;
    	let div6;
    	let t26;
    	let strong2;
    	let t28;
    	let div11;
    	let div8;
    	let t30;
    	let div9;
    	let t32;
    	let div10;
    	let t34;
    	let strong3;
    	let t36;
    	let div15;
    	let div12;
    	let t38;
    	let div13;
    	let t40;
    	let div14;
    	let t42;
    	let strong4;
    	let t44;
    	let div19;
    	let div16;
    	let t46;
    	let div17;
    	let t48;
    	let div18;
    	let t50;
    	let prism1;
    	let t51;
    	let h32;
    	let t53;
    	let p1;
    	let t54;
    	let i1;
    	let t56;
    	let t57;
    	let div37;
    	let strong5;
    	let t59;
    	let div24;
    	let div21;
    	let t61;
    	let div22;
    	let t63;
    	let div23;
    	let t65;
    	let strong6;
    	let t67;
    	let div28;
    	let div25;
    	let t69;
    	let div26;
    	let t71;
    	let div27;
    	let t73;
    	let strong7;
    	let t75;
    	let div32;
    	let div29;
    	let t77;
    	let div30;
    	let t79;
    	let div31;
    	let t81;
    	let strong8;
    	let t83;
    	let div36;
    	let div33;
    	let t85;
    	let div34;
    	let t87;
    	let div35;
    	let t89;
    	let prism2;
    	let t90;
    	let h33;
    	let t92;
    	let p2;
    	let t93;
    	let i2;
    	let t95;
    	let i3;
    	let t97;
    	let t98;
    	let div42;
    	let div41;
    	let div38;
    	let t100;
    	let div39;
    	let t102;
    	let div40;
    	let t104;
    	let prism3;
    	let t105;
    	let h34;
    	let t107;
    	let p3;
    	let t109;
    	let div59;
    	let strong9;
    	let t111;
    	let div46;
    	let div43;
    	let t113;
    	let div44;
    	let t115;
    	let div45;
    	let t117;
    	let strong10;
    	let t119;
    	let div50;
    	let div47;
    	let t121;
    	let div48;
    	let t123;
    	let div49;
    	let t125;
    	let strong11;
    	let t127;
    	let div54;
    	let div51;
    	let t129;
    	let div52;
    	let t131;
    	let div53;
    	let t133;
    	let strong12;
    	let t135;
    	let div58;
    	let div55;
    	let t137;
    	let div56;
    	let t139;
    	let div57;
    	let t141;
    	let prism4;
    	let t142;
    	let h35;
    	let t144;
    	let p4;
    	let t146;
    	let div70;
    	let strong13;
    	let t148;
    	let div64;
    	let div60;
    	let t150;
    	let div61;
    	let t152;
    	let div62;
    	let t154;
    	let div63;
    	let t156;
    	let strong14;
    	let t158;
    	let div69;
    	let div65;
    	let t160;
    	let div66;
    	let t162;
    	let div67;
    	let t164;
    	let div68;
    	let t166;
    	let prism5;
    	let t167;
    	let h2;
    	let t169;
    	let h36;
    	let t171;
    	let div76;
    	let div75;
    	let div71;
    	let t173;
    	let div72;
    	let t175;
    	let div73;
    	let t177;
    	let div74;
    	let t179;
    	let prism6;
    	let t180;
    	let h37;
    	let t182;
    	let p5;
    	let code0;
    	let t184;
    	let t185;
    	let p6;
    	let code1;
    	let t187;
    	let t188;
    	let div85;
    	let strong15;
    	let t190;
    	let div80;
    	let div77;
    	let t192;
    	let div78;
    	let t194;
    	let div79;
    	let t196;
    	let strong16;
    	let t198;
    	let div84;
    	let div81;
    	let t200;
    	let div82;
    	let t202;
    	let div83;
    	let t204;
    	let prism7;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_7$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_6$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_5$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism3 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_4$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism4 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_3$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism5 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism6 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism7 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Flex";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Flex container";
    			t3 = space();
    			create_component(prism0.$$.fragment);
    			t4 = space();
    			h31 = element("h3");
    			h31.textContent = "Justify content";
    			t6 = space();
    			p0 = element("p");
    			t7 = text("Justify content anvendes til ");
    			i0 = element("i");
    			i0.textContent = "horizontal";
    			t9 = text(" placering af child elementer.");
    			t10 = space();
    			div20 = element("div");
    			strong0 = element("strong");
    			strong0.textContent = "flex flex-justify--start";
    			t12 = space();
    			div3 = element("div");
    			div0 = element("div");
    			div0.textContent = "Flex item 1";
    			t14 = space();
    			div1 = element("div");
    			div1.textContent = "Flex item 2";
    			t16 = space();
    			div2 = element("div");
    			div2.textContent = "Flex item 3";
    			t18 = space();
    			strong1 = element("strong");
    			strong1.textContent = "flex flex-justify--end";
    			t20 = space();
    			div7 = element("div");
    			div4 = element("div");
    			div4.textContent = "Flex item 1";
    			t22 = space();
    			div5 = element("div");
    			div5.textContent = "Flex item 2";
    			t24 = space();
    			div6 = element("div");
    			div6.textContent = "Flex item 3";
    			t26 = space();
    			strong2 = element("strong");
    			strong2.textContent = "flex flex-justify--center";
    			t28 = space();
    			div11 = element("div");
    			div8 = element("div");
    			div8.textContent = "Flex item 1";
    			t30 = space();
    			div9 = element("div");
    			div9.textContent = "Flex item 2";
    			t32 = space();
    			div10 = element("div");
    			div10.textContent = "Flex item 3";
    			t34 = space();
    			strong3 = element("strong");
    			strong3.textContent = "flex flex-justify--around";
    			t36 = space();
    			div15 = element("div");
    			div12 = element("div");
    			div12.textContent = "Flex item 1";
    			t38 = space();
    			div13 = element("div");
    			div13.textContent = "Flex item 2";
    			t40 = space();
    			div14 = element("div");
    			div14.textContent = "Flex item 3";
    			t42 = space();
    			strong4 = element("strong");
    			strong4.textContent = "flex flex-justify--between";
    			t44 = space();
    			div19 = element("div");
    			div16 = element("div");
    			div16.textContent = "Flex item 1";
    			t46 = space();
    			div17 = element("div");
    			div17.textContent = "Flex item 2";
    			t48 = space();
    			div18 = element("div");
    			div18.textContent = "Flex item 3";
    			t50 = space();
    			create_component(prism1.$$.fragment);
    			t51 = space();
    			h32 = element("h3");
    			h32.textContent = "Align items";
    			t53 = space();
    			p1 = element("p");
    			t54 = text("Align items anvendes til ");
    			i1 = element("i");
    			i1.textContent = "veritcal";
    			t56 = text(" placering af child elementer.");
    			t57 = space();
    			div37 = element("div");
    			strong5 = element("strong");
    			strong5.textContent = "flex flex-align--start";
    			t59 = space();
    			div24 = element("div");
    			div21 = element("div");
    			div21.textContent = "Flex item 1";
    			t61 = space();
    			div22 = element("div");
    			div22.textContent = "Flex item 2";
    			t63 = space();
    			div23 = element("div");
    			div23.textContent = "Flex item 3";
    			t65 = space();
    			strong6 = element("strong");
    			strong6.textContent = "flex flex-align--end";
    			t67 = space();
    			div28 = element("div");
    			div25 = element("div");
    			div25.textContent = "Flex item 1";
    			t69 = space();
    			div26 = element("div");
    			div26.textContent = "Flex item 2";
    			t71 = space();
    			div27 = element("div");
    			div27.textContent = "Flex item 3";
    			t73 = space();
    			strong7 = element("strong");
    			strong7.textContent = "flex flex-align--center";
    			t75 = space();
    			div32 = element("div");
    			div29 = element("div");
    			div29.textContent = "Flex item 1";
    			t77 = space();
    			div30 = element("div");
    			div30.textContent = "Flex item 2";
    			t79 = space();
    			div31 = element("div");
    			div31.textContent = "Flex item 3";
    			t81 = space();
    			strong8 = element("strong");
    			strong8.textContent = "flex flex-align--stretch";
    			t83 = space();
    			div36 = element("div");
    			div33 = element("div");
    			div33.textContent = "Flex item 1";
    			t85 = space();
    			div34 = element("div");
    			div34.textContent = "Flex item 2";
    			t87 = space();
    			div35 = element("div");
    			div35.textContent = "Flex item 3";
    			t89 = space();
    			create_component(prism2.$$.fragment);
    			t90 = space();
    			h33 = element("h3");
    			h33.textContent = "Flex center";
    			t92 = space();
    			p2 = element("p");
    			t93 = text("Flex center centrere alle child elementer bde ");
    			i2 = element("i");
    			i2.textContent = "horizontalt";
    			t95 = text(" og ");
    			i3 = element("i");
    			i3.textContent = "vertical";
    			t97 = text(".");
    			t98 = space();
    			div42 = element("div");
    			div41 = element("div");
    			div38 = element("div");
    			div38.textContent = "Flex item 1";
    			t100 = space();
    			div39 = element("div");
    			div39.textContent = "Flex item 2";
    			t102 = space();
    			div40 = element("div");
    			div40.textContent = "Flex item 3";
    			t104 = space();
    			create_component(prism3.$$.fragment);
    			t105 = space();
    			h34 = element("h3");
    			h34.textContent = "Directions";
    			t107 = space();
    			p3 = element("p");
    			p3.textContent = "Directions bestemmer rkkeflgen for visning af child elementer.";
    			t109 = space();
    			div59 = element("div");
    			strong9 = element("strong");
    			strong9.textContent = "flex flex--column";
    			t111 = space();
    			div46 = element("div");
    			div43 = element("div");
    			div43.textContent = "Flex item 1";
    			t113 = space();
    			div44 = element("div");
    			div44.textContent = "Flex item 2";
    			t115 = space();
    			div45 = element("div");
    			div45.textContent = "Flex item 3";
    			t117 = space();
    			strong10 = element("strong");
    			strong10.textContent = "flex flex--column-reverse";
    			t119 = space();
    			div50 = element("div");
    			div47 = element("div");
    			div47.textContent = "Flex item 1";
    			t121 = space();
    			div48 = element("div");
    			div48.textContent = "Flex item 2";
    			t123 = space();
    			div49 = element("div");
    			div49.textContent = "Flex item 3";
    			t125 = space();
    			strong11 = element("strong");
    			strong11.textContent = "flex";
    			t127 = space();
    			div54 = element("div");
    			div51 = element("div");
    			div51.textContent = "Flex item 1";
    			t129 = space();
    			div52 = element("div");
    			div52.textContent = "Flex item 2";
    			t131 = space();
    			div53 = element("div");
    			div53.textContent = "Flex item 3";
    			t133 = space();
    			strong12 = element("strong");
    			strong12.textContent = "flex flex-row--reverse";
    			t135 = space();
    			div58 = element("div");
    			div55 = element("div");
    			div55.textContent = "Flex item 1";
    			t137 = space();
    			div56 = element("div");
    			div56.textContent = "Flex item 2";
    			t139 = space();
    			div57 = element("div");
    			div57.textContent = "Flex item 3";
    			t141 = space();
    			create_component(prism4.$$.fragment);
    			t142 = space();
    			h35 = element("h3");
    			h35.textContent = "Wrap";
    			t144 = space();
    			p4 = element("p");
    			p4.textContent = "Flex wrap srger for at alle child elementer beholder deres strrelse og istedet wrapper elementerne p multiple lines\n  istedet for one-line.";
    			t146 = space();
    			div70 = element("div");
    			strong13 = element("strong");
    			strong13.textContent = "flex";
    			t148 = space();
    			div64 = element("div");
    			div60 = element("div");
    			div60.textContent = "Flex item 1";
    			t150 = space();
    			div61 = element("div");
    			div61.textContent = "Flex item 2";
    			t152 = space();
    			div62 = element("div");
    			div62.textContent = "Flex item 3";
    			t154 = space();
    			div63 = element("div");
    			div63.textContent = "Flex item 4";
    			t156 = space();
    			strong14 = element("strong");
    			strong14.textContent = "flex flex-wrap--wrap";
    			t158 = space();
    			div69 = element("div");
    			div65 = element("div");
    			div65.textContent = "Flex item 1";
    			t160 = space();
    			div66 = element("div");
    			div66.textContent = "Flex item 2";
    			t162 = space();
    			div67 = element("div");
    			div67.textContent = "Flex item 3";
    			t164 = space();
    			div68 = element("div");
    			div68.textContent = "Flex item 4";
    			t166 = space();
    			create_component(prism5.$$.fragment);
    			t167 = space();
    			h2 = element("h2");
    			h2.textContent = "Flex items";
    			t169 = space();
    			h36 = element("h3");
    			h36.textContent = "Align self";
    			t171 = space();
    			div76 = element("div");
    			div75 = element("div");
    			div71 = element("div");
    			div71.textContent = "flex-item--start";
    			t173 = space();
    			div72 = element("div");
    			div72.textContent = "flex-item--end";
    			t175 = space();
    			div73 = element("div");
    			div73.textContent = "flex-item--center";
    			t177 = space();
    			div74 = element("div");
    			div74.textContent = "flex-item--stretch";
    			t179 = space();
    			create_component(prism6.$$.fragment);
    			t180 = space();
    			h37 = element("h3");
    			h37.textContent = "Grow and shrik";
    			t182 = space();
    			p5 = element("p");
    			code0 = element("code");
    			code0.textContent = "flex-item--grow";
    			t184 = text(" srger for at child element udfylder den tilbagevrende plads i flex containeren.");
    			t185 = space();
    			p6 = element("p");
    			code1 = element("code");
    			code1.textContent = "flex-item--noshrink";
    			t187 = text(" srger for at et child element altid vil have den samme strrelse ogs p scalering.");
    			t188 = space();
    			div85 = element("div");
    			strong15 = element("strong");
    			strong15.textContent = "Grow";
    			t190 = space();
    			div80 = element("div");
    			div77 = element("div");
    			div77.textContent = "flex-item--grow";
    			t192 = space();
    			div78 = element("div");
    			div78.textContent = "Flex item 2";
    			t194 = space();
    			div79 = element("div");
    			div79.textContent = "Flex item 3";
    			t196 = space();
    			strong16 = element("strong");
    			strong16.textContent = "No shrink";
    			t198 = space();
    			div84 = element("div");
    			div81 = element("div");
    			div81.textContent = "flex-item--noshrink width-2of3";
    			t200 = space();
    			div82 = element("div");
    			div82.textContent = "width-1of3";
    			t202 = space();
    			div83 = element("div");
    			div83.textContent = "width-1of3";
    			t204 = space();
    			create_component(prism7.$$.fragment);
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$x, 3, 0, 63);
    			add_location(h30, file$x, 5, 0, 96);
    			add_location(h31, file$x, 11, 0, 186);
    			add_location(i0, file$x, 12, 32, 243);
    			add_location(p0, file$x, 12, 0, 211);
    			attr_dev(strong0, "class", "margin-m");
    			add_location(strong0, file$x, 15, 2, 327);
    			attr_dev(div0, "class", "bg--graa4 padding-l");
    			add_location(div0, file$x, 17, 4, 438);
    			attr_dev(div1, "class", "bg--graa3 padding-l");
    			add_location(div1, file$x, 18, 4, 493);
    			attr_dev(div2, "class", "bg--graa2 padding-l");
    			add_location(div2, file$x, 19, 4, 548);
    			attr_dev(div3, "class", "flex flex-justify--start bg--eb");
    			add_location(div3, file$x, 16, 2, 388);
    			attr_dev(strong1, "class", "margin-m margin-l--t");
    			add_location(strong1, file$x, 21, 2, 610);
    			attr_dev(div4, "class", "bg--graa4 padding-l");
    			add_location(div4, file$x, 23, 4, 729);
    			attr_dev(div5, "class", "bg--graa3 padding-l");
    			add_location(div5, file$x, 24, 4, 784);
    			attr_dev(div6, "class", "bg--graa2 padding-l");
    			add_location(div6, file$x, 25, 4, 839);
    			attr_dev(div7, "class", "flex flex-justify--end bg--eb");
    			add_location(div7, file$x, 22, 2, 681);
    			attr_dev(strong2, "class", "margin-m margin-l--t");
    			add_location(strong2, file$x, 27, 2, 901);
    			attr_dev(div8, "class", "bg--graa4 padding-l");
    			add_location(div8, file$x, 29, 4, 1026);
    			attr_dev(div9, "class", "bg--graa3 padding-l");
    			add_location(div9, file$x, 30, 4, 1081);
    			attr_dev(div10, "class", "bg--graa2 padding-l");
    			add_location(div10, file$x, 31, 4, 1136);
    			attr_dev(div11, "class", "flex flex-justify--center bg--eb");
    			add_location(div11, file$x, 28, 2, 975);
    			attr_dev(strong3, "class", "margin-m margin-l--t");
    			add_location(strong3, file$x, 33, 2, 1198);
    			attr_dev(div12, "class", "bg--graa4 padding-l");
    			add_location(div12, file$x, 35, 4, 1323);
    			attr_dev(div13, "class", "bg--graa3 padding-l");
    			add_location(div13, file$x, 36, 4, 1378);
    			attr_dev(div14, "class", "bg--graa2 padding-l");
    			add_location(div14, file$x, 37, 4, 1433);
    			attr_dev(div15, "class", "flex flex-justify--around bg--eb");
    			add_location(div15, file$x, 34, 2, 1272);
    			attr_dev(strong4, "class", "margin-m margin-l--t");
    			add_location(strong4, file$x, 39, 2, 1495);
    			attr_dev(div16, "class", "bg--graa4 padding-l");
    			add_location(div16, file$x, 41, 4, 1622);
    			attr_dev(div17, "class", "bg--graa3 padding-l");
    			add_location(div17, file$x, 42, 4, 1677);
    			attr_dev(div18, "class", "bg--graa2 padding-l");
    			add_location(div18, file$x, 43, 4, 1732);
    			attr_dev(div19, "class", "flex flex-justify--between bg--eb");
    			add_location(div19, file$x, 40, 2, 1570);
    			attr_dev(div20, "class", "card bg--graa7");
    			add_location(div20, file$x, 14, 0, 296);
    			add_location(h32, file$x, 55, 0, 2067);
    			add_location(i1, file$x, 56, 28, 2116);
    			add_location(p1, file$x, 56, 0, 2088);
    			attr_dev(strong5, "class", "margin-m");
    			add_location(strong5, file$x, 59, 2, 2198);
    			attr_dev(div21, "class", "bg--graa4 padding-l");
    			add_location(div21, file$x, 61, 4, 2327);
    			attr_dev(div22, "class", "bg--graa3 padding-l");
    			add_location(div22, file$x, 62, 4, 2382);
    			attr_dev(div23, "class", "bg--graa2 padding-l");
    			add_location(div23, file$x, 63, 4, 2437);
    			attr_dev(div24, "class", "flex flex-align--start bg--eb");
    			set_style(div24, "height", "100px");
    			add_location(div24, file$x, 60, 2, 2257);
    			attr_dev(strong6, "class", "margin-m margin-l--t");
    			add_location(strong6, file$x, 65, 2, 2499);
    			attr_dev(div25, "class", "bg--graa4 padding-l");
    			add_location(div25, file$x, 67, 4, 2636);
    			attr_dev(div26, "class", "bg--graa3 padding-l");
    			add_location(div26, file$x, 68, 4, 2691);
    			attr_dev(div27, "class", "bg--graa2 padding-l");
    			add_location(div27, file$x, 69, 4, 2746);
    			attr_dev(div28, "class", "flex flex-align--end bg--eb");
    			set_style(div28, "height", "100px");
    			add_location(div28, file$x, 66, 2, 2568);
    			attr_dev(strong7, "class", "margin-m margin-l--t");
    			add_location(strong7, file$x, 71, 2, 2808);
    			attr_dev(div29, "class", "bg--graa4 padding-l");
    			add_location(div29, file$x, 73, 4, 2951);
    			attr_dev(div30, "class", "bg--graa3 padding-l");
    			add_location(div30, file$x, 74, 4, 3006);
    			attr_dev(div31, "class", "bg--graa2 padding-l");
    			add_location(div31, file$x, 75, 4, 3061);
    			attr_dev(div32, "class", "flex flex-align--center bg--eb");
    			set_style(div32, "height", "100px");
    			add_location(div32, file$x, 72, 2, 2880);
    			attr_dev(strong8, "class", "margin-m margin-l--t");
    			add_location(strong8, file$x, 77, 2, 3123);
    			attr_dev(div33, "class", "bg--graa4 padding-l");
    			add_location(div33, file$x, 79, 4, 3268);
    			attr_dev(div34, "class", "bg--graa3 padding-l");
    			add_location(div34, file$x, 80, 4, 3323);
    			attr_dev(div35, "class", "bg--graa2 padding-l");
    			add_location(div35, file$x, 81, 4, 3378);
    			attr_dev(div36, "class", "flex flex-align--stretch bg--eb");
    			set_style(div36, "height", "100px");
    			add_location(div36, file$x, 78, 2, 3196);
    			attr_dev(div37, "class", "card bg--graa7");
    			add_location(div37, file$x, 58, 0, 2167);
    			add_location(h33, file$x, 92, 0, 3659);
    			add_location(i2, file$x, 93, 50, 3730);
    			add_location(i3, file$x, 93, 72, 3752);
    			add_location(p2, file$x, 93, 0, 3680);
    			attr_dev(div38, "class", "bg--graa4 padding-l");
    			add_location(div38, file$x, 97, 4, 3870);
    			attr_dev(div39, "class", "bg--graa3 padding-l");
    			add_location(div39, file$x, 98, 4, 3925);
    			attr_dev(div40, "class", "bg--graa2 padding-l");
    			add_location(div40, file$x, 99, 4, 3980);
    			attr_dev(div41, "class", "flex flex--center bg--eb");
    			set_style(div41, "height", "100px");
    			add_location(div41, file$x, 96, 2, 3805);
    			attr_dev(div42, "class", "card bg--graa7");
    			add_location(div42, file$x, 95, 0, 3774);
    			add_location(h34, file$x, 107, 0, 4126);
    			add_location(p3, file$x, 108, 0, 4146);
    			attr_dev(strong9, "class", "margin-m");
    			add_location(strong9, file$x, 111, 2, 4250);
    			attr_dev(div43, "class", "bg--graa4 padding-l");
    			add_location(div43, file$x, 113, 4, 4340);
    			attr_dev(div44, "class", "bg--graa3 padding-l");
    			add_location(div44, file$x, 114, 4, 4395);
    			attr_dev(div45, "class", "bg--graa2 padding-l");
    			add_location(div45, file$x, 115, 4, 4450);
    			attr_dev(div46, "class", "flex flex--column");
    			add_location(div46, file$x, 112, 2, 4304);
    			attr_dev(strong10, "class", "margin-m margin-l--t");
    			add_location(strong10, file$x, 117, 2, 4512);
    			attr_dev(div47, "class", "bg--graa4 padding-l");
    			add_location(div47, file$x, 119, 4, 4630);
    			attr_dev(div48, "class", "bg--graa3 padding-l");
    			add_location(div48, file$x, 120, 4, 4685);
    			attr_dev(div49, "class", "bg--graa2 padding-l");
    			add_location(div49, file$x, 121, 4, 4740);
    			attr_dev(div50, "class", "flex flex--column-reverse");
    			add_location(div50, file$x, 118, 2, 4586);
    			attr_dev(strong11, "class", "margin-m margin-l--t");
    			add_location(strong11, file$x, 123, 2, 4802);
    			attr_dev(div51, "class", "bg--graa4 padding-l");
    			add_location(div51, file$x, 125, 4, 4885);
    			attr_dev(div52, "class", "bg--graa3 padding-l");
    			add_location(div52, file$x, 126, 4, 4940);
    			attr_dev(div53, "class", "bg--graa2 padding-l");
    			add_location(div53, file$x, 127, 4, 4995);
    			attr_dev(div54, "class", "flex bg--eb");
    			add_location(div54, file$x, 124, 2, 4855);
    			attr_dev(strong12, "class", "margin-m margin-l--t");
    			add_location(strong12, file$x, 129, 2, 5057);
    			attr_dev(div55, "class", "bg--graa4 padding-l");
    			add_location(div55, file$x, 131, 4, 5176);
    			attr_dev(div56, "class", "bg--graa3 padding-l");
    			add_location(div56, file$x, 132, 4, 5231);
    			attr_dev(div57, "class", "bg--graa2 padding-l");
    			add_location(div57, file$x, 133, 4, 5286);
    			attr_dev(div58, "class", "flex flex-row--reverse bg--eb");
    			add_location(div58, file$x, 130, 2, 5128);
    			attr_dev(div59, "class", "card bg--graa7");
    			add_location(div59, file$x, 110, 0, 4219);
    			add_location(h35, file$x, 144, 0, 5547);
    			add_location(p4, file$x, 145, 0, 5561);
    			attr_dev(strong13, "class", "margin-m");
    			add_location(strong13, file$x, 151, 2, 5747);
    			attr_dev(div60, "class", "bg--graa4 width-1of3 padding-l");
    			add_location(div60, file$x, 153, 4, 5811);
    			attr_dev(div61, "class", "bg--graa3 width-1of3 padding-l");
    			add_location(div61, file$x, 154, 4, 5877);
    			attr_dev(div62, "class", "bg--graa2 width-1of3 padding-l");
    			add_location(div62, file$x, 155, 4, 5943);
    			attr_dev(div63, "class", "bg--graa1 width-1of3 padding-l");
    			add_location(div63, file$x, 156, 4, 6009);
    			attr_dev(div64, "class", "flex");
    			add_location(div64, file$x, 152, 2, 5788);
    			attr_dev(strong14, "class", "margin-m margin-l--t");
    			add_location(strong14, file$x, 158, 2, 6082);
    			attr_dev(div65, "class", "bg--graa4 width-1of3 padding-l");
    			add_location(div65, file$x, 160, 4, 6197);
    			attr_dev(div66, "class", "bg--graa3 width-1of3 padding-l");
    			add_location(div66, file$x, 161, 4, 6263);
    			attr_dev(div67, "class", "bg--graa2 width-1of3 padding-l");
    			add_location(div67, file$x, 162, 4, 6329);
    			attr_dev(div68, "class", "bg--graa1 width-1of3 padding-l");
    			add_location(div68, file$x, 163, 4, 6395);
    			attr_dev(div69, "class", "flex flex-wrap--wrap bg--eb");
    			add_location(div69, file$x, 159, 2, 6151);
    			attr_dev(div70, "class", "card bg--graa7");
    			add_location(div70, file$x, 150, 0, 5716);
    			add_location(h2, file$x, 172, 0, 6580);
    			add_location(h36, file$x, 174, 0, 6601);
    			attr_dev(div71, "class", "flex-item--start bg--graa4 width-1of3 padding-l");
    			add_location(div71, file$x, 178, 4, 6705);
    			attr_dev(div72, "class", "flex-item--end bg--graa2 width-1of3 padding-l");
    			add_location(div72, file$x, 179, 4, 6793);
    			attr_dev(div73, "class", "flex-item--center bg--graa3 width-1of3 padding-l");
    			add_location(div73, file$x, 180, 4, 6877);
    			attr_dev(div74, "class", "flex-item--stretch bg--graa1 width-1of3 padding-l");
    			add_location(div74, file$x, 181, 4, 6967);
    			attr_dev(div75, "class", "flex bg--eb");
    			set_style(div75, "height", "100px");
    			add_location(div75, file$x, 177, 2, 6653);
    			attr_dev(div76, "class", "card bg--graa7");
    			add_location(div76, file$x, 176, 0, 6622);
    			add_location(h37, file$x, 194, 0, 7295);
    			add_location(code0, file$x, 195, 3, 7322);
    			add_location(p5, file$x, 195, 0, 7319);
    			add_location(code1, file$x, 197, 2, 7443);
    			add_location(p6, file$x, 196, 0, 7437);
    			attr_dev(strong15, "class", "margin-m margin-l--t");
    			add_location(strong15, file$x, 201, 2, 7598);
    			attr_dev(div77, "class", "flex-item--grow bg--graa4 padding-l");
    			add_location(div77, file$x, 203, 4, 7681);
    			attr_dev(div78, "class", "bg--graa3 padding-l");
    			add_location(div78, file$x, 204, 4, 7756);
    			attr_dev(div79, "class", "bg--graa2 padding-l");
    			add_location(div79, file$x, 205, 4, 7811);
    			attr_dev(div80, "class", "flex bg--eb");
    			add_location(div80, file$x, 202, 2, 7651);
    			attr_dev(strong16, "class", "margin-m margin-l--t");
    			add_location(strong16, file$x, 207, 2, 7873);
    			attr_dev(div81, "class", "flex-item--noshrink width-2of3 bg--graa4 padding-l");
    			add_location(div81, file$x, 209, 4, 7961);
    			attr_dev(div82, "class", "bg--graa3 width-1of3 padding-l");
    			add_location(div82, file$x, 210, 4, 8066);
    			attr_dev(div83, "class", "bg--graa2 width-1of3 padding-l");
    			add_location(div83, file$x, 211, 4, 8131);
    			attr_dev(div84, "class", "flex bg--eb");
    			add_location(div84, file$x, 208, 2, 7931);
    			attr_dev(div85, "class", "card bg--graa7");
    			add_location(div85, file$x, 200, 0, 7567);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, p0, anchor);
    			append_dev(p0, t7);
    			append_dev(p0, i0);
    			append_dev(p0, t9);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, div20, anchor);
    			append_dev(div20, strong0);
    			append_dev(div20, t12);
    			append_dev(div20, div3);
    			append_dev(div3, div0);
    			append_dev(div3, t14);
    			append_dev(div3, div1);
    			append_dev(div3, t16);
    			append_dev(div3, div2);
    			append_dev(div20, t18);
    			append_dev(div20, strong1);
    			append_dev(div20, t20);
    			append_dev(div20, div7);
    			append_dev(div7, div4);
    			append_dev(div7, t22);
    			append_dev(div7, div5);
    			append_dev(div7, t24);
    			append_dev(div7, div6);
    			append_dev(div20, t26);
    			append_dev(div20, strong2);
    			append_dev(div20, t28);
    			append_dev(div20, div11);
    			append_dev(div11, div8);
    			append_dev(div11, t30);
    			append_dev(div11, div9);
    			append_dev(div11, t32);
    			append_dev(div11, div10);
    			append_dev(div20, t34);
    			append_dev(div20, strong3);
    			append_dev(div20, t36);
    			append_dev(div20, div15);
    			append_dev(div15, div12);
    			append_dev(div15, t38);
    			append_dev(div15, div13);
    			append_dev(div15, t40);
    			append_dev(div15, div14);
    			append_dev(div20, t42);
    			append_dev(div20, strong4);
    			append_dev(div20, t44);
    			append_dev(div20, div19);
    			append_dev(div19, div16);
    			append_dev(div19, t46);
    			append_dev(div19, div17);
    			append_dev(div19, t48);
    			append_dev(div19, div18);
    			insert_dev(target, t50, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t51, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t53, anchor);
    			insert_dev(target, p1, anchor);
    			append_dev(p1, t54);
    			append_dev(p1, i1);
    			append_dev(p1, t56);
    			insert_dev(target, t57, anchor);
    			insert_dev(target, div37, anchor);
    			append_dev(div37, strong5);
    			append_dev(div37, t59);
    			append_dev(div37, div24);
    			append_dev(div24, div21);
    			append_dev(div24, t61);
    			append_dev(div24, div22);
    			append_dev(div24, t63);
    			append_dev(div24, div23);
    			append_dev(div37, t65);
    			append_dev(div37, strong6);
    			append_dev(div37, t67);
    			append_dev(div37, div28);
    			append_dev(div28, div25);
    			append_dev(div28, t69);
    			append_dev(div28, div26);
    			append_dev(div28, t71);
    			append_dev(div28, div27);
    			append_dev(div37, t73);
    			append_dev(div37, strong7);
    			append_dev(div37, t75);
    			append_dev(div37, div32);
    			append_dev(div32, div29);
    			append_dev(div32, t77);
    			append_dev(div32, div30);
    			append_dev(div32, t79);
    			append_dev(div32, div31);
    			append_dev(div37, t81);
    			append_dev(div37, strong8);
    			append_dev(div37, t83);
    			append_dev(div37, div36);
    			append_dev(div36, div33);
    			append_dev(div36, t85);
    			append_dev(div36, div34);
    			append_dev(div36, t87);
    			append_dev(div36, div35);
    			insert_dev(target, t89, anchor);
    			mount_component(prism2, target, anchor);
    			insert_dev(target, t90, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t92, anchor);
    			insert_dev(target, p2, anchor);
    			append_dev(p2, t93);
    			append_dev(p2, i2);
    			append_dev(p2, t95);
    			append_dev(p2, i3);
    			append_dev(p2, t97);
    			insert_dev(target, t98, anchor);
    			insert_dev(target, div42, anchor);
    			append_dev(div42, div41);
    			append_dev(div41, div38);
    			append_dev(div41, t100);
    			append_dev(div41, div39);
    			append_dev(div41, t102);
    			append_dev(div41, div40);
    			insert_dev(target, t104, anchor);
    			mount_component(prism3, target, anchor);
    			insert_dev(target, t105, anchor);
    			insert_dev(target, h34, anchor);
    			insert_dev(target, t107, anchor);
    			insert_dev(target, p3, anchor);
    			insert_dev(target, t109, anchor);
    			insert_dev(target, div59, anchor);
    			append_dev(div59, strong9);
    			append_dev(div59, t111);
    			append_dev(div59, div46);
    			append_dev(div46, div43);
    			append_dev(div46, t113);
    			append_dev(div46, div44);
    			append_dev(div46, t115);
    			append_dev(div46, div45);
    			append_dev(div59, t117);
    			append_dev(div59, strong10);
    			append_dev(div59, t119);
    			append_dev(div59, div50);
    			append_dev(div50, div47);
    			append_dev(div50, t121);
    			append_dev(div50, div48);
    			append_dev(div50, t123);
    			append_dev(div50, div49);
    			append_dev(div59, t125);
    			append_dev(div59, strong11);
    			append_dev(div59, t127);
    			append_dev(div59, div54);
    			append_dev(div54, div51);
    			append_dev(div54, t129);
    			append_dev(div54, div52);
    			append_dev(div54, t131);
    			append_dev(div54, div53);
    			append_dev(div59, t133);
    			append_dev(div59, strong12);
    			append_dev(div59, t135);
    			append_dev(div59, div58);
    			append_dev(div58, div55);
    			append_dev(div58, t137);
    			append_dev(div58, div56);
    			append_dev(div58, t139);
    			append_dev(div58, div57);
    			insert_dev(target, t141, anchor);
    			mount_component(prism4, target, anchor);
    			insert_dev(target, t142, anchor);
    			insert_dev(target, h35, anchor);
    			insert_dev(target, t144, anchor);
    			insert_dev(target, p4, anchor);
    			insert_dev(target, t146, anchor);
    			insert_dev(target, div70, anchor);
    			append_dev(div70, strong13);
    			append_dev(div70, t148);
    			append_dev(div70, div64);
    			append_dev(div64, div60);
    			append_dev(div64, t150);
    			append_dev(div64, div61);
    			append_dev(div64, t152);
    			append_dev(div64, div62);
    			append_dev(div64, t154);
    			append_dev(div64, div63);
    			append_dev(div70, t156);
    			append_dev(div70, strong14);
    			append_dev(div70, t158);
    			append_dev(div70, div69);
    			append_dev(div69, div65);
    			append_dev(div69, t160);
    			append_dev(div69, div66);
    			append_dev(div69, t162);
    			append_dev(div69, div67);
    			append_dev(div69, t164);
    			append_dev(div69, div68);
    			insert_dev(target, t166, anchor);
    			mount_component(prism5, target, anchor);
    			insert_dev(target, t167, anchor);
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t169, anchor);
    			insert_dev(target, h36, anchor);
    			insert_dev(target, t171, anchor);
    			insert_dev(target, div76, anchor);
    			append_dev(div76, div75);
    			append_dev(div75, div71);
    			append_dev(div75, t173);
    			append_dev(div75, div72);
    			append_dev(div75, t175);
    			append_dev(div75, div73);
    			append_dev(div75, t177);
    			append_dev(div75, div74);
    			insert_dev(target, t179, anchor);
    			mount_component(prism6, target, anchor);
    			insert_dev(target, t180, anchor);
    			insert_dev(target, h37, anchor);
    			insert_dev(target, t182, anchor);
    			insert_dev(target, p5, anchor);
    			append_dev(p5, code0);
    			append_dev(p5, t184);
    			insert_dev(target, t185, anchor);
    			insert_dev(target, p6, anchor);
    			append_dev(p6, code1);
    			append_dev(p6, t187);
    			insert_dev(target, t188, anchor);
    			insert_dev(target, div85, anchor);
    			append_dev(div85, strong15);
    			append_dev(div85, t190);
    			append_dev(div85, div80);
    			append_dev(div80, div77);
    			append_dev(div80, t192);
    			append_dev(div80, div78);
    			append_dev(div80, t194);
    			append_dev(div80, div79);
    			append_dev(div85, t196);
    			append_dev(div85, strong16);
    			append_dev(div85, t198);
    			append_dev(div85, div84);
    			append_dev(div84, div81);
    			append_dev(div84, t200);
    			append_dev(div84, div82);
    			append_dev(div84, t202);
    			append_dev(div84, div83);
    			insert_dev(target, t204, anchor);
    			mount_component(prism7, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    			const prism2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism2_changes.$$scope = { dirty, ctx };
    			}

    			prism2.$set(prism2_changes);
    			const prism3_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism3_changes.$$scope = { dirty, ctx };
    			}

    			prism3.$set(prism3_changes);
    			const prism4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism4_changes.$$scope = { dirty, ctx };
    			}

    			prism4.$set(prism4_changes);
    			const prism5_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism5_changes.$$scope = { dirty, ctx };
    			}

    			prism5.$set(prism5_changes);
    			const prism6_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism6_changes.$$scope = { dirty, ctx };
    			}

    			prism6.$set(prism6_changes);
    			const prism7_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism7_changes.$$scope = { dirty, ctx };
    			}

    			prism7.$set(prism7_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			transition_in(prism3.$$.fragment, local);
    			transition_in(prism4.$$.fragment, local);
    			transition_in(prism5.$$.fragment, local);
    			transition_in(prism6.$$.fragment, local);
    			transition_in(prism7.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			transition_out(prism3.$$.fragment, local);
    			transition_out(prism4.$$.fragment, local);
    			transition_out(prism5.$$.fragment, local);
    			transition_out(prism6.$$.fragment, local);
    			transition_out(prism7.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t3);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(div20);
    			if (detaching) detach_dev(t50);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t51);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t53);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t57);
    			if (detaching) detach_dev(div37);
    			if (detaching) detach_dev(t89);
    			destroy_component(prism2, detaching);
    			if (detaching) detach_dev(t90);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t92);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t98);
    			if (detaching) detach_dev(div42);
    			if (detaching) detach_dev(t104);
    			destroy_component(prism3, detaching);
    			if (detaching) detach_dev(t105);
    			if (detaching) detach_dev(h34);
    			if (detaching) detach_dev(t107);
    			if (detaching) detach_dev(p3);
    			if (detaching) detach_dev(t109);
    			if (detaching) detach_dev(div59);
    			if (detaching) detach_dev(t141);
    			destroy_component(prism4, detaching);
    			if (detaching) detach_dev(t142);
    			if (detaching) detach_dev(h35);
    			if (detaching) detach_dev(t144);
    			if (detaching) detach_dev(p4);
    			if (detaching) detach_dev(t146);
    			if (detaching) detach_dev(div70);
    			if (detaching) detach_dev(t166);
    			destroy_component(prism5, detaching);
    			if (detaching) detach_dev(t167);
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t169);
    			if (detaching) detach_dev(h36);
    			if (detaching) detach_dev(t171);
    			if (detaching) detach_dev(div76);
    			if (detaching) detach_dev(t179);
    			destroy_component(prism6, detaching);
    			if (detaching) detach_dev(t180);
    			if (detaching) detach_dev(h37);
    			if (detaching) detach_dev(t182);
    			if (detaching) detach_dev(p5);
    			if (detaching) detach_dev(t185);
    			if (detaching) detach_dev(p6);
    			if (detaching) detach_dev(t188);
    			if (detaching) detach_dev(div85);
    			if (detaching) detach_dev(t204);
    			destroy_component(prism7, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Flex', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Flex> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1 });
    	return [];
    }

    class Flex extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Flex",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    /* docs_src/utilities/Fonts.svelte generated by Svelte v3.53.1 */
    const file$w = "docs_src/utilities/Fonts.svelte";

    // (19:0) <Prism language="html">
    function create_default_slot_2$6(ctx) {
    	let t_value = `<div class="ff-primary"></div>
<div class="ff-secondary"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$6.name,
    		type: "slot",
    		source: "(19:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (32:0) <Prism language="html">
    function create_default_slot_1$a(ctx) {
    	let t_value = `<p class="fontweight-normal"></p>
<p class="fontweight-bold"></p>
<p class="fontweight-bolder"></p>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$a.name,
    		type: "slot",
    		source: "(32:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (92:0) <Prism language="html">
    function create_default_slot$h(ctx) {
    	let t_value = `<div class="fontsize-xxsmall"></div>
<div class="fontsize-xsmall"></div>
<div class="fontsize-small"></div>
<div class="fontsize-medium"></div>
<div class="fontsize-large"></div>
<div class="fontsize-xlarge"></div>
<div class="fontsize-xxlarge"></div>
<div class="fontsize-xxxlarge"></div>
<div class="fontsize-xxxxlarge"></div>

<div class="fontsize-smaller"></div>
<div class="fontsize-larger"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$h.name,
    		type: "slot",
    		source: "(92:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let h10;
    	let t1;
    	let h30;
    	let t3;
    	let div2;
    	let div0;
    	let strong0;
    	let t5;
    	let p0;
    	let t7;
    	let div1;
    	let strong1;
    	let t9;
    	let p1;
    	let t11;
    	let prism0;
    	let t12;
    	let h31;
    	let t14;
    	let div3;
    	let p2;
    	let t16;
    	let p3;
    	let t18;
    	let p4;
    	let t20;
    	let prism1;
    	let t21;
    	let h32;
    	let t23;
    	let p5;
    	let t25;
    	let p6;
    	let t27;
    	let p7;
    	let t28;
    	let u0;
    	let t30;
    	let u1;
    	let t32;
    	let t33;
    	let div31;
    	let div6;
    	let t34;
    	let div4;
    	let t36;
    	let div5;
    	let t38;
    	let div9;
    	let t39;
    	let div7;
    	let t41;
    	let div8;
    	let t43;
    	let div12;
    	let t44;
    	let div10;
    	let t46;
    	let div11;
    	let t48;
    	let div15;
    	let t49;
    	let div13;
    	let t51;
    	let div14;
    	let t53;
    	let div18;
    	let t54;
    	let div16;
    	let t56;
    	let div17;
    	let t58;
    	let div21;
    	let t59;
    	let div19;
    	let t61;
    	let div20;
    	let t63;
    	let div24;
    	let t64;
    	let div22;
    	let t66;
    	let div23;
    	let t68;
    	let div27;
    	let t69;
    	let div25;
    	let t71;
    	let div26;
    	let t73;
    	let div30;
    	let t74;
    	let div28;
    	let t76;
    	let div29;
    	let t78;
    	let prism2;
    	let t79;
    	let h33;
    	let t81;
    	let div32;
    	let h11;
    	let t83;
    	let h2;
    	let t85;
    	let h34;
    	let t87;
    	let h4;
    	let t89;
    	let h5;
    	let t91;
    	let h6;
    	let t93;
    	let p8;
    	let t95;
    	let p9;
    	let t97;
    	let p10;
    	let t99;
    	let p11;
    	let t101;
    	let p12;
    	let t103;
    	let p13;
    	let t105;
    	let p14;
    	let t107;
    	let p15;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h10 = element("h1");
    			h10.textContent = "Fonts";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Font family";
    			t3 = space();
    			div2 = element("div");
    			div0 = element("div");
    			strong0 = element("strong");
    			strong0.textContent = ".ff-primary:";
    			t5 = space();
    			p0 = element("p");
    			p0.textContent = "Aa Bb Cc Dd Ee Ff Gg Hh Ii Jj Kk Ll Mm Nn Oo Pp Qq Rr Ss Tt Uu Vv Ww Xx Yy Zz    1234567890";
    			t7 = space();
    			div1 = element("div");
    			strong1 = element("strong");
    			strong1.textContent = ".ff-secondary:";
    			t9 = space();
    			p1 = element("p");
    			p1.textContent = "Aa Bb Cc Dd Ee Ff Gg Hh Ii Jj Kk Ll Mm Nn Oo Pp Qq Rr Ss Tt Uu Vv Ww Xx Yy Zz    1234567890";
    			t11 = space();
    			create_component(prism0.$$.fragment);
    			t12 = space();
    			h31 = element("h3");
    			h31.textContent = "Font-weight";
    			t14 = space();
    			div3 = element("div");
    			p2 = element("p");
    			p2.textContent = "fontweight-normal";
    			t16 = space();
    			p3 = element("p");
    			p3.textContent = "fontweight-bold";
    			t18 = space();
    			p4 = element("p");
    			p4.textContent = "fontweight-bolder";
    			t20 = space();
    			create_component(prism1.$$.fragment);
    			t21 = space();
    			h32 = element("h3");
    			h32.textContent = "Font-size";
    			t23 = space();
    			p5 = element("p");
    			p5.textContent = "Font-size er sat i rem for at understtte brugerens font-size valg i browseren.";
    			t25 = space();
    			p6 = element("p");
    			p6.textContent = "Rem vrdien er udregnet i forhold til en basis font-size p 16px, hvilket er browser-standarden";
    			t27 = space();
    			p7 = element("p");
    			t28 = text("Der er bde en ");
    			u0 = element("u");
    			u0.textContent = "larger";
    			t30 = text(" og en ");
    			u1 = element("u");
    			u1.textContent = "smaller";
    			t32 = text(" mulighed, der begge er relative til parent fontsize");
    			t33 = space();
    			div31 = element("div");
    			div6 = element("div");
    			t34 = text("fontsize-xxsmall = .625rem ~ 10px;\n    ");
    			div4 = element("div");
    			div4.textContent = "fontsize-smaller";
    			t36 = space();
    			div5 = element("div");
    			div5.textContent = "fontsize-larger";
    			t38 = space();
    			div9 = element("div");
    			t39 = text("fontsize-xsmall = .75rem ~ 12px;\n    ");
    			div7 = element("div");
    			div7.textContent = "fontsize-smaller";
    			t41 = space();
    			div8 = element("div");
    			div8.textContent = "fontsize-larger";
    			t43 = space();
    			div12 = element("div");
    			t44 = text("fontsize-small = .875rem ~ 14px;\n    ");
    			div10 = element("div");
    			div10.textContent = "fontsize-smaller";
    			t46 = space();
    			div11 = element("div");
    			div11.textContent = "fontsize-larger";
    			t48 = space();
    			div15 = element("div");
    			t49 = text("fontsize-medium = 1rem ~ 16px;\n    ");
    			div13 = element("div");
    			div13.textContent = "fontsize-smaller";
    			t51 = space();
    			div14 = element("div");
    			div14.textContent = "fontsize-larger";
    			t53 = space();
    			div18 = element("div");
    			t54 = text("fontsize-large = 1.125rem ~ 18px;\n    ");
    			div16 = element("div");
    			div16.textContent = "fontsize-smaller";
    			t56 = space();
    			div17 = element("div");
    			div17.textContent = "fontsize-larger";
    			t58 = space();
    			div21 = element("div");
    			t59 = text("fontsize-xlarge = 1.25rem ~ 20px;\n    ");
    			div19 = element("div");
    			div19.textContent = "fontsize-smaller";
    			t61 = space();
    			div20 = element("div");
    			div20.textContent = "fontsize-larger";
    			t63 = space();
    			div24 = element("div");
    			t64 = text("fontsize-xxlarge = 1.875rem ~ 30px;\n    ");
    			div22 = element("div");
    			div22.textContent = "fontsize-smaller";
    			t66 = space();
    			div23 = element("div");
    			div23.textContent = "fontsize-larger";
    			t68 = space();
    			div27 = element("div");
    			t69 = text("fontsize-xxxlarge = 2.25rem ~ 36px;\n    ");
    			div25 = element("div");
    			div25.textContent = "fontsize-smaller";
    			t71 = space();
    			div26 = element("div");
    			div26.textContent = "fontsize-larger";
    			t73 = space();
    			div30 = element("div");
    			t74 = text("fontsize-xxxxlarge = 3.125rem ~ 50px;\n    ");
    			div28 = element("div");
    			div28.textContent = "fontsize-smaller";
    			t76 = space();
    			div29 = element("div");
    			div29.textContent = "fontsize-larger";
    			t78 = space();
    			create_component(prism2.$$.fragment);
    			t79 = space();
    			h33 = element("h3");
    			h33.textContent = "Headers and font aliases";
    			t81 = space();
    			div32 = element("div");
    			h11 = element("h1");
    			h11.textContent = "h1";
    			t83 = space();
    			h2 = element("h2");
    			h2.textContent = "h2";
    			t85 = space();
    			h34 = element("h3");
    			h34.textContent = "h3";
    			t87 = space();
    			h4 = element("h4");
    			h4.textContent = "h4";
    			t89 = space();
    			h5 = element("h5");
    			h5.textContent = "h5";
    			t91 = space();
    			h6 = element("h6");
    			h6.textContent = "h6";
    			t93 = space();
    			p8 = element("p");
    			p8.textContent = "fs-ads";
    			t95 = space();
    			p9 = element("p");
    			p9.textContent = "fs-bodytext";
    			t97 = space();
    			p10 = element("p");
    			p10.textContent = "fs-caption";
    			t99 = space();
    			p11 = element("p");
    			p11.textContent = "fs-quote";
    			t101 = space();
    			p12 = element("p");
    			p12.textContent = "fs-showmore";
    			t103 = space();
    			p13 = element("p");
    			p13.textContent = "fs-subtitle";
    			t105 = space();
    			p14 = element("p");
    			p14.textContent = "fs-timestamp";
    			t107 = space();
    			p15 = element("p");
    			p15.textContent = "fs-title";
    			attr_dev(h10, "class", "color--eb");
    			add_location(h10, file$w, 3, 0, 63);
    			add_location(h30, file$w, 5, 0, 97);
    			add_location(strong0, file$w, 9, 4, 206);
    			add_location(p0, file$w, 10, 4, 240);
    			attr_dev(div0, "class", "ff-primary margin-l--tb");
    			add_location(div0, file$w, 8, 2, 164);
    			add_location(strong1, file$w, 13, 4, 387);
    			add_location(p1, file$w, 14, 4, 423);
    			attr_dev(div1, "class", "ff-secondary");
    			add_location(div1, file$w, 12, 2, 356);
    			attr_dev(div2, "class", "card bg--graa7 padding-l--rl");
    			add_location(div2, file$w, 7, 0, 119);
    			add_location(h31, file$w, 23, 0, 649);
    			attr_dev(p2, "class", "fontweight-normal");
    			add_location(p2, file$w, 26, 2, 716);
    			attr_dev(p3, "class", "fontweight-bold");
    			add_location(p3, file$w, 27, 2, 769);
    			attr_dev(p4, "class", "fontweight-bolder");
    			add_location(p4, file$w, 28, 2, 818);
    			attr_dev(div3, "class", "card bg--graa7 padding-l--rl");
    			add_location(div3, file$w, 25, 0, 671);
    			add_location(h32, file$w, 37, 0, 1017);
    			add_location(p5, file$w, 39, 0, 1037);
    			add_location(p6, file$w, 40, 0, 1124);
    			add_location(u0, file$w, 41, 18, 1245);
    			add_location(u1, file$w, 41, 38, 1265);
    			add_location(p7, file$w, 41, 0, 1227);
    			attr_dev(div4, "class", "fontsize-smaller");
    			add_location(div4, file$w, 46, 4, 1465);
    			attr_dev(div5, "class", "fontsize-larger");
    			add_location(div5, file$w, 47, 4, 1522);
    			attr_dev(div6, "class", "fontsize-xxsmall padding-m--b");
    			add_location(div6, file$w, 44, 2, 1378);
    			attr_dev(div7, "class", "fontsize-smaller");
    			add_location(div7, file$w, 51, 4, 1669);
    			attr_dev(div8, "class", "fontsize-larger");
    			add_location(div8, file$w, 52, 4, 1726);
    			attr_dev(div9, "class", "fontsize-xsmall padding-m--tb");
    			add_location(div9, file$w, 49, 2, 1584);
    			attr_dev(div10, "class", "fontsize-smaller");
    			add_location(div10, file$w, 56, 4, 1872);
    			attr_dev(div11, "class", "fontsize-larger");
    			add_location(div11, file$w, 57, 4, 1929);
    			attr_dev(div12, "class", "fontsize-small padding-m--tb");
    			add_location(div12, file$w, 54, 2, 1788);
    			attr_dev(div13, "class", "fontsize-smaller");
    			add_location(div13, file$w, 61, 4, 2074);
    			attr_dev(div14, "class", "fontsize-larger");
    			add_location(div14, file$w, 62, 4, 2131);
    			attr_dev(div15, "class", "fontsize-medium padding-m--tb");
    			add_location(div15, file$w, 59, 2, 1991);
    			attr_dev(div16, "class", "fontsize-smaller");
    			add_location(div16, file$w, 66, 4, 2278);
    			attr_dev(div17, "class", "fontsize-larger");
    			add_location(div17, file$w, 67, 4, 2335);
    			attr_dev(div18, "class", "fontsize-large padding-m--tb");
    			add_location(div18, file$w, 64, 2, 2193);
    			attr_dev(div19, "class", "fontsize-smaller");
    			add_location(div19, file$w, 71, 4, 2483);
    			attr_dev(div20, "class", "fontsize-larger");
    			add_location(div20, file$w, 72, 4, 2540);
    			attr_dev(div21, "class", "fontsize-xlarge padding-m--tb");
    			add_location(div21, file$w, 69, 2, 2397);
    			attr_dev(div22, "class", "fontsize-smaller");
    			add_location(div22, file$w, 76, 4, 2691);
    			attr_dev(div23, "class", "fontsize-larger");
    			add_location(div23, file$w, 77, 4, 2748);
    			attr_dev(div24, "class", "fontsize-xxlarge padding-m--tb");
    			add_location(div24, file$w, 74, 2, 2602);
    			attr_dev(div25, "class", "fontsize-smaller");
    			add_location(div25, file$w, 81, 4, 2900);
    			attr_dev(div26, "class", "fontsize-larger");
    			add_location(div26, file$w, 82, 4, 2957);
    			attr_dev(div27, "class", "fontsize-xxxlarge padding-m--tb");
    			add_location(div27, file$w, 79, 2, 2810);
    			attr_dev(div28, "class", "fontsize-smaller");
    			add_location(div28, file$w, 86, 4, 3111);
    			attr_dev(div29, "class", "fontsize-larger");
    			add_location(div29, file$w, 87, 4, 3168);
    			attr_dev(div30, "class", "fontsize-xxxxlarge padding-m--t");
    			add_location(div30, file$w, 84, 2, 3019);
    			attr_dev(div31, "class", "card bg--graa7 padding-l");
    			add_location(div31, file$w, 43, 0, 1337);
    			add_location(h33, file$w, 106, 0, 3679);
    			add_location(h11, file$w, 109, 2, 3772);
    			add_location(h2, file$w, 110, 2, 3786);
    			add_location(h34, file$w, 111, 2, 3800);
    			add_location(h4, file$w, 112, 2, 3814);
    			add_location(h5, file$w, 113, 2, 3828);
    			add_location(h6, file$w, 114, 2, 3842);
    			attr_dev(p8, "class", "fs-ads");
    			add_location(p8, file$w, 116, 2, 3857);
    			attr_dev(p9, "class", "fs-bodytext");
    			add_location(p9, file$w, 117, 2, 3888);
    			attr_dev(p10, "class", "fs-caption");
    			add_location(p10, file$w, 118, 2, 3929);
    			attr_dev(p11, "class", "fs-quote");
    			add_location(p11, file$w, 119, 2, 3968);
    			attr_dev(p12, "class", "fs-showmore");
    			add_location(p12, file$w, 120, 2, 4003);
    			attr_dev(p13, "class", "fs-subtitle");
    			add_location(p13, file$w, 121, 2, 4044);
    			attr_dev(p14, "class", "fs-timestamp");
    			add_location(p14, file$w, 122, 2, 4085);
    			attr_dev(p15, "class", "fs-title");
    			add_location(p15, file$w, 123, 2, 4128);
    			attr_dev(div32, "class", "card bg--graa7 padding-l--rl padding-l--t");
    			add_location(div32, file$w, 108, 0, 3714);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h10, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, strong0);
    			append_dev(div0, t5);
    			append_dev(div0, p0);
    			append_dev(div2, t7);
    			append_dev(div2, div1);
    			append_dev(div1, strong1);
    			append_dev(div1, t9);
    			append_dev(div1, p1);
    			insert_dev(target, t11, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, p2);
    			append_dev(div3, t16);
    			append_dev(div3, p3);
    			append_dev(div3, t18);
    			append_dev(div3, p4);
    			insert_dev(target, t20, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t23, anchor);
    			insert_dev(target, p5, anchor);
    			insert_dev(target, t25, anchor);
    			insert_dev(target, p6, anchor);
    			insert_dev(target, t27, anchor);
    			insert_dev(target, p7, anchor);
    			append_dev(p7, t28);
    			append_dev(p7, u0);
    			append_dev(p7, t30);
    			append_dev(p7, u1);
    			append_dev(p7, t32);
    			insert_dev(target, t33, anchor);
    			insert_dev(target, div31, anchor);
    			append_dev(div31, div6);
    			append_dev(div6, t34);
    			append_dev(div6, div4);
    			append_dev(div6, t36);
    			append_dev(div6, div5);
    			append_dev(div31, t38);
    			append_dev(div31, div9);
    			append_dev(div9, t39);
    			append_dev(div9, div7);
    			append_dev(div9, t41);
    			append_dev(div9, div8);
    			append_dev(div31, t43);
    			append_dev(div31, div12);
    			append_dev(div12, t44);
    			append_dev(div12, div10);
    			append_dev(div12, t46);
    			append_dev(div12, div11);
    			append_dev(div31, t48);
    			append_dev(div31, div15);
    			append_dev(div15, t49);
    			append_dev(div15, div13);
    			append_dev(div15, t51);
    			append_dev(div15, div14);
    			append_dev(div31, t53);
    			append_dev(div31, div18);
    			append_dev(div18, t54);
    			append_dev(div18, div16);
    			append_dev(div18, t56);
    			append_dev(div18, div17);
    			append_dev(div31, t58);
    			append_dev(div31, div21);
    			append_dev(div21, t59);
    			append_dev(div21, div19);
    			append_dev(div21, t61);
    			append_dev(div21, div20);
    			append_dev(div31, t63);
    			append_dev(div31, div24);
    			append_dev(div24, t64);
    			append_dev(div24, div22);
    			append_dev(div24, t66);
    			append_dev(div24, div23);
    			append_dev(div31, t68);
    			append_dev(div31, div27);
    			append_dev(div27, t69);
    			append_dev(div27, div25);
    			append_dev(div27, t71);
    			append_dev(div27, div26);
    			append_dev(div31, t73);
    			append_dev(div31, div30);
    			append_dev(div30, t74);
    			append_dev(div30, div28);
    			append_dev(div30, t76);
    			append_dev(div30, div29);
    			insert_dev(target, t78, anchor);
    			mount_component(prism2, target, anchor);
    			insert_dev(target, t79, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t81, anchor);
    			insert_dev(target, div32, anchor);
    			append_dev(div32, h11);
    			append_dev(div32, t83);
    			append_dev(div32, h2);
    			append_dev(div32, t85);
    			append_dev(div32, h34);
    			append_dev(div32, t87);
    			append_dev(div32, h4);
    			append_dev(div32, t89);
    			append_dev(div32, h5);
    			append_dev(div32, t91);
    			append_dev(div32, h6);
    			append_dev(div32, t93);
    			append_dev(div32, p8);
    			append_dev(div32, t95);
    			append_dev(div32, p9);
    			append_dev(div32, t97);
    			append_dev(div32, p10);
    			append_dev(div32, t99);
    			append_dev(div32, p11);
    			append_dev(div32, t101);
    			append_dev(div32, p12);
    			append_dev(div32, t103);
    			append_dev(div32, p13);
    			append_dev(div32, t105);
    			append_dev(div32, p14);
    			append_dev(div32, t107);
    			append_dev(div32, p15);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    			const prism2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism2_changes.$$scope = { dirty, ctx };
    			}

    			prism2.$set(prism2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h10);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t11);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(div3);
    			if (detaching) detach_dev(t20);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t23);
    			if (detaching) detach_dev(p5);
    			if (detaching) detach_dev(t25);
    			if (detaching) detach_dev(p6);
    			if (detaching) detach_dev(t27);
    			if (detaching) detach_dev(p7);
    			if (detaching) detach_dev(t33);
    			if (detaching) detach_dev(div31);
    			if (detaching) detach_dev(t78);
    			destroy_component(prism2, detaching);
    			if (detaching) detach_dev(t79);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t81);
    			if (detaching) detach_dev(div32);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Fonts', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Fonts> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1 });
    	return [];
    }

    class Fonts$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Fonts",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    /* docs_src/utilities/Grid.svelte generated by Svelte v3.53.1 */
    const file$v = "docs_src/utilities/Grid.svelte";

    // (27:0) <Prism language="html">
    function create_default_slot_1$9(ctx) {
    	let t_value = `<div class="grid-width--xlarge"></div>
<div class="grid-width--large"></div>
<div class="grid-width--medium"></div>
<div class="grid-width--small"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$9.name,
    		type: "slot",
    		source: "(27:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (36:0) <Prism language="css">
    function create_default_slot$g(ctx) {
    	let t_value = `--grid-small: 610px;
--grid-medium: 730px;
--grid-large: 910px;
--grid-xlarge: 930px;` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$g.name,
    		type: "slot",
    		source: "(36:0) <Prism language=\\\"css\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let h1;
    	let t1;
    	let div4;
    	let div3;
    	let p0;
    	let t3;
    	let p1;
    	let t5;
    	let div2;
    	let p2;
    	let t7;
    	let p3;
    	let t9;
    	let div1;
    	let p4;
    	let t11;
    	let p5;
    	let t13;
    	let div0;
    	let p6;
    	let t15;
    	let p7;
    	let t17;
    	let h30;
    	let t19;
    	let prism0;
    	let t20;
    	let h31;
    	let t22;
    	let prism1;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "css",
    				$$slots: { default: [create_default_slot$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Grid";
    			t1 = space();
    			div4 = element("div");
    			div3 = element("div");
    			p0 = element("p");
    			p0.textContent = "grid-width--xlarge: 930px";
    			t3 = space();
    			p1 = element("p");
    			p1.textContent = "Page content width - frontpage";
    			t5 = space();
    			div2 = element("div");
    			p2 = element("p");
    			p2.textContent = "grid-width--large: 910px";
    			t7 = space();
    			p3 = element("p");
    			p3.textContent = "Page content width";
    			t9 = space();
    			div1 = element("div");
    			p4 = element("p");
    			p4.textContent = "grid-width--medium: 730px";
    			t11 = space();
    			p5 = element("p");
    			p5.textContent = "Bodytext container width";
    			t13 = space();
    			div0 = element("div");
    			p6 = element("p");
    			p6.textContent = "grid-width--small: 610px";
    			t15 = space();
    			p7 = element("p");
    			p7.textContent = "Widget width";
    			t17 = space();
    			h30 = element("h3");
    			h30.textContent = "HTML class names";
    			t19 = space();
    			create_component(prism0.$$.fragment);
    			t20 = space();
    			h31 = element("h3");
    			h31.textContent = "CSS variable names";
    			t22 = space();
    			create_component(prism1.$$.fragment);
    			attr_dev(h1, "class", "color--eb margin-l--b");
    			add_location(h1, file$v, 3, 0, 63);
    			add_location(p0, file$v, 7, 4, 243);
    			add_location(p1, file$v, 8, 4, 280);
    			add_location(p2, file$v, 10, 6, 409);
    			add_location(p3, file$v, 11, 6, 447);
    			add_location(p4, file$v, 13, 8, 568);
    			add_location(p5, file$v, 14, 8, 609);
    			add_location(p6, file$v, 16, 10, 740);
    			add_location(p7, file$v, 17, 10, 782);
    			attr_dev(div0, "class", "grid-width--small vertical-center bg--eb2");
    			set_style(div0, "overflow", "hidden");
    			add_location(div0, file$v, 15, 8, 649);
    			attr_dev(div1, "class", "grid-width--medium vertical-center bg--eb");
    			set_style(div1, "overflow", "hidden");
    			add_location(div1, file$v, 12, 6, 479);
    			attr_dev(div2, "class", "grid-width--large vertical-center bg--eb2");
    			set_style(div2, "overflow", "hidden");
    			add_location(div2, file$v, 9, 4, 322);
    			attr_dev(div3, "class", "grid-width--xlarge vertical-center bg--eb");
    			set_style(div3, "overflow", "hidden");
    			add_location(div3, file$v, 6, 2, 158);
    			attr_dev(div4, "class", "card bg--graa7 text-align--center");
    			add_location(div4, file$v, 5, 0, 108);
    			add_location(h30, file$v, 24, 0, 858);
    			add_location(h31, file$v, 33, 0, 1079);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, p0);
    			append_dev(div3, t3);
    			append_dev(div3, p1);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			append_dev(div2, p2);
    			append_dev(div2, t7);
    			append_dev(div2, p3);
    			append_dev(div2, t9);
    			append_dev(div2, div1);
    			append_dev(div1, p4);
    			append_dev(div1, t11);
    			append_dev(div1, p5);
    			append_dev(div1, t13);
    			append_dev(div1, div0);
    			append_dev(div0, p6);
    			append_dev(div0, t15);
    			append_dev(div0, p7);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t19, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t20, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t22, anchor);
    			mount_component(prism1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div4);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t19);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t20);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t22);
    			destroy_component(prism1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Grid', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Grid> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1 });
    	return [];
    }

    class Grid extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Grid",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    /* docs_src/utilities/Helpers.svelte generated by Svelte v3.53.1 */
    const file$u = "docs_src/utilities/Helpers.svelte";

    // (8:0) <Prism language="html">
    function create_default_slot_8$1(ctx) {
    	let t_value = `<div class="hidden"></div>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$1.name,
    		type: "slot",
    		source: "(8:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (14:0) <Prism language="html">
    function create_default_slot_7$1(ctx) {
    	let t_value = `<div class="position-absolute"></div>
<div class="position-fixed"></div>
<div class="position-relative"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$1.name,
    		type: "slot",
    		source: "(14:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (29:0) <Prism language="html">
    function create_default_slot_6$1(ctx) {
    	let t_value = `<div class="float-left"></div>
<div class="float-right"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(29:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (36:0) <Prism language="html">
    function create_default_slot_5$1(ctx) {
    	let t_value = `<div class="clear"></div>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(36:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (47:0) <Prism language="html">
    function create_default_slot_4$2(ctx) {
    	let t_value = `<div class="vertical-center"></div>
<div class="vertical-auto"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(47:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (60:0) <Prism language="html">
    function create_default_slot_3$2(ctx) {
    	let t_value = `<div class="margin-none padding-none"></div>
<div class="margin-s padding-s"></div>
<div class="margin-m padding-m"></div>
<div class="margin-l padding-l"></div>
<div class="margin-xl padding-xl"></div>
<div class="margin-xxl padding-xxl"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(60:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (74:0) <Prism language="html">
    function create_default_slot_2$5(ctx) {
    	let t_value = `<div class="margin-l--t padding-l--t"></div>
<div class="margin-l--r padding-l--r"></div>
<div class="margin-l--b padding-l--b"></div>
<div class="margin-l--l padding-l--l"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(74:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (83:0) <Prism language="html">
    function create_default_slot_1$8(ctx) {
    	let t_value = `<div class="margin-l--tb padding-l--tb"></div>
<div class="margin-l--rl padding-l--rl"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(83:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (98:0) <Prism language="html">
    function create_default_slot$f(ctx) {
    	let t_value = `<div class="box-shadow--small"></div>
<div class="box-shadow"></div>
<div class="box-shadow--large"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(98:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let h1;
    	let t1;
    	let h30;
    	let t3;
    	let prism0;
    	let t4;
    	let h31;
    	let t6;
    	let prism1;
    	let t7;
    	let h32;
    	let t9;
    	let div3;
    	let div2;
    	let div0;
    	let t11;
    	let div1;
    	let t13;
    	let prism2;
    	let t14;
    	let h33;
    	let t16;
    	let prism3;
    	let t17;
    	let h34;
    	let t19;
    	let p0;
    	let t21;
    	let div5;
    	let div4;
    	let t23;
    	let prism4;
    	let t24;
    	let h35;
    	let t26;
    	let p1;
    	let t27;
    	let strong0;
    	let t29;
    	let strong1;
    	let t31;
    	let em0;
    	let t33;
    	let em1;
    	let t35;
    	let t36;
    	let prism5;
    	let t37;
    	let p2;
    	let t38;
    	let strong2;
    	let t40;
    	let strong3;
    	let t42;
    	let t43;
    	let prism6;
    	let t44;
    	let p3;
    	let t45;
    	let em2;
    	let t47;
    	let em3;
    	let t49;
    	let t50;
    	let prism7;
    	let t51;
    	let h36;
    	let t53;
    	let div10;
    	let div9;
    	let div6;
    	let t55;
    	let div7;
    	let t57;
    	let div8;
    	let t59;
    	let prism8;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_8$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_7$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism3 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism4 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism5 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism6 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism7 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism8 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Helpers";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Skjult element";
    			t3 = space();
    			create_component(prism0.$$.fragment);
    			t4 = space();
    			h31 = element("h3");
    			h31.textContent = "Position";
    			t6 = space();
    			create_component(prism1.$$.fragment);
    			t7 = space();
    			h32 = element("h3");
    			h32.textContent = "Floats";
    			t9 = space();
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "float-left";
    			t11 = space();
    			div1 = element("div");
    			div1.textContent = "float-right";
    			t13 = space();
    			create_component(prism2.$$.fragment);
    			t14 = space();
    			h33 = element("h3");
    			h33.textContent = "Clear";
    			t16 = space();
    			create_component(prism3.$$.fragment);
    			t17 = space();
    			h34 = element("h3");
    			h34.textContent = "Centrr vertikalt";
    			t19 = space();
    			p0 = element("p");
    			p0.textContent = "Krver en fast bredde p elementet.";
    			t21 = space();
    			div5 = element("div");
    			div4 = element("div");
    			div4.textContent = "vertical-center";
    			t23 = space();
    			create_component(prism4.$$.fragment);
    			t24 = space();
    			h35 = element("h3");
    			h35.textContent = "Margin & padding";
    			t26 = space();
    			p1 = element("p");
    			t27 = text("For bde ");
    			strong0 = element("strong");
    			strong0.textContent = "margin";
    			t29 = text(" og ");
    			strong1 = element("strong");
    			strong1.textContent = "padding";
    			t31 = text(" klassen har vi fem strrelser\n  ");
    			em0 = element("em");
    			em0.textContent = "(s, m, l, xl og xxl)";
    			t33 = text("\n  og s\n  ");
    			em1 = element("em");
    			em1.textContent = "none";
    			t35 = text(" som sttes p med bindesteg.");
    			t36 = space();
    			create_component(prism5.$$.fragment);
    			t37 = space();
    			p2 = element("p");
    			t38 = text("nskes der derimod kun at have ");
    			strong2 = element("strong");
    			strong2.textContent = "margin";
    			t40 = text(" og ");
    			strong3 = element("strong");
    			strong3.textContent = "padding";
    			t42 = text(" i en retning tilfjes dette med double\n  bindestreg.");
    			t43 = space();
    			create_component(prism6.$$.fragment);
    			t44 = space();
    			p3 = element("p");
    			t45 = text("Vi har ogs to samle klasser for ");
    			em2 = element("em");
    			em2.textContent = "top-bottom";
    			t47 = text(" og ");
    			em3 = element("em");
    			em3.textContent = "right-left";
    			t49 = text(".");
    			t50 = space();
    			create_component(prism7.$$.fragment);
    			t51 = space();
    			h36 = element("h3");
    			h36.textContent = "Box-shadow";
    			t53 = space();
    			div10 = element("div");
    			div9 = element("div");
    			div6 = element("div");
    			div6.textContent = "box-shadow--small";
    			t55 = space();
    			div7 = element("div");
    			div7.textContent = "box-shadow";
    			t57 = space();
    			div8 = element("div");
    			div8.textContent = "box-shadow--large";
    			t59 = space();
    			create_component(prism8.$$.fragment);
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$u, 3, 0, 63);
    			add_location(h30, file$u, 5, 0, 99);
    			add_location(h31, file$u, 11, 0, 191);
    			add_location(h32, file$u, 19, 0, 361);
    			attr_dev(div0, "class", "bg--eb padding-m float-left");
    			add_location(div0, file$u, 23, 4, 419);
    			attr_dev(div1, "class", "bg--eb padding-m float-right");
    			add_location(div1, file$u, 24, 4, 481);
    			add_location(div2, file$u, 22, 2, 409);
    			attr_dev(div3, "class", "card bg--graa7");
    			add_location(div3, file$u, 21, 0, 378);
    			add_location(h33, file$u, 33, 0, 661);
    			add_location(h34, file$u, 39, 0, 743);
    			add_location(p0, file$u, 40, 0, 770);
    			attr_dev(div4, "class", "vertical-center width-1of3 padding-l bg--eb");
    			add_location(div4, file$u, 43, 2, 845);
    			attr_dev(div5, "class", "card bg--graa7");
    			add_location(div5, file$u, 42, 0, 814);
    			add_location(h35, file$u, 51, 0, 1042);
    			add_location(strong0, file$u, 53, 11, 1083);
    			add_location(strong1, file$u, 53, 38, 1110);
    			add_location(em0, file$u, 54, 2, 1167);
    			add_location(em1, file$u, 56, 2, 1207);
    			add_location(p1, file$u, 52, 0, 1068);
    			add_location(strong2, file$u, 69, 33, 1579);
    			add_location(strong3, file$u, 69, 60, 1606);
    			add_location(p2, file$u, 68, 0, 1542);
    			add_location(em2, file$u, 80, 36, 1946);
    			add_location(em3, file$u, 80, 59, 1969);
    			add_location(p3, file$u, 80, 0, 1910);
    			add_location(h36, file$u, 87, 0, 2129);
    			attr_dev(div6, "class", "border-radius box-shadow--small padding-xl margin-l bg--eb");
    			add_location(div6, file$u, 91, 4, 2212);
    			attr_dev(div7, "class", "border-radius box-shadow padding-xl margin-l bg--eb");
    			add_location(div7, file$u, 92, 4, 2312);
    			attr_dev(div8, "class", "border-radius box-shadow--large padding-xl margin-l bg--eb");
    			add_location(div8, file$u, 93, 4, 2398);
    			attr_dev(div9, "class", "card-content");
    			add_location(div9, file$u, 90, 2, 2181);
    			attr_dev(div10, "class", "card bg--graa7");
    			add_location(div10, file$u, 89, 0, 2150);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t11);
    			append_dev(div2, div1);
    			insert_dev(target, t13, anchor);
    			mount_component(prism2, target, anchor);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t16, anchor);
    			mount_component(prism3, target, anchor);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, h34, anchor);
    			insert_dev(target, t19, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			insert_dev(target, t23, anchor);
    			mount_component(prism4, target, anchor);
    			insert_dev(target, t24, anchor);
    			insert_dev(target, h35, anchor);
    			insert_dev(target, t26, anchor);
    			insert_dev(target, p1, anchor);
    			append_dev(p1, t27);
    			append_dev(p1, strong0);
    			append_dev(p1, t29);
    			append_dev(p1, strong1);
    			append_dev(p1, t31);
    			append_dev(p1, em0);
    			append_dev(p1, t33);
    			append_dev(p1, em1);
    			append_dev(p1, t35);
    			insert_dev(target, t36, anchor);
    			mount_component(prism5, target, anchor);
    			insert_dev(target, t37, anchor);
    			insert_dev(target, p2, anchor);
    			append_dev(p2, t38);
    			append_dev(p2, strong2);
    			append_dev(p2, t40);
    			append_dev(p2, strong3);
    			append_dev(p2, t42);
    			insert_dev(target, t43, anchor);
    			mount_component(prism6, target, anchor);
    			insert_dev(target, t44, anchor);
    			insert_dev(target, p3, anchor);
    			append_dev(p3, t45);
    			append_dev(p3, em2);
    			append_dev(p3, t47);
    			append_dev(p3, em3);
    			append_dev(p3, t49);
    			insert_dev(target, t50, anchor);
    			mount_component(prism7, target, anchor);
    			insert_dev(target, t51, anchor);
    			insert_dev(target, h36, anchor);
    			insert_dev(target, t53, anchor);
    			insert_dev(target, div10, anchor);
    			append_dev(div10, div9);
    			append_dev(div9, div6);
    			append_dev(div9, t55);
    			append_dev(div9, div7);
    			append_dev(div9, t57);
    			append_dev(div9, div8);
    			insert_dev(target, t59, anchor);
    			mount_component(prism8, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    			const prism2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism2_changes.$$scope = { dirty, ctx };
    			}

    			prism2.$set(prism2_changes);
    			const prism3_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism3_changes.$$scope = { dirty, ctx };
    			}

    			prism3.$set(prism3_changes);
    			const prism4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism4_changes.$$scope = { dirty, ctx };
    			}

    			prism4.$set(prism4_changes);
    			const prism5_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism5_changes.$$scope = { dirty, ctx };
    			}

    			prism5.$set(prism5_changes);
    			const prism6_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism6_changes.$$scope = { dirty, ctx };
    			}

    			prism6.$set(prism6_changes);
    			const prism7_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism7_changes.$$scope = { dirty, ctx };
    			}

    			prism7.$set(prism7_changes);
    			const prism8_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism8_changes.$$scope = { dirty, ctx };
    			}

    			prism8.$set(prism8_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			transition_in(prism3.$$.fragment, local);
    			transition_in(prism4.$$.fragment, local);
    			transition_in(prism5.$$.fragment, local);
    			transition_in(prism6.$$.fragment, local);
    			transition_in(prism7.$$.fragment, local);
    			transition_in(prism8.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			transition_out(prism3.$$.fragment, local);
    			transition_out(prism4.$$.fragment, local);
    			transition_out(prism5.$$.fragment, local);
    			transition_out(prism6.$$.fragment, local);
    			transition_out(prism7.$$.fragment, local);
    			transition_out(prism8.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t3);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t6);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(div3);
    			if (detaching) detach_dev(t13);
    			destroy_component(prism2, detaching);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t16);
    			destroy_component(prism3, detaching);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(h34);
    			if (detaching) detach_dev(t19);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(div5);
    			if (detaching) detach_dev(t23);
    			destroy_component(prism4, detaching);
    			if (detaching) detach_dev(t24);
    			if (detaching) detach_dev(h35);
    			if (detaching) detach_dev(t26);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t36);
    			destroy_component(prism5, detaching);
    			if (detaching) detach_dev(t37);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t43);
    			destroy_component(prism6, detaching);
    			if (detaching) detach_dev(t44);
    			if (detaching) detach_dev(p3);
    			if (detaching) detach_dev(t50);
    			destroy_component(prism7, detaching);
    			if (detaching) detach_dev(t51);
    			if (detaching) detach_dev(h36);
    			if (detaching) detach_dev(t53);
    			if (detaching) detach_dev(div10);
    			if (detaching) detach_dev(t59);
    			destroy_component(prism8, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Helpers', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Helpers> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1 });
    	return [];
    }

    class Helpers extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Helpers",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    /* docs_src/utilities/Separator.svelte generated by Svelte v3.53.1 */
    const file$t = "docs_src/utilities/Separator.svelte";

    // (23:0) <Prism language="html">
    function create_default_slot$e(ctx) {
    	let t_value = `<div class="separator"></div>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(23:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let h1;
    	let t1;
    	let h3;
    	let t3;
    	let div0;
    	let p0;
    	let t4;
    	let i;
    	let t6;
    	let t7;
    	let div4;
    	let div3;
    	let p1;
    	let t9;
    	let div1;
    	let t10;
    	let p2;
    	let t12;
    	let div2;
    	let t13;
    	let p3;
    	let t15;
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Separator";
    			t1 = space();
    			h3 = element("h3");
    			h3.textContent = "Separator";
    			t3 = space();
    			div0 = element("div");
    			p0 = element("p");
    			t4 = text("Separator is ");
    			i = element("i");
    			i.textContent = "class";
    			t6 = text(" that can be used to seperate content i.e in a box/container.");
    			t7 = space();
    			div4 = element("div");
    			div3 = element("div");
    			p1 = element("p");
    			p1.textContent = "Header";
    			t9 = space();
    			div1 = element("div");
    			t10 = space();
    			p2 = element("p");
    			p2.textContent = "Content";
    			t12 = space();
    			div2 = element("div");
    			t13 = space();
    			p3 = element("p");
    			p3.textContent = "Footer";
    			t15 = space();
    			create_component(prism.$$.fragment);
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$t, 4, 0, 56);
    			add_location(h3, file$t, 6, 0, 94);
    			add_location(i, file$t, 9, 18, 138);
    			add_location(p0, file$t, 9, 2, 122);
    			add_location(div0, file$t, 8, 0, 114);
    			add_location(p1, file$t, 14, 4, 309);
    			attr_dev(div1, "class", "separator");
    			add_location(div1, file$t, 15, 4, 327);
    			add_location(p2, file$t, 16, 4, 357);
    			attr_dev(div2, "class", "separator");
    			add_location(div2, file$t, 17, 4, 376);
    			add_location(p3, file$t, 18, 4, 406);
    			attr_dev(div3, "class", "width-1of3 padding-m box-shadow border-radius");
    			add_location(div3, file$t, 13, 2, 245);
    			attr_dev(div4, "class", "flex");
    			add_location(div4, file$t, 12, 0, 224);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h3, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div0, anchor);
    			append_dev(div0, p0);
    			append_dev(p0, t4);
    			append_dev(p0, i);
    			append_dev(p0, t6);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, p1);
    			append_dev(div3, t9);
    			append_dev(div3, div1);
    			append_dev(div3, t10);
    			append_dev(div3, p2);
    			append_dev(div3, t12);
    			append_dev(div3, div2);
    			append_dev(div3, t13);
    			append_dev(div3, p3);
    			insert_dev(target, t15, anchor);
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism_changes.$$scope = { dirty, ctx };
    			}

    			prism.$set(prism_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div4);
    			if (detaching) detach_dev(t15);
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Separator', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Separator> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1 });
    	return [];
    }

    class Separator extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Separator",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    /* docs_src/utilities/Sizing.svelte generated by Svelte v3.53.1 */
    const file$s = "docs_src/utilities/Sizing.svelte";

    // (22:0) <Prism language="html">
    function create_default_slot_1$7(ctx) {
    	let t_value = `<div class="width-100vw"></div>
<div class="width-auto"></div>
<div class="width-1of1"></div>
<div class="width-5of6"></div>
<div class="width-3of4"></div>
<div class="width-2of3"></div>
<div class="width-1of2"></div>
<div class="width-1of3"></div>
<div class="width-1of4"></div>
<div class="width-1of5"></div>
<div class="width-1of6"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(22:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (51:0) <Prism language="html">
    function create_default_slot$d(ctx) {
    	let t_value = `<div class="height-100vh"></div>
<div class="height-auto"></div>
<div class="height-1of1"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(51:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let h1;
    	let t1;
    	let h30;
    	let t3;
    	let div11;
    	let div0;
    	let t5;
    	let div1;
    	let t7;
    	let div2;
    	let t9;
    	let div3;
    	let t11;
    	let div4;
    	let t13;
    	let div5;
    	let t15;
    	let div6;
    	let t17;
    	let div7;
    	let t19;
    	let div8;
    	let t21;
    	let div9;
    	let t23;
    	let div10;
    	let t25;
    	let prism0;
    	let t26;
    	let h31;
    	let t28;
    	let div17;
    	let div15;
    	let div12;
    	let t30;
    	let div13;
    	let t32;
    	let div14;
    	let t34;
    	let div16;
    	let p;
    	let t36;
    	let prism1;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Sizing";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Bredder";
    			t3 = space();
    			div11 = element("div");
    			div0 = element("div");
    			div0.textContent = "width-100vw";
    			t5 = space();
    			div1 = element("div");
    			div1.textContent = "width-auto";
    			t7 = space();
    			div2 = element("div");
    			div2.textContent = "width-1of1";
    			t9 = space();
    			div3 = element("div");
    			div3.textContent = "width-5of6";
    			t11 = space();
    			div4 = element("div");
    			div4.textContent = "width-3of4";
    			t13 = space();
    			div5 = element("div");
    			div5.textContent = "width-2of3";
    			t15 = space();
    			div6 = element("div");
    			div6.textContent = "width-1of2";
    			t17 = space();
    			div7 = element("div");
    			div7.textContent = "width-1of3";
    			t19 = space();
    			div8 = element("div");
    			div8.textContent = "width-1of4";
    			t21 = space();
    			div9 = element("div");
    			div9.textContent = "width-1of5";
    			t23 = space();
    			div10 = element("div");
    			div10.textContent = "width-1of6";
    			t25 = space();
    			create_component(prism0.$$.fragment);
    			t26 = space();
    			h31 = element("h3");
    			h31.textContent = "Hjder";
    			t28 = space();
    			div17 = element("div");
    			div15 = element("div");
    			div12 = element("div");
    			div12.textContent = "height-100vh*";
    			t30 = space();
    			div13 = element("div");
    			div13.textContent = "height-auto";
    			t32 = space();
    			div14 = element("div");
    			div14.textContent = "height-1of1";
    			t34 = space();
    			div16 = element("div");
    			p = element("p");
    			p.textContent = "* Viewport height - Vr opmrksom p at disse opfrer sig meget forskelligt p forskellige devices html";
    			t36 = space();
    			create_component(prism1.$$.fragment);
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$s, 3, 0, 63);
    			add_location(h30, file$s, 5, 0, 98);
    			attr_dev(div0, "class", "bg--eb padding-m width-100vw");
    			add_location(div0, file$s, 8, 2, 147);
    			attr_dev(div1, "class", "bg--eb padding-m width-auto");
    			add_location(div1, file$s, 9, 2, 209);
    			attr_dev(div2, "class", "bg--eb padding-m width-1of1");
    			add_location(div2, file$s, 10, 2, 269);
    			attr_dev(div3, "class", "bg--eb padding-m width-5of6");
    			add_location(div3, file$s, 11, 2, 329);
    			attr_dev(div4, "class", "bg--eb padding-m width-3of4");
    			add_location(div4, file$s, 12, 2, 389);
    			attr_dev(div5, "class", "bg--eb padding-m width-2of3");
    			add_location(div5, file$s, 13, 2, 449);
    			attr_dev(div6, "class", "bg--eb padding-m width-1of2");
    			add_location(div6, file$s, 14, 2, 509);
    			attr_dev(div7, "class", "bg--eb padding-m width-1of3");
    			add_location(div7, file$s, 15, 2, 569);
    			attr_dev(div8, "class", "bg--eb padding-m width-1of4");
    			add_location(div8, file$s, 16, 2, 629);
    			attr_dev(div9, "class", "bg--eb padding-m width-1of5");
    			add_location(div9, file$s, 17, 2, 689);
    			attr_dev(div10, "class", "bg--eb padding-m width-1of6");
    			add_location(div10, file$s, 18, 2, 749);
    			attr_dev(div11, "class", "card bg--graa7");
    			add_location(div11, file$s, 7, 0, 116);
    			add_location(h31, file$s, 35, 0, 1197);
    			attr_dev(div12, "class", "bg--eb padding-m width-1of4 height-100vh");
    			set_style(div12, "display", "inline-block");
    			add_location(div12, file$s, 39, 4, 1322);
    			attr_dev(div13, "class", "bg--eb padding-m width-1of4 height-auto");
    			set_style(div13, "display", "inline-block");
    			add_location(div13, file$s, 40, 4, 1430);
    			attr_dev(div14, "class", "bg--eb padding-m width-1of4 height-1of1");
    			set_style(div14, "display", "inline-block");
    			add_location(div14, file$s, 41, 4, 1535);
    			attr_dev(div15, "class", "text-align--center bg--graa7");
    			set_style(div15, "height", "200px");
    			set_style(div15, "overflow", "hidden");
    			add_location(div15, file$s, 38, 2, 1235);
    			attr_dev(p, "class", "fontsize-small");
    			add_location(p, file$s, 44, 4, 1677);
    			attr_dev(div16, "class", "card-footer");
    			add_location(div16, file$s, 43, 2, 1647);
    			attr_dev(div17, "class", "card");
    			add_location(div17, file$s, 37, 0, 1214);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div11, anchor);
    			append_dev(div11, div0);
    			append_dev(div11, t5);
    			append_dev(div11, div1);
    			append_dev(div11, t7);
    			append_dev(div11, div2);
    			append_dev(div11, t9);
    			append_dev(div11, div3);
    			append_dev(div11, t11);
    			append_dev(div11, div4);
    			append_dev(div11, t13);
    			append_dev(div11, div5);
    			append_dev(div11, t15);
    			append_dev(div11, div6);
    			append_dev(div11, t17);
    			append_dev(div11, div7);
    			append_dev(div11, t19);
    			append_dev(div11, div8);
    			append_dev(div11, t21);
    			append_dev(div11, div9);
    			append_dev(div11, t23);
    			append_dev(div11, div10);
    			insert_dev(target, t25, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t26, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t28, anchor);
    			insert_dev(target, div17, anchor);
    			append_dev(div17, div15);
    			append_dev(div15, div12);
    			append_dev(div15, t30);
    			append_dev(div15, div13);
    			append_dev(div15, t32);
    			append_dev(div15, div14);
    			append_dev(div17, t34);
    			append_dev(div17, div16);
    			append_dev(div16, p);
    			insert_dev(target, t36, anchor);
    			mount_component(prism1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div11);
    			if (detaching) detach_dev(t25);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t26);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t28);
    			if (detaching) detach_dev(div17);
    			if (detaching) detach_dev(t36);
    			destroy_component(prism1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Sizing', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sizing> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1 });
    	return [];
    }

    class Sizing extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Sizing",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* docs_src/utilities/Text.svelte generated by Svelte v3.53.1 */
    const file$r = "docs_src/utilities/Text.svelte";

    // (14:0) <Prism language="html">
    function create_default_slot_2$4(ctx) {
    	let t_value = `<p class="text-align--center"></p>
<p class="text-align--left"></p>
<p class="text-align--right"></p>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(14:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (27:0) <Prism language="html">
    function create_default_slot_1$6(ctx) {
    	let t_value = `<p class="text-transform--lowercase"></p>
<p class="text-transform--uppercase"></p>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(27:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (49:0) <Prism language="html">
    function create_default_slot$c(ctx) {
    	let t_value = `<div class="lineheight-m">
  <p>line-height: 1.5em</p>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(49:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let h1;
    	let t1;
    	let h30;
    	let t3;
    	let div0;
    	let p0;
    	let t5;
    	let p1;
    	let t7;
    	let p2;
    	let t9;
    	let prism0;
    	let t10;
    	let h31;
    	let t12;
    	let div1;
    	let p3;
    	let t14;
    	let p4;
    	let t16;
    	let prism1;
    	let t17;
    	let h32;
    	let t19;
    	let p5;
    	let t21;
    	let div5;
    	let div4;
    	let div2;
    	let p6;
    	let t23;
    	let p7;
    	let t25;
    	let p8;
    	let t27;
    	let div3;
    	let p9;
    	let t29;
    	let p10;
    	let t31;
    	let p11;
    	let t33;
    	let prism2;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Text";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Text alignment";
    			t3 = space();
    			div0 = element("div");
    			p0 = element("p");
    			p0.textContent = "Centreret tekst";
    			t5 = space();
    			p1 = element("p");
    			p1.textContent = "Venstrestillet tekst";
    			t7 = space();
    			p2 = element("p");
    			p2.textContent = "Hjrestillet tekst";
    			t9 = space();
    			create_component(prism0.$$.fragment);
    			t10 = space();
    			h31 = element("h3");
    			h31.textContent = "Text transform";
    			t12 = space();
    			div1 = element("div");
    			p3 = element("p");
    			p3.textContent = "SM BOGSTAVER";
    			t14 = space();
    			p4 = element("p");
    			p4.textContent = "store bogstaver";
    			t16 = space();
    			create_component(prism1.$$.fragment);
    			t17 = space();
    			h32 = element("h3");
    			h32.textContent = "Line height";
    			t19 = space();
    			p5 = element("p");
    			p5.textContent = "Default line-height will be based on the browser usually around 1.2";
    			t21 = space();
    			div5 = element("div");
    			div4 = element("div");
    			div2 = element("div");
    			p6 = element("p");
    			p6.textContent = "normal line-height";
    			t23 = space();
    			p7 = element("p");
    			p7.textContent = "normal line-height";
    			t25 = space();
    			p8 = element("p");
    			p8.textContent = "normal line-height";
    			t27 = space();
    			div3 = element("div");
    			p9 = element("p");
    			p9.textContent = "lineheight-m";
    			t29 = space();
    			p10 = element("p");
    			p10.textContent = "lineheight-m";
    			t31 = space();
    			p11 = element("p");
    			p11.textContent = "lineheight-m";
    			t33 = space();
    			create_component(prism2.$$.fragment);
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$r, 3, 0, 63);
    			add_location(h30, file$r, 5, 0, 96);
    			attr_dev(p0, "class", "text-align--center");
    			add_location(p0, file$r, 8, 2, 162);
    			attr_dev(p1, "class", "text-align--left");
    			add_location(p1, file$r, 9, 2, 214);
    			attr_dev(p2, "class", "text-align--right");
    			add_location(p2, file$r, 10, 2, 269);
    			attr_dev(div0, "class", "card bg--graa7 padding-m");
    			add_location(div0, file$r, 7, 0, 121);
    			add_location(h31, file$r, 19, 0, 471);
    			attr_dev(p3, "class", "text-transform--lowercase");
    			add_location(p3, file$r, 22, 2, 537);
    			attr_dev(p4, "class", "text-transform--uppercase");
    			add_location(p4, file$r, 23, 2, 594);
    			attr_dev(div1, "class", "card bg--graa7 padding-m");
    			add_location(div1, file$r, 21, 0, 496);
    			add_location(h32, file$r, 31, 0, 783);
    			add_location(p5, file$r, 32, 0, 804);
    			add_location(p6, file$r, 36, 6, 1008);
    			add_location(p7, file$r, 37, 6, 1040);
    			add_location(p8, file$r, 38, 6, 1072);
    			attr_dev(div2, "class", "width-1of3 margin-m");
    			add_location(div2, file$r, 35, 4, 968);
    			add_location(p9, file$r, 41, 6, 1166);
    			add_location(p10, file$r, 42, 6, 1192);
    			add_location(p11, file$r, 43, 6, 1218);
    			attr_dev(div3, "class", "width-1of3 margin-m lineheight-m");
    			add_location(div3, file$r, 40, 4, 1113);
    			attr_dev(div4, "class", "card-content flex flex-justify--between");
    			add_location(div4, file$r, 34, 2, 910);
    			attr_dev(div5, "class", "card bg--graa7");
    			add_location(div5, file$r, 33, 0, 879);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div0, anchor);
    			append_dev(div0, p0);
    			append_dev(div0, t5);
    			append_dev(div0, p1);
    			append_dev(div0, t7);
    			append_dev(div0, p2);
    			insert_dev(target, t9, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, p3);
    			append_dev(div1, t14);
    			append_dev(div1, p4);
    			insert_dev(target, t16, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t19, anchor);
    			insert_dev(target, p5, anchor);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, p6);
    			append_dev(div2, t23);
    			append_dev(div2, p7);
    			append_dev(div2, t25);
    			append_dev(div2, p8);
    			append_dev(div4, t27);
    			append_dev(div4, div3);
    			append_dev(div3, p9);
    			append_dev(div3, t29);
    			append_dev(div3, p10);
    			append_dev(div3, t31);
    			append_dev(div3, p11);
    			insert_dev(target, t33, anchor);
    			mount_component(prism2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    			const prism2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism2_changes.$$scope = { dirty, ctx };
    			}

    			prism2.$set(prism2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t9);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t16);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t19);
    			if (detaching) detach_dev(p5);
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(div5);
    			if (detaching) detach_dev(t33);
    			destroy_component(prism2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1 });
    	return [];
    }

    class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    const utilities = {
        href: '/utilities',
        routes: [
            { component: Animation, href: '/utilities/animation', title: 'Animation' },
            { component: Border, href: '/utilities/border', title: 'Border' },
            { component: Color, href: '/utilities/color', title: 'Color' },
            { component: Flex, href: '/utilities/flex', title: 'Flex' },
            { component: Fonts$1, href: '/utilities/fonts', title: 'Fonts' },
            { component: Grid, href: '/utilities/grid', title: 'Grid' },
            { component: Helpers, href: '/utilities/helpers', title: 'Helpers' },
            { component: Separator, href: '/utilities/separator', title: 'Separator' },
            { component: Sizing, href: '/utilities/sizing', title: 'Sizing' },
            { component: Text, href: '/utilities/text', title: 'Text' },
        ],
        title: 'Utilities',
    };

    /* docs_src/cssvariables/Colors.svelte generated by Svelte v3.53.1 */
    const file$q = "docs_src/cssvariables/Colors.svelte";

    // (14:0) <Prism language="css">
    function create_default_slot$b(ctx) {
    	let t_value = `
  --color--accept: var(--color--green);
  --fgcolor--accept: var(--fgcolor--green);
  --color--cancel: var(--color--red);
  --fgcolor--cancel: var(--fgcolor--red);
  --color--default: var(--color--bluedark);
  --fgcolor--default: var(--fgcolor--bluedark);
  --color--primary: var(--color--bruger);
  --fgcolor--primary: var(--fgcolor--bruger);
  --color--secondary: var(--color--graa3);
  --fgcolor--secondary: var(--fgcolor--graa3);
  ` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(14:0) <Prism language=\\\"css\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let h1;
    	let t1;
    	let div;
    	let p0;
    	let t3;
    	let p1;
    	let a;
    	let t5;
    	let prism;
    	let current;
    	let mounted;
    	let dispose;

    	prism = new Prism$1({
    			props: {
    				language: "css",
    				$$slots: { default: [create_default_slot$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Colors";
    			t1 = space();
    			div = element("div");
    			p0 = element("p");
    			p0.textContent = "Named colors for ease of use";
    			t3 = space();
    			p1 = element("p");
    			a = element("a");
    			a.textContent = "See list of colors";
    			t5 = space();
    			create_component(prism.$$.fragment);
    			add_location(h1, file$q, 6, 0, 230);
    			add_location(p0, file$q, 9, 2, 255);
    			attr_dev(a, "href", "#a11y");
    			add_location(a, file$q, 10, 5, 296);
    			add_location(p1, file$q, 10, 2, 293);
    			add_location(div, file$q, 8, 0, 247);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, p0);
    			append_dev(div, t3);
    			append_dev(div, p1);
    			append_dev(p1, a);
    			insert_dev(target, t5, anchor);
    			mount_component(prism, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a, {
    					disabled: false,
    					href: /*colorRoute*/ ctx[0].href
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const prism_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				prism_changes.$$scope = { dirty, ctx };
    			}

    			prism.$set(prism_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t5);
    			destroy_component(prism, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Colors', slots, []);
    	const colorRoute = utilities.routes.find(util => util.title === 'Color');
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Colors> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ link, Prism: Prism$1, utilities, colorRoute });
    	return [colorRoute];
    }

    class Colors extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Colors",
    			options,
    			id: create_fragment$q.name
    		});
    	}
    }

    /* docs_src/cssvariables/Distance.svelte generated by Svelte v3.53.1 */
    const file$p = "docs_src/cssvariables/Distance.svelte";

    // (6:0) <Prism language="css">
    function create_default_slot_1$5(ctx) {
    	let t_value = `
  --distance-large: 20px;
  --distance-medium: 10px;
  --distance-small: 5px;
  --distance-standard: 10px;
  --distance-xlarge: 30px;
  --distance-xxlarge: 50px;
  ` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(6:0) <Prism language=\\\"css\\\">",
    		ctx
    	});

    	return block;
    }

    // (17:0) <Prism language="css">
    function create_default_slot$a(ctx) {
    	let t_value = `
  --distance-large: 15px;
  --distance-medium: 10px;
  --distance-small: 5px;
  --distance-standard: 10px;
  --distance-xlarge: 20px;
  --distance-xxlarge: 30px;
  ` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(17:0) <Prism language=\\\"css\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let h1;
    	let t1;
    	let prism0;
    	let t2;
    	let h2;
    	let t4;
    	let prism1;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "css",
    				$$slots: { default: [create_default_slot_1$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "css",
    				$$slots: { default: [create_default_slot$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Distance";
    			t1 = space();
    			create_component(prism0.$$.fragment);
    			t2 = space();
    			h2 = element("h2");
    			h2.textContent = "Smartphone values";
    			t4 = space();
    			create_component(prism1.$$.fragment);
    			add_location(h1, file$p, 3, 0, 63);
    			add_location(h2, file$p, 15, 0, 286);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(prism1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t4);
    			destroy_component(prism1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Distance', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Distance> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1 });
    	return [];
    }

    class Distance extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Distance",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    /* docs_src/cssvariables/Fonts.svelte generated by Svelte v3.53.1 */
    const file$o = "docs_src/cssvariables/Fonts.svelte";

    // (8:0) <Prism language="css">
    function create_default_slot_4$1(ctx) {
    	let t_value = `
  --fontfamily--primary: "Work Sans", var(--fontfamily--secondary);
  --fontfamily--secondary: Arial, Helvetica, sans-serif;
  ` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(8:0) <Prism language=\\\"css\\\">",
    		ctx
    	});

    	return block;
    }

    // (17:0) <Prism language="css">
    function create_default_slot_3$1(ctx) {
    	let t_value = `
  --fs-rem-large: 1.125rem; /* 18px */
  --fs-rem-medium: 1rem; /* 16px */
  --fs-rem-small: .875rem; /* 14px */
  --fs-rem-xlarge: 1.25rem; /* 20px */
  --fs-rem-xsmall: .75rem; /* 12px */
  --fs-rem-xxlarge: 1.875rem; /* 30px */
  --fs-rem-xxsmall: .625rem; /* 10px */
  --fs-rem-xxxlarge: 2.25rem; /* 36px */
  --fs-rem-xxxsmall: .4375rem; /* 7px */
  --fs-rem-xxxxlarge: 3.125rem; /* 50px */
  --fs-large: var(--fs-rem-large);
  --fs-medium: var(--fs-rem-medium);
  --fs-small: var(--fs-rem-small);
  --fs-xlarge: var(--fs-rem-xlarge);
  --fs-xsmall: var(--fs-rem-xsmall);
  --fs-xxlarge: var(--fs-rem-xxlarge);
  --fs-xxsmall: var(--fs-rem-xxsmall);
  --fs-xxxlarge: var(--fs-rem-xxxxlarge);
  ` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(17:0) <Prism language=\\\"css\\\">",
    		ctx
    	});

    	return block;
    }

    // (42:0) <Prism language="css">
    function create_default_slot_2$3(ctx) {
    	let t_value = `
  --fs-ads: var(--fs-xxsmall);
  --fs-bodytext: var(--fs-large);
  --fs-caption: var(--fs-small);
  --fs-quote: var(--fs-xxlarge);
  --fs-showmore: var(--fs-medium);
  --fs-subtitle: var(--fs-xlarge);
  --fs-timestamp: var(--fs-xsmall);
  --fs-title: var(--fs-xxxlarge);
  ` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(42:0) <Prism language=\\\"css\\\">",
    		ctx
    	});

    	return block;
    }

    // (57:0) <Prism language="css">
    function create_default_slot_1$4(ctx) {
    	let t_value = `
  --fs-large: var(--fs-rem-medium);
  --fs-medium: var(--fs-rem-medium);
  --fs-small: var(--fs-rem-xsmall);
  --fs-xlarge: var(--fs-rem-xlarge);
  --fs-xsmall: var(--fs-rem-xxsmall);
  --fs-xxlarge: var(--fs-rem-xxlarge);
  --fs-xxsmall: var(--fs-rem-xxxsmall);
  --fs-xxxlarge: var(--fs-rem-xxxlarge);
  ` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(57:0) <Prism language=\\\"css\\\">",
    		ctx
    	});

    	return block;
    }

    // (72:0) <Prism language="css">
    function create_default_slot$9(ctx) {
    	let t_value = `
  --fs-ads: var(--fs-xxsmall);
  --fs-bodytext: var(--fs-large);
  --fs-caption: var(--fs-small);
  --fs-quote: var(--fs-xxlarge);
  --fs-showmore: var(--fs-medium);
  --fs-subtitle: var(--fs-xlarge);
  --fs-timestamp: var(--fs-xsmall);
  --fs-title: var(--fs-xxxlarge);
` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(72:0) <Prism language=\\\"css\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let h1;
    	let t1;
    	let h20;
    	let t3;
    	let prism0;
    	let t4;
    	let h21;
    	let t6;
    	let prism1;
    	let t7;
    	let h22;
    	let t9;
    	let prism2;
    	let t10;
    	let h23;
    	let t12;
    	let prism3;
    	let t13;
    	let h24;
    	let t15;
    	let prism4;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "css",
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "css",
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "css",
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism3 = new Prism$1({
    			props: {
    				language: "css",
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism4 = new Prism$1({
    			props: {
    				language: "css",
    				$$slots: { default: [create_default_slot$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Fonts";
    			t1 = space();
    			h20 = element("h2");
    			h20.textContent = "Font families";
    			t3 = space();
    			create_component(prism0.$$.fragment);
    			t4 = space();
    			h21 = element("h2");
    			h21.textContent = "Fontsizes";
    			t6 = space();
    			create_component(prism1.$$.fragment);
    			t7 = space();
    			h22 = element("h2");
    			h22.textContent = "Aliased Fontsizes";
    			t9 = space();
    			create_component(prism2.$$.fragment);
    			t10 = space();
    			h23 = element("h2");
    			h23.textContent = "SMARTPHONE Fontsizes";
    			t12 = space();
    			create_component(prism3.$$.fragment);
    			t13 = space();
    			h24 = element("h2");
    			h24.textContent = "SMARTPHONE Aliased Fontsizes";
    			t15 = space();
    			create_component(prism4.$$.fragment);
    			add_location(h1, file$o, 3, 0, 63);
    			add_location(h20, file$o, 5, 0, 79);
    			add_location(h21, file$o, 14, 0, 271);
    			add_location(h22, file$o, 39, 0, 1031);
    			add_location(h23, file$o, 54, 0, 1373);
    			add_location(h24, file$o, 69, 0, 1751);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h20, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, h21, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, h22, anchor);
    			insert_dev(target, t9, anchor);
    			mount_component(prism2, target, anchor);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, h23, anchor);
    			insert_dev(target, t12, anchor);
    			mount_component(prism3, target, anchor);
    			insert_dev(target, t13, anchor);
    			insert_dev(target, h24, anchor);
    			insert_dev(target, t15, anchor);
    			mount_component(prism4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    			const prism2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism2_changes.$$scope = { dirty, ctx };
    			}

    			prism2.$set(prism2_changes);
    			const prism3_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism3_changes.$$scope = { dirty, ctx };
    			}

    			prism3.$set(prism3_changes);
    			const prism4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism4_changes.$$scope = { dirty, ctx };
    			}

    			prism4.$set(prism4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			transition_in(prism3.$$.fragment, local);
    			transition_in(prism4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			transition_out(prism3.$$.fragment, local);
    			transition_out(prism4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h20);
    			if (detaching) detach_dev(t3);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(h21);
    			if (detaching) detach_dev(t6);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(h22);
    			if (detaching) detach_dev(t9);
    			destroy_component(prism2, detaching);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(h23);
    			if (detaching) detach_dev(t12);
    			destroy_component(prism3, detaching);
    			if (detaching) detach_dev(t13);
    			if (detaching) detach_dev(h24);
    			if (detaching) detach_dev(t15);
    			destroy_component(prism4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Fonts', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Fonts> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1 });
    	return [];
    }

    class Fonts extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Fonts",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    /* docs_src/cssvariables/Misc.svelte generated by Svelte v3.53.1 */
    const file$n = "docs_src/cssvariables/Misc.svelte";

    // (12:0) <Prism language="css">
    function create_default_slot_1$3(ctx) {
    	let t_value = `
  --box-shadow: 0 5px 18px rgba(var(--rgb-color--black), .1);
  --box-shadow--dark: 0 5px 18px rgba(var(--rgb-color--black), .6);
  ` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(12:0) <Prism language=\\\"css\\\">",
    		ctx
    	});

    	return block;
    }

    // (21:0) <Prism language="css">
    function create_default_slot$8(ctx) {
    	let t_value = `
  --border-radius--small: 5px;
  --border-radius: 10px;
  --border-radius--medium: var(--border-radius);
  ` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(21:0) <Prism language=\\\"css\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let h1;
    	let t1;
    	let div;
    	let p;
    	let t3;
    	let h20;
    	let t5;
    	let prism0;
    	let t6;
    	let h21;
    	let t8;
    	let prism1;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "css",
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "css",
    				$$slots: { default: [create_default_slot$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Miscellaneous";
    			t1 = space();
    			div = element("div");
    			p = element("p");
    			p.textContent = "Variables that didn't fit another category";
    			t3 = space();
    			h20 = element("h2");
    			h20.textContent = "Box shadow";
    			t5 = space();
    			create_component(prism0.$$.fragment);
    			t6 = space();
    			h21 = element("h2");
    			h21.textContent = "Border radius";
    			t8 = space();
    			create_component(prism1.$$.fragment);
    			add_location(h1, file$n, 3, 0, 63);
    			add_location(p, file$n, 6, 2, 95);
    			add_location(div, file$n, 5, 0, 87);
    			add_location(h20, file$n, 9, 0, 153);
    			add_location(h21, file$n, 18, 0, 347);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, h20, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, h21, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(prism1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(h20);
    			if (detaching) detach_dev(t5);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(h21);
    			if (detaching) detach_dev(t8);
    			destroy_component(prism1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Misc', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Misc> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1 });
    	return [];
    }

    class Misc extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Misc",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    const href = '/cssvariables';
    const cssvariables = {
        href,
        routes: [
            { component: Colors, href: `${href}/colors`, title: 'Colors' },
            { component: Distance, href: `${href}/distance`, title: 'Distance' },
            { component: Fonts, href: `${href}/fonts`, title: 'Fonts' },
            { component: Misc, href: `${href}/misc`, title: 'Misc' },
        ],
        title: 'CSS variables',
    };

    /* docs_src/exportedfunctions/HorizontalScrollHandler.svelte generated by Svelte v3.53.1 */
    const file$m = "docs_src/exportedfunctions/HorizontalScrollHandler.svelte";

    // (73:0) {:else}
    function create_else_block$2(ctx) {
    	let prism0;
    	let t;
    	let prism1;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism0.$$.fragment);
    			t = space();
    			create_component(prism1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(prism1, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(prism1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(73:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (55:0) {#if $sourceType === 'svelte'}
    function create_if_block$2(ctx) {
    	let p;
    	let t0;
    	let b;
    	let t2;
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("See full implementation in ");
    			b = element("b");
    			b.textContent = "HorizontalScroll.svelte";
    			t2 = space();
    			create_component(prism.$$.fragment);
    			add_location(b, file$m, 55, 32, 1838);
    			add_location(p, file$m, 55, 2, 1808);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, b);
    			insert_dev(target, t2, anchor);
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t2);
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(55:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (74:2) <Prism language="js">
    function create_default_slot_2$2(ctx) {
    	let t_value = `import {
  HorizontalScrollHandler,
  SCROLLDIRECTION,
} from '@ekstra-bladet/designsystem';

const scrollItemContainer = document.getElementById('scrollItemContainer');
const scrollContainer = document.getElementById('scrollContainer');

const horizontalScrollHandler = new HorizontalScrollHandler();
horizontalScrollHandler.init(scrollItemContainer, scrollContainer);

prevScrollBtn.addEventListener('click', () => {
  horizontalScrollHandler.scrollWithButton(SCROLLDIRECTION.left);
});

nextScrollBtn.addEventListener('click', () => {
  horizontalScrollHandler.scrollWithButton(SCROLLDIRECTION.right);
});
` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(74:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (95:2) <Prism language="html">
    function create_default_slot_1$2(ctx) {
    	let t_value = `<div
  id="scrollContainer"
  class="horizontal-scroll-container"
  data-atend="false"
  data-atstart="true"
>
  <div id="scrollItemContainer" data-horizontallist="itemcontainer" class="horizontal-scroll-items flex">
    ...
  </div>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(95:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (57:2) <Prism language="js"     >
    function create_default_slot$7(ctx) {
    	let t_value = `import { HorizontalScrollHandler, SCROLLDIRECTION } from '../../functions/horizontalscroll';

let scrollContainer: HTMLDivElement;
let scrollItemContainer: HTMLDivElement;

const horizontalScrollHandler = new HorizontalScrollHandler();

onMount(() => {
  horizontalScrollHandler.init(scrollItemContainer, scrollContainer);
});

afterUpdate(() => {
  horizontalScrollHandler.update();
});` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(57:2) <Prism language=\\\"js\\\"     >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let h1;
    	let t1;
    	let p0;
    	let t3;
    	let h20;
    	let t5;
    	let p1;
    	let t6;
    	let b0;
    	let t8;
    	let t9;
    	let p2;
    	let t11;
    	let ul;
    	let li0;
    	let t13;
    	let li1;
    	let t15;
    	let h21;
    	let t17;
    	let p3;
    	let t19;
    	let p4;
    	let t21;
    	let code;
    	let div3;
    	let div0;
    	let h30;
    	let t23;
    	let p5;
    	let t25;
    	let p6;
    	let b1;
    	let t27;
    	let em0;
    	let t29;
    	let t30;
    	let p7;
    	let b2;
    	let t32;
    	let em1;
    	let t34;
    	let t35;
    	let div1;
    	let h31;
    	let t37;
    	let p8;
    	let t39;
    	let p9;
    	let b3;
    	let t41;
    	let em2;
    	let t43;
    	let t44;
    	let div2;
    	let h32;
    	let t46;
    	let p10;
    	let t48;
    	let p11;
    	let t49;
    	let em3;
    	let t51;
    	let t52;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$2, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "HorizontalScroll";
    			t1 = space();
    			p0 = element("p");
    			p0.textContent = "The file exports an enum called SCROLLDIRECTION and a class called HorizontalScrollHandler.";
    			t3 = space();
    			h20 = element("h2");
    			h20.textContent = "SCROLLDIRECTION - enum";
    			t5 = space();
    			p1 = element("p");
    			t6 = text("The idea of the enum is to ensure correct arguments is passed to ");
    			b0 = element("b");
    			b0.textContent = "scrollWithButton";
    			t8 = text(" function.");
    			t9 = space();
    			p2 = element("p");
    			p2.textContent = "Properties:";
    			t11 = space();
    			ul = element("ul");
    			li0 = element("li");
    			li0.textContent = "left";
    			t13 = space();
    			li1 = element("li");
    			li1.textContent = "right";
    			t15 = space();
    			h21 = element("h2");
    			h21.textContent = "HorizontalScrollHandler - Class";
    			t17 = space();
    			p3 = element("p");
    			p3.textContent = "Instantiation takes no arguments.";
    			t19 = space();
    			p4 = element("p");
    			p4.textContent = "The class has three public functions";
    			t21 = space();
    			code = element("code");
    			div3 = element("div");
    			div0 = element("div");
    			h30 = element("h3");
    			h30.textContent = "init";
    			t23 = space();
    			p5 = element("p");
    			p5.textContent = "Sets up function to handle scrolling";
    			t25 = space();
    			p6 = element("p");
    			b1 = element("b");
    			b1.textContent = "@param scrollItemContainer";
    			t27 = text(" HTMLDivElement ");
    			em0 = element("em");
    			em0.textContent = "required";
    			t29 = text(" - the closest parent to the elements in the scroll\n        list");
    			t30 = space();
    			p7 = element("p");
    			b2 = element("b");
    			b2.textContent = "@param scrollContainer";
    			t32 = text(" HTMLDivElement ");
    			em1 = element("em");
    			em1.textContent = "required";
    			t34 = text(" - the parent, which has the width of the element");
    			t35 = space();
    			div1 = element("div");
    			h31 = element("h3");
    			h31.textContent = "scrollWithButton";
    			t37 = space();
    			p8 = element("p");
    			p8.textContent = "Moves the list to make the next element, which is not fully visible, the new \"first\" element of the list";
    			t39 = space();
    			p9 = element("p");
    			b3 = element("b");
    			b3.textContent = "@param scrollContainer";
    			t41 = text(" HTMLDivElement ");
    			em2 = element("em");
    			em2.textContent = "required";
    			t43 = text(" - the parent, which has the width of the element");
    			t44 = space();
    			div2 = element("div");
    			h32 = element("h3");
    			h32.textContent = "update";
    			t46 = space();
    			p10 = element("p");
    			p10.textContent = "Should be called when new elements are added to list, to ensure all elements will be visible through click\n        functionality";
    			t48 = space();
    			p11 = element("p");
    			t49 = text("The reason for the use of an init function and not utilizing the contructor is to ensure an instance exists when\n  referencing ");
    			em3 = element("em");
    			em3.textContent = "scrollWithButton";
    			t51 = text(" in svelte context");
    			t52 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			add_location(h1, file$m, 4, 0, 103);
    			add_location(p0, file$m, 6, 0, 130);
    			add_location(h20, file$m, 8, 0, 230);
    			add_location(b0, file$m, 10, 68, 331);
    			add_location(p1, file$m, 10, 0, 263);
    			add_location(p2, file$m, 11, 0, 369);
    			add_location(li0, file$m, 13, 2, 395);
    			add_location(li1, file$m, 14, 2, 411);
    			add_location(ul, file$m, 12, 0, 388);
    			add_location(h21, file$m, 17, 0, 433);
    			add_location(p3, file$m, 19, 0, 475);
    			add_location(p4, file$m, 20, 0, 516);
    			attr_dev(h30, "class", "margin-none");
    			add_location(h30, file$m, 24, 6, 627);
    			add_location(p5, file$m, 25, 6, 667);
    			add_location(b1, file$m, 27, 8, 729);
    			add_location(em0, file$m, 27, 57, 778);
    			add_location(p6, file$m, 26, 6, 717);
    			add_location(b2, file$m, 31, 8, 889);
    			add_location(em1, file$m, 31, 53, 934);
    			add_location(p7, file$m, 30, 6, 877);
    			add_location(div0, file$m, 23, 4, 615);
    			attr_dev(h31, "class", "margin-none");
    			add_location(h31, file$m, 35, 6, 1039);
    			add_location(p8, file$m, 36, 6, 1091);
    			add_location(b3, file$m, 38, 8, 1221);
    			add_location(em2, file$m, 38, 53, 1266);
    			add_location(p9, file$m, 37, 6, 1209);
    			add_location(div1, file$m, 34, 4, 1027);
    			attr_dev(h32, "class", "margin-none");
    			add_location(h32, file$m, 42, 6, 1371);
    			add_location(p10, file$m, 43, 6, 1413);
    			add_location(div2, file$m, 41, 4, 1359);
    			attr_dev(div3, "class", "padding-xl--l padding-m--tb");
    			add_location(div3, file$m, 22, 2, 569);
    			add_location(code, file$m, 21, 0, 560);
    			add_location(em3, file$m, 52, 14, 1726);
    			add_location(p11, file$m, 50, 0, 1593);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, h20, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, p1, anchor);
    			append_dev(p1, t6);
    			append_dev(p1, b0);
    			append_dev(p1, t8);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, p2, anchor);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(ul, t13);
    			append_dev(ul, li1);
    			insert_dev(target, t15, anchor);
    			insert_dev(target, h21, anchor);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, p3, anchor);
    			insert_dev(target, t19, anchor);
    			insert_dev(target, p4, anchor);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, code, anchor);
    			append_dev(code, div3);
    			append_dev(div3, div0);
    			append_dev(div0, h30);
    			append_dev(div0, t23);
    			append_dev(div0, p5);
    			append_dev(div0, t25);
    			append_dev(div0, p6);
    			append_dev(p6, b1);
    			append_dev(p6, t27);
    			append_dev(p6, em0);
    			append_dev(p6, t29);
    			append_dev(div0, t30);
    			append_dev(div0, p7);
    			append_dev(p7, b2);
    			append_dev(p7, t32);
    			append_dev(p7, em1);
    			append_dev(p7, t34);
    			append_dev(div3, t35);
    			append_dev(div3, div1);
    			append_dev(div1, h31);
    			append_dev(div1, t37);
    			append_dev(div1, p8);
    			append_dev(div1, t39);
    			append_dev(div1, p9);
    			append_dev(p9, b3);
    			append_dev(p9, t41);
    			append_dev(p9, em2);
    			append_dev(p9, t43);
    			append_dev(div3, t44);
    			append_dev(div3, div2);
    			append_dev(div2, h32);
    			append_dev(div2, t46);
    			append_dev(div2, p10);
    			insert_dev(target, t48, anchor);
    			insert_dev(target, p11, anchor);
    			append_dev(p11, t49);
    			append_dev(p11, em3);
    			append_dev(p11, t51);
    			insert_dev(target, t52, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(h20);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(ul);
    			if (detaching) detach_dev(t15);
    			if (detaching) detach_dev(h21);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(p3);
    			if (detaching) detach_dev(t19);
    			if (detaching) detach_dev(p4);
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(code);
    			if (detaching) detach_dev(t48);
    			if (detaching) detach_dev(p11);
    			if (detaching) detach_dev(t52);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('HorizontalScrollHandler', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<HorizontalScrollHandler> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1, sourceType, $sourceType });
    	return [$sourceType];
    }

    class HorizontalScrollHandler extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HorizontalScrollHandler",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    /* docs_src/exportedfunctions/SplitNfitTitle.svelte generated by Svelte v3.53.1 */
    const file$l = "docs_src/exportedfunctions/SplitNfitTitle.svelte";

    // (37:0) <Prism language="js">
    function create_default_slot$6(ctx) {
    	let t_value = `import { splitNfitTitle } from '@ekstra-bladet/designsystem/svelte/functions/splitNfitTitle';

const titleEl = splitNfitTitle('This is my title that I want split and fitted');
document.appendChild(titleEl);
` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(37:0) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let h1;
    	let t1;
    	let p0;
    	let t2;
    	let a0;
    	let t4;
    	let a1;
    	let t6;
    	let t7;
    	let p1;
    	let t9;
    	let code;
    	let div10;
    	let div0;
    	let b0;
    	let t11;
    	let em;
    	let t13;
    	let div9;
    	let b1;
    	let t15;
    	let div8;
    	let div1;
    	let b2;
    	let t17;
    	let t18;
    	let div2;
    	let b3;
    	let t20;
    	let t21;
    	let div3;
    	let b4;
    	let t23;
    	let t24;
    	let div4;
    	let b5;
    	let t26;
    	let t27;
    	let div5;
    	let b6;
    	let t29;
    	let t30;
    	let div6;
    	let b7;
    	let t32;
    	let t33;
    	let div7;
    	let b8;
    	let t35;
    	let t36;
    	let prism;
    	let current;
    	let mounted;
    	let dispose;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "SplitNfitTitle";
    			t1 = space();
    			p0 = element("p");
    			t2 = text("Uses\n  ");
    			a0 = element("a");
    			a0.textContent = `${/*splitRoute*/ ctx[0].title}`;
    			t4 = text(" to split the title, and\n  then uses\n  ");
    			a1 = element("a");
    			a1.textContent = "fitty";
    			t6 = text(" to adjust font-size to make the\n  lines fit the width of the parent element.");
    			t7 = space();
    			p1 = element("p");
    			p1.textContent = "Returns a document fragment";
    			t9 = space();
    			code = element("code");
    			div10 = element("div");
    			div0 = element("div");
    			b0 = element("b");
    			b0.textContent = "@param title";
    			t11 = text(" string ");
    			em = element("em");
    			em.textContent = "required";
    			t13 = space();
    			div9 = element("div");
    			b1 = element("b");
    			b1.textContent = "@param options";
    			t15 = text(" object\n      ");
    			div8 = element("div");
    			div1 = element("div");
    			b2 = element("b");
    			b2.textContent = "@prop maxLines?";
    			t17 = text(" number = 10");
    			t18 = space();
    			div2 = element("div");
    			b3 = element("b");
    			b3.textContent = "@prop minLines?";
    			t20 = text(" number = 1");
    			t21 = space();
    			div3 = element("div");
    			b4 = element("b");
    			b4.textContent = "@prop maxSize?";
    			t23 = text(" number");
    			t24 = space();
    			div4 = element("div");
    			b5 = element("b");
    			b5.textContent = "@prop minSize?";
    			t26 = text(" number");
    			t27 = space();
    			div5 = element("div");
    			b6 = element("b");
    			b6.textContent = "@prop multiLine?";
    			t29 = text(" boolean");
    			t30 = space();
    			div6 = element("div");
    			b7 = element("b");
    			b7.textContent = "@prop observeMutations?";
    			t32 = text(" MutationObserverInit");
    			t33 = space();
    			div7 = element("div");
    			b8 = element("b");
    			b8.textContent = "@prop safe?";
    			t35 = text(" boolean = false - when false the browser waits for document.fonts.ready, should be false if\n          using custom fonts");
    			t36 = space();
    			create_component(prism.$$.fragment);
    			add_location(h1, file$l, 6, 0, 263);
    			attr_dev(a0, "href", "#a11y");
    			add_location(a0, file$l, 10, 2, 301);
    			attr_dev(a1, "href", "https://www.npmjs.com/package/fitty");
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "rel", "noreferrer");
    			add_location(a1, file$l, 12, 2, 433);
    			add_location(p0, file$l, 8, 0, 288);
    			add_location(p1, file$l, 15, 0, 604);
    			add_location(b0, file$l, 18, 9, 699);
    			add_location(em, file$l, 18, 36, 726);
    			add_location(div0, file$l, 18, 4, 694);
    			add_location(b1, file$l, 20, 6, 766);
    			add_location(b2, file$l, 22, 13, 841);
    			add_location(div1, file$l, 22, 8, 836);
    			add_location(b3, file$l, 23, 13, 895);
    			add_location(div2, file$l, 23, 8, 890);
    			add_location(b4, file$l, 24, 13, 948);
    			add_location(div3, file$l, 24, 8, 943);
    			add_location(b5, file$l, 25, 13, 996);
    			add_location(div4, file$l, 25, 8, 991);
    			add_location(b6, file$l, 26, 13, 1044);
    			add_location(div5, file$l, 26, 8, 1039);
    			add_location(b7, file$l, 27, 13, 1095);
    			add_location(div6, file$l, 27, 8, 1090);
    			add_location(b8, file$l, 29, 10, 1177);
    			add_location(div7, file$l, 28, 8, 1161);
    			attr_dev(div8, "class", "padding-l--l");
    			add_location(div8, file$l, 21, 6, 801);
    			add_location(div9, file$l, 19, 4, 754);
    			attr_dev(div10, "class", "padding-xl--l padding-m--tb");
    			add_location(div10, file$l, 17, 2, 648);
    			add_location(code, file$l, 16, 0, 639);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			append_dev(p0, t2);
    			append_dev(p0, a0);
    			append_dev(p0, t4);
    			append_dev(p0, a1);
    			append_dev(p0, t6);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, code, anchor);
    			append_dev(code, div10);
    			append_dev(div10, div0);
    			append_dev(div0, b0);
    			append_dev(div0, t11);
    			append_dev(div0, em);
    			append_dev(div10, t13);
    			append_dev(div10, div9);
    			append_dev(div9, b1);
    			append_dev(div9, t15);
    			append_dev(div9, div8);
    			append_dev(div8, div1);
    			append_dev(div1, b2);
    			append_dev(div1, t17);
    			append_dev(div8, t18);
    			append_dev(div8, div2);
    			append_dev(div2, b3);
    			append_dev(div2, t20);
    			append_dev(div8, t21);
    			append_dev(div8, div3);
    			append_dev(div3, b4);
    			append_dev(div3, t23);
    			append_dev(div8, t24);
    			append_dev(div8, div4);
    			append_dev(div4, b5);
    			append_dev(div4, t26);
    			append_dev(div8, t27);
    			append_dev(div8, div5);
    			append_dev(div5, b6);
    			append_dev(div5, t29);
    			append_dev(div8, t30);
    			append_dev(div8, div6);
    			append_dev(div6, b7);
    			append_dev(div6, t32);
    			append_dev(div8, t33);
    			append_dev(div8, div7);
    			append_dev(div7, b8);
    			append_dev(div7, t35);
    			insert_dev(target, t36, anchor);
    			mount_component(prism, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a0, {
    					disabled: false,
    					href: /*splitRoute*/ ctx[0].href
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const prism_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				prism_changes.$$scope = { dirty, ctx };
    			}

    			prism.$set(prism_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(code);
    			if (detaching) detach_dev(t36);
    			destroy_component(prism, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SplitNfitTitle', slots, []);
    	const splitRoute = exportedfunctions.routes.find(exfunc => exfunc.title === 'SplitTitle');
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SplitNfitTitle> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		link,
    		Prism: Prism$1,
    		exportedfunctions,
    		splitRoute
    	});

    	return [splitRoute];
    }

    class SplitNfitTitle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SplitNfitTitle",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* docs_src/exportedfunctions/SplitTitle.svelte generated by Svelte v3.53.1 */
    const file$k = "docs_src/exportedfunctions/SplitTitle.svelte";

    // (15:0) <Prism language="js">
    function create_default_slot$5(ctx) {
    	let t_value = `import { splitTitle } from '@ekstra-bladet/designsystem/svelte/functions/splitTitle';

const lines = splitTitle('Split this into lines', 2, 3);
` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(15:0) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let h1;
    	let t1;
    	let p0;
    	let t3;
    	let p1;
    	let t5;
    	let code;
    	let div3;
    	let div0;
    	let b0;
    	let t7;
    	let em;
    	let t9;
    	let div1;
    	let b1;
    	let t11;
    	let t12;
    	let div2;
    	let b2;
    	let t14;
    	let t15;
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "SplitTitle";
    			t1 = space();
    			p0 = element("p");
    			p0.textContent = "Splits the title into lines based on given min and max number of lines.";
    			t3 = space();
    			p1 = element("p");
    			p1.textContent = "The created lines is returned as an array of strings.";
    			t5 = space();
    			code = element("code");
    			div3 = element("div");
    			div0 = element("div");
    			b0 = element("b");
    			b0.textContent = "@param input";
    			t7 = text(" string ");
    			em = element("em");
    			em.textContent = "required";
    			t9 = space();
    			div1 = element("div");
    			b1 = element("b");
    			b1.textContent = "@param minLines";
    			t11 = text(" number = 1");
    			t12 = space();
    			div2 = element("div");
    			b2 = element("b");
    			b2.textContent = "@param maxLines";
    			t14 = text(" number = 4");
    			t15 = space();
    			create_component(prism.$$.fragment);
    			add_location(h1, file$k, 3, 0, 63);
    			add_location(p0, file$k, 4, 0, 83);
    			add_location(p1, file$k, 5, 0, 162);
    			add_location(b0, file$k, 8, 9, 247);
    			add_location(em, file$k, 8, 36, 274);
    			add_location(div0, file$k, 8, 4, 242);
    			add_location(b1, file$k, 9, 9, 307);
    			add_location(div1, file$k, 9, 4, 302);
    			add_location(b2, file$k, 10, 9, 356);
    			add_location(div2, file$k, 10, 4, 351);
    			add_location(div3, file$k, 7, 2, 232);
    			add_location(code, file$k, 6, 0, 223);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, code, anchor);
    			append_dev(code, div3);
    			append_dev(div3, div0);
    			append_dev(div0, b0);
    			append_dev(div0, t7);
    			append_dev(div0, em);
    			append_dev(div3, t9);
    			append_dev(div3, div1);
    			append_dev(div1, b1);
    			append_dev(div1, t11);
    			append_dev(div3, t12);
    			append_dev(div3, div2);
    			append_dev(div2, b2);
    			append_dev(div2, t14);
    			insert_dev(target, t15, anchor);
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism_changes.$$scope = { dirty, ctx };
    			}

    			prism.$set(prism_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(code);
    			if (detaching) detach_dev(t15);
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SplitTitle', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SplitTitle> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1 });
    	return [];
    }

    class SplitTitle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SplitTitle",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    /* docs_src/exportedfunctions/Throttle.svelte generated by Svelte v3.53.1 */
    const file$j = "docs_src/exportedfunctions/Throttle.svelte";

    // (19:0) <Prism language="js">
    function create_default_slot$4(ctx) {
    	let t_value = `import { throttle } from '@ekstra-bladet/designsystem';

window.addEventListener(
  'scroll',
  throttle((data) => {
    callback(data);
  }, 150)
);
` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(19:0) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let h1;
    	let t1;
    	let p0;
    	let t3;
    	let p1;
    	let t5;
    	let code;
    	let div0;
    	let b0;
    	let t7;
    	let em0;
    	let t9;
    	let t10;
    	let div1;
    	let b1;
    	let t12;
    	let em1;
    	let t14;
    	let t15;
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Throttle";
    			t1 = space();
    			p0 = element("p");
    			p0.textContent = "Throttle the execution of a given callback. Usefull with scroll events as they fire rapidly and there is no good way\n  to tell if the user stopped scrolling.";
    			t3 = space();
    			p1 = element("p");
    			p1.textContent = "Takes a callback function and a number, the amount of milliseconds to throttle, as arguments";
    			t5 = space();
    			code = element("code");
    			div0 = element("div");
    			b0 = element("b");
    			b0.textContent = "@param callback";
    			t7 = space();
    			em0 = element("em");
    			em0.textContent = "required";
    			t9 = text(" callback function");
    			t10 = space();
    			div1 = element("div");
    			b1 = element("b");
    			b1.textContent = "@param wait";
    			t12 = space();
    			em1 = element("em");
    			em1.textContent = "required";
    			t14 = text(" number of milliseconds to wait");
    			t15 = space();
    			create_component(prism.$$.fragment);
    			add_location(h1, file$j, 3, 0, 63);
    			add_location(p0, file$j, 4, 0, 81);
    			add_location(p1, file$j, 8, 0, 250);
    			add_location(b0, file$j, 12, 4, 370);
    			add_location(em0, file$j, 12, 27, 393);
    			add_location(div0, file$j, 11, 2, 360);
    			add_location(b1, file$j, 15, 4, 450);
    			add_location(em1, file$j, 15, 23, 469);
    			add_location(div1, file$j, 14, 2, 440);
    			add_location(code, file$j, 10, 0, 351);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, code, anchor);
    			append_dev(code, div0);
    			append_dev(div0, b0);
    			append_dev(div0, t7);
    			append_dev(div0, em0);
    			append_dev(div0, t9);
    			append_dev(code, t10);
    			append_dev(code, div1);
    			append_dev(div1, b1);
    			append_dev(div1, t12);
    			append_dev(div1, em1);
    			append_dev(div1, t14);
    			insert_dev(target, t15, anchor);
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism_changes.$$scope = { dirty, ctx };
    			}

    			prism.$set(prism_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(code);
    			if (detaching) detach_dev(t15);
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Throttle', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Throttle> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1 });
    	return [];
    }

    class Throttle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Throttle",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* docs_src/exportedfunctions/TimePassedSince.svelte generated by Svelte v3.53.1 */
    const file$i = "docs_src/exportedfunctions/TimePassedSince.svelte";

    // (12:0) <Prism language="js">
    function create_default_slot$3(ctx) {
    	let t_value = `import { timePassedSince } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(12:0) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let h1;
    	let t1;
    	let p0;
    	let t3;
    	let code;
    	let div;
    	let p1;
    	let b;
    	let t5;
    	let em;
    	let t7;
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "timePassedSince";
    			t1 = space();
    			p0 = element("p");
    			p0.textContent = "Takes a datetimestring and transforms it to a string with the time passed since the given time";
    			t3 = space();
    			code = element("code");
    			div = element("div");
    			p1 = element("p");
    			b = element("b");
    			b.textContent = "@param datetime";
    			t5 = text(" valid datetimestring ");
    			em = element("em");
    			em.textContent = "required";
    			t7 = space();
    			create_component(prism.$$.fragment);
    			add_location(h1, file$i, 3, 0, 63);
    			add_location(p0, file$i, 4, 0, 88);
    			add_location(b, file$i, 7, 7, 248);
    			add_location(em, file$i, 7, 51, 292);
    			add_location(p1, file$i, 7, 4, 245);
    			attr_dev(div, "class", "padding-xl--l padding-m--tb");
    			add_location(div, file$i, 6, 2, 199);
    			add_location(code, file$i, 5, 0, 190);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, code, anchor);
    			append_dev(code, div);
    			append_dev(div, p1);
    			append_dev(p1, b);
    			append_dev(p1, t5);
    			append_dev(p1, em);
    			insert_dev(target, t7, anchor);
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism_changes.$$scope = { dirty, ctx };
    			}

    			prism.$set(prism_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(code);
    			if (detaching) detach_dev(t7);
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TimePassedSince', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TimePassedSince> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1 });
    	return [];
    }

    class TimePassedSince extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TimePassedSince",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    var top = 'top';
    var bottom = 'bottom';
    var right = 'right';
    var left = 'left';
    var auto = 'auto';
    var basePlacements = [top, bottom, right, left];
    var start = 'start';
    var end = 'end';
    var clippingParents = 'clippingParents';
    var viewport = 'viewport';
    var popper = 'popper';
    var reference = 'reference';
    var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []); // modifiers that need to read the DOM

    var beforeRead = 'beforeRead';
    var read = 'read';
    var afterRead = 'afterRead'; // pure-logic modifiers

    var beforeMain = 'beforeMain';
    var main = 'main';
    var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

    var beforeWrite = 'beforeWrite';
    var write = 'write';
    var afterWrite = 'afterWrite';
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

    function getNodeName(element) {
      return element ? (element.nodeName || '').toLowerCase() : null;
    }

    function getWindow(node) {
      if (node == null) {
        return window;
      }

      if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }

      return node;
    }

    function isElement$1(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }

    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }

    function isShadowRoot(node) {
      // IE 11 has no ShadowRoot
      if (typeof ShadowRoot === 'undefined') {
        return false;
      }

      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }

    // and applies them to the HTMLElements such as popper and arrow

    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function (name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        } // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]


        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (name) {
          var value = attributes[name];

          if (value === false) {
            element.removeAttribute(name);
          } else {
            element.setAttribute(name, value === true ? '' : value);
          }
        });
      });
    }

    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;

      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }

      return function () {
        Object.keys(state.elements).forEach(function (name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

          var style = styleProperties.reduce(function (style, property) {
            style[property] = '';
            return style;
          }, {}); // arrow is optional + virtual elements

          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }

          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function (attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    } // eslint-disable-next-line import/no-unused-modules


    var applyStyles$1 = {
      name: 'applyStyles',
      enabled: true,
      phase: 'write',
      fn: applyStyles,
      effect: effect$2,
      requires: ['computeStyles']
    };

    function getBasePlacement$1(placement) {
      return placement.split('-')[0];
    }

    var max = Math.max;
    var min = Math.min;
    var round = Math.round;

    function getUAString() {
      var uaData = navigator.userAgentData;

      if (uaData != null && uaData.brands) {
        return uaData.brands.map(function (item) {
          return item.brand + "/" + item.version;
        }).join(' ');
      }

      return navigator.userAgent;
    }

    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString());
    }

    function getBoundingClientRect(element, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
        includeScale = false;
      }

      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }

      var clientRect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;

      if (includeScale && isHTMLElement(element)) {
        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
      }

      var _ref = isElement$1(element) ? getWindow(element) : window,
          visualViewport = _ref.visualViewport;

      var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width = clientRect.width / scaleX;
      var height = clientRect.height / scaleY;
      return {
        width: width,
        height: height,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x,
        x: x,
        y: y
      };
    }

    // means it doesn't take into account transforms.

    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
      // Fixes https://github.com/popperjs/popper-core/issues/1223

      var width = element.offsetWidth;
      var height = element.offsetHeight;

      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }

      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }

      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
      };
    }

    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

      if (parent.contains(child)) {
        return true;
      } // then fallback to custom implementation with Shadow DOM support
      else if (rootNode && isShadowRoot(rootNode)) {
          var next = child;

          do {
            if (next && parent.isSameNode(next)) {
              return true;
            } // $FlowFixMe[prop-missing]: need a better way to handle this...


            next = next.parentNode || next.host;
          } while (next);
        } // Give up, the result is false


      return false;
    }

    function getComputedStyle(element) {
      return getWindow(element).getComputedStyle(element);
    }

    function isTableElement(element) {
      return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
    }

    function getDocumentElement(element) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return ((isElement$1(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
      element.document) || window.document).documentElement;
    }

    function getParentNode(element) {
      if (getNodeName(element) === 'html') {
        return element;
      }

      return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || ( // DOM Element detected
        isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element) // fallback

      );
    }

    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle(element).position === 'fixed') {
        return null;
      }

      return element.offsetParent;
    } // `.offsetParent` reports `null` for fixed elements, while absolute elements
    // return the containing block


    function getContainingBlock(element) {
      var isFirefox = /firefox/i.test(getUAString());
      var isIE = /Trident/i.test(getUAString());

      if (isIE && isHTMLElement(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = getComputedStyle(element);

        if (elementCss.position === 'fixed') {
          return null;
        }
      }

      var currentNode = getParentNode(element);

      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }

      while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

        if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }

      return null;
    } // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.


    function getOffsetParent(element) {
      var window = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);

      while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
        offsetParent = getTrueOffsetParent(offsetParent);
      }

      if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
        return window;
      }

      return offsetParent || getContainingBlock(element) || window;
    }

    function getMainAxisFromPlacement(placement) {
      return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
    }

    function within(min$1, value, max$1) {
      return max(min$1, min(value, max$1));
    }
    function withinMaxClamp(min, value, max) {
      var v = within(min, value, max);
      return v > max ? max : v;
    }

    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }

    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }

    function expandToHashMap(value, keys) {
      return keys.reduce(function (hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }

    var toPaddingObject = function toPaddingObject(padding, state) {
      padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    };

    function arrow(_ref) {
      var _state$modifiersData$;

      var state = _ref.state,
          name = _ref.name,
          options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement$1(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? 'height' : 'width';

      if (!arrowElement || !popperOffsets) {
        return;
      }

      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === 'y' ? top : left;
      var maxProp = axis === 'y' ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
      var startDiff = popperOffsets[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
      // outside of the popper bounds

      var min = paddingObject[minProp];
      var max = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset = within(min, center, max); // Prevents breaking syntax highlighting...

      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
    }

    function effect$1(_ref2) {
      var state = _ref2.state,
          options = _ref2.options;
      var _options$element = options.element,
          arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

      if (arrowElement == null) {
        return;
      } // CSS selector


      if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);

        if (!arrowElement) {
          return;
        }
      }

      {
        if (!isHTMLElement(arrowElement)) {
          console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
        }
      }

      if (!contains(state.elements.popper, arrowElement)) {
        {
          console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
        }

        return;
      }

      state.elements.arrow = arrowElement;
    } // eslint-disable-next-line import/no-unused-modules


    var arrow$1 = {
      name: 'arrow',
      enabled: true,
      phase: 'main',
      fn: arrow,
      effect: effect$1,
      requires: ['popperOffsets'],
      requiresIfExists: ['preventOverflow']
    };

    function getVariation(placement) {
      return placement.split('-')[1];
    }

    var unsetSides = {
      top: 'auto',
      right: 'auto',
      bottom: 'auto',
      left: 'auto'
    }; // Round the offsets to the nearest suitable subpixel based on the DPR.
    // Zooming can change the DPR, but it seems to report a value that will
    // cleanly divide the values into the appropriate subpixels.

    function roundOffsetsByDPR(_ref) {
      var x = _ref.x,
          y = _ref.y;
      var win = window;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round(x * dpr) / dpr || 0,
        y: round(y * dpr) / dpr || 0
      };
    }

    function mapToStyles(_ref2) {
      var _Object$assign2;

      var popper = _ref2.popper,
          popperRect = _ref2.popperRect,
          placement = _ref2.placement,
          variation = _ref2.variation,
          offsets = _ref2.offsets,
          position = _ref2.position,
          gpuAcceleration = _ref2.gpuAcceleration,
          adaptive = _ref2.adaptive,
          roundOffsets = _ref2.roundOffsets,
          isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x,
          x = _offsets$x === void 0 ? 0 : _offsets$x,
          _offsets$y = offsets.y,
          y = _offsets$y === void 0 ? 0 : _offsets$y;

      var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
        x: x,
        y: y
      }) : {
        x: x,
        y: y
      };

      x = _ref3.x;
      y = _ref3.y;
      var hasX = offsets.hasOwnProperty('x');
      var hasY = offsets.hasOwnProperty('y');
      var sideX = left;
      var sideY = top;
      var win = window;

      if (adaptive) {
        var offsetParent = getOffsetParent(popper);
        var heightProp = 'clientHeight';
        var widthProp = 'clientWidth';

        if (offsetParent === getWindow(popper)) {
          offsetParent = getDocumentElement(popper);

          if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
            heightProp = 'scrollHeight';
            widthProp = 'scrollWidth';
          }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


        offsetParent = offsetParent;

        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
          offsetParent[heightProp];
          y -= offsetY - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }

        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
          offsetParent[widthProp];
          x -= offsetX - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }

      var commonStyles = Object.assign({
        position: position
      }, adaptive && unsetSides);

      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x,
        y: y
      }) : {
        x: x,
        y: y
      };

      x = _ref4.x;
      y = _ref4.y;

      if (gpuAcceleration) {
        var _Object$assign;

        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }

      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
    }

    function computeStyles(_ref5) {
      var state = _ref5.state,
          options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration,
          gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
          _options$adaptive = options.adaptive,
          adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
          _options$roundOffsets = options.roundOffsets,
          roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

      {
        var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';

        if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
          return transitionProperty.indexOf(property) >= 0;
        })) {
          console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
        }
      }

      var commonStyles = {
        placement: getBasePlacement$1(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration,
        isFixed: state.options.strategy === 'fixed'
      };

      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive: adaptive,
          roundOffsets: roundOffsets
        })));
      }

      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: 'absolute',
          adaptive: false,
          roundOffsets: roundOffsets
        })));
      }

      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-placement': state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var computeStyles$1 = {
      name: 'computeStyles',
      enabled: true,
      phase: 'beforeWrite',
      fn: computeStyles,
      data: {}
    };

    var passive = {
      passive: true
    };

    function effect(_ref) {
      var state = _ref.state,
          instance = _ref.instance,
          options = _ref.options;
      var _options$scroll = options.scroll,
          scroll = _options$scroll === void 0 ? true : _options$scroll,
          _options$resize = options.resize,
          resize = _options$resize === void 0 ? true : _options$resize;
      var window = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.addEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.addEventListener('resize', instance.update, passive);
      }

      return function () {
        if (scroll) {
          scrollParents.forEach(function (scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
          });
        }

        if (resize) {
          window.removeEventListener('resize', instance.update, passive);
        }
      };
    } // eslint-disable-next-line import/no-unused-modules


    var eventListeners = {
      name: 'eventListeners',
      enabled: true,
      phase: 'write',
      fn: function fn() {},
      effect: effect,
      data: {}
    };

    var hash$1 = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash$1[matched];
      });
    }

    var hash = {
      start: 'end',
      end: 'start'
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function (matched) {
        return hash[matched];
      });
    }

    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      };
    }

    function getWindowScrollBarX(element) {
      // If <html> has a CSS width greater than the viewport, then this will be
      // incorrect for RTL.
      // Popper 1 is broken in this case and never had a bug report so let's assume
      // it's not an issue. I don't think anyone ever specifies width on <html>
      // anyway.
      // Browsers where the left scrollbar doesn't cause an issue report `0` for
      // this (e.g. Edge 2019, IE11, Safari)
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }

    function getViewportRect(element, strategy) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0;

      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        var layoutViewport = isLayoutViewport();

        if (layoutViewport || !layoutViewport && strategy === 'fixed') {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }

      return {
        width: width,
        height: height,
        x: x + getWindowScrollBarX(element),
        y: y
      };
    }

    // of the `<html>` and `<body>` rect bounds if horizontally scrollable

    function getDocumentRect(element) {
      var _element$ownerDocumen;

      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;

      if (getComputedStyle(body || html).direction === 'rtl') {
        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
      }

      return {
        width: width,
        height: height,
        x: x,
        y: y
      };
    }

    function isScrollParent(element) {
      // Firefox wants us to check `-x` and `-y` variations as well
      var _getComputedStyle = getComputedStyle(element),
          overflow = _getComputedStyle.overflow,
          overflowX = _getComputedStyle.overflowX,
          overflowY = _getComputedStyle.overflowY;

      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }

    function getScrollParent(node) {
      if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
        // $FlowFixMe[incompatible-return]: assume body is always available
        return node.ownerDocument.body;
      }

      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }

      return getScrollParent(getParentNode(node));
    }

    /*
    given a DOM element, return the list of all scroll parents, up the list of ancesors
    until we get to the top window object. This list is what we attach scroll listeners
    to, because if any of these parent elements scroll, we'll need to re-calculate the
    reference element's position.
    */

    function listScrollParents(element, list) {
      var _element$ownerDocumen;

      if (list === void 0) {
        list = [];
      }

      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)));
    }

    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }

    function getInnerBoundingClientRect(element, strategy) {
      var rect = getBoundingClientRect(element, false, strategy === 'fixed');
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }

    function getClientRectFromMixedType(element, clippingParent, strategy) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    } // A "clipping parent" is an overflowable container with the characteristic of
    // clipping (or hiding) overflowing elements with a position different from
    // `initial`


    function getClippingParents(element) {
      var clippingParents = listScrollParents(getParentNode(element));
      var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

      if (!isElement$1(clipperElement)) {
        return [];
      } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


      return clippingParents.filter(function (clippingParent) {
        return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
      });
    } // Gets the maximum area that the element is visible in due to any number of
    // clipping parents


    function getClippingRect(element, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
      var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents[0];
      var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }

    function computeOffsets(_ref) {
      var reference = _ref.reference,
          element = _ref.element,
          placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement$1(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference.x + reference.width / 2 - element.width / 2;
      var commonY = reference.y + reference.height / 2 - element.height / 2;
      var offsets;

      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference.y - element.height
          };
          break;

        case bottom:
          offsets = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;

        case right:
          offsets = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;

        case left:
          offsets = {
            x: reference.x - element.width,
            y: commonY
          };
          break;

        default:
          offsets = {
            x: reference.x,
            y: reference.y
          };
      }

      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

      if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';

        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
            break;

          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
            break;
        }
      }

      return offsets;
    }

    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          _options$placement = _options.placement,
          placement = _options$placement === void 0 ? state.placement : _options$placement,
          _options$strategy = _options.strategy,
          strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
          _options$boundary = _options.boundary,
          boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
          _options$rootBoundary = _options.rootBoundary,
          rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
          _options$elementConte = _options.elementContext,
          elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
          _options$altBoundary = _options.altBoundary,
          altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
          _options$padding = _options.padding,
          padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
      // 0 or negative = within the clipping rect

      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

      if (elementContext === popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function (key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
          overflowOffsets[key] += offset[axis] * multiply;
        });
      }

      return overflowOffsets;
    }

    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          placement = _options.placement,
          boundary = _options.boundary,
          rootBoundary = _options.rootBoundary,
          padding = _options.padding,
          flipVariations = _options.flipVariations,
          _options$allowedAutoP = _options.allowedAutoPlacements,
          allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
        return getVariation(placement) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function (placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
      });

      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;

        {
          console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
        }
      } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


      var overflows = allowedPlacements.reduce(function (acc, placement) {
        acc[placement] = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding
        })[getBasePlacement$1(placement)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function (a, b) {
        return overflows[a] - overflows[b];
      });
    }

    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement$1(placement) === auto) {
        return [];
      }

      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }

    function flip(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;

      if (state.modifiersData[name]._skip) {
        return;
      }

      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
          specifiedFallbackPlacements = options.fallbackPlacements,
          padding = options.padding,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          _options$flipVariatio = options.flipVariations,
          flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
          allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement$1(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
        return acc.concat(getBasePlacement$1(placement) === auto ? computeAutoPlacement(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding,
          flipVariations: flipVariations,
          allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements[0];

      for (var i = 0; i < placements.length; i++) {
        var placement = placements[i];

        var _basePlacement = getBasePlacement$1(placement);

        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          altBoundary: altBoundary,
          padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }

        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];

        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }

        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }

        if (checks.every(function (check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }

        checksMap.set(placement, checks);
      }

      if (makeFallbackChecks) {
        // `2` may be desired in some cases  research later
        var numberOfChecks = flipVariations ? 3 : 1;

        var _loop = function _loop(_i) {
          var fittingPlacement = placements.find(function (placement) {
            var checks = checksMap.get(placement);

            if (checks) {
              return checks.slice(0, _i).every(function (check) {
                return check;
              });
            }
          });

          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };

        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);

          if (_ret === "break") break;
        }
      }

      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    } // eslint-disable-next-line import/no-unused-modules


    var flip$1 = {
      name: 'flip',
      enabled: true,
      phase: 'main',
      fn: flip,
      requiresIfExists: ['offset'],
      data: {
        _skip: false
      }
    };

    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }

      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }

    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function (side) {
        return overflow[side] >= 0;
      });
    }

    function hide(_ref) {
      var state = _ref.state,
          name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: 'reference'
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
      });
    } // eslint-disable-next-line import/no-unused-modules


    var hide$1 = {
      name: 'hide',
      enabled: true,
      phase: 'main',
      requiresIfExists: ['preventOverflow'],
      fn: hide
    };

    function distanceAndSkiddingToXY(placement, rects, offset) {
      var basePlacement = getBasePlacement$1(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

      var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
        placement: placement
      })) : offset,
          skidding = _ref[0],
          distance = _ref[1];

      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }

    function offset(_ref2) {
      var state = _ref2.state,
          options = _ref2.options,
          name = _ref2.name;
      var _options$offset = options.offset,
          offset = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function (acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement],
          x = _data$state$placement.x,
          y = _data$state$placement.y;

      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var offset$1 = {
      name: 'offset',
      enabled: true,
      phase: 'main',
      requires: ['popperOffsets'],
      fn: offset
    };

    function popperOffsets(_ref) {
      var state = _ref.state,
          name = _ref.name;
      // Offsets are the actual position the popper needs to have to be
      // properly positioned near its reference element
      // This is the most basic placement, and will be adjusted by
      // the modifiers in the next step
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var popperOffsets$1 = {
      name: 'popperOffsets',
      enabled: true,
      phase: 'read',
      fn: popperOffsets,
      data: {}
    };

    function getAltAxis(axis) {
      return axis === 'x' ? 'y' : 'x';
    }

    function preventOverflow(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;
      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          padding = options.padding,
          _options$tether = options.tether,
          tether = _options$tether === void 0 ? true : _options$tether,
          _options$tetherOffset = options.tetherOffset,
          tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
      });
      var basePlacement = getBasePlacement$1(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
        x: 0,
        y: 0
      };

      if (!popperOffsets) {
        return;
      }

      if (checkMainAxis) {
        var _offsetModifierState$;

        var mainSide = mainAxis === 'y' ? top : left;
        var altSide = mainAxis === 'y' ? bottom : right;
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min$1 = offset + overflow[mainSide];
        var max$1 = offset - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds

        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)

        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
        popperOffsets[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset;
      }

      if (checkAltAxis) {
        var _offsetModifierState$2;

        var _mainSide = mainAxis === 'x' ? top : left;

        var _altSide = mainAxis === 'x' ? bottom : right;

        var _offset = popperOffsets[altAxis];

        var _len = altAxis === 'y' ? 'height' : 'width';

        var _min = _offset + overflow[_mainSide];

        var _max = _offset - overflow[_altSide];

        var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

        popperOffsets[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var preventOverflow$1 = {
      name: 'preventOverflow',
      enabled: true,
      phase: 'main',
      fn: preventOverflow,
      requiresIfExists: ['offset']
    };

    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }

    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }

    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round(rect.width) / element.offsetWidth || 1;
      var scaleY = round(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    } // Returns the composite rect of an element relative to its offsetParent.
    // Composite means it takes into account transforms as well as layout.


    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }

      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };

      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }

        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }

      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }

    function order(modifiers) {
      var map = new Map();
      var visited = new Set();
      var result = [];
      modifiers.forEach(function (modifier) {
        map.set(modifier.name, modifier);
      }); // On visiting object, check for its dependencies and visit them recursively

      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function (dep) {
          if (!visited.has(dep)) {
            var depModifier = map.get(dep);

            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }

      modifiers.forEach(function (modifier) {
        if (!visited.has(modifier.name)) {
          // check for visited object
          sort(modifier);
        }
      });
      return result;
    }

    function orderModifiers(modifiers) {
      // order based on dependencies
      var orderedModifiers = order(modifiers); // order based on phase

      return modifierPhases.reduce(function (acc, phase) {
        return acc.concat(orderedModifiers.filter(function (modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }

    function debounce$1(fn) {
      var pending;
      return function () {
        if (!pending) {
          pending = new Promise(function (resolve) {
            Promise.resolve().then(function () {
              pending = undefined;
              resolve(fn());
            });
          });
        }

        return pending;
      };
    }

    function format(str) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return [].concat(args).reduce(function (p, c) {
        return p.replace(/%s/, c);
      }, str);
    }

    var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
    var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
    var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
    function validateModifiers(modifiers) {
      modifiers.forEach(function (modifier) {
        [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
        .filter(function (value, index, self) {
          return self.indexOf(value) === index;
        }).forEach(function (key) {
          switch (key) {
            case 'name':
              if (typeof modifier.name !== 'string') {
                console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
              }

              break;

            case 'enabled':
              if (typeof modifier.enabled !== 'boolean') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
              }

              break;

            case 'phase':
              if (modifierPhases.indexOf(modifier.phase) < 0) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
              }

              break;

            case 'fn':
              if (typeof modifier.fn !== 'function') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
              }

              break;

            case 'effect':
              if (modifier.effect != null && typeof modifier.effect !== 'function') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
              }

              break;

            case 'requires':
              if (modifier.requires != null && !Array.isArray(modifier.requires)) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
              }

              break;

            case 'requiresIfExists':
              if (!Array.isArray(modifier.requiresIfExists)) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
              }

              break;

            case 'options':
            case 'data':
              break;

            default:
              console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
                return "\"" + s + "\"";
              }).join(', ') + "; but \"" + key + "\" was provided.");
          }

          modifier.requires && modifier.requires.forEach(function (requirement) {
            if (modifiers.find(function (mod) {
              return mod.name === requirement;
            }) == null) {
              console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
            }
          });
        });
      });
    }

    function uniqueBy(arr, fn) {
      var identifiers = new Set();
      return arr.filter(function (item) {
        var identifier = fn(item);

        if (!identifiers.has(identifier)) {
          identifiers.add(identifier);
          return true;
        }
      });
    }

    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function (merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
      }, {}); // IE11 does not support Object.values

      return Object.keys(merged).map(function (key) {
        return merged[key];
      });
    }

    var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
    var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
    var DEFAULT_OPTIONS = {
      placement: 'bottom',
      modifiers: [],
      strategy: 'absolute'
    };

    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return !args.some(function (element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
      });
    }

    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }

      var _generatorOptions = generatorOptions,
          _generatorOptions$def = _generatorOptions.defaultModifiers,
          defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
          _generatorOptions$def2 = _generatorOptions.defaultOptions,
          defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper(reference, popper, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var state = {
          placement: 'bottom',
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference,
            popper: popper
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state: state,
          setOptions: function setOptions(setOptionsAction) {
            var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options);
            state.scrollParents = {
              reference: isElement$1(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
              popper: listScrollParents(popper)
            }; // Orders the modifiers based on their dependencies and `phase`
            // properties

            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

            state.orderedModifiers = orderedModifiers.filter(function (m) {
              return m.enabled;
            }); // Validate the provided modifiers so that the consumer will get warned
            // if one of the modifiers is invalid for any reason

            {
              var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
                var name = _ref.name;
                return name;
              });
              validateModifiers(modifiers);

              if (getBasePlacement$1(state.options.placement) === auto) {
                var flipModifier = state.orderedModifiers.find(function (_ref2) {
                  var name = _ref2.name;
                  return name === 'flip';
                });

                if (!flipModifier) {
                  console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
                }
              }

              var _getComputedStyle = getComputedStyle(popper),
                  marginTop = _getComputedStyle.marginTop,
                  marginRight = _getComputedStyle.marginRight,
                  marginBottom = _getComputedStyle.marginBottom,
                  marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
              // cause bugs with positioning, so we'll warn the consumer


              if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
                return parseFloat(margin);
              })) {
                console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
              }
            }

            runModifierEffects();
            return instance.update();
          },
          // Sync update  it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }

            var _state$elements = state.elements,
                reference = _state$elements.reference,
                popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
            // anymore

            if (!areValidElements(reference, popper)) {
              {
                console.error(INVALID_ELEMENT_ERROR);
              }

              return;
            } // Store the reference and popper rects to be read by modifiers


            state.rects = {
              reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
              popper: getLayoutRect(popper)
            }; // Modifiers have the ability to reset the current update cycle. The
            // most common use case for this is the `flip` modifier changing the
            // placement, which then needs to re-run all the modifiers, because the
            // logic was previously ran for the previous placement and is therefore
            // stale/incorrect

            state.reset = false;
            state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
            // is filled with the initial data specified by the modifier. This means
            // it doesn't persist and is fresh on each update.
            // To ensure persistent data, use `${name}#persistent`

            state.orderedModifiers.forEach(function (modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            var __debug_loops__ = 0;

            for (var index = 0; index < state.orderedModifiers.length; index++) {
              {
                __debug_loops__ += 1;

                if (__debug_loops__ > 100) {
                  console.error(INFINITE_LOOP_ERROR);
                  break;
                }
              }

              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }

              var _state$orderedModifie = state.orderedModifiers[index],
                  fn = _state$orderedModifie.fn,
                  _state$orderedModifie2 = _state$orderedModifie.options,
                  _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                  name = _state$orderedModifie.name;

              if (typeof fn === 'function') {
                state = fn({
                  state: state,
                  options: _options,
                  name: name,
                  instance: instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update  it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce$1(function () {
            return new Promise(function (resolve) {
              instance.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };

        if (!areValidElements(reference, popper)) {
          {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return instance;
        }

        instance.setOptions(options).then(function (state) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state);
          }
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.

        function runModifierEffects() {
          state.orderedModifiers.forEach(function (_ref3) {
            var name = _ref3.name,
                _ref3$options = _ref3.options,
                options = _ref3$options === void 0 ? {} : _ref3$options,
                effect = _ref3.effect;

            if (typeof effect === 'function') {
              var cleanupFn = effect({
                state: state,
                name: name,
                instance: instance,
                options: options
              });

              var noopFn = function noopFn() {};

              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }

        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function (fn) {
            return fn();
          });
          effectCleanupFns = [];
        }

        return instance;
      };
    }

    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /*#__PURE__*/popperGenerator({
      defaultModifiers: defaultModifiers
    }); // eslint-disable-next-line import/no-unused-modules

    /**!
    * tippy.js v6.3.7
    * (c) 2017-2021 atomiks
    * MIT License
    */
    var CONTENT_CLASS = "tippy-content";
    var BACKDROP_CLASS = "tippy-backdrop";
    var ARROW_CLASS = "tippy-arrow";
    var SVG_ARROW_CLASS = "tippy-svg-arrow";
    var TOUCH_OPTIONS = {
      passive: true,
      capture: true
    };
    var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {
      return document.body;
    };

    function hasOwnProperty(obj, key) {
      return {}.hasOwnProperty.call(obj, key);
    }
    function getValueAtIndexOrReturn(value, index, defaultValue) {
      if (Array.isArray(value)) {
        var v = value[index];
        return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
      }

      return value;
    }
    function isType(value, type) {
      var str = {}.toString.call(value);
      return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
    }
    function invokeWithArgsOrReturn(value, args) {
      return typeof value === 'function' ? value.apply(void 0, args) : value;
    }
    function debounce(fn, ms) {
      // Avoid wrapping in `setTimeout` if ms is 0 anyway
      if (ms === 0) {
        return fn;
      }

      var timeout;
      return function (arg) {
        clearTimeout(timeout);
        timeout = setTimeout(function () {
          fn(arg);
        }, ms);
      };
    }
    function removeProperties(obj, keys) {
      var clone = Object.assign({}, obj);
      keys.forEach(function (key) {
        delete clone[key];
      });
      return clone;
    }
    function splitBySpaces(value) {
      return value.split(/\s+/).filter(Boolean);
    }
    function normalizeToArray(value) {
      return [].concat(value);
    }
    function pushIfUnique(arr, value) {
      if (arr.indexOf(value) === -1) {
        arr.push(value);
      }
    }
    function unique(arr) {
      return arr.filter(function (item, index) {
        return arr.indexOf(item) === index;
      });
    }
    function getBasePlacement(placement) {
      return placement.split('-')[0];
    }
    function arrayFrom(value) {
      return [].slice.call(value);
    }
    function removeUndefinedProps(obj) {
      return Object.keys(obj).reduce(function (acc, key) {
        if (obj[key] !== undefined) {
          acc[key] = obj[key];
        }

        return acc;
      }, {});
    }

    function div() {
      return document.createElement('div');
    }
    function isElement(value) {
      return ['Element', 'Fragment'].some(function (type) {
        return isType(value, type);
      });
    }
    function isNodeList(value) {
      return isType(value, 'NodeList');
    }
    function isMouseEvent(value) {
      return isType(value, 'MouseEvent');
    }
    function isReferenceElement(value) {
      return !!(value && value._tippy && value._tippy.reference === value);
    }
    function getArrayOfElements(value) {
      if (isElement(value)) {
        return [value];
      }

      if (isNodeList(value)) {
        return arrayFrom(value);
      }

      if (Array.isArray(value)) {
        return value;
      }

      return arrayFrom(document.querySelectorAll(value));
    }
    function setTransitionDuration(els, value) {
      els.forEach(function (el) {
        if (el) {
          el.style.transitionDuration = value + "ms";
        }
      });
    }
    function setVisibilityState(els, state) {
      els.forEach(function (el) {
        if (el) {
          el.setAttribute('data-state', state);
        }
      });
    }
    function getOwnerDocument(elementOrElements) {
      var _element$ownerDocumen;

      var _normalizeToArray = normalizeToArray(elementOrElements),
          element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body


      return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
    }
    function isCursorOutsideInteractiveBorder(popperTreeData, event) {
      var clientX = event.clientX,
          clientY = event.clientY;
      return popperTreeData.every(function (_ref) {
        var popperRect = _ref.popperRect,
            popperState = _ref.popperState,
            props = _ref.props;
        var interactiveBorder = props.interactiveBorder;
        var basePlacement = getBasePlacement(popperState.placement);
        var offsetData = popperState.modifiersData.offset;

        if (!offsetData) {
          return true;
        }

        var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
        var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
        var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
        var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
        var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
        var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
        var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
        var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
        return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
      });
    }
    function updateTransitionEndListener(box, action, listener) {
      var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
      // `webkitTransitionEnd`...

      ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
        box[method](event, listener);
      });
    }
    /**
     * Compared to xxx.contains, this function works for dom structures with shadow
     * dom
     */

    function actualContains(parent, child) {
      var target = child;

      while (target) {
        var _target$getRootNode;

        if (parent.contains(target)) {
          return true;
        }

        target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
      }

      return false;
    }

    var currentInput = {
      isTouch: false
    };
    var lastMouseMoveTime = 0;
    /**
     * When a `touchstart` event is fired, it's assumed the user is using touch
     * input. We'll bind a `mousemove` event listener to listen for mouse input in
     * the future. This way, the `isTouch` property is fully dynamic and will handle
     * hybrid devices that use a mix of touch + mouse input.
     */

    function onDocumentTouchStart() {
      if (currentInput.isTouch) {
        return;
      }

      currentInput.isTouch = true;

      if (window.performance) {
        document.addEventListener('mousemove', onDocumentMouseMove);
      }
    }
    /**
     * When two `mousemove` event are fired consecutively within 20ms, it's assumed
     * the user is using mouse input again. `mousemove` can fire on touch devices as
     * well, but very rarely that quickly.
     */

    function onDocumentMouseMove() {
      var now = performance.now();

      if (now - lastMouseMoveTime < 20) {
        currentInput.isTouch = false;
        document.removeEventListener('mousemove', onDocumentMouseMove);
      }

      lastMouseMoveTime = now;
    }
    /**
     * When an element is in focus and has a tippy, leaving the tab/window and
     * returning causes it to show again. For mouse users this is unexpected, but
     * for keyboard use it makes sense.
     * TODO: find a better technique to solve this problem
     */

    function onWindowBlur() {
      var activeElement = document.activeElement;

      if (isReferenceElement(activeElement)) {
        var instance = activeElement._tippy;

        if (activeElement.blur && !instance.state.isVisible) {
          activeElement.blur();
        }
      }
    }
    function bindGlobalEventListeners() {
      document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
      window.addEventListener('blur', onWindowBlur);
    }

    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
    var isIE11 = isBrowser ? // @ts-ignore
    !!window.msCrypto : false;

    function createMemoryLeakWarning(method) {
      var txt = method === 'destroy' ? 'n already-' : ' ';
      return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", 'indicates a potential memory leak.'].join(' ');
    }
    function clean(value) {
      var spacesAndTabs = /[ \t]{2,}/g;
      var lineStartWithSpaces = /^[ \t]*/gm;
      return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
    }

    function getDevMessage(message) {
      return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\uD83D\uDC77\u200D This is a development-only message. It will be removed in production.\n  ");
    }

    function getFormattedMessage(message) {
      return [getDevMessage(message), // title
      'color: #00C584; font-size: 1.3em; font-weight: bold;', // message
      'line-height: 1.5', // footer
      'color: #a6a095;'];
    } // Assume warnings and errors never have the same message

    var visitedMessages;

    {
      resetVisitedMessages();
    }

    function resetVisitedMessages() {
      visitedMessages = new Set();
    }
    function warnWhen(condition, message) {
      if (condition && !visitedMessages.has(message)) {
        var _console;

        visitedMessages.add(message);

        (_console = console).warn.apply(_console, getFormattedMessage(message));
      }
    }
    function errorWhen(condition, message) {
      if (condition && !visitedMessages.has(message)) {
        var _console2;

        visitedMessages.add(message);

        (_console2 = console).error.apply(_console2, getFormattedMessage(message));
      }
    }
    function validateTargets(targets) {
      var didPassFalsyValue = !targets;
      var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;
      errorWhen(didPassFalsyValue, ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element,', 'Element[], or NodeList.'].join(' '));
      errorWhen(didPassPlainObject, ['tippy() was passed a plain object which is not supported as an argument', 'for virtual positioning. Use props.getReferenceClientRect instead.'].join(' '));
    }

    var pluginProps = {
      animateFill: false,
      followCursor: false,
      inlinePositioning: false,
      sticky: false
    };
    var renderProps = {
      allowHTML: false,
      animation: 'fade',
      arrow: true,
      content: '',
      inertia: false,
      maxWidth: 350,
      role: 'tooltip',
      theme: '',
      zIndex: 9999
    };
    var defaultProps = Object.assign({
      appendTo: TIPPY_DEFAULT_APPEND_TO,
      aria: {
        content: 'auto',
        expanded: 'auto'
      },
      delay: 0,
      duration: [300, 250],
      getReferenceClientRect: null,
      hideOnClick: true,
      ignoreAttributes: false,
      interactive: false,
      interactiveBorder: 2,
      interactiveDebounce: 0,
      moveTransition: '',
      offset: [0, 10],
      onAfterUpdate: function onAfterUpdate() {},
      onBeforeUpdate: function onBeforeUpdate() {},
      onCreate: function onCreate() {},
      onDestroy: function onDestroy() {},
      onHidden: function onHidden() {},
      onHide: function onHide() {},
      onMount: function onMount() {},
      onShow: function onShow() {},
      onShown: function onShown() {},
      onTrigger: function onTrigger() {},
      onUntrigger: function onUntrigger() {},
      onClickOutside: function onClickOutside() {},
      placement: 'top',
      plugins: [],
      popperOptions: {},
      render: null,
      showOnCreate: false,
      touch: true,
      trigger: 'mouseenter focus',
      triggerTarget: null
    }, pluginProps, renderProps);
    var defaultKeys = Object.keys(defaultProps);
    var setDefaultProps = function setDefaultProps(partialProps) {
      /* istanbul ignore else */
      {
        validateProps(partialProps, []);
      }

      var keys = Object.keys(partialProps);
      keys.forEach(function (key) {
        defaultProps[key] = partialProps[key];
      });
    };
    function getExtendedPassedProps(passedProps) {
      var plugins = passedProps.plugins || [];
      var pluginProps = plugins.reduce(function (acc, plugin) {
        var name = plugin.name,
            defaultValue = plugin.defaultValue;

        if (name) {
          var _name;

          acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
        }

        return acc;
      }, {});
      return Object.assign({}, passedProps, pluginProps);
    }
    function getDataAttributeProps(reference, plugins) {
      var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
        plugins: plugins
      }))) : defaultKeys;
      var props = propKeys.reduce(function (acc, key) {
        var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

        if (!valueAsString) {
          return acc;
        }

        if (key === 'content') {
          acc[key] = valueAsString;
        } else {
          try {
            acc[key] = JSON.parse(valueAsString);
          } catch (e) {
            acc[key] = valueAsString;
          }
        }

        return acc;
      }, {});
      return props;
    }
    function evaluateProps(reference, props) {
      var out = Object.assign({}, props, {
        content: invokeWithArgsOrReturn(props.content, [reference])
      }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
      out.aria = Object.assign({}, defaultProps.aria, out.aria);
      out.aria = {
        expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
        content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
      };
      return out;
    }
    function validateProps(partialProps, plugins) {
      if (partialProps === void 0) {
        partialProps = {};
      }

      if (plugins === void 0) {
        plugins = [];
      }

      var keys = Object.keys(partialProps);
      keys.forEach(function (prop) {
        var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
        var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`

        if (didPassUnknownProp) {
          didPassUnknownProp = plugins.filter(function (plugin) {
            return plugin.name === prop;
          }).length === 0;
        }

        warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", 'a plugin, forgot to pass it in an array as props.plugins.', '\n\n', 'All props: https://atomiks.github.io/tippyjs/v6/all-props/\n', 'Plugins: https://atomiks.github.io/tippyjs/v6/plugins/'].join(' '));
      });
    }

    function getChildren(popper) {
      var box = popper.firstElementChild;
      var boxChildren = arrayFrom(box.children);
      return {
        box: box,
        content: boxChildren.find(function (node) {
          return node.classList.contains(CONTENT_CLASS);
        }),
        arrow: boxChildren.find(function (node) {
          return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
        }),
        backdrop: boxChildren.find(function (node) {
          return node.classList.contains(BACKDROP_CLASS);
        })
      };
    }

    var idCounter = 1;
    var mouseMoveListeners = []; // Used by `hideAll()`

    var mountedInstances = [];
    function createTippy(reference, passedProps) {
      var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
      //  Private members
      // ===========================================================================

      var showTimeout;
      var hideTimeout;
      var scheduleHideAnimationFrame;
      var isVisibleFromClick = false;
      var didHideDueToDocumentMouseDown = false;
      var didTouchMove = false;
      var ignoreOnFirstUpdate = false;
      var lastTriggerEvent;
      var currentTransitionEndListener;
      var onFirstUpdate;
      var listeners = [];
      var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
      var currentTarget; // ===========================================================================
      //  Public members
      // ===========================================================================

      var id = idCounter++;
      var popperInstance = null;
      var plugins = unique(props.plugins);
      var state = {
        // Is the instance currently enabled?
        isEnabled: true,
        // Is the tippy currently showing and not transitioning out?
        isVisible: false,
        // Has the instance been destroyed?
        isDestroyed: false,
        // Is the tippy currently mounted to the DOM?
        isMounted: false,
        // Has the tippy finished transitioning in?
        isShown: false
      };
      var instance = {
        // properties
        id: id,
        reference: reference,
        popper: div(),
        popperInstance: popperInstance,
        props: props,
        state: state,
        plugins: plugins,
        // methods
        clearDelayTimeouts: clearDelayTimeouts,
        setProps: setProps,
        setContent: setContent,
        show: show,
        hide: hide,
        hideWithInteractivity: hideWithInteractivity,
        enable: enable,
        disable: disable,
        unmount: unmount,
        destroy: destroy
      }; // TODO: Investigate why this early return causes a TDZ error in the tests 
      // it doesn't seem to happen in the browser

      /* istanbul ignore if */

      if (!props.render) {
        {
          errorWhen(true, 'render() function has not been supplied.');
        }

        return instance;
      } // ===========================================================================
      // Initial mutations
      // ===========================================================================


      var _props$render = props.render(instance),
          popper = _props$render.popper,
          onUpdate = _props$render.onUpdate;

      popper.setAttribute('data-tippy-root', '');
      popper.id = "tippy-" + instance.id;
      instance.popper = popper;
      reference._tippy = instance;
      popper._tippy = instance;
      var pluginsHooks = plugins.map(function (plugin) {
        return plugin.fn(instance);
      });
      var hasAriaExpanded = reference.hasAttribute('aria-expanded');
      addListeners();
      handleAriaExpandedAttribute();
      handleStyles();
      invokeHook('onCreate', [instance]);

      if (props.showOnCreate) {
        scheduleShow();
      } // Prevent a tippy with a delay from hiding if the cursor left then returned
      // before it started hiding


      popper.addEventListener('mouseenter', function () {
        if (instance.props.interactive && instance.state.isVisible) {
          instance.clearDelayTimeouts();
        }
      });
      popper.addEventListener('mouseleave', function () {
        if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
          getDocument().addEventListener('mousemove', debouncedOnMouseMove);
        }
      });
      return instance; // ===========================================================================
      //  Private methods
      // ===========================================================================

      function getNormalizedTouchSettings() {
        var touch = instance.props.touch;
        return Array.isArray(touch) ? touch : [touch, 0];
      }

      function getIsCustomTouchBehavior() {
        return getNormalizedTouchSettings()[0] === 'hold';
      }

      function getIsDefaultRenderFn() {
        var _instance$props$rende;

        // @ts-ignore
        return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
      }

      function getCurrentTarget() {
        return currentTarget || reference;
      }

      function getDocument() {
        var parent = getCurrentTarget().parentNode;
        return parent ? getOwnerDocument(parent) : document;
      }

      function getDefaultTemplateChildren() {
        return getChildren(popper);
      }

      function getDelay(isShow) {
        // For touch or keyboard input, force `0` delay for UX reasons
        // Also if the instance is mounted but not visible (transitioning out),
        // ignore delay
        if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
          return 0;
        }

        return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
      }

      function handleStyles(fromHide) {
        if (fromHide === void 0) {
          fromHide = false;
        }

        popper.style.pointerEvents = instance.props.interactive && !fromHide ? '' : 'none';
        popper.style.zIndex = "" + instance.props.zIndex;
      }

      function invokeHook(hook, args, shouldInvokePropsHook) {
        if (shouldInvokePropsHook === void 0) {
          shouldInvokePropsHook = true;
        }

        pluginsHooks.forEach(function (pluginHooks) {
          if (pluginHooks[hook]) {
            pluginHooks[hook].apply(pluginHooks, args);
          }
        });

        if (shouldInvokePropsHook) {
          var _instance$props;

          (_instance$props = instance.props)[hook].apply(_instance$props, args);
        }
      }

      function handleAriaContentAttribute() {
        var aria = instance.props.aria;

        if (!aria.content) {
          return;
        }

        var attr = "aria-" + aria.content;
        var id = popper.id;
        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          var currentValue = node.getAttribute(attr);

          if (instance.state.isVisible) {
            node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
          } else {
            var nextValue = currentValue && currentValue.replace(id, '').trim();

            if (nextValue) {
              node.setAttribute(attr, nextValue);
            } else {
              node.removeAttribute(attr);
            }
          }
        });
      }

      function handleAriaExpandedAttribute() {
        if (hasAriaExpanded || !instance.props.aria.expanded) {
          return;
        }

        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          if (instance.props.interactive) {
            node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
          } else {
            node.removeAttribute('aria-expanded');
          }
        });
      }

      function cleanupInteractiveMouseListeners() {
        getDocument().removeEventListener('mousemove', debouncedOnMouseMove);
        mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
          return listener !== debouncedOnMouseMove;
        });
      }

      function onDocumentPress(event) {
        // Moved finger to scroll instead of an intentional tap outside
        if (currentInput.isTouch) {
          if (didTouchMove || event.type === 'mousedown') {
            return;
          }
        }

        var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper

        if (instance.props.interactive && actualContains(popper, actualTarget)) {
          return;
        } // Clicked on the event listeners target


        if (normalizeToArray(instance.props.triggerTarget || reference).some(function (el) {
          return actualContains(el, actualTarget);
        })) {
          if (currentInput.isTouch) {
            return;
          }

          if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
            return;
          }
        } else {
          invokeHook('onClickOutside', [instance, event]);
        }

        if (instance.props.hideOnClick === true) {
          instance.clearDelayTimeouts();
          instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
          // currentTarget. This lets a tippy with `focus` trigger know that it
          // should not show

          didHideDueToDocumentMouseDown = true;
          setTimeout(function () {
            didHideDueToDocumentMouseDown = false;
          }); // The listener gets added in `scheduleShow()`, but this may be hiding it
          // before it shows, and hide()'s early bail-out behavior can prevent it
          // from being cleaned up

          if (!instance.state.isMounted) {
            removeDocumentPress();
          }
        }
      }

      function onTouchMove() {
        didTouchMove = true;
      }

      function onTouchStart() {
        didTouchMove = false;
      }

      function addDocumentPress() {
        var doc = getDocument();
        doc.addEventListener('mousedown', onDocumentPress, true);
        doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
        doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
        doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
      }

      function removeDocumentPress() {
        var doc = getDocument();
        doc.removeEventListener('mousedown', onDocumentPress, true);
        doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
        doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
        doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
      }

      function onTransitionedOut(duration, callback) {
        onTransitionEnd(duration, function () {
          if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
            callback();
          }
        });
      }

      function onTransitionedIn(duration, callback) {
        onTransitionEnd(duration, callback);
      }

      function onTransitionEnd(duration, callback) {
        var box = getDefaultTemplateChildren().box;

        function listener(event) {
          if (event.target === box) {
            updateTransitionEndListener(box, 'remove', listener);
            callback();
          }
        } // Make callback synchronous if duration is 0
        // `transitionend` won't fire otherwise


        if (duration === 0) {
          return callback();
        }

        updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
        updateTransitionEndListener(box, 'add', listener);
        currentTransitionEndListener = listener;
      }

      function on(eventType, handler, options) {
        if (options === void 0) {
          options = false;
        }

        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          node.addEventListener(eventType, handler, options);
          listeners.push({
            node: node,
            eventType: eventType,
            handler: handler,
            options: options
          });
        });
      }

      function addListeners() {
        if (getIsCustomTouchBehavior()) {
          on('touchstart', onTrigger, {
            passive: true
          });
          on('touchend', onMouseLeave, {
            passive: true
          });
        }

        splitBySpaces(instance.props.trigger).forEach(function (eventType) {
          if (eventType === 'manual') {
            return;
          }

          on(eventType, onTrigger);

          switch (eventType) {
            case 'mouseenter':
              on('mouseleave', onMouseLeave);
              break;

            case 'focus':
              on(isIE11 ? 'focusout' : 'blur', onBlurOrFocusOut);
              break;

            case 'focusin':
              on('focusout', onBlurOrFocusOut);
              break;
          }
        });
      }

      function removeListeners() {
        listeners.forEach(function (_ref) {
          var node = _ref.node,
              eventType = _ref.eventType,
              handler = _ref.handler,
              options = _ref.options;
          node.removeEventListener(eventType, handler, options);
        });
        listeners = [];
      }

      function onTrigger(event) {
        var _lastTriggerEvent;

        var shouldScheduleClickHide = false;

        if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
          return;
        }

        var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
        lastTriggerEvent = event;
        currentTarget = event.currentTarget;
        handleAriaExpandedAttribute();

        if (!instance.state.isVisible && isMouseEvent(event)) {
          // If scrolling, `mouseenter` events can be fired if the cursor lands
          // over a new target, but `mousemove` events don't get fired. This
          // causes interactive tooltips to get stuck open until the cursor is
          // moved
          mouseMoveListeners.forEach(function (listener) {
            return listener(event);
          });
        } // Toggle show/hide when clicking click-triggered tooltips


        if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
          shouldScheduleClickHide = true;
        } else {
          scheduleShow(event);
        }

        if (event.type === 'click') {
          isVisibleFromClick = !shouldScheduleClickHide;
        }

        if (shouldScheduleClickHide && !wasFocused) {
          scheduleHide(event);
        }
      }

      function onMouseMove(event) {
        var target = event.target;
        var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);

        if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
          return;
        }

        var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
          var _instance$popperInsta;

          var instance = popper._tippy;
          var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

          if (state) {
            return {
              popperRect: popper.getBoundingClientRect(),
              popperState: state,
              props: props
            };
          }

          return null;
        }).filter(Boolean);

        if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
          cleanupInteractiveMouseListeners();
          scheduleHide(event);
        }
      }

      function onMouseLeave(event) {
        var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;

        if (shouldBail) {
          return;
        }

        if (instance.props.interactive) {
          instance.hideWithInteractivity(event);
          return;
        }

        scheduleHide(event);
      }

      function onBlurOrFocusOut(event) {
        if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
          return;
        } // If focus was moved to within the popper


        if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
          return;
        }

        scheduleHide(event);
      }

      function isEventListenerStopped(event) {
        return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
      }

      function createPopperInstance() {
        destroyPopperInstance();
        var _instance$props2 = instance.props,
            popperOptions = _instance$props2.popperOptions,
            placement = _instance$props2.placement,
            offset = _instance$props2.offset,
            getReferenceClientRect = _instance$props2.getReferenceClientRect,
            moveTransition = _instance$props2.moveTransition;
        var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
        var computedReference = getReferenceClientRect ? {
          getBoundingClientRect: getReferenceClientRect,
          contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
        } : reference;
        var tippyModifier = {
          name: '$$tippy',
          enabled: true,
          phase: 'beforeWrite',
          requires: ['computeStyles'],
          fn: function fn(_ref2) {
            var state = _ref2.state;

            if (getIsDefaultRenderFn()) {
              var _getDefaultTemplateCh = getDefaultTemplateChildren(),
                  box = _getDefaultTemplateCh.box;

              ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
                if (attr === 'placement') {
                  box.setAttribute('data-placement', state.placement);
                } else {
                  if (state.attributes.popper["data-popper-" + attr]) {
                    box.setAttribute("data-" + attr, '');
                  } else {
                    box.removeAttribute("data-" + attr);
                  }
                }
              });
              state.attributes.popper = {};
            }
          }
        };
        var modifiers = [{
          name: 'offset',
          options: {
            offset: offset
          }
        }, {
          name: 'preventOverflow',
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        }, {
          name: 'flip',
          options: {
            padding: 5
          }
        }, {
          name: 'computeStyles',
          options: {
            adaptive: !moveTransition
          }
        }, tippyModifier];

        if (getIsDefaultRenderFn() && arrow) {
          modifiers.push({
            name: 'arrow',
            options: {
              element: arrow,
              padding: 3
            }
          });
        }

        modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
        instance.popperInstance = createPopper(computedReference, popper, Object.assign({}, popperOptions, {
          placement: placement,
          onFirstUpdate: onFirstUpdate,
          modifiers: modifiers
        }));
      }

      function destroyPopperInstance() {
        if (instance.popperInstance) {
          instance.popperInstance.destroy();
          instance.popperInstance = null;
        }
      }

      function mount() {
        var appendTo = instance.props.appendTo;
        var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
        // it's directly after the reference element so the elements inside the
        // tippy can be tabbed to
        // If there are clipping issues, the user can specify a different appendTo
        // and ensure focus management is handled correctly manually

        var node = getCurrentTarget();

        if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === 'parent') {
          parentNode = node.parentNode;
        } else {
          parentNode = invokeWithArgsOrReturn(appendTo, [node]);
        } // The popper element needs to exist on the DOM before its position can be
        // updated as Popper needs to read its dimensions


        if (!parentNode.contains(popper)) {
          parentNode.appendChild(popper);
        }

        instance.state.isMounted = true;
        createPopperInstance();
        /* istanbul ignore else */

        {
          // Accessibility check
          warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ['Interactive tippy element may not be accessible via keyboard', 'navigation because it is not directly after the reference element', 'in the DOM source order.', '\n\n', 'Using a wrapper <div> or <span> tag around the reference element', 'solves this by creating a new parentNode context.', '\n\n', 'Specifying `appendTo: document.body` silences this warning, but it', 'assumes you are using a focus management solution to handle', 'keyboard navigation.', '\n\n', 'See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity'].join(' '));
        }
      }

      function getNestedPopperTree() {
        return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
      }

      function scheduleShow(event) {
        instance.clearDelayTimeouts();

        if (event) {
          invokeHook('onTrigger', [instance, event]);
        }

        addDocumentPress();
        var delay = getDelay(true);

        var _getNormalizedTouchSe = getNormalizedTouchSettings(),
            touchValue = _getNormalizedTouchSe[0],
            touchDelay = _getNormalizedTouchSe[1];

        if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
          delay = touchDelay;
        }

        if (delay) {
          showTimeout = setTimeout(function () {
            instance.show();
          }, delay);
        } else {
          instance.show();
        }
      }

      function scheduleHide(event) {
        instance.clearDelayTimeouts();
        invokeHook('onUntrigger', [instance, event]);

        if (!instance.state.isVisible) {
          removeDocumentPress();
          return;
        } // For interactive tippies, scheduleHide is added to a document.body handler
        // from onMouseLeave so must intercept scheduled hides from mousemove/leave
        // events when trigger contains mouseenter and click, and the tip is
        // currently shown as a result of a click.


        if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
          return;
        }

        var delay = getDelay(false);

        if (delay) {
          hideTimeout = setTimeout(function () {
            if (instance.state.isVisible) {
              instance.hide();
            }
          }, delay);
        } else {
          // Fixes a `transitionend` problem when it fires 1 frame too
          // late sometimes, we don't want hide() to be called.
          scheduleHideAnimationFrame = requestAnimationFrame(function () {
            instance.hide();
          });
        }
      } // ===========================================================================
      //  Public methods
      // ===========================================================================


      function enable() {
        instance.state.isEnabled = true;
      }

      function disable() {
        // Disabling the instance should also hide it
        // https://github.com/atomiks/tippy.js-react/issues/106
        instance.hide();
        instance.state.isEnabled = false;
      }

      function clearDelayTimeouts() {
        clearTimeout(showTimeout);
        clearTimeout(hideTimeout);
        cancelAnimationFrame(scheduleHideAnimationFrame);
      }

      function setProps(partialProps) {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));
        }

        if (instance.state.isDestroyed) {
          return;
        }

        invokeHook('onBeforeUpdate', [instance, partialProps]);
        removeListeners();
        var prevProps = instance.props;
        var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
          ignoreAttributes: true
        }));
        instance.props = nextProps;
        addListeners();

        if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
          cleanupInteractiveMouseListeners();
          debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
        } // Ensure stale aria-expanded attributes are removed


        if (prevProps.triggerTarget && !nextProps.triggerTarget) {
          normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
            node.removeAttribute('aria-expanded');
          });
        } else if (nextProps.triggerTarget) {
          reference.removeAttribute('aria-expanded');
        }

        handleAriaExpandedAttribute();
        handleStyles();

        if (onUpdate) {
          onUpdate(prevProps, nextProps);
        }

        if (instance.popperInstance) {
          createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
          // and the nested ones get re-rendered first.
          // https://github.com/atomiks/tippyjs-react/issues/177
          // TODO: find a cleaner / more efficient solution(!)

          getNestedPopperTree().forEach(function (nestedPopper) {
            // React (and other UI libs likely) requires a rAF wrapper as it flushes
            // its work in one
            requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
          });
        }

        invokeHook('onAfterUpdate', [instance, partialProps]);
      }

      function setContent(content) {
        instance.setProps({
          content: content
        });
      }

      function show() {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));
        } // Early bail-out


        var isAlreadyVisible = instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

        if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
          return;
        } // Normalize `disabled` behavior across browsers.
        // Firefox allows events on disabled elements, but Chrome doesn't.
        // Using a wrapper element (i.e. <span>) is recommended.


        if (getCurrentTarget().hasAttribute('disabled')) {
          return;
        }

        invokeHook('onShow', [instance], false);

        if (instance.props.onShow(instance) === false) {
          return;
        }

        instance.state.isVisible = true;

        if (getIsDefaultRenderFn()) {
          popper.style.visibility = 'visible';
        }

        handleStyles();
        addDocumentPress();

        if (!instance.state.isMounted) {
          popper.style.transition = 'none';
        } // If flipping to the opposite side after hiding at least once, the
        // animation will use the wrong placement without resetting the duration


        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh2.box,
              content = _getDefaultTemplateCh2.content;

          setTransitionDuration([box, content], 0);
        }

        onFirstUpdate = function onFirstUpdate() {
          var _instance$popperInsta2;

          if (!instance.state.isVisible || ignoreOnFirstUpdate) {
            return;
          }

          ignoreOnFirstUpdate = true; // reflow

          void popper.offsetHeight;
          popper.style.transition = instance.props.moveTransition;

          if (getIsDefaultRenderFn() && instance.props.animation) {
            var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
                _box = _getDefaultTemplateCh3.box,
                _content = _getDefaultTemplateCh3.content;

            setTransitionDuration([_box, _content], duration);
            setVisibilityState([_box, _content], 'visible');
          }

          handleAriaContentAttribute();
          handleAriaExpandedAttribute();
          pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the
          // popper has been positioned for the first time

          (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
          invokeHook('onMount', [instance]);

          if (instance.props.animation && getIsDefaultRenderFn()) {
            onTransitionedIn(duration, function () {
              instance.state.isShown = true;
              invokeHook('onShown', [instance]);
            });
          }
        };

        mount();
      }

      function hide() {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));
        } // Early bail-out


        var isAlreadyHidden = !instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

        if (isAlreadyHidden || isDestroyed || isDisabled) {
          return;
        }

        invokeHook('onHide', [instance], false);

        if (instance.props.onHide(instance) === false) {
          return;
        }

        instance.state.isVisible = false;
        instance.state.isShown = false;
        ignoreOnFirstUpdate = false;
        isVisibleFromClick = false;

        if (getIsDefaultRenderFn()) {
          popper.style.visibility = 'hidden';
        }

        cleanupInteractiveMouseListeners();
        removeDocumentPress();
        handleStyles(true);

        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh4.box,
              content = _getDefaultTemplateCh4.content;

          if (instance.props.animation) {
            setTransitionDuration([box, content], duration);
            setVisibilityState([box, content], 'hidden');
          }
        }

        handleAriaContentAttribute();
        handleAriaExpandedAttribute();

        if (instance.props.animation) {
          if (getIsDefaultRenderFn()) {
            onTransitionedOut(duration, instance.unmount);
          }
        } else {
          instance.unmount();
        }
      }

      function hideWithInteractivity(event) {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hideWithInteractivity'));
        }

        getDocument().addEventListener('mousemove', debouncedOnMouseMove);
        pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
        debouncedOnMouseMove(event);
      }

      function unmount() {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('unmount'));
        }

        if (instance.state.isVisible) {
          instance.hide();
        }

        if (!instance.state.isMounted) {
          return;
        }

        destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
        // tree by default. This seems mainly for interactive tippies, but we should
        // find a workaround if possible

        getNestedPopperTree().forEach(function (nestedPopper) {
          nestedPopper._tippy.unmount();
        });

        if (popper.parentNode) {
          popper.parentNode.removeChild(popper);
        }

        mountedInstances = mountedInstances.filter(function (i) {
          return i !== instance;
        });
        instance.state.isMounted = false;
        invokeHook('onHidden', [instance]);
      }

      function destroy() {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));
        }

        if (instance.state.isDestroyed) {
          return;
        }

        instance.clearDelayTimeouts();
        instance.unmount();
        removeListeners();
        delete reference._tippy;
        instance.state.isDestroyed = true;
        invokeHook('onDestroy', [instance]);
      }
    }

    function tippy(targets, optionalProps) {
      if (optionalProps === void 0) {
        optionalProps = {};
      }

      var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
      /* istanbul ignore else */

      {
        validateTargets(targets);
        validateProps(optionalProps, plugins);
      }

      bindGlobalEventListeners();
      var passedProps = Object.assign({}, optionalProps, {
        plugins: plugins
      });
      var elements = getArrayOfElements(targets);
      /* istanbul ignore else */

      {
        var isSingleContentElement = isElement(passedProps.content);
        var isMoreThanOneReferenceElement = elements.length > 1;
        warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ['tippy() was passed an Element as the `content` prop, but more than', 'one tippy instance was created by this invocation. This means the', 'content element will only be appended to the last tippy instance.', '\n\n', 'Instead, pass the .innerHTML of the element, or use a function that', 'returns a cloned version of the element instead.', '\n\n', '1) content: element.innerHTML\n', '2) content: () => element.cloneNode(true)'].join(' '));
      }

      var instances = elements.reduce(function (acc, reference) {
        var instance = reference && createTippy(reference, passedProps);

        if (instance) {
          acc.push(instance);
        }

        return acc;
      }, []);
      return isElement(targets) ? instances[0] : instances;
    }

    tippy.defaultProps = defaultProps;
    tippy.setDefaultProps = setDefaultProps;
    tippy.currentInput = currentInput;

    // every time the popper is destroyed (i.e. a new target), removing the styles
    // and causing transitions to break for singletons when the console is open, but
    // most notably for non-transform styles being used, `gpuAcceleration: false`.

    Object.assign({}, applyStyles$1, {
      effect: function effect(_ref) {
        var state = _ref.state;
        var initialStyles = {
          popper: {
            position: state.options.strategy,
            left: '0',
            top: '0',
            margin: '0'
          },
          arrow: {
            position: 'absolute'
          },
          reference: {}
        };
        Object.assign(state.elements.popper.style, initialStyles.popper);
        state.styles = initialStyles;

        if (state.elements.arrow) {
          Object.assign(state.elements.arrow.style, initialStyles.arrow);
        } // intentionally return no cleanup function
        // return () => { ... }

      }
    });

    tippy.setDefaultProps({
      animation: false
    });

    /**
     *
     * @param anchorNode
     * @param tooltipNode
     * @param tippyOptions
     * @returns
     */
    function tooltipRender(anchorNode, tooltipNode, tippyOptions = {}) {
        return tippy(anchorNode, Object.assign({ render() {
                const popperElem = document.createElement('div');
                const arrowElem = document.createElement('div');
                popperElem.className = 'tooltip-container';
                arrowElem.className = 'tooltip-arrow';
                arrowElem.setAttribute('data-popper-arrow', '');
                popperElem.appendChild(tooltipNode);
                popperElem.appendChild(arrowElem);
                return {
                    popper: popperElem,
                };
            }, zIndex: 9999999 }, tippyOptions));
    }

    const tooltipStore = writable({});

    /* src/components/tooltip/Tooltip.svelte generated by Svelte v3.53.1 */
    const file$h = "src/components/tooltip/Tooltip.svelte";

    // (38:2) {:else}
    function create_else_block$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*content*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content*/ 2) set_data_dev(t, /*content*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(38:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (36:22) 
    function create_if_block_1(ctx) {
    	let html_tag;
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag(false);
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(/*content*/ ctx[1], target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content*/ 2) html_tag.p(/*content*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(36:22) ",
    		ctx
    	});

    	return block;
    }

    // (34:2) {#if !textOnly}
    function create_if_block$1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*content*/ ctx[1];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (switch_value !== (switch_value = /*content*/ ctx[1])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(34:2) {#if !textOnly}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$1, create_if_block_1, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*textOnly*/ ctx[4]) return 0;
    		if (/*allowHTML*/ ctx[0]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			toggle_class(div, "tooltip-textonly", /*textOnly*/ ctx[4]);
    			add_location(div, file$h, 32, 0, 1148);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			/*div_binding*/ ctx[7](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			if (!current || dirty & /*textOnly*/ 16) {
    				toggle_class(div, "tooltip-textonly", /*textOnly*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			/*div_binding*/ ctx[7](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance_1($$self, $$props, $$invalidate) {
    	let textOnly;
    	let $tooltipStore;
    	validate_store(tooltipStore, 'tooltipStore');
    	component_subscribe($$self, tooltipStore, $$value => $$invalidate(9, $tooltipStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tooltip', slots, []);
    	let { allowHTML = false } = $$props;
    	let { anchorNode } = $$props;
    	let { content } = $$props;
    	let { props = {} } = $$props;
    	let { tippyOptions = {} } = $$props;
    	let tooltipNode;
    	let instance = null;

    	onMount(() => {
    		instance = tooltipRender(anchorNode, tooltipNode, tippyOptions);

    		// Add to store for programmatic access, if anchor has unique id
    		if (anchorNode.hasAttribute('id')) {
    			const id = anchorNode.getAttribute('id');
    			set_store_value(tooltipStore, $tooltipStore[id] = instance, $tooltipStore);
    		}
    	});

    	afterUpdate(() => {
    		instance.setProps(tippyOptions);
    	});

    	onDestroy(() => {
    		// Remove tooltip instance and store entry
    		instance.destroy();

    		if (anchorNode.hasAttribute('id')) {
    			const id = anchorNode.getAttribute('id');
    			delete $tooltipStore[id];
    		}
    	});

    	$$self.$$.on_mount.push(function () {
    		if (anchorNode === undefined && !('anchorNode' in $$props || $$self.$$.bound[$$self.$$.props['anchorNode']])) {
    			console.warn("<Tooltip> was created without expected prop 'anchorNode'");
    		}

    		if (content === undefined && !('content' in $$props || $$self.$$.bound[$$self.$$.props['content']])) {
    			console.warn("<Tooltip> was created without expected prop 'content'");
    		}
    	});

    	const writable_props = ['allowHTML', 'anchorNode', 'content', 'props', 'tippyOptions'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tooltip> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			tooltipNode = $$value;
    			$$invalidate(3, tooltipNode);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('allowHTML' in $$props) $$invalidate(0, allowHTML = $$props.allowHTML);
    		if ('anchorNode' in $$props) $$invalidate(5, anchorNode = $$props.anchorNode);
    		if ('content' in $$props) $$invalidate(1, content = $$props.content);
    		if ('props' in $$props) $$invalidate(2, props = $$props.props);
    		if ('tippyOptions' in $$props) $$invalidate(6, tippyOptions = $$props.tippyOptions);
    	};

    	$$self.$capture_state = () => ({
    		afterUpdate,
    		onDestroy,
    		onMount,
    		SvelteComponent: SvelteComponentDev,
    		tooltipRender,
    		tooltipStore,
    		allowHTML,
    		anchorNode,
    		content,
    		props,
    		tippyOptions,
    		tooltipNode,
    		instance,
    		textOnly,
    		$tooltipStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('allowHTML' in $$props) $$invalidate(0, allowHTML = $$props.allowHTML);
    		if ('anchorNode' in $$props) $$invalidate(5, anchorNode = $$props.anchorNode);
    		if ('content' in $$props) $$invalidate(1, content = $$props.content);
    		if ('props' in $$props) $$invalidate(2, props = $$props.props);
    		if ('tippyOptions' in $$props) $$invalidate(6, tippyOptions = $$props.tippyOptions);
    		if ('tooltipNode' in $$props) $$invalidate(3, tooltipNode = $$props.tooltipNode);
    		if ('instance' in $$props) instance = $$props.instance;
    		if ('textOnly' in $$props) $$invalidate(4, textOnly = $$props.textOnly);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*content*/ 2) {
    			$$invalidate(4, textOnly = typeof content === 'string' || content instanceof String);
    		}
    	};

    	return [
    		allowHTML,
    		content,
    		props,
    		tooltipNode,
    		textOnly,
    		anchorNode,
    		tippyOptions,
    		div_binding
    	];
    }

    class Tooltip$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance_1, create_fragment$h, safe_not_equal, {
    			allowHTML: 0,
    			anchorNode: 5,
    			content: 1,
    			props: 2,
    			tippyOptions: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tooltip",
    			options,
    			id: create_fragment$h.name
    		});
    	}

    	get allowHTML() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set allowHTML(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get anchorNode() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set anchorNode(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get props() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set props(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tippyOptions() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tippyOptions(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function tooltip (anchorNode, options) {
        const target = document.createElement('div');
        const instance = new Tooltip$1({
            props: Object.assign({ anchorNode }, options),
            target,
        });
        return {
            destroy() {
                instance.$destroy();
            },
            update(newProps) {
                instance.$set(newProps);
            },
        };
    }

    /* docs_src/exportedfunctions/Tooltip.svelte generated by Svelte v3.53.1 */
    const file$g = "docs_src/exportedfunctions/Tooltip.svelte";

    // (150:0) {:else}
    function create_else_block(ctx) {
    	let h2;
    	let t1;
    	let code;
    	let div4;
    	let div0;
    	let t3;
    	let div1;
    	let t5;
    	let div2;
    	let t7;
    	let div3;
    	let t9;
    	let prism0;
    	let t10;
    	let p0;
    	let t12;
    	let div10;
    	let div5;
    	let b0;
    	let t14;
    	let em;
    	let t16;
    	let t17;
    	let div6;
    	let b1;
    	let t19;
    	let t20;
    	let div7;
    	let b2;
    	let t22;
    	let t23;
    	let div8;
    	let b3;
    	let t25;
    	let t26;
    	let div9;
    	let b4;
    	let t28;
    	let t29;
    	let h30;
    	let t31;
    	let prism1;
    	let t32;
    	let h31;
    	let t34;
    	let p1;
    	let t36;
    	let prism2;
    	let t37;
    	let h32;
    	let t39;
    	let prism3;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism3 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Tooltip as a function";
    			t1 = space();
    			code = element("code");
    			div4 = element("div");
    			div0 = element("div");
    			div0.textContent = "@param anchorNode HTMLElement - required";
    			t3 = space();
    			div1 = element("div");
    			div1.textContent = "@param tooltipNode HTMLElement - required";
    			t5 = space();
    			div2 = element("div");
    			div2.textContent = "@param tippyOptions TTippyCustomOptions - optional";
    			t7 = space();
    			div3 = element("div");
    			div3.textContent = "@returns A tooltip instance";
    			t9 = space();
    			create_component(prism0.$$.fragment);
    			t10 = space();
    			p0 = element("p");
    			p0.textContent = "To make easier use of tooltips on ekstrabladet.dk it is globally avaible through the data-tooltip attributes";
    			t12 = space();
    			div10 = element("div");
    			div5 = element("div");
    			b0 = element("b");
    			b0.textContent = "data-tooltip";
    			t14 = space();
    			em = element("em");
    			em.textContent = "required";
    			t16 = text(" String or id selector(#selector) for element to show in tooltip");
    			t17 = space();
    			div6 = element("div");
    			b1 = element("b");
    			b1.textContent = "data-tooltip-callback";
    			t19 = text(" global function to call as callback");
    			t20 = space();
    			div7 = element("div");
    			b2 = element("b");
    			b2.textContent = "data-tooltip-interactive";
    			t22 = text(" boolean deciding if the user can interact with the tooltip");
    			t23 = space();
    			div8 = element("div");
    			b3 = element("b");
    			b3.textContent = "data-tooltip-placement";
    			t25 = text(" auto | top | right | bottom | left - where should the tooltip pop from, defaults to auto");
    			t26 = space();
    			div9 = element("div");
    			b4 = element("b");
    			b4.textContent = "data-tooltip-trigger";
    			t28 = text(" which user action should trigger the popup, defaults to mouseenter");
    			t29 = space();
    			h30 = element("h3");
    			h30.textContent = "Simple tooltip";
    			t31 = space();
    			create_component(prism1.$$.fragment);
    			t32 = space();
    			h31 = element("h3");
    			h31.textContent = "HTML tooltip";
    			t34 = space();
    			p1 = element("p");
    			p1.textContent = "Content should be HTML Entity encoded if possible";
    			t36 = space();
    			create_component(prism2.$$.fragment);
    			t37 = space();
    			h32 = element("h3");
    			h32.textContent = "Custom tooltip";
    			t39 = space();
    			create_component(prism3.$$.fragment);
    			attr_dev(h2, "class", "color--eb");
    			add_location(h2, file$g, 150, 2, 5250);
    			add_location(div0, file$g, 154, 6, 5361);
    			add_location(div1, file$g, 155, 6, 5419);
    			add_location(div2, file$g, 156, 6, 5478);
    			add_location(div3, file$g, 157, 6, 5546);
    			attr_dev(div4, "class", "padding-xl--l padding-m--tb");
    			add_location(div4, file$g, 153, 4, 5313);
    			add_location(code, file$g, 152, 2, 5302);
    			add_location(p0, file$g, 164, 2, 5744);
    			add_location(b0, file$g, 167, 9, 5878);
    			add_location(em, file$g, 167, 29, 5898);
    			add_location(div5, file$g, 167, 4, 5873);
    			add_location(b1, file$g, 168, 9, 5995);
    			add_location(div6, file$g, 168, 4, 5990);
    			add_location(b2, file$g, 169, 9, 6075);
    			add_location(div7, file$g, 169, 4, 6070);
    			add_location(b3, file$g, 171, 6, 6188);
    			add_location(div8, file$g, 170, 4, 6176);
    			add_location(b4, file$g, 173, 9, 6327);
    			add_location(div9, file$g, 173, 4, 6322);
    			add_location(div10, file$g, 166, 2, 5863);
    			add_location(h30, file$g, 175, 2, 6439);
    			add_location(h31, file$g, 180, 2, 6563);
    			add_location(p1, file$g, 181, 2, 6587);
    			add_location(h32, file$g, 186, 2, 6777);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, code, anchor);
    			append_dev(code, div4);
    			append_dev(div4, div0);
    			append_dev(div4, t3);
    			append_dev(div4, div1);
    			append_dev(div4, t5);
    			append_dev(div4, div2);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			insert_dev(target, t9, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, div10, anchor);
    			append_dev(div10, div5);
    			append_dev(div5, b0);
    			append_dev(div5, t14);
    			append_dev(div5, em);
    			append_dev(div5, t16);
    			append_dev(div10, t17);
    			append_dev(div10, div6);
    			append_dev(div6, b1);
    			append_dev(div6, t19);
    			append_dev(div10, t20);
    			append_dev(div10, div7);
    			append_dev(div7, b2);
    			append_dev(div7, t22);
    			append_dev(div10, t23);
    			append_dev(div10, div8);
    			append_dev(div8, b3);
    			append_dev(div8, t25);
    			append_dev(div10, t26);
    			append_dev(div10, div9);
    			append_dev(div9, b4);
    			append_dev(div9, t28);
    			insert_dev(target, t29, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t31, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t32, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t34, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t36, anchor);
    			mount_component(prism2, target, anchor);
    			insert_dev(target, t37, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t39, anchor);
    			mount_component(prism3, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    			const prism2_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				prism2_changes.$$scope = { dirty, ctx };
    			}

    			prism2.$set(prism2_changes);
    			const prism3_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				prism3_changes.$$scope = { dirty, ctx };
    			}

    			prism3.$set(prism3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			transition_in(prism3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			transition_out(prism3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(code);
    			if (detaching) detach_dev(t9);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(div10);
    			if (detaching) detach_dev(t29);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t31);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t32);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t34);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t36);
    			destroy_component(prism2, detaching);
    			if (detaching) detach_dev(t37);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t39);
    			destroy_component(prism3, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(150:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (17:0) {#if $sourceType === 'svelte'}
    function create_if_block(ctx) {
    	let h2;
    	let t1;
    	let p0;
    	let t2;
    	let a0;
    	let t4;
    	let prism0;
    	let t5;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t7;
    	let th1;
    	let t9;
    	let th2;
    	let t11;
    	let th3;
    	let t13;
    	let tbody;
    	let tr1;
    	let td0;
    	let t15;
    	let td1;
    	let t17;
    	let td2;
    	let t18;
    	let td3;
    	let t20;
    	let tr2;
    	let td4;
    	let t22;
    	let td5;
    	let t24;
    	let td6;
    	let t26;
    	let td7;
    	let t27;
    	let a1;
    	let t29;
    	let tr3;
    	let td8;
    	let t31;
    	let td9;
    	let t33;
    	let td10;
    	let t35;
    	let td11;
    	let t37;
    	let tr4;
    	let td12;
    	let t39;
    	let td13;
    	let t41;
    	let td14;
    	let t43;
    	let td15;
    	let t44;
    	let a2;
    	let br0;
    	let t46;
    	let img;
    	let img_src_value;
    	let t47;
    	let t48;
    	let h30;
    	let t50;
    	let p1;
    	let t52;
    	let prism1;
    	let t53;
    	let h31;
    	let t55;
    	let div0;
    	let p2;
    	let t57;
    	let prism2;
    	let t58;
    	let h32;
    	let t60;
    	let div2;
    	let div1;
    	let icon;
    	let t61;
    	let br1;
    	let t62;
    	let button;
    	let t63;
    	let prism3;
    	let t64;
    	let prism4;
    	let current;
    	let mounted;
    	let dispose;

    	prism0 = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	icon = new Icon$1({
    			props: {
    				className: "tooltip-toggle",
    				name: "question-circle",
    				width: "18"
    			},
    			$$inline: true
    		});

    	button = new Button$1({
    			props: {
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[2]);

    	prism3 = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism4 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Tooltip as an action (svelte)";
    			t1 = space();
    			p0 = element("p");
    			t2 = text("More about actions\n    ");
    			a0 = element("a");
    			a0.textContent = "svelte action";
    			t4 = space();
    			create_component(prism0.$$.fragment);
    			t5 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Option";
    			t7 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t9 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t11 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t13 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "content";
    			t15 = space();
    			td1 = element("td");
    			td1.textContent = "string / SvelteComponent";
    			t17 = space();
    			td2 = element("td");
    			t18 = space();
    			td3 = element("td");
    			td3.textContent = "Input text, HTML or SvelteComponent";
    			t20 = space();
    			tr2 = element("tr");
    			td4 = element("td");
    			td4.textContent = "allowHTML";
    			t22 = space();
    			td5 = element("td");
    			td5.textContent = "boolean";
    			t24 = space();
    			td6 = element("td");
    			td6.textContent = "false";
    			t26 = space();
    			td7 = element("td");
    			t27 = text("Optional: Parse content as HTML ");
    			a1 = element("a");
    			a1.textContent = "(see Svelte-docs)";
    			t29 = space();
    			tr3 = element("tr");
    			td8 = element("td");
    			td8.textContent = "props";
    			t31 = space();
    			td9 = element("td");
    			td9.textContent = "Object";
    			t33 = space();
    			td10 = element("td");
    			td10.textContent = "empty";
    			t35 = space();
    			td11 = element("td");
    			td11.textContent = "Optional: Object of props to pass if using SvelteComponent";
    			t37 = space();
    			tr4 = element("tr");
    			td12 = element("td");
    			td12.textContent = "tippyOptions";
    			t39 = space();
    			td13 = element("td");
    			td13.textContent = "Object";
    			t41 = space();
    			td14 = element("td");
    			td14.textContent = "empty";
    			t43 = space();
    			td15 = element("td");
    			t44 = text("Optional: Tippy options ");
    			a2 = element("a");
    			a2.textContent = "(see reference)";
    			br0 = element("br");
    			t46 = text("Props marked with\n          ");
    			img = element("img");
    			t47 = text(" not supported");
    			t48 = space();
    			h30 = element("h3");
    			h30.textContent = "Simple tooltip";
    			t50 = space();
    			p1 = element("p");
    			p1.textContent = "Hover me";
    			t52 = space();
    			create_component(prism1.$$.fragment);
    			t53 = space();
    			h31 = element("h3");
    			h31.textContent = "Advanced tooltip";
    			t55 = space();
    			div0 = element("div");
    			p2 = element("p");
    			p2.textContent = "Click me";
    			t57 = space();
    			create_component(prism2.$$.fragment);
    			t58 = space();
    			h32 = element("h3");
    			h32.textContent = "Programmatic access";
    			t60 = space();
    			div2 = element("div");
    			div1 = element("div");
    			create_component(icon.$$.fragment);
    			t61 = space();
    			br1 = element("br");
    			t62 = space();
    			create_component(button.$$.fragment);
    			t63 = space();
    			create_component(prism3.$$.fragment);
    			t64 = space();
    			create_component(prism4.$$.fragment);
    			attr_dev(h2, "class", "color--eb");
    			add_location(h2, file$g, 17, 2, 626);
    			attr_dev(a0, "href", "https://svelte.dev/docs#template-syntax-element-directives-use-action");
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "rel", "noreferrer");
    			add_location(a0, file$g, 21, 4, 717);
    			add_location(p0, file$g, 19, 2, 686);
    			add_location(th0, file$g, 33, 8, 1059);
    			add_location(th1, file$g, 34, 8, 1083);
    			add_location(th2, file$g, 35, 8, 1105);
    			add_location(th3, file$g, 36, 8, 1136);
    			add_location(tr0, file$g, 32, 6, 1046);
    			add_location(thead, file$g, 31, 4, 1032);
    			add_location(td0, file$g, 41, 8, 1213);
    			add_location(td1, file$g, 42, 8, 1238);
    			add_location(td2, file$g, 43, 8, 1280);
    			add_location(td3, file$g, 44, 8, 1295);
    			add_location(tr1, file$g, 40, 6, 1200);
    			add_location(td4, file$g, 47, 8, 1371);
    			add_location(td5, file$g, 48, 8, 1398);
    			add_location(td6, file$g, 49, 8, 1423);
    			attr_dev(a1, "href", "https://svelte.dev/tutorial/html-tags");
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "rel", "noreferrer");
    			add_location(a1, file$g, 51, 43, 1493);
    			add_location(td7, file$g, 50, 8, 1446);
    			add_location(tr2, file$g, 46, 6, 1358);
    			add_location(td8, file$g, 59, 8, 1688);
    			add_location(td9, file$g, 60, 8, 1711);
    			add_location(td10, file$g, 61, 8, 1735);
    			add_location(td11, file$g, 62, 8, 1758);
    			add_location(tr3, file$g, 58, 6, 1675);
    			add_location(td12, file$g, 65, 8, 1857);
    			add_location(td13, file$g, 66, 8, 1887);
    			add_location(td14, file$g, 67, 8, 1911);
    			attr_dev(a2, "href", "https://atomiks.github.io/tippyjs/v6/all-props/");
    			attr_dev(a2, "target", "_blank");
    			attr_dev(a2, "rel", "noreferrer");
    			add_location(a2, file$g, 69, 35, 1973);
    			add_location(br0, file$g, 73, 11, 2130);
    			if (!src_url_equal(img.src, img_src_value = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTEiIGZpbGw9IiNEQUU2RkYiLz4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTEiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcikiLz4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTEiIHN0cm9rZT0iIzc3NjFEMSIgc3Ryb2tlLXdpZHRoPSIyIi8+CjxwYXRoIGQ9Ik03LjgwMTkxIDcuMkgxMy42ODE5QzE0LjY2MTkgNy4yIDE1LjM3MTIgNy40MjQgMTUuODA5OSA3Ljg3MkMxNi4yNTc5IDguMzEwNjcgMTYuNDgxOSA5LjAyIDE2LjQ4MTkgMTBWMTEuMjZDMTYuNDgxOSAxMi4wMzQ3IDE2LjM1MTIgMTIuNjM2NyAxNi4wODk5IDEzLjA2NkMxNS44Mzc5IDEzLjQ5NTMgMTUuNDMxOSAxMy43OCAxNC44NzE5IDEzLjkyTDE2LjYyMTkgMTdIMTMuODkxOUwxMi4yODE5IDE0LjA2SDEwLjMyMTlWMTdINy44MDE5MVY3LjJaTTEzLjk2MTkgMTBDMTMuOTYxOSA5LjQ0IDEzLjY4MTkgOS4xNiAxMy4xMjE5IDkuMTZIMTAuMzIxOVYxMi4xSDEzLjEyMTlDMTMuNjgxOSAxMi4xIDEzLjk2MTkgMTEuODIgMTMuOTYxOSAxMS4yNlYxMFoiIGZpbGw9IiM3NzYxRDEiLz4KPGRlZnM+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhciIgeDE9IjEyIiB5MT0iMCIgeDI9IjEyIiB5Mj0iMjQiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0VGREVGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IndoaXRlIiBzdG9wLW9wYWNpdHk9IjAiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "(R)");
    			add_location(img, file$g, 74, 10, 2164);
    			add_location(td15, file$g, 68, 8, 1934);
    			add_location(tr4, file$g, 64, 6, 1844);
    			add_location(tbody, file$g, 39, 4, 1186);
    			attr_dev(table, "class", "table");
    			add_location(table, file$g, 30, 2, 1006);
    			add_location(h30, file$g, 83, 2, 3504);
    			set_style(p1, "display", "inline-block");
    			attr_dev(p1, "class", "margin-none");
    			add_location(p1, file$g, 85, 2, 3531);
    			add_location(h31, file$g, 93, 2, 3795);
    			set_style(p2, "display", "inline-block");
    			set_style(p2, "cursor", "pointer");
    			attr_dev(p2, "class", "margin-none");
    			add_location(p2, file$g, 95, 4, 3833);
    			add_location(div0, file$g, 94, 2, 3823);
    			add_location(h32, file$g, 118, 2, 4364);
    			attr_dev(div1, "id", "test-anchor");
    			set_style(div1, "display", "inline-block");
    			add_location(div1, file$g, 121, 4, 4441);
    			add_location(br1, file$g, 130, 4, 4678);
    			attr_dev(div2, "class", "flex flex-justify--between");
    			add_location(div2, file$g, 120, 2, 4396);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			append_dev(p0, t2);
    			append_dev(p0, a0);
    			insert_dev(target, t4, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t7);
    			append_dev(tr0, th1);
    			append_dev(tr0, t9);
    			append_dev(tr0, th2);
    			append_dev(tr0, t11);
    			append_dev(tr0, th3);
    			append_dev(table, t13);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t15);
    			append_dev(tr1, td1);
    			append_dev(tr1, t17);
    			append_dev(tr1, td2);
    			append_dev(tr1, t18);
    			append_dev(tr1, td3);
    			append_dev(tbody, t20);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td4);
    			append_dev(tr2, t22);
    			append_dev(tr2, td5);
    			append_dev(tr2, t24);
    			append_dev(tr2, td6);
    			append_dev(tr2, t26);
    			append_dev(tr2, td7);
    			append_dev(td7, t27);
    			append_dev(td7, a1);
    			append_dev(tbody, t29);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td8);
    			append_dev(tr3, t31);
    			append_dev(tr3, td9);
    			append_dev(tr3, t33);
    			append_dev(tr3, td10);
    			append_dev(tr3, t35);
    			append_dev(tr3, td11);
    			append_dev(tbody, t37);
    			append_dev(tbody, tr4);
    			append_dev(tr4, td12);
    			append_dev(tr4, t39);
    			append_dev(tr4, td13);
    			append_dev(tr4, t41);
    			append_dev(tr4, td14);
    			append_dev(tr4, t43);
    			append_dev(tr4, td15);
    			append_dev(td15, t44);
    			append_dev(td15, a2);
    			append_dev(td15, br0);
    			append_dev(td15, t46);
    			append_dev(td15, img);
    			append_dev(td15, t47);
    			insert_dev(target, t48, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t50, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t52, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t53, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t55, anchor);
    			insert_dev(target, div0, anchor);
    			append_dev(div0, p2);
    			insert_dev(target, t57, anchor);
    			mount_component(prism2, target, anchor);
    			insert_dev(target, t58, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t60, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			mount_component(icon, div1, null);
    			append_dev(div2, t61);
    			append_dev(div2, br1);
    			append_dev(div2, t62);
    			mount_component(button, div2, null);
    			insert_dev(target, t63, anchor);
    			mount_component(prism3, target, anchor);
    			insert_dev(target, t64, anchor);
    			mount_component(prism4, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(tooltip.call(null, p1, { content: 'Text, HTML or SvelteComponent' })),
    					action_destroyer(tooltip.call(null, p2, {
    						content: Spinner,
    						props: { isLoading: true },
    						tippyOptions: {
    							interactive: true,
    							placement: 'bottom',
    							trigger: 'click'
    						}
    					})),
    					action_destroyer(tooltip.call(null, div1, { content: 'String or SvelteTemplate' }))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    			const prism2_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				prism2_changes.$$scope = { dirty, ctx };
    			}

    			prism2.$set(prism2_changes);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    			const prism3_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				prism3_changes.$$scope = { dirty, ctx };
    			}

    			prism3.$set(prism3_changes);
    			const prism4_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				prism4_changes.$$scope = { dirty, ctx };
    			}

    			prism4.$set(prism4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			transition_in(icon.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			transition_in(prism3.$$.fragment, local);
    			transition_in(prism4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			transition_out(icon.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			transition_out(prism3.$$.fragment, local);
    			transition_out(prism4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t4);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(table);
    			if (detaching) detach_dev(t48);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t50);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t52);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t53);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t55);
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t57);
    			destroy_component(prism2, detaching);
    			if (detaching) detach_dev(t58);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t60);
    			if (detaching) detach_dev(div2);
    			destroy_component(icon);
    			destroy_component(button);
    			if (detaching) detach_dev(t63);
    			destroy_component(prism3, detaching);
    			if (detaching) detach_dev(t64);
    			destroy_component(prism4, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(17:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (161:2) <Prism language="js">
    function create_default_slot_9(ctx) {
    	let t_value = `import { tooltipRender } from '@ekstra-bladet/designsystem/svelte/functions/tooltipAction';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(161:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (177:2) <Prism language="html">
    function create_default_slot_8(ctx) {
    	let t_value = `<div data-tooltip="Simple text tooltip">Hover</div>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(177:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (183:2) <Prism language="html">
    function create_default_slot_7(ctx) {
    	let t_value = `<div data-tooltip="Simple text<br>tooltip" data-tooltip-allowhtml="true">Hover</div>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(183:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (188:2) <Prism language="html">
    function create_default_slot_6(ctx) {
    	let t_value = `<div
  data-tooltip="#testid"
  data-tooltip-interactive="true"
  data-tooltip-placement="bottom"
  data-tooltip-trigger="click">
    Click
</div>

<div id="testid" class="hidden">
  <p>Custom input</p>
  <button>Test</button>
</div>
    ` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(188:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (27:2) <Prism language="js">
    function create_default_slot_5(ctx) {
    	let t_value = `import { tooltipAction } from '@ekstra-bladet/designsystem/svelte/functions/tooltipAction';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(27:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (90:2) <Prism language="html">
    function create_default_slot_4(ctx) {
    	let t_value = `<p use:tooltipAction={{ content: 'Text, HTML or SvelteComponent' }}>Hover me</p>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(90:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (109:2) <Prism language="html">
    function create_default_slot_3(ctx) {
    	let t_value = `<p use:tooltip={{
      content: Spinner,
      props: { isLoading: true },
      tippyOptions: { interactive: true, placement: 'bottom', trigger: 'click' },
    }}>
    Click me
</p>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(109:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (132:4) <Button       on:click={() => {         $tooltipStore['test-anchor'].show();       }}>
    function create_default_slot_2$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Show tooltip");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(132:4) <Button       on:click={() => {         $tooltipStore['test-anchor'].show();       }}>",
    		ctx
    	});

    	return block;
    }

    // (139:2) <Prism language="js">
    function create_default_slot_1$1(ctx) {
    	let t_value = `import { tooltipAction, tooltipStore } from '@ekstra-bladet/designsystem/svelte/functions/tooltipAction';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(139:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (143:2) <Prism language="html">
    function create_default_slot$2(ctx) {
    	let t_value = `<div id="uniqueid" use:tooltipAction={{ content: 'Test String' }}>
    <Icon className="tooltip-toggle" name="question-circle" width="18" />
</div>

<Button on:click={(e) => {$tooltipStore['uniqueid'].show();}}>Show tooltip</Button>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(143:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let h1;
    	let t1;
    	let p;
    	let t2;
    	let a;
    	let t4;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Tooltip";
    			t1 = space();
    			p = element("p");
    			t2 = text("Tooltips is a wrapper used to create tooltips with third party library\n  ");
    			a = element("a");
    			a.textContent = "tippy.js";
    			t4 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$g, 9, 0, 414);
    			attr_dev(a, "href", "https://atomiks.github.io/tippyjs/");
    			add_location(a, file$g, 13, 2, 529);
    			add_location(p, file$g, 11, 0, 450);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t2);
    			append_dev(p, a);
    			insert_dev(target, t4, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t4);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let $sourceType;
    	let $tooltipStore;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	validate_store(tooltipStore, 'tooltipStore');
    	component_subscribe($$self, tooltipStore, $$value => $$invalidate(1, $tooltipStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tooltip', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tooltip> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		$tooltipStore['test-anchor'].show();
    	};

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		Button: Button$1,
    		Icon: Icon$1,
    		Spinner,
    		sourceType,
    		tooltip,
    		tooltipStore,
    		$sourceType,
    		$tooltipStore
    	});

    	return [$sourceType, $tooltipStore, click_handler];
    }

    class Tooltip extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tooltip",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    const exportedfunctions = {
        href: '/exportedfunctions',
        routes: [
            {
                component: HorizontalScrollHandler,
                href: '/exportedfunctions/horizontalscrollhandler',
                title: 'HorizontalScrollHandler',
            },
            { component: SplitNfitTitle, href: '/exportedfunctions/splitnfittitle', title: 'SplitNfitTitle' },
            { component: SplitTitle, href: '/exportedfunctions/splittitle', title: 'SplitTitle' },
            { component: Throttle, href: '/exportedfunctions/throttle', title: 'Throttle' },
            { component: TimePassedSince, href: '/exportedfunctions/timepassedsince', title: 'TimePassedSince' },
            { component: Tooltip, href: '/exportedfunctions/tooltip', title: 'Tooltip' },
        ],
        title: 'Functions',
    };

    /* docs_src/guidelines/Svelte.svelte generated by Svelte v3.53.1 */
    const file$f = "docs_src/guidelines/Svelte.svelte";

    // (28:0) <Prism language="js">
    function create_default_slot$1(ctx) {
    	let t_value = `npx degit EkstraBladetUdvikling/sveltetemplate my-svelte-project` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(28:0) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let h1;
    	let t1;
    	let h30;
    	let t3;
    	let ol;
    	let li0;
    	let t5;
    	let li1;
    	let t7;
    	let li2;
    	let t9;
    	let li3;
    	let t11;
    	let li4;
    	let t13;
    	let li5;
    	let t15;
    	let li6;
    	let t17;
    	let li7;
    	let t19;
    	let li8;
    	let t21;
    	let h31;
    	let t23;
    	let p;
    	let t25;
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Svelte";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Rules";
    			t3 = space();
    			ol = element("ol");
    			li0 = element("li");
    			li0.textContent = "There must be a rigorous division of logic (script-part) and views (template, class selection, etc.)";
    			t5 = space();
    			li1 = element("li");
    			li1.textContent = "Component-specific styling should preferably be solved using the designsystem instead of styling within the\n    Svelte-files.";
    			t7 = space();
    			li2 = element("li");
    			li2.textContent = "Svelte functions should (if possible) be used instead of native functions (eg createEventListener).";
    			t9 = space();
    			li3 = element("li");
    			li3.textContent = "Script tag content must be kept to an absolute minimum.";
    			t11 = space();
    			li4 = element("li");
    			li4.textContent = "As a rule, the state must provide all data in the format required by the components. Ie. Filtering takes place in\n    state management and not in the respective components.";
    			t13 = space();
    			li5 = element("li");
    			li5.textContent = "Design system: on:click should exist on all elements of the design system";
    			t15 = space();
    			li6 = element("li");
    			li6.textContent = "The use of Svelte is agreed in the front-end group, so that it is only used where it makes sense.";
    			t17 = space();
    			li7 = element("li");
    			li7.textContent = "Svelte-store is used and each part of the state is divided into several readable / writeable, instead of one object.";
    			t19 = space();
    			li8 = element("li");
    			li8.textContent = "Writables may only be updated using actions (functions) and may not be exported directly.";
    			t21 = space();
    			h31 = element("h3");
    			h31.textContent = "Create Svelte App";
    			t23 = space();
    			p = element("p");
    			p.textContent = "The recommended way to start new apps with Svelte is by using our Svelte Template:";
    			t25 = space();
    			create_component(prism.$$.fragment);
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$f, 3, 0, 63);
    			add_location(h30, file$f, 4, 0, 97);
    			attr_dev(li0, "class", "svelte-9h10az");
    			add_location(li0, file$f, 6, 2, 119);
    			attr_dev(li1, "class", "svelte-9h10az");
    			add_location(li1, file$f, 7, 2, 231);
    			attr_dev(li2, "class", "svelte-9h10az");
    			add_location(li2, file$f, 11, 2, 376);
    			attr_dev(li3, "class", "svelte-9h10az");
    			add_location(li3, file$f, 12, 2, 487);
    			attr_dev(li4, "class", "svelte-9h10az");
    			add_location(li4, file$f, 13, 2, 554);
    			attr_dev(li5, "class", "svelte-9h10az");
    			add_location(li5, file$f, 17, 2, 746);
    			attr_dev(li6, "class", "svelte-9h10az");
    			add_location(li6, file$f, 18, 2, 831);
    			attr_dev(li7, "class", "svelte-9h10az");
    			add_location(li7, file$f, 19, 2, 940);
    			attr_dev(li8, "class", "svelte-9h10az");
    			add_location(li8, file$f, 22, 2, 1076);
    			add_location(ol, file$f, 5, 0, 112);
    			add_location(h31, file$f, 25, 0, 1182);
    			add_location(p, file$f, 26, 0, 1209);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, ol, anchor);
    			append_dev(ol, li0);
    			append_dev(ol, t5);
    			append_dev(ol, li1);
    			append_dev(ol, t7);
    			append_dev(ol, li2);
    			append_dev(ol, t9);
    			append_dev(ol, li3);
    			append_dev(ol, t11);
    			append_dev(ol, li4);
    			append_dev(ol, t13);
    			append_dev(ol, li5);
    			append_dev(ol, t15);
    			append_dev(ol, li6);
    			append_dev(ol, t17);
    			append_dev(ol, li7);
    			append_dev(ol, t19);
    			append_dev(ol, li8);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t23, anchor);
    			insert_dev(target, p, anchor);
    			insert_dev(target, t25, anchor);
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism_changes.$$scope = { dirty, ctx };
    			}

    			prism.$set(prism_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(ol);
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t23);
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t25);
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Svelte', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Svelte> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1 });
    	return [];
    }

    class Svelte extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Svelte",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    const guidelines = {
        href: '/guidelines',
        routes: [{ component: Svelte, href: '/guidelines/svelte', title: 'Svelte' }],
        title: 'Guidelines',
    };

    /* docs_src/components/Home.svelte generated by Svelte v3.53.1 */
    const file$e = "docs_src/components/Home.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[0] = list[i];
    	return child_ctx;
    }

    // (12:2) {#each components.routes as route}
    function create_each_block$5(ctx) {
    	let li;
    	let a;
    	let t_value = /*route*/ ctx[0].title + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "href", "#a11y");
    			add_location(a, file$e, 12, 8, 349);
    			add_location(li, file$e, 12, 4, 345);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, t);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a, {
    					disabled: false,
    					href: /*route*/ ctx[0].href
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(12:2) {#each components.routes as route}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let h1;
    	let t1;
    	let div;
    	let p;
    	let t3;
    	let ul;
    	let each_value = components.routes;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Components";
    			t1 = space();
    			div = element("div");
    			p = element("p");
    			p.textContent = "Components mainly consists of svelte components but can be used as straight HTML components if it's a must";
    			t3 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h1, file$e, 4, 0, 122);
    			add_location(p, file$e, 7, 2, 177);
    			attr_dev(div, "class", "grid-width--small");
    			add_location(div, file$e, 6, 0, 143);
    			add_location(ul, file$e, 10, 0, 299);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*components*/ 0) {
    				each_value = components.routes;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Home', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ link, components });
    	return [];
    }

    class Home$5 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* docs_src/cssvariables/Home.svelte generated by Svelte v3.53.1 */
    const file$d = "docs_src/cssvariables/Home.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[0] = list[i];
    	return child_ctx;
    }

    // (12:2) {#each cssvariables.routes as route}
    function create_each_block$4(ctx) {
    	let li;
    	let a;
    	let t_value = /*route*/ ctx[0].title + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "href", "#a11y");
    			add_location(a, file$d, 12, 8, 340);
    			add_location(li, file$d, 12, 4, 336);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, t);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a, {
    					disabled: false,
    					href: /*route*/ ctx[0].href
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(12:2) {#each cssvariables.routes as route}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let h1;
    	let t1;
    	let div;
    	let p0;
    	let t3;
    	let p1;
    	let t5;
    	let ul;
    	let each_value = cssvariables.routes;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "CSS Variables";
    			t1 = space();
    			div = element("div");
    			p0 = element("p");
    			p0.textContent = "Utility CSS variables to be used in styling";
    			t3 = space();
    			p1 = element("p");
    			p1.textContent = "These are not meant to be overridden";
    			t5 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h1, file$d, 4, 0, 126);
    			add_location(p0, file$d, 7, 2, 184);
    			add_location(p1, file$d, 8, 2, 237);
    			attr_dev(div, "class", "grid-width--small");
    			add_location(div, file$d, 6, 0, 150);
    			add_location(ul, file$d, 10, 0, 288);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, p0);
    			append_dev(div, t3);
    			append_dev(div, p1);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*cssvariables*/ 0) {
    				each_value = cssvariables.routes;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Home', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ link, cssvariables });
    	return [];
    }

    class Home$4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    /* docs_src/exportedfunctions/Home.svelte generated by Svelte v3.53.1 */
    const file$c = "docs_src/exportedfunctions/Home.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[0] = list[i];
    	return child_ctx;
    }

    // (11:2) {#each exportedfunctions.routes as route}
    function create_each_block$3(ctx) {
    	let li;
    	let a;
    	let t_value = /*route*/ ctx[0].title + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "href", "#a11y");
    			add_location(a, file$c, 11, 8, 368);
    			add_location(li, file$c, 11, 4, 364);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, t);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a, {
    					disabled: false,
    					href: /*route*/ ctx[0].href
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(11:2) {#each exportedfunctions.routes as route}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let h1;
    	let t1;
    	let div;
    	let p;
    	let t3;
    	let ul;
    	let each_value = exportedfunctions.routes;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Exported Functions";
    			t1 = space();
    			div = element("div");
    			p = element("p");
    			p.textContent = "Functions exported from the design system to be used in svelte/typescript/javascript applications";
    			t3 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h1, file$c, 4, 0, 136);
    			add_location(p, file$c, 7, 2, 199);
    			attr_dev(div, "class", "grid-width--small");
    			add_location(div, file$c, 6, 0, 165);
    			add_location(ul, file$c, 9, 0, 311);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*exportedfunctions*/ 0) {
    				each_value = exportedfunctions.routes;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Home', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ link, exportedfunctions });
    	return [];
    }

    class Home$3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    /* docs_src/guidelines/Home.svelte generated by Svelte v3.53.1 */
    const file$b = "docs_src/guidelines/Home.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[0] = list[i];
    	return child_ctx;
    }

    // (14:2) {#each guidelines.routes as route}
    function create_each_block$2(ctx) {
    	let li;
    	let a;
    	let t_value = /*route*/ ctx[0].title + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "href", "#a11y");
    			add_location(a, file$b, 14, 8, 373);
    			add_location(li, file$b, 14, 4, 369);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, t);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a, {
    					disabled: false,
    					href: /*route*/ ctx[0].href
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(14:2) {#each guidelines.routes as route}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let h1;
    	let t1;
    	let div;
    	let p;
    	let t3;
    	let ul;
    	let each_value = guidelines.routes;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Guidelines";
    			t1 = space();
    			div = element("div");
    			p = element("p");
    			p.textContent = "Guidelines on how to implements languages or frameworks when working with frontend code in the context of Ekstra\n    Bladet";
    			t3 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h1, file$b, 4, 0, 122);
    			add_location(p, file$b, 7, 2, 177);
    			attr_dev(div, "class", "grid-width--small");
    			add_location(div, file$b, 6, 0, 143);
    			add_location(ul, file$b, 12, 0, 323);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*guidelines*/ 0) {
    				each_value = guidelines.routes;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Home', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ link, guidelines });
    	return [];
    }

    class Home$2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* docs_src/assets/icons/css-vars.svg.rollup-plugin.svelte generated by Svelte v3.53.1 */

    const file$a = "docs_src/assets/icons/css-vars.svg.rollup-plugin.svelte";

    function create_fragment$a(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fab" },
    		{ "data-icon": "css3-alt" },
    		{
    			class: "svg-inline--fa fa-css3-alt fa-w-12"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 384 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M0 32l34.9 395.8L192 480l157.1-52.2L384 32H0zm313.1 80l-4.8 47.3L193 208.6l-.3.1h111.5l-12.8 146.6-98.2 28.7-98.8-29.2-6.4-73.9h48.9l3.2 38.3 52.6 13.3 54.7-15.4 3.7-61.6-166.3-.5v-.1l-.2.1-3.6-46.3L193.1 162l6.5-2.7H76.7L70.9 112h242.2z");
    			add_location(path, file$a, 0, 206, 206);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$a, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fab" },
    				{ "data-icon": "css3-alt" },
    				{
    					class: "svg-inline--fa fa-css3-alt fa-w-12"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 384 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Css_vars_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Css_vars_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Css_vars_svg_rollup_plugin",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    /* docs_src/assets/icons/guideline.svg.rollup-plugin.svelte generated by Svelte v3.53.1 */

    const file$9 = "docs_src/assets/icons/guideline.svg.rollup-plugin.svelte";

    function create_fragment$9(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "book" },
    		{ class: "svg-inline--fa fa-book fa-w-14" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M356 160H188c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12v8c0 6.6-5.4 12-12 12zm12 52v-8c0-6.6-5.4-12-12-12H188c-6.6 0-12 5.4-12 12v8c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12zm64.7 268h3.3c6.6 0 12 5.4 12 12v8c0 6.6-5.4 12-12 12H80c-44.2 0-80-35.8-80-80V80C0 35.8 35.8 0 80 0h344c13.3 0 24 10.7 24 24v368c0 10-6.2 18.6-14.9 22.2-3.6 16.1-4.4 45.6-.4 65.8zM128 384h288V32H128v352zm-96 16c13.4-10 30-16 48-16h16V32H80c-26.5 0-48 21.5-48 48v320zm372.3 80c-3.1-20.4-2.9-45.2 0-64H80c-64 0-64 64 0 64h324.3z");
    			add_location(path, file$9, 0, 198, 198);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$9, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "book" },
    				{ class: "svg-inline--fa fa-book fa-w-14" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Guideline_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Guideline_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Guideline_svg_rollup_plugin",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    /* docs_src/assets/icons/js-functions.svg.rollup-plugin.svelte generated by Svelte v3.53.1 */

    const file$8 = "docs_src/assets/icons/js-functions.svg.rollup-plugin.svelte";

    function create_fragment$8(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fab" },
    		{ "data-icon": "js-square" },
    		{
    			class: "svg-inline--fa fa-js-square fa-w-14"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM243.8 381.4c0 43.6-25.6 63.5-62.9 63.5-33.7 0-53.2-17.4-63.2-38.5l34.3-20.7c6.6 11.7 12.6 21.6 27.1 21.6 13.8 0 22.6-5.4 22.6-26.5V237.7h42.1v143.7zm99.6 63.5c-39.1 0-64.4-18.6-76.7-43l34.3-19.8c9 14.7 20.8 25.6 41.5 25.6 17.4 0 28.6-8.7 28.6-20.8 0-14.4-11.4-19.5-30.7-28l-10.5-4.5c-30.4-12.9-50.5-29.2-50.5-63.5 0-31.6 24.1-55.6 61.6-55.6 26.8 0 46 9.3 59.8 33.7L368 290c-7.2-12.9-15-18-27.1-18-12.3 0-20.1 7.8-20.1 18 0 12.6 7.8 17.7 25.9 25.6l10.5 4.5c35.8 15.3 55.9 31 55.9 66.2 0 37.8-29.8 58.6-69.7 58.6z");
    			add_location(path, file$8, 0, 208, 208);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$8, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fab" },
    				{ "data-icon": "js-square" },
    				{
    					class: "svg-inline--fa fa-js-square fa-w-14"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Js_functions_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Js_functions_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Js_functions_svg_rollup_plugin",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    /* docs_src/assets/icons/utility.svg.rollup-plugin.svelte generated by Svelte v3.53.1 */

    const file$7 = "docs_src/assets/icons/utility.svg.rollup-plugin.svelte";

    function create_fragment$7(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fab" },
    		{ "data-icon": "connectdevelop" },
    		{
    			class: "svg-inline--fa fa-connectdevelop fa-w-18"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M550.5 241l-50.089-86.786c1.071-2.142 1.875-4.553 1.875-7.232 0-8.036-6.696-14.733-14.732-15.001l-55.447-95.893c.536-1.607 1.071-3.214 1.071-4.821 0-8.571-6.964-15.268-15.268-15.268-4.821 0-8.839 2.143-11.786 5.625H299.518C296.839 18.143 292.821 16 288 16s-8.839 2.143-11.518 5.625H170.411C167.464 18.143 163.447 16 158.625 16c-8.303 0-15.268 6.696-15.268 15.268 0 1.607.536 3.482 1.072 4.821l-55.983 97.233c-5.356 2.41-9.107 7.5-9.107 13.661 0 .535.268 1.071.268 1.607l-53.304 92.143c-7.232 1.339-12.59 7.5-12.59 15 0 7.232 5.089 13.393 12.054 15l55.179 95.358c-.536 1.607-.804 2.946-.804 4.821 0 7.232 5.089 13.393 12.054 14.732l51.697 89.732c-.536 1.607-1.071 3.482-1.071 5.357 0 8.571 6.964 15.268 15.268 15.268 4.821 0 8.839-2.143 11.518-5.357h106.875C279.161 493.857 283.447 496 288 496s8.839-2.143 11.518-5.357h107.143c2.678 2.946 6.696 4.821 10.982 4.821 8.571 0 15.268-6.964 15.268-15.268 0-1.607-.267-2.946-.803-4.285l51.697-90.268c6.964-1.339 12.054-7.5 12.054-14.732 0-1.607-.268-3.214-.804-4.821l54.911-95.358c6.964-1.339 12.322-7.5 12.322-15-.002-7.232-5.092-13.393-11.788-14.732zM153.535 450.732l-43.66-75.803h43.66v75.803zm0-83.839h-43.66c-.268-1.071-.804-2.142-1.339-3.214l44.999-47.41v50.624zm0-62.411l-50.357 53.304c-1.339-.536-2.679-1.34-4.018-1.607L43.447 259.75c.535-1.339.535-2.679.535-4.018s0-2.41-.268-3.482l51.965-90c2.679-.268 5.357-1.072 7.768-2.679l50.089 51.965v92.946zm0-102.322l-45.803-47.41c1.339-2.143 2.143-4.821 2.143-7.767 0-.268-.268-.804-.268-1.072l43.928-15.804v72.053zm0-80.625l-43.66 15.804 43.66-75.536v59.732zm326.519 39.108l.804 1.339L445.5 329.125l-63.75-67.232 98.036-101.518.268.268zM291.75 355.107l11.518 11.786H280.5l11.25-11.786zm-.268-11.25l-83.303-85.446 79.553-84.375 83.036 87.589-79.286 82.232zm5.357 5.893l79.286-82.232 67.5 71.25-5.892 28.125H313.714l-16.875-17.143zM410.411 44.393c1.071.536 2.142 1.072 3.482 1.34l57.857 100.714v.536c0 2.946.803 5.624 2.143 7.767L376.393 256l-83.035-87.589L410.411 44.393zm-9.107-2.143L287.732 162.518l-57.054-60.268 166.339-60h4.287zm-123.483 0c2.678 2.678 6.16 4.285 10.179 4.285s7.5-1.607 10.179-4.285h75L224.786 95.821 173.893 42.25h103.928zm-116.249 5.625l1.071-2.142a33.834 33.834 0 0 0 2.679-.804l51.161 53.84-54.911 19.821V47.875zm0 79.286l60.803-21.964 59.732 63.214-79.553 84.107-40.982-42.053v-83.304zm0 92.678L198 257.607l-36.428 38.304v-76.072zm0 87.858l42.053-44.464 82.768 85.982-17.143 17.678H161.572v-59.196zm6.964 162.053c-1.607-1.607-3.482-2.678-5.893-3.482l-1.071-1.607v-89.732h99.91l-91.607 94.821h-1.339zm129.911 0c-2.679-2.41-6.428-4.285-10.447-4.285s-7.767 1.875-10.447 4.285h-96.429l91.607-94.821h38.304l91.607 94.821H298.447zm120-11.786l-4.286 7.5c-1.339.268-2.41.803-3.482 1.339l-89.196-91.875h114.376l-17.412 83.036zm12.856-22.232l12.858-60.803h21.964l-34.822 60.803zm34.822-68.839h-20.357l4.553-21.16 17.143 18.214c-.535.803-1.071 1.874-1.339 2.946zm66.161-107.411l-55.447 96.697c-1.339.535-2.679 1.071-4.018 1.874l-20.625-21.964 34.554-163.928 45.803 79.286c-.267 1.339-.803 2.678-.803 4.285 0 1.339.268 2.411.536 3.75z");
    			add_location(path, file$7, 0, 218, 218);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$7, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fab" },
    				{ "data-icon": "connectdevelop" },
    				{
    					class: "svg-inline--fa fa-connectdevelop fa-w-18"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Utility_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Utility_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Utility_svg_rollup_plugin",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* docs_src/main/Home.svelte generated by Svelte v3.53.1 */
    const file$6 = "docs_src/main/Home.svelte";

    function create_fragment$6(ctx) {
    	let div15;
    	let div14;
    	let div0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div1;
    	let h1;
    	let t2;
    	let div2;
    	let t4;
    	let div13;
    	let a0;
    	let div4;
    	let div3;
    	let h20;
    	let t6;
    	let componentsicon;
    	let t7;
    	let a1;
    	let div6;
    	let div5;
    	let h21;
    	let t9;
    	let utilityicon;
    	let t10;
    	let a2;
    	let div8;
    	let div7;
    	let h22;
    	let t12;
    	let guidelineicon;
    	let t13;
    	let a3;
    	let div10;
    	let div9;
    	let h23;
    	let t15;
    	let jsfunctionsicon;
    	let t16;
    	let a4;
    	let div12;
    	let div11;
    	let h24;
    	let t18;
    	let cssvarsicon;
    	let current;
    	let mounted;
    	let dispose;

    	componentsicon = new Components_svg_rollup_plugin({
    			props: { width: "60", height: "60" },
    			$$inline: true
    		});

    	utilityicon = new Utility_svg_rollup_plugin({
    			props: { width: "60", height: "60" },
    			$$inline: true
    		});

    	guidelineicon = new Guideline_svg_rollup_plugin({
    			props: { width: "45", height: "60" },
    			$$inline: true
    		});

    	jsfunctionsicon = new Js_functions_svg_rollup_plugin({
    			props: { width: "60", height: "60" },
    			$$inline: true
    		});

    	cssvarsicon = new Css_vars_svg_rollup_plugin({
    			props: { width: "45", height: "60" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div15 = element("div");
    			div14 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div1 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Design system";
    			t2 = space();
    			div2 = element("div");
    			div2.textContent = "yarn add @ekstra-bladet/designsystem";
    			t4 = space();
    			div13 = element("div");
    			a0 = element("a");
    			div4 = element("div");
    			div3 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Components";
    			t6 = space();
    			create_component(componentsicon.$$.fragment);
    			t7 = space();
    			a1 = element("a");
    			div6 = element("div");
    			div5 = element("div");
    			h21 = element("h2");
    			h21.textContent = "Utilities";
    			t9 = space();
    			create_component(utilityicon.$$.fragment);
    			t10 = space();
    			a2 = element("a");
    			div8 = element("div");
    			div7 = element("div");
    			h22 = element("h2");
    			h22.textContent = "Guidelines";
    			t12 = space();
    			create_component(guidelineicon.$$.fragment);
    			t13 = space();
    			a3 = element("a");
    			div10 = element("div");
    			div9 = element("div");
    			h23 = element("h2");
    			h23.textContent = "JS Functions";
    			t15 = space();
    			create_component(jsfunctionsicon.$$.fragment);
    			t16 = space();
    			a4 = element("a");
    			div12 = element("div");
    			div11 = element("div");
    			h24 = element("h2");
    			h24.textContent = "CSS Variables";
    			t18 = space();
    			create_component(cssvarsicon.$$.fragment);
    			attr_dev(img, "alt", "");
    			if (!src_url_equal(img.src, img_src_value = "ekstrabladet.svg")) attr_dev(img, "src", img_src_value);
    			set_style(img, "height", "70px");
    			add_location(img, file$6, 16, 6, 773);
    			attr_dev(div0, "class", "flex flex-justify--center");
    			add_location(div0, file$6, 15, 4, 727);
    			add_location(h1, file$6, 19, 6, 906);
    			attr_dev(div1, "class", "flex flex-justify--center margin-l--b");
    			add_location(div1, file$6, 18, 4, 847);
    			attr_dev(div2, "class", "text-align--center margin-m--tb padding-m bg--graa7");
    			add_location(div2, file$6, 21, 4, 944);
    			attr_dev(h20, "class", "color--graa1");
    			add_location(h20, file$6, 26, 12, 1322);
    			attr_dev(div3, "class", "flex-item flex-item--center text-align--center");
    			add_location(div3, file$6, 25, 10, 1249);
    			attr_dev(div4, "class", "card padding-m");
    			add_location(div4, file$6, 24, 8, 1210);
    			attr_dev(a0, "href", "#a11y");
    			attr_dev(a0, "class", "home-section-item components svelte-1rqm2fs");
    			add_location(a0, file$6, 23, 6, 1094);
    			attr_dev(h21, "class", "color--graa1");
    			add_location(h21, file$6, 34, 12, 1692);
    			attr_dev(div5, "class", "flex-item flex-item--center text-align--center");
    			add_location(div5, file$6, 33, 10, 1619);
    			attr_dev(div6, "class", "card padding-m");
    			add_location(div6, file$6, 32, 8, 1580);
    			attr_dev(a1, "href", "#a11y");
    			attr_dev(a1, "class", "home-section-item utilities svelte-1rqm2fs");
    			add_location(a1, file$6, 31, 6, 1466);
    			attr_dev(h22, "class", "color--graa1");
    			add_location(h22, file$6, 42, 12, 2060);
    			attr_dev(div7, "class", "flex-item flex-item--center text-align--center");
    			add_location(div7, file$6, 41, 10, 1987);
    			attr_dev(div8, "class", "card padding-m");
    			add_location(div8, file$6, 40, 8, 1948);
    			attr_dev(a2, "href", "#a11y");
    			attr_dev(a2, "class", "home-section-item guidelines svelte-1rqm2fs");
    			add_location(a2, file$6, 39, 6, 1832);
    			attr_dev(h23, "class", "color--graa1");
    			add_location(h23, file$6, 54, 12, 2476);
    			attr_dev(div9, "class", "flex-item flex-item--center text-align--center");
    			add_location(div9, file$6, 53, 10, 2403);
    			attr_dev(div10, "class", "card padding-m");
    			add_location(div10, file$6, 52, 8, 2364);
    			attr_dev(a3, "href", "#a11y");
    			attr_dev(a3, "class", "home-section-item exportedfunctions svelte-1rqm2fs");
    			add_location(a3, file$6, 47, 6, 2203);
    			attr_dev(h24, "class", "color--graa1");
    			add_location(h24, file$6, 62, 12, 2855);
    			attr_dev(div11, "class", "flex-item flex-item--center text-align--center");
    			add_location(div11, file$6, 61, 10, 2782);
    			attr_dev(div12, "class", "card padding-m");
    			add_location(div12, file$6, 60, 8, 2743);
    			attr_dev(a4, "href", "#a11y");
    			attr_dev(a4, "class", "home-section-item cssvariables svelte-1rqm2fs");
    			add_location(a4, file$6, 59, 6, 2623);
    			attr_dev(div13, "class", "grid home-section svelte-1rqm2fs");
    			add_location(div13, file$6, 22, 4, 1056);
    			attr_dev(div14, "class", "grid-width--medium");
    			add_location(div14, file$6, 14, 2, 690);
    			attr_dev(div15, "class", "flex flex-justify--around width-1of1");
    			add_location(div15, file$6, 13, 0, 637);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div15, anchor);
    			append_dev(div15, div14);
    			append_dev(div14, div0);
    			append_dev(div0, img);
    			append_dev(div14, t0);
    			append_dev(div14, div1);
    			append_dev(div1, h1);
    			append_dev(div14, t2);
    			append_dev(div14, div2);
    			append_dev(div14, t4);
    			append_dev(div14, div13);
    			append_dev(div13, a0);
    			append_dev(a0, div4);
    			append_dev(div4, div3);
    			append_dev(div3, h20);
    			append_dev(div3, t6);
    			mount_component(componentsicon, div3, null);
    			append_dev(div13, t7);
    			append_dev(div13, a1);
    			append_dev(a1, div6);
    			append_dev(div6, div5);
    			append_dev(div5, h21);
    			append_dev(div5, t9);
    			mount_component(utilityicon, div5, null);
    			append_dev(div13, t10);
    			append_dev(div13, a2);
    			append_dev(a2, div8);
    			append_dev(div8, div7);
    			append_dev(div7, h22);
    			append_dev(div7, t12);
    			mount_component(guidelineicon, div7, null);
    			append_dev(div13, t13);
    			append_dev(div13, a3);
    			append_dev(a3, div10);
    			append_dev(div10, div9);
    			append_dev(div9, h23);
    			append_dev(div9, t15);
    			mount_component(jsfunctionsicon, div9, null);
    			append_dev(div13, t16);
    			append_dev(div13, a4);
    			append_dev(a4, div12);
    			append_dev(div12, div11);
    			append_dev(div11, h24);
    			append_dev(div11, t18);
    			mount_component(cssvarsicon, div11, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link.call(null, a0, { disabled: false, href: components.href })),
    					action_destroyer(link.call(null, a1, { disabled: false, href: utilities.href })),
    					action_destroyer(link.call(null, a2, { disabled: false, href: guidelines.href })),
    					action_destroyer(link.call(null, a3, {
    						disabled: false,
    						href: exportedfunctions.href
    					})),
    					action_destroyer(link.call(null, a4, { disabled: false, href: cssvariables.href }))
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(componentsicon.$$.fragment, local);
    			transition_in(utilityicon.$$.fragment, local);
    			transition_in(guidelineicon.$$.fragment, local);
    			transition_in(jsfunctionsicon.$$.fragment, local);
    			transition_in(cssvarsicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(componentsicon.$$.fragment, local);
    			transition_out(utilityicon.$$.fragment, local);
    			transition_out(guidelineicon.$$.fragment, local);
    			transition_out(jsfunctionsicon.$$.fragment, local);
    			transition_out(cssvarsicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div15);
    			destroy_component(componentsicon);
    			destroy_component(utilityicon);
    			destroy_component(guidelineicon);
    			destroy_component(jsfunctionsicon);
    			destroy_component(cssvarsicon);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Home', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		link,
    		ComponentsIcon: Components_svg_rollup_plugin,
    		CssVarsIcon: Css_vars_svg_rollup_plugin,
    		GuidelineIcon: Guideline_svg_rollup_plugin,
    		JSFunctionsIcon: Js_functions_svg_rollup_plugin,
    		UtilityIcon: Utility_svg_rollup_plugin,
    		components,
    		cssvariables,
    		exportedfunctions,
    		guidelines,
    		utilities
    	});

    	return [];
    }

    class Home$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* docs_src/utilities/Home.svelte generated by Svelte v3.53.1 */
    const file$5 = "docs_src/utilities/Home.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[0] = list[i];
    	return child_ctx;
    }

    // (14:2) {#each utilities.routes as route}
    function create_each_block$1(ctx) {
    	let li;
    	let a;
    	let t_value = /*route*/ ctx[0].title + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "href", "#a11y");
    			add_location(a, file$5, 14, 8, 284);
    			add_location(li, file$5, 14, 4, 280);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, t);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a, {
    					disabled: false,
    					href: /*route*/ ctx[0].href
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(14:2) {#each utilities.routes as route}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let h1;
    	let t1;
    	let div;
    	let p;
    	let t3;
    	let ul;
    	let each_value = utilities.routes;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Utilities";
    			t1 = space();
    			div = element("div");
    			p = element("p");
    			p.textContent = "Utilities exposed from Ekstra Bladet designsystem";
    			t3 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h1, file$5, 6, 0, 116);
    			add_location(p, file$5, 9, 2, 170);
    			attr_dev(div, "class", "grid-width--small");
    			add_location(div, file$5, 8, 0, 136);
    			add_location(ul, file$5, 12, 0, 235);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*utilities*/ 0) {
    				each_value = utilities.routes;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Home', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ link, utilities });
    	return [];
    }

    class Home extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    // Fills the object to create a SPA routing
    const spaRoutes = {
        '/': Home$1,
        [guidelines.href]: Home$2,
        [components.href]: Home$5,
        [utilities.href]: Home,
        [exportedfunctions.href]: Home$3,
        [cssvariables.href]: Home$4,
    };
    [
        ...guidelines.routes,
        ...components.routes,
        ...utilities.routes,
        ...exportedfunctions.routes,
        ...cssvariables.routes,
    ].forEach((route) => {
        spaRoutes[route.href] = route.component;
    });
    const routes = spaRoutes;
    const menuItems = [guidelines, components, utilities, exportedfunctions, cssvariables];

    /* docs/svg/symbol/icons.svg.rollup-plugin.svelte generated by Svelte v3.53.1 */

    const file$4 = "docs/svg/symbol/icons.svg.rollup-plugin.svelte";

    function create_fragment$4(ctx) {
    	let svg;
    	let symbol0;
    	let path0;
    	let symbol1;
    	let path1;
    	let symbol2;
    	let path2;
    	let symbol3;
    	let path3;
    	let symbol4;
    	let path4;
    	let symbol5;
    	let path5;
    	let symbol6;
    	let path6;
    	let symbol7;
    	let path7;
    	let symbol8;
    	let path8;
    	let symbol9;
    	let path9;
    	let symbol10;
    	let path10;
    	let symbol11;
    	let path11;
    	let symbol12;
    	let path12;
    	let symbol13;
    	let path13;
    	let symbol14;
    	let path14;
    	let symbol15;
    	let path15;
    	let symbol16;
    	let path16;
    	let symbol17;
    	let path17;
    	let symbol18;
    	let path18;
    	let symbol19;
    	let path19;
    	let symbol20;
    	let path20;
    	let symbol21;
    	let path21;
    	let symbol22;
    	let path22;
    	let symbol23;
    	let path23;
    	let symbol24;
    	let path24;
    	let symbol25;
    	let path25;
    	let symbol26;
    	let path26;
    	let symbol27;
    	let path27;
    	let symbol28;
    	let path28;
    	let symbol29;
    	let path29;
    	let symbol30;
    	let path30;
    	let symbol31;
    	let path31;
    	let symbol32;
    	let path32;
    	let symbol33;
    	let path33;
    	let symbol34;
    	let path34;
    	let symbol35;
    	let path35;
    	let symbol36;
    	let path36;
    	let path37;
    	let path38;
    	let symbol37;
    	let path39;
    	let symbol38;
    	let path40;
    	let path41;
    	let path42;
    	let symbol39;
    	let path43;
    	let path44;
    	let path45;
    	let symbol40;
    	let path46;
    	let symbol41;
    	let path47;
    	let path48;
    	let path49;
    	let symbol42;
    	let path50;
    	let symbol43;
    	let path51;
    	let symbol44;
    	let path52;
    	let symbol45;
    	let path53;
    	let symbol46;
    	let path54;
    	let symbol47;
    	let path55;
    	let symbol48;
    	let path56;
    	let symbol49;
    	let path57;
    	let symbol50;
    	let path58;
    	let path59;
    	let symbol51;
    	let path60;
    	let symbol52;
    	let path61;
    	let symbol53;
    	let path62;
    	let symbol54;
    	let path63;
    	let symbol55;
    	let path64;
    	let symbol56;
    	let path65;
    	let symbol57;
    	let path66;
    	let symbol58;
    	let path67;
    	let symbol59;
    	let path68;
    	let symbol60;
    	let path69;
    	let symbol61;
    	let path70;
    	let symbol62;
    	let path71;
    	let symbol63;
    	let path72;
    	let symbol64;
    	let path73;
    	let symbol65;
    	let path74;
    	let symbol66;
    	let path75;
    	let symbol67;
    	let path76;
    	let symbol68;
    	let path77;
    	let path78;
    	let path79;
    	let path80;
    	let symbol69;
    	let path81;
    	let symbol70;
    	let path82;
    	let symbol71;
    	let path83;
    	let symbol72;
    	let path84;
    	let symbol73;
    	let path85;
    	let symbol74;
    	let path86;
    	let symbol75;
    	let path87;
    	let symbol76;
    	let path88;
    	let symbol77;
    	let path89;
    	let symbol78;
    	let path90;
    	let symbol79;
    	let path91;
    	let symbol80;
    	let path92;
    	let symbol81;
    	let path93;
    	let symbol82;
    	let path94;
    	let symbol83;
    	let path95;
    	let symbol84;
    	let path96;
    	let symbol85;
    	let path97;
    	let symbol86;
    	let path98;
    	let symbol87;
    	let path99;
    	let symbol88;
    	let path100;
    	let symbol89;
    	let path101;
    	let symbol90;
    	let path102;
    	let symbol91;
    	let path103;
    	let symbol92;
    	let path104;
    	let symbol93;
    	let path105;
    	let symbol94;
    	let path106;
    	let symbol95;
    	let path107;
    	let symbol96;
    	let path108;
    	let symbol97;
    	let path109;
    	let symbol98;
    	let path110;
    	let symbol99;
    	let path111;
    	let symbol100;
    	let path112;
    	let symbol101;
    	let path113;
    	let symbol102;
    	let path114;
    	let symbol103;
    	let path115;
    	let symbol104;
    	let path116;
    	let symbol105;
    	let path117;
    	let symbol106;
    	let rect;
    	let path118;
    	let symbol107;
    	let path119;
    	let symbol108;
    	let path120;
    	let symbol109;
    	let path121;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			symbol0 = svg_element("symbol");
    			path0 = svg_element("path");
    			symbol1 = svg_element("symbol");
    			path1 = svg_element("path");
    			symbol2 = svg_element("symbol");
    			path2 = svg_element("path");
    			symbol3 = svg_element("symbol");
    			path3 = svg_element("path");
    			symbol4 = svg_element("symbol");
    			path4 = svg_element("path");
    			symbol5 = svg_element("symbol");
    			path5 = svg_element("path");
    			symbol6 = svg_element("symbol");
    			path6 = svg_element("path");
    			symbol7 = svg_element("symbol");
    			path7 = svg_element("path");
    			symbol8 = svg_element("symbol");
    			path8 = svg_element("path");
    			symbol9 = svg_element("symbol");
    			path9 = svg_element("path");
    			symbol10 = svg_element("symbol");
    			path10 = svg_element("path");
    			symbol11 = svg_element("symbol");
    			path11 = svg_element("path");
    			symbol12 = svg_element("symbol");
    			path12 = svg_element("path");
    			symbol13 = svg_element("symbol");
    			path13 = svg_element("path");
    			symbol14 = svg_element("symbol");
    			path14 = svg_element("path");
    			symbol15 = svg_element("symbol");
    			path15 = svg_element("path");
    			symbol16 = svg_element("symbol");
    			path16 = svg_element("path");
    			symbol17 = svg_element("symbol");
    			path17 = svg_element("path");
    			symbol18 = svg_element("symbol");
    			path18 = svg_element("path");
    			symbol19 = svg_element("symbol");
    			path19 = svg_element("path");
    			symbol20 = svg_element("symbol");
    			path20 = svg_element("path");
    			symbol21 = svg_element("symbol");
    			path21 = svg_element("path");
    			symbol22 = svg_element("symbol");
    			path22 = svg_element("path");
    			symbol23 = svg_element("symbol");
    			path23 = svg_element("path");
    			symbol24 = svg_element("symbol");
    			path24 = svg_element("path");
    			symbol25 = svg_element("symbol");
    			path25 = svg_element("path");
    			symbol26 = svg_element("symbol");
    			path26 = svg_element("path");
    			symbol27 = svg_element("symbol");
    			path27 = svg_element("path");
    			symbol28 = svg_element("symbol");
    			path28 = svg_element("path");
    			symbol29 = svg_element("symbol");
    			path29 = svg_element("path");
    			symbol30 = svg_element("symbol");
    			path30 = svg_element("path");
    			symbol31 = svg_element("symbol");
    			path31 = svg_element("path");
    			symbol32 = svg_element("symbol");
    			path32 = svg_element("path");
    			symbol33 = svg_element("symbol");
    			path33 = svg_element("path");
    			symbol34 = svg_element("symbol");
    			path34 = svg_element("path");
    			symbol35 = svg_element("symbol");
    			path35 = svg_element("path");
    			symbol36 = svg_element("symbol");
    			path36 = svg_element("path");
    			path37 = svg_element("path");
    			path38 = svg_element("path");
    			symbol37 = svg_element("symbol");
    			path39 = svg_element("path");
    			symbol38 = svg_element("symbol");
    			path40 = svg_element("path");
    			path41 = svg_element("path");
    			path42 = svg_element("path");
    			symbol39 = svg_element("symbol");
    			path43 = svg_element("path");
    			path44 = svg_element("path");
    			path45 = svg_element("path");
    			symbol40 = svg_element("symbol");
    			path46 = svg_element("path");
    			symbol41 = svg_element("symbol");
    			path47 = svg_element("path");
    			path48 = svg_element("path");
    			path49 = svg_element("path");
    			symbol42 = svg_element("symbol");
    			path50 = svg_element("path");
    			symbol43 = svg_element("symbol");
    			path51 = svg_element("path");
    			symbol44 = svg_element("symbol");
    			path52 = svg_element("path");
    			symbol45 = svg_element("symbol");
    			path53 = svg_element("path");
    			symbol46 = svg_element("symbol");
    			path54 = svg_element("path");
    			symbol47 = svg_element("symbol");
    			path55 = svg_element("path");
    			symbol48 = svg_element("symbol");
    			path56 = svg_element("path");
    			symbol49 = svg_element("symbol");
    			path57 = svg_element("path");
    			symbol50 = svg_element("symbol");
    			path58 = svg_element("path");
    			path59 = svg_element("path");
    			symbol51 = svg_element("symbol");
    			path60 = svg_element("path");
    			symbol52 = svg_element("symbol");
    			path61 = svg_element("path");
    			symbol53 = svg_element("symbol");
    			path62 = svg_element("path");
    			symbol54 = svg_element("symbol");
    			path63 = svg_element("path");
    			symbol55 = svg_element("symbol");
    			path64 = svg_element("path");
    			symbol56 = svg_element("symbol");
    			path65 = svg_element("path");
    			symbol57 = svg_element("symbol");
    			path66 = svg_element("path");
    			symbol58 = svg_element("symbol");
    			path67 = svg_element("path");
    			symbol59 = svg_element("symbol");
    			path68 = svg_element("path");
    			symbol60 = svg_element("symbol");
    			path69 = svg_element("path");
    			symbol61 = svg_element("symbol");
    			path70 = svg_element("path");
    			symbol62 = svg_element("symbol");
    			path71 = svg_element("path");
    			symbol63 = svg_element("symbol");
    			path72 = svg_element("path");
    			symbol64 = svg_element("symbol");
    			path73 = svg_element("path");
    			symbol65 = svg_element("symbol");
    			path74 = svg_element("path");
    			symbol66 = svg_element("symbol");
    			path75 = svg_element("path");
    			symbol67 = svg_element("symbol");
    			path76 = svg_element("path");
    			symbol68 = svg_element("symbol");
    			path77 = svg_element("path");
    			path78 = svg_element("path");
    			path79 = svg_element("path");
    			path80 = svg_element("path");
    			symbol69 = svg_element("symbol");
    			path81 = svg_element("path");
    			symbol70 = svg_element("symbol");
    			path82 = svg_element("path");
    			symbol71 = svg_element("symbol");
    			path83 = svg_element("path");
    			symbol72 = svg_element("symbol");
    			path84 = svg_element("path");
    			symbol73 = svg_element("symbol");
    			path85 = svg_element("path");
    			symbol74 = svg_element("symbol");
    			path86 = svg_element("path");
    			symbol75 = svg_element("symbol");
    			path87 = svg_element("path");
    			symbol76 = svg_element("symbol");
    			path88 = svg_element("path");
    			symbol77 = svg_element("symbol");
    			path89 = svg_element("path");
    			symbol78 = svg_element("symbol");
    			path90 = svg_element("path");
    			symbol79 = svg_element("symbol");
    			path91 = svg_element("path");
    			symbol80 = svg_element("symbol");
    			path92 = svg_element("path");
    			symbol81 = svg_element("symbol");
    			path93 = svg_element("path");
    			symbol82 = svg_element("symbol");
    			path94 = svg_element("path");
    			symbol83 = svg_element("symbol");
    			path95 = svg_element("path");
    			symbol84 = svg_element("symbol");
    			path96 = svg_element("path");
    			symbol85 = svg_element("symbol");
    			path97 = svg_element("path");
    			symbol86 = svg_element("symbol");
    			path98 = svg_element("path");
    			symbol87 = svg_element("symbol");
    			path99 = svg_element("path");
    			symbol88 = svg_element("symbol");
    			path100 = svg_element("path");
    			symbol89 = svg_element("symbol");
    			path101 = svg_element("path");
    			symbol90 = svg_element("symbol");
    			path102 = svg_element("path");
    			symbol91 = svg_element("symbol");
    			path103 = svg_element("path");
    			symbol92 = svg_element("symbol");
    			path104 = svg_element("path");
    			symbol93 = svg_element("symbol");
    			path105 = svg_element("path");
    			symbol94 = svg_element("symbol");
    			path106 = svg_element("path");
    			symbol95 = svg_element("symbol");
    			path107 = svg_element("path");
    			symbol96 = svg_element("symbol");
    			path108 = svg_element("path");
    			symbol97 = svg_element("symbol");
    			path109 = svg_element("path");
    			symbol98 = svg_element("symbol");
    			path110 = svg_element("path");
    			symbol99 = svg_element("symbol");
    			path111 = svg_element("path");
    			symbol100 = svg_element("symbol");
    			path112 = svg_element("path");
    			symbol101 = svg_element("symbol");
    			path113 = svg_element("path");
    			symbol102 = svg_element("symbol");
    			path114 = svg_element("path");
    			symbol103 = svg_element("symbol");
    			path115 = svg_element("path");
    			symbol104 = svg_element("symbol");
    			path116 = svg_element("path");
    			symbol105 = svg_element("symbol");
    			path117 = svg_element("path");
    			symbol106 = svg_element("symbol");
    			rect = svg_element("rect");
    			path118 = svg_element("path");
    			symbol107 = svg_element("symbol");
    			path119 = svg_element("path");
    			symbol108 = svg_element("symbol");
    			path120 = svg_element("path");
    			symbol109 = svg_element("symbol");
    			path121 = svg_element("path");
    			attr_dev(path0, "d", "M443.5 162.6l-7.1-7.1c-4.7-4.7-12.3-4.7-17 0L224 351 28.5 155.5c-4.7-4.7-12.3-4.7-17 0l-7.1 7.1c-4.7 4.7-4.7 12.3 0 17l211 211.1c4.7 4.7 12.3 4.7 17 0l211-211.1c4.8-4.7 4.8-12.3.1-17z");
    			add_location(path0, file$4, 0, 231, 231);
    			attr_dev(symbol0, "class", "aasvg-inline--fa aafa-chevron-down aafa-w-14");
    			attr_dev(symbol0, "viewBox", "0 0 448 512");
    			attr_dev(symbol0, "id", "angle-down");
    			attr_dev(symbol0, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol0, file$4, 0, 97, 97);
    			attr_dev(path1, "d", "M238.475 475.535l7.071-7.07c4.686-4.686 4.686-12.284 0-16.971L50.053 256 245.546 60.506c4.686-4.686 4.686-12.284 0-16.971l-7.071-7.07c-4.686-4.686-12.284-4.686-16.97 0L10.454 247.515c-4.686 4.686-4.686 12.284 0 16.971l211.051 211.05c4.686 4.686 12.284 4.686 16.97-.001z");
    			add_location(path1, file$4, 0, 568, 568);
    			attr_dev(symbol1, "class", "absvg-inline--fa abfa-chevron-left abfa-w-8");
    			attr_dev(symbol1, "viewBox", "0 0 256 512");
    			attr_dev(symbol1, "id", "angle-left");
    			attr_dev(symbol1, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol1, file$4, 0, 435, 435);
    			attr_dev(path2, "d", "M17.525 36.465l-7.071 7.07c-4.686 4.686-4.686 12.284 0 16.971L205.947 256 10.454 451.494c-4.686 4.686-4.686 12.284 0 16.971l7.071 7.07c4.686 4.686 12.284 4.686 16.97 0l211.051-211.05c4.686-4.686 4.686-12.284 0-16.971L34.495 36.465c-4.686-4.687-12.284-4.687-16.97 0z");
    			add_location(path2, file$4, 0, 993, 993);
    			attr_dev(symbol2, "class", "acsvg-inline--fa acfa-chevron-right acfa-w-8");
    			attr_dev(symbol2, "viewBox", "0 0 256 512");
    			attr_dev(symbol2, "id", "angle-right");
    			attr_dev(symbol2, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol2, file$4, 0, 858, 858);
    			attr_dev(path3, "d", "M4.465 366.475l7.07 7.071c4.686 4.686 12.284 4.686 16.971 0L224 178.053l195.494 195.493c4.686 4.686 12.284 4.686 16.971 0l7.07-7.071c4.686-4.686 4.686-12.284 0-16.97l-211.05-211.051c-4.686-4.686-12.284-4.686-16.971 0L4.465 349.505c-4.687 4.686-4.687 12.284 0 16.97z");
    			add_location(path3, file$4, 0, 1409, 1409);
    			attr_dev(symbol3, "class", "adsvg-inline--fa adfa-chevron-up adfa-w-14");
    			attr_dev(symbol3, "viewBox", "0 0 448 512");
    			attr_dev(symbol3, "id", "angle-up");
    			attr_dev(symbol3, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol3, file$4, 0, 1279, 1279);
    			attr_dev(path4, "d", "M443.5 248.5l-7.1-7.1c-4.7-4.7-12.3-4.7-17 0L241 419.9V44c0-6.6-5.4-12-12-12h-10c-6.6 0-12 5.4-12 12v375.9L28.5 241.4c-4.7-4.7-12.3-4.7-17 0l-7.1 7.1c-4.7 4.7-4.7 12.3 0 17l211 211.1c4.7 4.7 12.3 4.7 17 0l211-211.1c4.8-4.8 4.8-12.3.1-17z");
    			add_location(path4, file$4, 0, 1827, 1827);
    			attr_dev(symbol4, "class", "aesvg-inline--fa aefa-arrow-down aefa-w-14");
    			attr_dev(symbol4, "viewBox", "0 0 448 512");
    			attr_dev(symbol4, "id", "arrow-down");
    			attr_dev(symbol4, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol4, file$4, 0, 1695, 1695);
    			attr_dev(path5, "d", "M231.536 475.535l7.071-7.07c4.686-4.686 4.686-12.284 0-16.971L60.113 273H436c6.627 0 12-5.373 12-12v-10c0-6.627-5.373-12-12-12H60.113L238.607 60.506c4.686-4.686 4.686-12.284 0-16.971l-7.071-7.07c-4.686-4.686-12.284-4.686-16.97 0L3.515 247.515c-4.686 4.686-4.686 12.284 0 16.971l211.051 211.05c4.686 4.686 12.284 4.686 16.97-.001z");
    			add_location(path5, file$4, 0, 2217, 2217);
    			attr_dev(symbol5, "class", "afsvg-inline--fa affa-arrow-left affa-w-14");
    			attr_dev(symbol5, "viewBox", "0 0 448 512");
    			attr_dev(symbol5, "id", "arrow-left");
    			attr_dev(symbol5, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol5, file$4, 0, 2085, 2085);
    			attr_dev(path6, "d", "M216.464 36.465l-7.071 7.07c-4.686 4.686-4.686 12.284 0 16.971L387.887 239H12c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h375.887L209.393 451.494c-4.686 4.686-4.686 12.284 0 16.971l7.071 7.07c4.686 4.686 12.284 4.686 16.97 0l211.051-211.05c4.686-4.686 4.686-12.284 0-16.971L233.434 36.465c-4.686-4.687-12.284-4.687-16.97 0z");
    			add_location(path6, file$4, 0, 2701, 2701);
    			attr_dev(symbol6, "class", "agsvg-inline--fa agfa-arrow-right agfa-w-14");
    			attr_dev(symbol6, "viewBox", "0 0 448 512");
    			attr_dev(symbol6, "id", "arrow-right");
    			attr_dev(symbol6, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol6, file$4, 0, 2567, 2567);
    			attr_dev(path7, "d", "M4.465 263.536l7.07 7.071c4.686 4.686 12.284 4.686 16.971 0L207 92.113V468c0 6.627 5.373 12 12 12h10c6.627 0 12-5.373 12-12V92.113l178.494 178.493c4.686 4.686 12.284 4.686 16.971 0l7.07-7.071c4.686-4.686 4.686-12.284 0-16.97l-211.05-211.05c-4.686-4.686-12.284-4.686-16.971 0L4.465 246.566c-4.687 4.686-4.687 12.284 0 16.97z");
    			add_location(path7, file$4, 0, 3179, 3179);
    			attr_dev(symbol7, "class", "ahsvg-inline--fa ahfa-arrow-up ahfa-w-14");
    			attr_dev(symbol7, "viewBox", "0 0 448 512");
    			attr_dev(symbol7, "id", "arrow-up");
    			attr_dev(symbol7, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol7, file$4, 0, 3051, 3051);
    			attr_dev(path8, "d", "M27 46.5h-4.5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5H27c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5zm-12 0H2c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5h13c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5zm34-11.1H2c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5h47c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5zm0-11.1H33.5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5H49c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5zm-26.3 0H3.3c-1.6 0-2.8-1.2-2.8-2.8V3C.5 1.4 1.7.2 3.3.2h19.4c1.6 0 2.8 1.2 2.8 2.8v18.5c-.1 1.6-1.2 2.8-2.8 2.8zm-19.2-3h18.9v-18H3.5v18zM49 13.2H33.5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5H49c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5zm0-9.9H33.5c-.8 0-1.5-.7-1.5-1.5S32.7.3 33.5.3H49c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5z");
    			add_location(path8, file$4, 0, 3599, 3599);
    			attr_dev(symbol8, "viewBox", "0 0 51 47");
    			attr_dev(symbol8, "id", "article");
    			attr_dev(symbol8, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol8, file$4, 0, 3523, 3523);
    			attr_dev(path9, "class", "ajst0");
    			attr_dev(path9, "d", "M8 15.6C3.8 15.6.4 12.2.4 8S3.8.4 8 .4s7.6 3.4 7.6 7.6v1.3c0 1.3-1.1 2.4-2.4 2.4-1 0-1.8-.6-2.2-1.4-.7.9-1.7 1.4-2.9 1.4C6 11.7 4.3 10 4.3 8S6 4.3 8 4.3c1.1 0 2 .5 2.7 1.2v-.7h1v4.5c0 .8.6 1.4 1.4 1.4s1.4-.6 1.4-1.4V8c0-3.6-2.9-6.6-6.6-6.6-3.5 0-6.5 3-6.5 6.6 0 3.6 2.9 6.6 6.6 6.6v1zM8 5.3C6.5 5.3 5.3 6.5 5.3 8c0 1.5 1.2 2.7 2.7 2.7 1.5 0 2.7-1.2 2.7-2.7 0-1.5-1.2-2.7-2.7-2.7z");
    			add_location(path9, file$4, 0, 4345, 4345);
    			attr_dev(symbol9, "viewBox", "0 0 16 16");
    			attr_dev(symbol9, "id", "at");
    			attr_dev(symbol9, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol9, file$4, 0, 4274, 4274);
    			attr_dev(path10, "d", "M224 480c-17.66 0-32-14.38-32-32.03h-32c0 35.31 28.72 64.03 64 64.03s64-28.72 64-64.03h-32c0 17.65-14.34 32.03-32 32.03zm209.38-145.19c-27.96-26.62-49.34-54.48-49.34-148.91 0-79.59-63.39-144.5-144.04-152.35V16c0-8.84-7.16-16-16-16s-16 7.16-16 16v17.56C127.35 41.41 63.96 106.31 63.96 185.9c0 94.42-21.39 122.29-49.35 148.91-13.97 13.3-18.38 33.41-11.25 51.23C10.64 404.24 28.16 416 48 416h352c19.84 0 37.36-11.77 44.64-29.97 7.13-17.82 2.71-37.92-11.26-51.22zM400 384H48c-14.23 0-21.34-16.47-11.32-26.01 34.86-33.19 59.28-70.34 59.28-172.08C95.96 118.53 153.23 64 224 64c70.76 0 128.04 54.52 128.04 121.9 0 101.35 24.21 138.7 59.28 172.08C421.38 367.57 414.17 384 400 384z");
    			add_location(path10, file$4, 0, 4879, 4879);
    			attr_dev(symbol10, "class", "aksvg-inline--fa akfa-bell akfa-w-14");
    			attr_dev(symbol10, "viewBox", "0 0 448 512");
    			attr_dev(symbol10, "id", "bell");
    			attr_dev(symbol10, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol10, file$4, 0, 4759, 4759);
    			attr_dev(path11, "d", "M336 0H48C21.49 0 0 21.49 0 48v464l192-112 192 112V48c0-26.51-21.49-48-48-48zm16 456.287l-160-93.333-160 93.333V48c0-8.822 7.178-16 16-16h288c8.822 0 16 7.178 16 16v408.287z");
    			add_location(path11, file$4, 0, 5651, 5651);
    			attr_dev(symbol11, "viewBox", "0 0 384 512");
    			attr_dev(symbol11, "id", "bookmark");
    			attr_dev(symbol11, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol11, file$4, 0, 5572, 5572);
    			attr_dev(path12, "d", "M0 512V48C0 21.49 21.49 0 48 0h288c26.51 0 48 21.49 48 48v464L192 400 0 512z");
    			add_location(path12, file$4, 0, 5930, 5930);
    			attr_dev(symbol12, "viewBox", "0 0 384 512");
    			attr_dev(symbol12, "id", "bookmark-solid");
    			attr_dev(symbol12, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol12, file$4, 0, 5845, 5845);
    			attr_dev(path13, "d", "M400 64h-48V12c0-6.627-5.373-12-12-12h-8c-6.627 0-12 5.373-12 12v52H128V12c0-6.627-5.373-12-12-12h-8c-6.627 0-12 5.373-12 12v52H48C21.49 64 0 85.49 0 112v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zM48 96h352c8.822 0 16 7.178 16 16v48H32v-48c0-8.822 7.178-16 16-16zm352 384H48c-8.822 0-16-7.178-16-16V192h384v272c0 8.822-7.178 16-16 16z");
    			add_location(path13, file$4, 0, 6155, 6155);
    			attr_dev(symbol13, "class", "ansvg-inline--fa anfa-calendar anfa-w-14");
    			attr_dev(symbol13, "viewBox", "0 0 448 512");
    			attr_dev(symbol13, "id", "calendar");
    			attr_dev(symbol13, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol13, file$4, 0, 6027, 6027);
    			attr_dev(path14, "d", "M324.3 64c3.3 0 6.3 2.1 7.5 5.2l22.1 58.8H464c8.8 0 16 7.2 16 16v288c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V144c0-8.8 7.2-16 16-16h110.2l20.1-53.6c2.3-6.2 8.3-10.4 15-10.4h131m0-32h-131c-20 0-37.9 12.4-44.9 31.1L136 96H48c-26.5 0-48 21.5-48 48v288c0 26.5 21.5 48 48 48h416c26.5 0 48-21.5 48-48V144c0-26.5-21.5-48-48-48h-88l-14.3-38c-5.8-15.7-20.7-26-37.4-26zM256 408c-66.2 0-120-53.8-120-120s53.8-120 120-120 120 53.8 120 120-53.8 120-120 120zm0-208c-48.5 0-88 39.5-88 88s39.5 88 88 88 88-39.5 88-88-39.5-88-88-88z");
    			add_location(path14, file$4, 0, 6673, 6673);
    			attr_dev(symbol14, "class", "aosvg-inline--fa aofa-camera aofa-w-16");
    			attr_dev(symbol14, "viewBox", "0 0 512 512");
    			attr_dev(symbol14, "id", "camera");
    			attr_dev(symbol14, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol14, file$4, 0, 6549, 6549);
    			attr_dev(path15, "d", "M512 144v288c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V144c0-26.5 21.5-48 48-48h88l12.3-32.9c7-18.7 24.9-31.1 44.9-31.1h125.5c20 0 37.9 12.4 44.9 31.1L376 96h88c26.5 0 48 21.5 48 48zM376 288c0-66.2-53.8-120-120-120s-120 53.8-120 120 53.8 120 120 120 120-53.8 120-120zm-32 0c0 48.5-39.5 88-88 88s-88-39.5-88-88 39.5-88 88-88 88 39.5 88 88z");
    			add_location(path15, file$4, 0, 7341, 7341);
    			attr_dev(symbol15, "class", "apsvg-inline--fa apfa-camera apfa-w-16");
    			attr_dev(symbol15, "viewBox", "0 0 512 512");
    			attr_dev(symbol15, "id", "camera-solid");
    			attr_dev(symbol15, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol15, file$4, 0, 7211, 7211);
    			attr_dev(path16, "d", "M424 352h16c4.4 0 8-3.6 8-8V104c0-4.4-3.6-8-8-8h-16c-4.4 0-8 3.6-8 8v240c0 4.4 3.6 8 8 8zm-96 0h16c4.4 0 8-3.6 8-8V200c0-4.4-3.6-8-8-8h-16c-4.4 0-8 3.6-8 8v144c0 4.4 3.6 8 8 8zm-192 0h16c4.4 0 8-3.6 8-8v-80c0-4.4-3.6-8-8-8h-16c-4.4 0-8 3.6-8 8v80c0 4.4 3.6 8 8 8zm96 0h16c4.4 0 8-3.6 8-8V136c0-4.4-3.6-8-8-8h-16c-4.4 0-8 3.6-8 8v208c0 4.4 3.6 8 8 8zm272 64H32V72c0-4.42-3.58-8-8-8H8c-4.42 0-8 3.58-8 8v360c0 8.84 7.16 16 16 16h488c4.42 0 8-3.58 8-8v-16c0-4.42-3.58-8-8-8z");
    			add_location(path16, file$4, 0, 7784, 7784);
    			attr_dev(symbol16, "viewBox", "0 0 512 512");
    			attr_dev(symbol16, "id", "chart-bar");
    			attr_dev(symbol16, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol16, file$4, 0, 7704, 7704);
    			attr_dev(path17, "d", "M413.505 91.951L133.49 371.966l-98.995-98.995c-4.686-4.686-12.284-4.686-16.971 0L6.211 284.284c-4.686 4.686-4.686 12.284 0 16.971l118.794 118.794c4.686 4.686 12.284 4.686 16.971 0l299.813-299.813c4.686-4.686 4.686-12.284 0-16.971l-11.314-11.314c-4.686-4.686-12.284-4.686-16.97 0z");
    			add_location(path17, file$4, 0, 8398, 8398);
    			attr_dev(symbol17, "class", "arsvg-inline--fa arfa-check arfa-w-14");
    			attr_dev(symbol17, "viewBox", "0 0 448 512");
    			attr_dev(symbol17, "id", "check");
    			attr_dev(symbol17, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol17, file$4, 0, 8276, 8276);
    			attr_dev(path18, "d", "M256 8C119.033 8 8 119.033 8 256s111.033 248 248 248 248-111.033 248-248S392.967 8 256 8zm0 464c-118.664 0-216-96.055-216-216 0-118.663 96.055-216 216-216 118.664 0 216 96.055 216 216 0 118.663-96.055 216-216 216zm141.63-274.961L217.15 376.071c-4.705 4.667-12.303 4.637-16.97-.068l-85.878-86.572c-4.667-4.705-4.637-12.303.068-16.97l8.52-8.451c4.705-4.667 12.303-4.637 16.97.068l68.976 69.533 163.441-162.13c4.705-4.667 12.303-4.637 16.97.068l8.451 8.52c4.668 4.705 4.637 12.303-.068 16.97z");
    			add_location(path18, file$4, 0, 8834, 8834);
    			attr_dev(symbol18, "class", "assvg-inline--fa asfa-check-circle asfa-w-16");
    			attr_dev(symbol18, "viewBox", "0 0 512 512");
    			attr_dev(symbol18, "id", "check-circle");
    			attr_dev(symbol18, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol18, file$4, 0, 8698, 8698);
    			attr_dev(path19, "d", "M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z");
    			add_location(path19, file$4, 0, 9486, 9486);
    			attr_dev(symbol19, "class", "atsvg-inline--fa atfa-check-circle atfa-w-16");
    			attr_dev(symbol19, "viewBox", "0 0 512 512");
    			attr_dev(symbol19, "id", "check-circle-solid");
    			attr_dev(symbol19, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol19, file$4, 0, 9344, 9344);
    			attr_dev(path20, "d", "M400 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zm0 32c8.823 0 16 7.178 16 16v352c0 8.822-7.177 16-16 16H48c-8.822 0-16-7.178-16-16V80c0-8.822 7.178-16 16-16h352m-34.301 98.293l-8.451-8.52c-4.667-4.705-12.265-4.736-16.97-.068l-163.441 162.13-68.976-69.533c-4.667-4.705-12.265-4.736-16.97-.068l-8.52 8.451c-4.705 4.667-4.736 12.265-.068 16.97l85.878 86.572c4.667 4.705 12.265 4.736 16.97.068l180.48-179.032c4.704-4.667 4.735-12.265.068-16.97z");
    			add_location(path20, file$4, 0, 9999, 9999);
    			attr_dev(symbol20, "class", "ausvg-inline--fa aufa-check-square aufa-w-14");
    			attr_dev(symbol20, "viewBox", "0 0 448 512");
    			attr_dev(symbol20, "id", "check-square");
    			attr_dev(symbol20, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol20, file$4, 0, 9863, 9863);
    			attr_dev(path21, "d", "M400 480H48c-26.51 0-48-21.49-48-48V80c0-26.51 21.49-48 48-48h352c26.51 0 48 21.49 48 48v352c0 26.51-21.49 48-48 48zm-204.686-98.059l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.248-16.379-6.249-22.628 0L184 302.745l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.25 16.379 6.25 22.628.001z");
    			add_location(path21, file$4, 0, 10667, 10667);
    			attr_dev(symbol21, "class", "avsvg-inline--fa avfa-check-square avfa-w-14");
    			attr_dev(symbol21, "viewBox", "0 0 448 512");
    			attr_dev(symbol21, "id", "check-square-solid");
    			attr_dev(symbol21, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol21, file$4, 0, 10525, 10525);
    			attr_dev(path22, "d", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm216 248c0 118.7-96.1 216-216 216-118.7 0-216-96.1-216-216 0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216z");
    			add_location(path22, file$4, 0, 11191, 11191);
    			attr_dev(symbol22, "class", "awsvg-inline--fa awfa-circle awfa-w-16");
    			attr_dev(symbol22, "viewBox", "0 0 512 512");
    			attr_dev(symbol22, "id", "circle");
    			attr_dev(symbol22, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol22, file$4, 0, 11067, 11067);
    			attr_dev(path23, "d", "M288 24.103v8.169a11.995 11.995 0 009.698 11.768C396.638 63.425 472 150.461 472 256c0 118.663-96.055 216-216 216-118.663 0-216-96.055-216-216 0-104.534 74.546-192.509 174.297-211.978A11.993 11.993 0 00224 32.253v-8.147c0-7.523-6.845-13.193-14.237-11.798C94.472 34.048 7.364 135.575 8.004 257.332c.72 137.052 111.477 246.956 248.531 246.667C393.255 503.711 504 392.789 504 256c0-121.187-86.924-222.067-201.824-243.704C294.807 10.908 288 16.604 288 24.103z");
    			add_location(path23, file$4, 0, 11526, 11526);
    			attr_dev(symbol23, "class", "axsvg-inline--fa axfa-circle-notch axfa-w-16");
    			attr_dev(symbol23, "viewBox", "0 0 512 512");
    			attr_dev(symbol23, "id", "circle-notch");
    			attr_dev(symbol23, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol23, file$4, 0, 11390, 11390);
    			attr_dev(path24, "d", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8z");
    			add_location(path24, file$4, 0, 12131, 12131);
    			attr_dev(symbol24, "class", "aysvg-inline--fa ayfa-circle ayfa-w-16");
    			attr_dev(symbol24, "viewBox", "0 0 512 512");
    			attr_dev(symbol24, "id", "circle-solid");
    			attr_dev(symbol24, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol24, file$4, 0, 12001, 12001);
    			attr_dev(path25, "d", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm216 248c0 118.7-96.1 216-216 216-118.7 0-216-96.1-216-216 0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216zm-148.9 88.3l-81.2-59c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h14c6.6 0 12 5.4 12 12v146.3l70.5 51.3c5.4 3.9 6.5 11.4 2.6 16.8l-8.2 11.3c-3.9 5.3-11.4 6.5-16.8 2.6z");
    			add_location(path25, file$4, 0, 12343, 12343);
    			attr_dev(symbol25, "class", "azsvg-inline--fa azfa-clock azfa-w-16");
    			attr_dev(symbol25, "viewBox", "0 0 512 512");
    			attr_dev(symbol25, "id", "clock");
    			attr_dev(symbol25, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol25, file$4, 0, 12221, 12221);
    			attr_dev(path26, "d", "M482.696 299.276l-32.61-18.827a195.168 195.168 0 000-48.899l32.61-18.827c9.576-5.528 14.195-16.902 11.046-27.501-11.214-37.749-31.175-71.728-57.535-99.595-7.634-8.07-19.817-9.836-29.437-4.282l-32.562 18.798a194.125 194.125 0 00-42.339-24.48V38.049c0-11.13-7.652-20.804-18.484-23.367-37.644-8.909-77.118-8.91-114.77 0-10.831 2.563-18.484 12.236-18.484 23.367v37.614a194.101 194.101 0 00-42.339 24.48L105.23 81.345c-9.621-5.554-21.804-3.788-29.437 4.282-26.36 27.867-46.321 61.847-57.535 99.595-3.149 10.599 1.47 21.972 11.046 27.501l32.61 18.827a195.168 195.168 0 000 48.899l-32.61 18.827c-9.576 5.528-14.195 16.902-11.046 27.501 11.214 37.748 31.175 71.728 57.535 99.595 7.634 8.07 19.817 9.836 29.437 4.283l32.562-18.798a194.08 194.08 0 0042.339 24.479v37.614c0 11.13 7.652 20.804 18.484 23.367 37.645 8.909 77.118 8.91 114.77 0 10.831-2.563 18.484-12.236 18.484-23.367v-37.614a194.138 194.138 0 0042.339-24.479l32.562 18.798c9.62 5.554 21.803 3.788 29.437-4.283 26.36-27.867 46.321-61.847 57.535-99.595 3.149-10.599-1.47-21.972-11.046-27.501zm-65.479 100.461l-46.309-26.74c-26.988 23.071-36.559 28.876-71.039 41.059v53.479a217.145 217.145 0 01-87.738 0v-53.479c-33.621-11.879-43.355-17.395-71.039-41.059l-46.309 26.74c-19.71-22.09-34.689-47.989-43.929-75.958l46.329-26.74c-6.535-35.417-6.538-46.644 0-82.079l-46.329-26.74c9.24-27.969 24.22-53.869 43.929-75.969l46.309 26.76c27.377-23.434 37.063-29.065 71.039-41.069V44.464a216.79 216.79 0 0187.738 0v53.479c33.978 12.005 43.665 17.637 71.039 41.069l46.309-26.76c19.709 22.099 34.689 47.999 43.929 75.969l-46.329 26.74c6.536 35.426 6.538 46.644 0 82.079l46.329 26.74c-9.24 27.968-24.219 53.868-43.929 75.957zM256 160c-52.935 0-96 43.065-96 96s43.065 96 96 96 96-43.065 96-96-43.065-96-96-96zm0 160c-35.29 0-64-28.71-64-64s28.71-64 64-64 64 28.71 64 64-28.71 64-64 64z");
    			add_location(path26, file$4, 0, 12831, 12831);
    			attr_dev(symbol26, "class", "basvg-inline--fa bafa-cog bafa-w-16");
    			attr_dev(symbol26, "viewBox", "0 0 512 512");
    			attr_dev(symbol26, "id", "cog");
    			attr_dev(symbol26, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol26, file$4, 0, 12713, 12713);
    			attr_dev(path27, "d", "M487.4 315.7l-42.6-24.6c4.3-23.2 4.3-47 0-70.2l42.6-24.6c4.9-2.8 7.1-8.6 5.5-14-11.1-35.6-30-67.8-54.7-94.6-3.8-4.1-10-5.1-14.8-2.3L380.8 110c-17.9-15.4-38.5-27.3-60.8-35.1V25.8c0-5.6-3.9-10.5-9.4-11.7-36.7-8.2-74.3-7.8-109.2 0-5.5 1.2-9.4 6.1-9.4 11.7V75c-22.2 7.9-42.8 19.8-60.8 35.1L88.7 85.5c-4.9-2.8-11-1.9-14.8 2.3-24.7 26.7-43.6 58.9-54.7 94.6-1.7 5.4.6 11.2 5.5 14L67.3 221c-4.3 23.2-4.3 47 0 70.2l-42.6 24.6c-4.9 2.8-7.1 8.6-5.5 14 11.1 35.6 30 67.8 54.7 94.6 3.8 4.1 10 5.1 14.8 2.3l42.6-24.6c17.9 15.4 38.5 27.3 60.8 35.1v49.2c0 5.6 3.9 10.5 9.4 11.7 36.7 8.2 74.3 7.8 109.2 0 5.5-1.2 9.4-6.1 9.4-11.7v-49.2c22.2-7.9 42.8-19.8 60.8-35.1l42.6 24.6c4.9 2.8 11 1.9 14.8-2.3 24.7-26.7 43.6-58.9 54.7-94.6 1.5-5.5-.7-11.3-5.6-14.1zM256 336c-44.1 0-80-35.9-80-80s35.9-80 80-80 80 35.9 80 80-35.9 80-80 80z");
    			add_location(path27, file$4, 0, 14794, 14794);
    			attr_dev(symbol27, "class", "bbsvg-inline--fa bbfa-cog bbfa-w-16");
    			attr_dev(symbol27, "viewBox", "0 0 512 512");
    			attr_dev(symbol27, "id", "cog-solid");
    			attr_dev(symbol27, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol27, file$4, 0, 14670, 14670);
    			attr_dev(path28, "d", "M256 64c123.5 0 224 79 224 176S379.5 416 256 416c-28.3 0-56.3-4.3-83.2-12.8l-15.2-4.8-13 9.2c-23 16.3-58.5 35.3-102.6 39.6 12-15.1 29.8-40.4 40.8-69.6l7.1-18.7-13.7-14.6C47.3 313.7 32 277.6 32 240c0-97 100.5-176 224-176m0-32C114.6 32 0 125.1 0 240c0 47.6 19.9 91.2 52.9 126.3C38 405.7 7 439.1 6.5 439.5c-6.6 7-8.4 17.2-4.6 26 3.8 8.8 12.4 14.5 22 14.5 61.5 0 110-25.7 139.1-46.3 29 9.1 60.2 14.3 93 14.3 141.4 0 256-93.1 256-208S397.4 32 256 32z");
    			add_location(path28, file$4, 0, 15751, 15751);
    			attr_dev(symbol28, "class", "bcsvg-inline--fa bcfa-comment bcfa-w-16");
    			attr_dev(symbol28, "viewBox", "0 0 512 512");
    			attr_dev(symbol28, "id", "comment");
    			attr_dev(symbol28, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol28, file$4, 0, 15625, 15625);
    			attr_dev(path29, "d", "M256 32C114.6 32 0 125.1 0 240c0 49.6 21.4 95 57 130.7C44.5 421.1 2.7 466 2.2 466.5c-2.2 2.3-2.8 5.7-1.5 8.7S4.8 480 8 480c66.3 0 116-31.8 140.6-51.4 32.7 12.3 69 19.4 107.4 19.4 141.4 0 256-93.1 256-208S397.4 32 256 32z");
    			add_location(path29, file$4, 0, 16349, 16349);
    			attr_dev(symbol29, "class", "bdsvg-inline--fa bdfa-comment bdfa-w-16");
    			attr_dev(symbol29, "viewBox", "0 0 512 512");
    			attr_dev(symbol29, "id", "comment-solid");
    			attr_dev(symbol29, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol29, file$4, 0, 16217, 16217);
    			attr_dev(path30, "d", "M416 192c0-88.4-93.1-160-208-160S0 103.6 0 192c0 34.3 14.1 65.9 38 92-13.4 30.2-35.5 54.2-35.8 54.5-2.2 2.3-2.8 5.7-1.5 8.7S4.8 352 8 352c36.6 0 66.9-12.3 88.7-25 32.2 15.7 70.3 25 111.3 25 114.9 0 208-71.6 208-160zm122 220c23.9-26 38-57.7 38-92 0-66.9-53.5-124.2-129.3-148.1.9 6.6 1.3 13.3 1.3 20.1 0 105.9-107.7 192-240 192-10.8 0-21.3-.8-31.7-1.9C207.8 439.6 281.8 480 368 480c41 0 79.1-9.2 111.3-25 21.8 12.7 52.1 25 88.7 25 3.2 0 6.1-1.9 7.3-4.8 1.3-2.9.7-6.3-1.5-8.7-.3-.3-22.4-24.2-35.8-54.5z");
    			add_location(path30, file$4, 0, 16724, 16724);
    			attr_dev(symbol30, "class", "besvg-inline--fa befa-comments befa-w-18");
    			attr_dev(symbol30, "viewBox", "0 0 576 512");
    			attr_dev(symbol30, "id", "comments-solid");
    			attr_dev(symbol30, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol30, file$4, 0, 16590, 16590);
    			attr_dev(path31, "d", "M528 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h480c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM48 64h480c8.8 0 16 7.2 16 16v48H32V80c0-8.8 7.2-16 16-16zm480 384H48c-8.8 0-16-7.2-16-16V224h512v208c0 8.8-7.2 16-16 16zm-336-84v8c0 6.6-5.4 12-12 12h-72c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h72c6.6 0 12 5.4 12 12zm192 0v8c0 6.6-5.4 12-12 12H236c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h136c6.6 0 12 5.4 12 12z");
    			add_location(path31, file$4, 0, 17377, 17377);
    			attr_dev(symbol31, "class", "bfsvg-inline--fa bffa-credit-card bffa-w-18");
    			attr_dev(symbol31, "viewBox", "0 0 576 512");
    			attr_dev(symbol31, "id", "creditcard");
    			attr_dev(symbol31, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol31, file$4, 0, 17244, 17244);
    			attr_dev(path32, "d", "M0 432c0 26.5 21.5 48 48 48h480c26.5 0 48-21.5 48-48V256H0v176zm192-68c0-6.6 5.4-12 12-12h136c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H204c-6.6 0-12-5.4-12-12v-40zm-128 0c0-6.6 5.4-12 12-12h72c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H76c-6.6 0-12-5.4-12-12v-40zM576 80v48H0V80c0-26.5 21.5-48 48-48h480c26.5 0 48 21.5 48 48z");
    			add_location(path32, file$4, 0, 17958, 17958);
    			attr_dev(symbol32, "class", "bgsvg-inline--fa bgfa-credit-card bgfa-w-18");
    			attr_dev(symbol32, "viewBox", "0 0 576 512");
    			attr_dev(symbol32, "id", "creditcard-solid");
    			attr_dev(symbol32, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol32, file$4, 0, 17819, 17819);
    			attr_dev(path33, "d", "M528 0H48C21.5 0 0 21.5 0 48v288c0 26.5 21.5 48 48 48h192l-24 96h-72c-8.8 0-16 7.2-16 16s7.2 16 16 16h288c8.8 0 16-7.2 16-16s-7.2-16-16-16h-72l-24-96h192c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zM249 480l16-64h46l16 64h-78zm295-144c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V48c0-8.8 7.2-16 16-16h480c8.8 0 16 7.2 16 16v288z");
    			add_location(path33, file$4, 0, 18428, 18428);
    			attr_dev(symbol33, "class", "bhsvg-inline--fa bhfa-desktop bhfa-w-18");
    			attr_dev(symbol33, "viewBox", "0 0 576 512");
    			attr_dev(symbol33, "id", "desktop");
    			attr_dev(symbol33, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol33, file$4, 0, 18302, 18302);
    			attr_dev(path34, "d", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 464c-118.7 0-216-96.1-216-216 0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216 0 118.7-96.1 216-216 216zm0-296c-44.2 0-80 35.8-80 80s35.8 80 80 80 80-35.8 80-80-35.8-80-80-80z");
    			add_location(path34, file$4, 0, 18857, 18857);
    			attr_dev(symbol34, "viewBox", "0 0 512 512");
    			attr_dev(symbol34, "id", "dot-circle");
    			attr_dev(symbol34, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol34, file$4, 0, 18776, 18776);
    			attr_dev(path35, "d", "M237.4 122.1h120.5v238.5h237.4V481H357.9v238.5H237.4V481H0V360.5h237.4V122.1z");
    			add_location(path35, file$4, 0, 19211, 19211);
    			attr_dev(symbol35, "viewBox", "0 122.1 595.3 597.4");
    			attr_dev(symbol35, "id", "ebplus");
    			attr_dev(symbol35, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol35, file$4, 0, 19126, 19126);
    			attr_dev(path36, "d", "M135 0h95v365h-95z");
    			add_location(path36, file$4, 0, 19392, 19392);
    			attr_dev(path37, "fill", "#ddd");
    			attr_dev(path37, "d", "M135 230v33.493L230 230h-95z");
    			add_location(path37, file$4, 0, 19422, 19422);
    			attr_dev(path38, "d", "M365 135v95H0v-95z");
    			add_location(path38, file$4, 0, 19474, 19474);
    			attr_dev(symbol36, "viewBox", "0 0 365 365");
    			attr_dev(symbol36, "id", "ebplus-black");
    			attr_dev(symbol36, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol36, file$4, 0, 19309, 19309);
    			attr_dev(path39, "d", "M36.4 0C16.3 0 0 16.3 0 36.4s16.3 36.4 36.4 36.4 36.4-16.3 36.4-36.4S56.5 0 36.4 0zm20.1 41.9H42.2v14.2H30.6V41.9H16.3V31.4h14.2V17.2h11.7v14.1h14.2v10.6z");
    			add_location(path39, file$4, 0, 19605, 19605);
    			attr_dev(symbol37, "viewBox", "0 0 72.8 72.8");
    			attr_dev(symbol37, "id", "ebplus-circle-solid");
    			attr_dev(symbol37, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol37, file$4, 0, 19513, 19513);
    			attr_dev(path40, "fill", "#fff");
    			attr_dev(path40, "d", "M135 0h95v365h-95z");
    			add_location(path40, file$4, 0, 19863, 19863);
    			attr_dev(path41, "fill", "#690000");
    			attr_dev(path41, "d", "M135 230v33.493L230 230h-95z");
    			add_location(path41, file$4, 0, 19905, 19905);
    			attr_dev(path42, "fill", "#fff");
    			attr_dev(path42, "d", "M365 135v95H0v-95z");
    			add_location(path42, file$4, 0, 19960, 19960);
    			attr_dev(symbol38, "viewBox", "0 0 365 365");
    			attr_dev(symbol38, "id", "ebplus-white");
    			attr_dev(symbol38, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol38, file$4, 0, 19780, 19780);
    			attr_dev(path43, "fill", "#fff");
    			attr_dev(path43, "d", "M135 0h95v365h-95z");
    			add_location(path43, file$4, 0, 20106, 20106);
    			attr_dev(path44, "fill", "#333");
    			attr_dev(path44, "d", "M135 230v33.493L230 230h-95z");
    			add_location(path44, file$4, 0, 20148, 20148);
    			attr_dev(path45, "fill", "#fff");
    			attr_dev(path45, "d", "M365 135v95H0v-95z");
    			add_location(path45, file$4, 0, 20200, 20200);
    			attr_dev(symbol39, "viewBox", "0 0 365 365");
    			attr_dev(symbol39, "id", "ebplus-white-blackshadow");
    			attr_dev(symbol39, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol39, file$4, 0, 20011, 20011);
    			attr_dev(path46, "d", "M417.8 315.5l20-20c3.8-3.8 10.2-1.1 10.2 4.2V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h292.3c5.3 0 8 6.5 4.2 10.2l-20 20c-1.1 1.1-2.7 1.8-4.2 1.8H48c-8.8 0-16 7.2-16 16v352c0 8.8 7.2 16 16 16h352c8.8 0 16-7.2 16-16V319.7c0-1.6.6-3.1 1.8-4.2zm145.9-191.2L251.2 436.8l-99.9 11.1c-13.4 1.5-24.7-9.8-23.2-23.2l11.1-99.9L451.7 12.3c16.4-16.4 43-16.4 59.4 0l52.6 52.6c16.4 16.4 16.4 43 0 59.4zm-93.6 48.4L403.4 106 169.8 339.5l-8.3 75.1 75.1-8.3 233.5-233.6zm71-85.2l-52.6-52.6c-3.8-3.8-10.2-4-14.1 0L426 83.3l66.7 66.7 48.4-48.4c3.9-3.8 3.9-10.2 0-14.1z");
    			add_location(path46, file$4, 0, 20371, 20371);
    			attr_dev(symbol40, "class", "bosvg-inline--fa bofa-edit bofa-w-18");
    			attr_dev(symbol40, "viewBox", "0 0 576 512");
    			attr_dev(symbol40, "id", "edit");
    			attr_dev(symbol40, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol40, file$4, 0, 20251, 20251);
    			attr_dev(path47, "fill", "#B30000");
    			attr_dev(path47, "d", "M0-.9h100V78l-49.5 9.5L0 77.6V-.9z");
    			add_location(path47, file$4, 0, 21055, 21055);
    			attr_dev(path48, "fill", "#FFF");
    			attr_dev(path48, "d", "M23 42.3H10.6v-4.5h9.8v-3.4h-9.8v-4.6h11.5v-3.3h-16v19.6h17zM39.7 46.1l-6-8.8 5-5.4h-4.8l-5.2 5.6v-11h-3.9v19.6h3.9v-3.9l2.3-2.3 3.8 6.2z");
    			add_location(path48, file$4, 0, 21116, 21116);
    			attr_dev(path49, "fill", "#FFF");
    			attr_dev(path49, "d", "M46.3 43.9c-2.4 0-3.1-.5-3.5-2h-3.7c0 3.1 2.5 4.9 6.7 4.9 4.7 0 7.5-1.8 7.5-4.8 0-2-1.6-3.7-3.6-4.1l-5.6-.9c-.6-.1-1.2-.7-1.2-1.4 0-.8.8-1.4 2.3-1.4 3 0 3.5.4 3.6 2h3.8v-.5c0-2.4-2.8-4.5-6.5-4.5-4.2 0-6.9 1.8-6.9 4.9 0 1.8 1.3 3.6 3 3.8l5.8 1c.8.1 1.3.5 1.3 1.2.1 1.2-.8 1.8-3 1.8zM56.5 42.6c0 2.6 1.7 4.2 4.7 4.2 1.1 0 2-.2 3.6-1v-1.9c-.7.1-1.7.1-2 .1-1.6 0-2.2-.6-2.2-1.8v-7.6h3.8V32h-3.8v-5.4h-2.9l-.1 1.2c-.6 3.8-.7 4.2-1.8 4.2h-2.5v2.6h3.4l-.2 8zM70.8 39.9c0-3.1 1.7-4.8 4.7-4.8h1.7v-3.6H76c-2.3 0-4.1 1.1-5.3 3.2V32h-3.8v14.2h4v-6.3zM91 41.5v-5.9c0-1.7-.2-2.3-1-2.8-1.3-1.1-3.4-1.6-5.8-1.6-4.3 0-6.3 1.4-6.6 4.8h3.7c.2-1.6 1-2 3-2 2.2 0 2.9.6 2.9 2.3 0 .7-.2 1-1.1 1.1l-4.1.5c-4.1.5-5.6 1.8-5.6 4.6 0 2.6 2 4.2 5.4 4.2 2.5 0 4.1-.8 5.5-2.9.8 2.2 1.8 2.9 3.7 2.9 1 0 1.8-.2 3.4-1.1v-1.8c-.8.1-1.4.1-1.7.1-1.2 0-1.7-.7-1.7-2.4zm-8 2.4c-1.4 0-2.3-.7-2.3-1.8 0-1.6.7-1.9 5.3-2.8l1.2-.2c0 3.2-1.3 4.8-4.2 4.8zM20.1 58.8c2.8-.6 4.2-2.2 4.2-4.4 0-2.6-2.4-4.7-5.5-4.7H6.1v19.5h12.5c3.7 0 6.4-2.2 6.4-5.3 0-2.7-1.6-4.2-4.9-5.1zm-9.5-6h5.9c2.3 0 3.1.6 3.1 2.3 0 1.8-.8 2.4-3.1 2.4h-5.9v-4.7zm5.9 12.9h-6v-5.3h6c2.4 0 3.5.8 3.5 2.6 0 2.1-.9 2.7-3.5 2.7zM26.9 49.8H31v19.5h-4.1zM47.4 64.9l-.1-6.9c-.1-2.3-2.5-3.6-6.6-3.6-5.1 0-6.9 1.2-7.1 4.8h3.8c.2-1.4.8-1.9 2.9-1.9 2.4 0 3.1.5 3.1 2.2 0 .7-.4 1-1.2 1.1-.2 0-1.9.1-4.1.5-3.8.5-5.4 1.8-5.4 4.6 0 2.6 1.9 4.2 5.3 4.2 2.6 0 4.1-.7 5.6-2.9.7 2 1.8 2.9 3.9 2.9 1 0 1.7-.2 2.9-.8v-2c-.5.1-.8.1-1.2.1-1.3-.1-1.8-.7-1.8-2.3zm-8 2.1c-1.7 0-2.5-.6-2.5-1.7 0-1.3 1-2 3.1-2.4 1.9-.2 1.8-.2 3.2-.6.1 3.1-1.2 4.7-3.8 4.7zM61.7 57.3c-1.3-1.9-2.8-2.8-4.9-2.8-3.8 0-6.7 3.2-6.7 7.6 0 4.8 2.5 7.8 6.6 7.8 2.3 0 3.4-.6 5.2-2.8v2.3h3.9V49.8h-4v7.5zm-4.1 9.8c-2.4 0-3.5-1.7-3.5-4.9 0-3 1.2-4.7 3.5-4.7 2.2 0 3.6 1.9 3.6 4.7 0 3-1.4 4.9-3.6 4.9zM75.5 54.6c-4.5 0-7.8 3.4-7.8 7.7 0 4.6 3.2 7.8 7.8 7.8 4.4 0 7.2-1.8 7.7-5.1h-3.8c-.5 1.6-1.3 2-3.4 2-2.8 0-4.1-1.3-4.1-4h11.3c0-5-3-8.4-7.7-8.4zM72 60.9c.2-2.3 1.3-3.5 3.4-3.5 2.2 0 3.2 1.1 3.4 3.5H72zM90.3 65.7v-7.6h4v-2.9h-4v-5.3h-2.9l-.1 1.1c-.7 4.2-.6 4.2-1.7 4.2h-2.3v2.9h3l-.1 6.9v.5c0 3.2 1.4 4.7 4.6 4.7 1.6 0 2.4-.1 3.7-.8v-2.2c-.8.1-1.7.1-2 .1-1.6-.1-2.2-.5-2.2-1.6z");
    			add_location(path49, file$4, 0, 21277, 21277);
    			attr_dev(symbol41, "viewBox", "0 0 100 88");
    			attr_dev(symbol41, "id", "ekstrabladet");
    			attr_dev(symbol41, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol41, file$4, 0, 20973, 20973);
    			attr_dev(path50, "d", "M464 64H48C21.5 64 0 85.5 0 112v288c0 26.5 21.5 48 48 48h416c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zM48 96h416c8.8 0 16 7.2 16 16v41.4c-21.9 18.5-53.2 44-150.6 121.3-16.9 13.4-50.2 45.7-73.4 45.3-23.2.4-56.6-31.9-73.4-45.3C85.2 197.4 53.9 171.9 32 153.4V112c0-8.8 7.2-16 16-16zm416 320H48c-8.8 0-16-7.2-16-16V195c22.8 18.7 58.8 47.6 130.7 104.7 20.5 16.4 56.7 52.5 93.3 52.3 36.4.3 72.3-35.5 93.3-52.3 71.9-57.1 107.9-86 130.7-104.7v205c0 8.8-7.2 16-16 16z");
    			add_location(path50, file$4, 0, 23585, 23585);
    			attr_dev(symbol42, "class", "bqsvg-inline--fa bqfa-envelope bqfa-w-16");
    			attr_dev(symbol42, "viewBox", "0 0 512 512");
    			attr_dev(symbol42, "id", "envelope");
    			attr_dev(symbol42, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol42, file$4, 0, 23457, 23457);
    			attr_dev(path51, "d", "M256 40c118.621 0 216 96.075 216 216 0 119.291-96.61 216-216 216-119.244 0-216-96.562-216-216 0-119.203 96.602-216 216-216m0-32C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm-11.49 120h22.979c6.823 0 12.274 5.682 11.99 12.5l-7 168c-.268 6.428-5.556 11.5-11.99 11.5h-8.979c-6.433 0-11.722-5.073-11.99-11.5l-7-168c-.283-6.818 5.167-12.5 11.99-12.5zM256 340c-15.464 0-28 12.536-28 28s12.536 28 28 28 28-12.536 28-28-12.536-28-28-28z");
    			add_location(path51, file$4, 0, 24217, 24217);
    			attr_dev(symbol43, "class", "brsvg-inline--fa brfa-exclamation-circle brfa-w-16");
    			attr_dev(symbol43, "viewBox", "0 0 512 512");
    			attr_dev(symbol43, "id", "exclamation-circle");
    			attr_dev(symbol43, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol43, file$4, 0, 24069, 24069);
    			attr_dev(path52, "d", "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z");
    			add_location(path52, file$4, 0, 24880, 24880);
    			attr_dev(symbol44, "class", "bssvg-inline--fa bsfa-exclamation-circle bsfa-w-16");
    			attr_dev(symbol44, "viewBox", "0 0 512 512");
    			attr_dev(symbol44, "id", "exclamation-circle-solid");
    			attr_dev(symbol44, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol44, file$4, 0, 24726, 24726);
    			attr_dev(path53, "d", "M270.2 160h35.5c3.4 0 6.1 2.8 6 6.2l-7.5 196c-.1 3.2-2.8 5.8-6 5.8h-20.5c-3.2 0-5.9-2.5-6-5.8l-7.5-196c-.1-3.4 2.6-6.2 6-6.2zM288 388c-15.5 0-28 12.5-28 28s12.5 28 28 28 28-12.5 28-28-12.5-28-28-28zm281.5 52L329.6 24c-18.4-32-64.7-32-83.2 0L6.5 440c-18.4 31.9 4.6 72 41.6 72H528c36.8 0 60-40 41.5-72zM528 480H48c-12.3 0-20-13.3-13.9-24l240-416c6.1-10.6 21.6-10.7 27.7 0l240 416c6.2 10.6-1.5 24-13.8 24z");
    			add_location(path53, file$4, 0, 25435, 25435);
    			attr_dev(symbol45, "class", "btsvg-inline--fa btfa-exclamation-triangle btfa-w-18");
    			attr_dev(symbol45, "viewBox", "0 0 576 512");
    			attr_dev(symbol45, "id", "exclamation-triangle");
    			attr_dev(symbol45, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol45, file$4, 0, 25283, 25283);
    			attr_dev(path54, "d", "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z");
    			add_location(path54, file$4, 0, 26016, 26016);
    			attr_dev(symbol46, "class", "busvg-inline--fa bufa-exclamation-triangle bufa-w-18");
    			attr_dev(symbol46, "viewBox", "0 0 576 512");
    			attr_dev(symbol46, "id", "exclamation-triangle-solid");
    			attr_dev(symbol46, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol46, file$4, 0, 25858, 25858);
    			attr_dev(path55, "d", "M0 180V56c0-13.3 10.7-24 24-24h124c6.6 0 12 5.4 12 12v8c0 6.6-5.4 12-12 12H32v116c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zM300 32h124c13.3 0 24 10.7 24 24v124c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12V64H300c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12zm148 300v124c0 13.3-10.7 24-24 24H300c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h116V332c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12zM148 480H24c-13.3 0-24-10.7-24-24V332c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v116h116c6.6 0 12 5.4 12 12v8c0 6.6-5.4 12-12 12z");
    			add_location(path55, file$4, 0, 26609, 26609);
    			attr_dev(symbol47, "class", "bvsvg-inline--fa bvfa-expand bvfa-w-14");
    			attr_dev(symbol47, "viewBox", "0 0 448 512");
    			attr_dev(symbol47, "id", "expand");
    			attr_dev(symbol47, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol47, file$4, 0, 26485, 26485);
    			attr_dev(path56, "d", "M440 256h-16a8 8 0 00-8 8v200a16 16 0 01-16 16H48a16 16 0 01-16-16V112a16 16 0 0116-16h200a8 8 0 008-8V72a8 8 0 00-8-8H48a48 48 0 00-48 48v352a48 48 0 0048 48h352a48 48 0 0048-48V264a8 8 0 00-8-8zM480 0h-.06l-96.16.17c-28.45 0-42.66 34.54-22.58 54.62l35.28 35.28-265 265a12 12 0 000 17l8.49 8.49a12 12 0 0017 0l265-265 35.28 35.27c20 20 54.57 6 54.62-22.57l.13-96.21A32 32 0 00480 0zm-.17 128.17l-96-96L480 32z");
    			add_location(path56, file$4, 0, 27278, 27278);
    			attr_dev(symbol48, "class", "bwsvg-inline--fa bwfa-external-link-alt bwfa-w-16");
    			attr_dev(symbol48, "viewBox", "0 0 512 512");
    			attr_dev(symbol48, "id", "external-link");
    			attr_dev(symbol48, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol48, file$4, 0, 27136, 27136);
    			attr_dev(path57, "d", "M279.14 288l14.22-92.66h-88.91v-60.13c0-25.35 12.42-50.06 52.24-50.06h40.42V6.26S260.43 0 225.36 0c-73.22 0-121.08 44.38-121.08 124.72v70.62H22.89V288h81.39v224h100.17V288z");
    			add_location(path57, file$4, 0, 27839, 27839);
    			attr_dev(symbol49, "class", "bxsvg-inline--fa bxfa-facebook-f bxfa-w-10");
    			attr_dev(symbol49, "viewBox", "0 0 320 512");
    			attr_dev(symbol49, "id", "facebook");
    			attr_dev(symbol49, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol49, file$4, 0, 27709, 27709);
    			attr_dev(path58, "d", "M15.6.8c.8-.8 2-.8 2.8 0l6.7 6.7c1.9 1.9 4.4 2.9 7.1 2.9H34v6H0v-6h1.9c2.7 0 5.2-1.1 7.1-2.9L15.6.8z");
    			attr_dev(path58, "fill", "var(--ebds-figcaption-bg)");
    			add_location(path58, file$4, 0, 28117, 28117);
    			attr_dev(path59, "d", "M9.7 12.9l6.6-6.6c.4-.4 1-.4 1.4 0l6.6 6.6c.6.6.2 1.7-.7 1.7H10.4c-.9 0-1.3-1-.7-1.7z");
    			add_location(path59, file$4, 0, 28262, 28262);
    			attr_dev(symbol50, "viewBox", "0 0 34 16.4");
    			attr_dev(symbol50, "id", "figcaption-pin");
    			attr_dev(symbol50, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol50, file$4, 0, 28032, 28032);
    			attr_dev(path60, "d", "M487.976 0H24.028C2.71 0-8.047 25.866 7.058 40.971L192 225.941V432c0 7.831 3.821 15.17 10.237 19.662l80 55.98C298.02 518.69 320 507.493 320 487.98V225.941l184.947-184.97C520.021 25.896 509.338 0 487.976 0z");
    			add_location(path60, file$4, 0, 28498, 28498);
    			attr_dev(symbol51, "class", "bzsvg-inline--fa bzfa-filter bzfa-w-16");
    			attr_dev(symbol51, "viewBox", "0 0 512 512");
    			attr_dev(symbol51, "id", "filter-solid");
    			attr_dev(symbol51, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol51, file$4, 0, 28368, 28368);
    			attr_dev(path61, "d", "M483.7 179.4C449.7 74.6 352.5 8 248.1 8 81.2 8-40 171.4 12.3 332.6 46.3 437.4 143.7 504 248 504c166.9 0 288-163.4 235.7-324.6zm-43 173.7l-94.3 11.6-17.8-24.9 33.7-104.1 28.9-9 69.6 65c-3.6 21.1-10.3 41.8-20.1 61.4zM35.6 291.5l69.4-64.9 28.9 9 33.9 103.7-18.1 25.2-94.2-11.6c-13-26-17.2-45.2-19.9-61.4zm196.5-180.7v32.9L146.2 206l-31.5-9.8-18-93.9c15.3-15.1 32.8-27.8 52-37.8l83.4 46.3zm149.4 85.4L350 206l-85.9-62.3v-32.9l83.6-46.4c19.1 10 36.7 22.7 52 37.9l-18.2 93.9zm-215.4 35l82-59.5 82.1 59.6-31.1 96H197.5l-31.4-96.1zm297.7 19.5L412.7 203l13.3-68.3c34.5 50.8 37.3 97.2 37.8 116zM309.2 49.2l-61.1 33.9-61-33.8c71.5-21.2 122-.1 122.1-.1zM70.3 134.1L83.5 203l-51.1 47.5c.8-31.8 8.7-63.4 23.6-92.6 4.2-8.3 9.1-16.2 14.3-23.8zm7.5 254l68.7 8.4 29.2 62.7c-38.8-13.8-72.7-38.5-97.9-71.1zm137.9 81.3l-40.1-86 17.4-24.2h110.2l17.3 24.2-40.1 86c-22.7 3.5-42.4 3.4-64.7 0zm104.8-10.2l29.2-62.7 69-8.5c-25 32.6-58.8 57.1-98.2 71.2z");
    			add_location(path61, file$4, 0, 28801, 28801);
    			attr_dev(symbol52, "viewBox", "0 0 496 512");
    			attr_dev(symbol52, "id", "futbol");
    			attr_dev(symbol52, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol52, file$4, 0, 28724, 28724);
    			attr_dev(path62, "d", "M43.7 54.5c-.3 0-.6 0-.9-.1l-32.7-6.6c-.8-.2-1.3-1-1.2-1.8.2-.8 1-1.3 1.8-1.2l32.8 6.6h.2c.1 0 .1 0 .6-.1h.1s0-.1.1-.1V51l7.1-35c0-.2 0-.4-.1-.6-.1-.1-.2-.2-.4-.3l-5.1-.8c-.8-.1-1.4-.9-1.2-1.7.1-.8.9-1.4 1.7-1.2l4.9.9c1 .2 1.8.7 2.4 1.5.6.9.8 1.9.6 2.9l-7.1 34.9c-.1 1-.8 2-1.7 2.5-.1 0-.1.1-.2.1l-.2.1c-.4 0-.9.2-1.5.2zm-4.1-11.2H4.2C2 43.3.5 41.7.5 39.6V4.2C.5 2 2.1.5 4.2.5h35.4c2.2 0 3.7 1.6 3.7 3.7v35.4c0 2.2-1.5 3.7-3.7 3.7zM3.5 36.7v2.9c0 .5.2.7.7.7h35.4c.5 0 .7-.2.7-.7v-2.9H3.5zm34.2-3h2.6V4.2c0-.5-.2-.7-.7-.7H4.2c-.5 0-.7.2-.7.7v29.5h2.6c.2-1.7.6-3.4 1.4-5.1 1.2-2.4 4.8-3.7 9.8-5.4.2-.5.2-1.7 0-2.1-2.1-2.4-3-5.2-2.8-8.1 0-2.2.6-4 1.9-5.5C17.8 5.9 19.7 5 22 5c2 0 3.9.9 5.5 2.4l.1.1c1.3 1.6 1.9 3.5 1.7 5.6.2 3-.8 5.9-2.7 7.9-.2.5-.2 1.8 0 2.3.6.2 1.3.5 1.9.7 4 1.5 6.9 2.6 7.9 4.6.7 1.7 1.2 3.4 1.3 5.1zm-28.6 0h25.6c-.2-1.3-.5-2.6-1.1-3.9-.4-.9-3.4-2-6.2-3-.7-.3-1.4-.5-2.2-.8-.5-.2-1.2-.7-1.5-1.8-.5-1.5-.3-3.9.4-4.9.1-.1.1-.2.2-.2 1.4-1.4 2.2-3.6 2-5.9v-.3c.2-1.3-.1-2.5-.9-3.4-.6-.6-1.8-1.5-3.3-1.5-1.4 0-2.5.5-3.3 1.5-.8 1-1.2 2.2-1.2 3.7v.1c-.2 2.2.5 4.2 2.1 6 .9.9 1.1 3.3.8 4.6-.4 1.6-1.3 2.1-1.8 2.3-2.8.9-7.5 2.5-8.2 3.9-.8 1-1.2 2.3-1.4 3.6zm8.2-12.6c0 .1 0 .1 0 0 0 .1 0 .1 0 0z");
    			add_location(path62, file$4, 0, 29823, 29823);
    			attr_dev(symbol53, "viewBox", "0 0 55 55");
    			attr_dev(symbol53, "id", "gallery");
    			attr_dev(symbol53, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol53, file$4, 0, 29747, 29747);
    			attr_dev(path63, "d", "M14.9 52.7c-.5 0-1.1-.1-1.6-.3-.9-.4-1.6-1.2-2-2.3L6.7 38.3c-.4-1-.4-2.1.1-3 .4-.9 1.2-1.6 2.2-1.9l2-.9c1-.4 2.1-.4 3.1 0 .9.4 1.6 1.2 2 2.3l4.6 11.8c.4 1 .4 2.1-.1 3-.4.9-1.2 1.6-2.2 1.9l-2 .9c-.5.2-1 .3-1.5.3zm-2.4-17.6c-.1 0-.2 0-.3.1l-2 .9s-.1 0-.1.1c-.2.1-.4.2-.5.4-.1.2-.1.4 0 .7l4.7 11.9c.1.3.2.5.4.6.2.1.4.1.7 0l2-.9s.1 0 .1-.1c.2-.1.4-.2.5-.4.1-.2.1-.4 0-.7l-4.7-11.9c-.1-.3-.2-.5-.4-.6-.2-.1-.3-.1-.4-.1zM38 52.6c-.5 0-.9-.1-1.3-.3l-2.2-1c-1.9-.8-2.9-3.1-2.2-5L37 34.6c.8-2 3.1-3 5-2.2l2.2 1c.9.3 1.6 1.1 2.1 2 .5 1 .5 2 .1 3l-4.7 11.9c-.4.9-1.1 1.7-2 2.1-.6.1-1.1.2-1.7.2zm2.7-17.5c-.3 0-.7.3-.9.6l-4.7 11.9c-.2.4.1.9.6 1.1l2.2 1c.3.1.9-.2 1-.6l4.7-11.9c.1-.2.1-.4 0-.6-.1-.2-.3-.4-.5-.5l-2.2-1h-.2zm-.4 14.5zm3.7 2.9c-.2 0-.5-.1-.7-.2-.7-.4-1-1.3-.6-2 .1-.1 6.8-12.6 6.8-23.8 0-12.7-10.3-23-23-23s-23 10.3-23 23c0 11.1 6.7 23.7 6.8 23.8.4.7.1 1.6-.6 2-.7.4-1.6.1-2-.6C7.4 51.2.5 38.4.5 26.5c0-14.3 11.7-26 26-26s26 11.7 26 26c0 11.9-6.9 24.7-7.2 25.2-.3.5-.8.8-1.3.8z");
    			add_location(path63, file$4, 0, 31127, 31127);
    			attr_dev(symbol54, "viewBox", "0 0 53 53");
    			attr_dev(symbol54, "id", "headphones");
    			attr_dev(symbol54, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol54, file$4, 0, 31048, 31048);
    			attr_dev(path64, "d", "M192 208c0-17.67-14.33-32-32-32h-16c-35.35 0-64 28.65-64 64v48c0 35.35 28.65 64 64 64h16c17.67 0 32-14.33 32-32V208zm176 144c35.35 0 64-28.65 64-64v-48c0-35.35-28.65-64-64-64h-16c-17.67 0-32 14.33-32 32v112c0 17.67 14.33 32 32 32h16zM256 0C113.18 0 4.58 118.83 0 256v16c0 8.84 7.16 16 16 16h16c8.84 0 16-7.16 16-16v-16c0-114.69 93.31-208 208-208s208 93.31 208 208h-.12c.08 2.43.12 165.72.12 165.72 0 23.35-18.93 42.28-42.28 42.28H320c0-26.51-21.49-48-48-48h-32c-26.51 0-48 21.49-48 48s21.49 48 48 48h181.72c49.86 0 90.28-40.42 90.28-90.28V256C507.42 118.83 398.82 0 256 0z");
    			add_location(path64, file$4, 0, 32205, 32205);
    			attr_dev(symbol55, "viewBox", "0 0 512 512");
    			attr_dev(symbol55, "id", "headset");
    			attr_dev(symbol55, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol55, file$4, 0, 32127, 32127);
    			attr_dev(path65, "d", "M462.3 62.7c-54.5-46.4-136-38.7-186.6 13.5L256 96.6l-19.7-20.3C195.5 34.1 113.2 8.7 49.7 62.7c-62.8 53.6-66.1 149.8-9.9 207.8l193.5 199.8c6.2 6.4 14.4 9.7 22.6 9.7 8.2 0 16.4-3.2 22.6-9.7L472 270.5c56.4-58 53.1-154.2-9.7-207.8zm-13.1 185.6L256.4 448.1 62.8 248.3c-38.4-39.6-46.4-115.1 7.7-161.2 54.8-46.8 119.2-12.9 142.8 11.5l42.7 44.1 42.7-44.1c23.2-24 88.2-58 142.8-11.5 54 46 46.1 121.5 7.7 161.2z");
    			add_location(path65, file$4, 0, 32920, 32920);
    			attr_dev(symbol56, "class", "cesvg-inline--fa cefa-heart cefa-w-16");
    			attr_dev(symbol56, "viewBox", "0 0 512 512");
    			attr_dev(symbol56, "id", "heart");
    			attr_dev(symbol56, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol56, file$4, 0, 32798, 32798);
    			attr_dev(path66, "d", "M256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c6.3 6.5 14.5 9.7 22.7 9.7V96.5z");
    			add_location(path66, file$4, 0, 33429, 33429);
    			attr_dev(symbol57, "viewBox", "0 0 512 512");
    			attr_dev(symbol57, "id", "heart-half-solid");
    			attr_dev(symbol57, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol57, file$4, 0, 33342, 33342);
    			attr_dev(path67, "d", "M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3 0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z");
    			add_location(path67, file$4, 0, 33706, 33706);
    			attr_dev(symbol58, "class", "cgsvg-inline--fa cgfa-heart cgfa-w-16");
    			attr_dev(symbol58, "viewBox", "0 0 512 512");
    			attr_dev(symbol58, "id", "heart-solid");
    			attr_dev(symbol58, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol58, file$4, 0, 33578, 33578);
    			attr_dev(path68, "d", "M20 24h10c6.627 0 12 5.373 12 12v94.625C85.196 57.047 165.239 7.715 256.793 8.001 393.18 8.428 504.213 120.009 504 256.396 503.786 393.181 392.834 504 256 504c-63.926 0-122.202-24.187-166.178-63.908-5.113-4.618-5.354-12.561-.482-17.433l7.069-7.069c4.503-4.503 11.749-4.714 16.482-.454C150.782 449.238 200.935 470 256 470c117.744 0 214-95.331 214-214 0-117.744-95.331-214-214-214-82.862 0-154.737 47.077-190.289 116H164c6.627 0 12 5.373 12 12v10c0 6.627-5.373 12-12 12H20c-6.627 0-12-5.373-12-12V36c0-6.627 5.373-12 12-12zm321.647 315.235l4.706-6.47c3.898-5.36 2.713-12.865-2.647-16.763L272 263.853V116c0-6.627-5.373-12-12-12h-8c-6.627 0-12 5.373-12 12v164.147l84.884 61.734c5.36 3.899 12.865 2.714 16.763-2.646z");
    			add_location(path68, file$4, 0, 34060, 34060);
    			attr_dev(symbol59, "class", "chsvg-inline--fa chfa-history chfa-w-16");
    			attr_dev(symbol59, "viewBox", "0 0 512 512");
    			attr_dev(symbol59, "id", "history");
    			attr_dev(symbol59, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol59, file$4, 0, 33934, 33934);
    			attr_dev(path69, "d", "M256 40c118.621 0 216 96.075 216 216 0 119.291-96.61 216-216 216-119.244 0-216-96.562-216-216 0-119.203 96.602-216 216-216m0-32C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm-36 344h12V232h-12c-6.627 0-12-5.373-12-12v-8c0-6.627 5.373-12 12-12h48c6.627 0 12 5.373 12 12v140h12c6.627 0 12 5.373 12 12v8c0 6.627-5.373 12-12 12h-72c-6.627 0-12-5.373-12-12v-8c0-6.627 5.373-12 12-12zm36-240c-17.673 0-32 14.327-32 32s14.327 32 32 32 32-14.327 32-32-14.327-32-32-32z");
    			add_location(path69, file$4, 0, 34926, 34926);
    			attr_dev(symbol60, "class", "cisvg-inline--fa cifa-info-circle cifa-w-16");
    			attr_dev(symbol60, "viewBox", "0 0 512 512");
    			attr_dev(symbol60, "id", "info-circle");
    			attr_dev(symbol60, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol60, file$4, 0, 34792, 34792);
    			attr_dev(path70, "d", "M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z");
    			add_location(path70, file$4, 0, 35606, 35606);
    			attr_dev(symbol61, "class", "cjsvg-inline--fa cjfa-info-circle cjfa-w-16");
    			attr_dev(symbol61, "viewBox", "0 0 512 512");
    			attr_dev(symbol61, "id", "info-circle-solid");
    			attr_dev(symbol61, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol61, file$4, 0, 35466, 35466);
    			attr_dev(path71, "d", "M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z");
    			add_location(path71, file$4, 0, 36156, 36156);
    			attr_dev(symbol62, "class", "cksvg-inline--fa ckfa-instagram ckfa-w-14");
    			attr_dev(symbol62, "viewBox", "0 0 448 512");
    			attr_dev(symbol62, "id", "instagram");
    			attr_dev(symbol62, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol62, file$4, 0, 36026, 36026);
    			attr_dev(path72, "d", "M3.339 9.491L.488 8.394a.733.733 0 01-.292-1.187L6.621.254C7.16-.332 8.156.179 7.95.938l-1.51 5.57 2.85 1.098a.733.733 0 01.292 1.187l-6.425 6.953c-.541.586-1.535.075-1.33-.684l1.512-5.57z");
    			add_location(path72, file$4, 0, 37177, 37177);
    			attr_dev(symbol63, "viewBox", "0 0 10 16");
    			attr_dev(symbol63, "id", "lightning");
    			attr_dev(symbol63, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol63, file$4, 0, 37099, 37099);
    			attr_dev(path73, "d", "M100.28 448H7.4V148.9h92.88zM53.79 108.1C24.09 108.1 0 83.5 0 53.8a53.79 53.79 0 01107.58 0c0 29.7-24.1 54.3-53.79 54.3zM447.9 448h-92.68V302.4c0-34.7-.7-79.2-48.29-79.2-48.29 0-55.69 37.7-55.69 76.7V448h-92.78V148.9h89.08v40.8h1.3c12.4-23.5 42.69-48.3 87.88-48.3 94 0 111.28 61.9 111.28 142.3V448z");
    			add_location(path73, file$4, 0, 37517, 37517);
    			attr_dev(symbol64, "class", "cmsvg-inline--fa cmfa-linkedin-in cmfa-w-14");
    			attr_dev(symbol64, "viewBox", "0 0 448 512");
    			attr_dev(symbol64, "id", "linkedin");
    			attr_dev(symbol64, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol64, file$4, 0, 37386, 37386);
    			attr_dev(path74, "d", "M61.77 401l17.5-20.15a19.92 19.92 0 005.07-14.19v-3.31C84.34 356 80.5 352 73 352H16a8 8 0 00-8 8v16a8 8 0 008 8h22.84a154.82 154.82 0 00-11 12.31l-5.61 7c-4 5.07-5.25 10.13-2.8 14.88l1.05 1.93c3 5.76 6.3 7.88 12.25 7.88h4.73c10.33 0 15.94 2.44 15.94 9.09 0 4.72-4.2 8.22-14.36 8.22a41.54 41.54 0 01-15.47-3.12c-6.49-3.88-11.74-3.5-15.6 3.12l-5.59 9.31c-3.73 6.13-3.2 11.72 2.62 15.94 7.71 4.69 20.39 9.44 37 9.44 34.16 0 48.5-22.75 48.5-44.12-.03-14.38-9.12-29.76-28.73-34.88zM12.1 320H80a8 8 0 008-8v-16a8 8 0 00-8-8H41.33c3.28-10.29 48.33-18.68 48.33-56.44 0-29.06-25-39.56-44.47-39.56-21.36 0-33.8 10-40.45 18.75-4.38 5.59-3 10.84 2.79 15.37l8.58 6.88c5.61 4.56 11 2.47 16.13-2.44a13.4 13.4 0 019.45-3.84c3.33 0 9.28 1.56 9.28 8.75C51 248.19 0 257.31 0 304.59v4C0 316 5.08 320 12.1 320zM16 160h64a8 8 0 008-8v-16a8 8 0 00-8-8H64V40a8 8 0 00-8-8H32a8 8 0 00-7.14 4.42l-8 16A8 8 0 0024 64h8v64H16a8 8 0 00-8 8v16a8 8 0 008 8zm488-80H168a8 8 0 00-8 8v16a8 8 0 008 8h336a8 8 0 008-8V88a8 8 0 00-8-8zm0 320H168a8 8 0 00-8 8v16a8 8 0 008 8h336a8 8 0 008-8v-16a8 8 0 00-8-8zm0-160H168a8 8 0 00-8 8v16a8 8 0 008 8h336a8 8 0 008-8v-16a8 8 0 00-8-8z");
    			add_location(path74, file$4, 0, 37914, 37914);
    			attr_dev(symbol65, "viewBox", "0 0 512 512");
    			attr_dev(symbol65, "id", "list-ol");
    			attr_dev(symbol65, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol65, file$4, 0, 37836, 37836);
    			attr_dev(path75, "d", "M400 224h-16v-62.5C384 73.1 312.9.3 224.5 0 136-.3 64 71.6 64 160v64H48c-26.5 0-48 21.5-48 48v192c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V272c0-26.5-21.5-48-48-48zM96 160c0-70.6 57.4-128 128-128s128 57.4 128 128v64H96v-64zm304 320H48c-8.8 0-16-7.2-16-16V272c0-8.8 7.2-16 16-16h352c8.8 0 16 7.2 16 16v192c0 8.8-7.2 16-16 16z");
    			add_location(path75, file$4, 0, 39197, 39197);
    			attr_dev(symbol66, "class", "cosvg-inline--fa cofa-lock cofa-w-14");
    			attr_dev(symbol66, "viewBox", "0 0 448 512");
    			attr_dev(symbol66, "id", "lock");
    			attr_dev(symbol66, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol66, file$4, 0, 39077, 39077);
    			attr_dev(path76, "d", "M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0zM192 272c44.183 0 80-35.817 80-80s-35.817-80-80-80-80 35.817-80 80 35.817 80 80 80z");
    			add_location(path76, file$4, 0, 39685, 39685);
    			attr_dev(symbol67, "class", "cpsvg-inline--fa cpfa-map-marker-alt cpfa-w-12");
    			attr_dev(symbol67, "viewBox", "0 0 384 512");
    			attr_dev(symbol67, "id", "mappin-solid");
    			attr_dev(symbol67, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol67, file$4, 0, 39547, 39547);
    			attr_dev(path77, "d", "M0 70.7h63.3v10.9H0z");
    			add_location(path77, file$4, 0, 40033, 40033);
    			attr_dev(path78, "d", "M0 81.5l21.2-19.7v-14L0 67.5z");
    			add_location(path78, file$4, 0, 40065, 40065);
    			attr_dev(path79, "d", "M31.8 0C14.2 0 0 14.2 0 31.8c0 13.8 8.9 25.6 21.2 30v-14c-5.2-3.4-8.6-9.3-8.6-16 0-10.6 8.6-19.2 19.2-19.2S51 21.2 51 31.8c0 6.7-3.4 12.5-8.6 16v14c12.3-4.4 21.2-16.1 21.2-30C63.6 14.2 49.3 0 31.8 0z");
    			add_location(path79, file$4, 0, 40106, 40106);
    			attr_dev(path80, "d", "M63.6 81.5L42.4 61.7V47.8l21.2 19.7z");
    			add_location(path80, file$4, 0, 40317, 40317);
    			attr_dev(symbol68, "viewBox", "0 0 63.6 81.5");
    			attr_dev(symbol68, "id", "medielogin");
    			attr_dev(symbol68, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol68, file$4, 0, 39950, 39950);
    			attr_dev(path81, "d", "M442 114H6a6 6 0 01-6-6V84a6 6 0 016-6h436a6 6 0 016 6v24a6 6 0 01-6 6zm0 160H6a6 6 0 01-6-6v-24a6 6 0 016-6h436a6 6 0 016 6v24a6 6 0 01-6 6zm0 160H6a6 6 0 01-6-6v-24a6 6 0 016-6h436a6 6 0 016 6v24a6 6 0 01-6 6z");
    			add_location(path81, file$4, 0, 40498, 40498);
    			attr_dev(symbol69, "class", "crsvg-inline--fa crfa-bars crfa-w-14");
    			attr_dev(symbol69, "viewBox", "0 0 448 512");
    			attr_dev(symbol69, "id", "menubars");
    			attr_dev(symbol69, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol69, file$4, 0, 40374, 40374);
    			attr_dev(path82, "d", "M0 4.3h30v4H0zM0 12.3h30v4H0zM0 20.3h30v4H0z");
    			add_location(path82, file$4, 0, 40813, 40813);
    			attr_dev(symbol70, "viewBox", "0 0 30 30");
    			attr_dev(symbol70, "id", "menubars-solid");
    			attr_dev(symbol70, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol70, file$4, 0, 40730, 40730);
    			attr_dev(path83, "d", "M475 63.5v201.7H316V63.5h159m-279.1 0v86h-159v-86h159m0 208.8v176.2h-159V272.3h159M475 387.1v61.4H316v-61.4h159m14.4-360.6H301.6c-12.5 0-22.6 10-22.6 22.3v231.1c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V48.8c0-12.3-10.1-22.3-22.6-22.3zm-279.1 0H22.5C10 26.5-.1 36.5-.1 48.8v115.4c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V48.8c.1-12.3-10.1-22.3-22.6-22.3zm0 208.8H22.5c-12.5 0-22.6 10-22.6 22.3v205.6c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V257.6c.1-12.3-10.1-22.3-22.6-22.3zm279.1 114.8H301.6c-12.5 0-22.6 10-22.6 22.3v90.8c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3v-90.8c0-12.3-10.1-22.3-22.6-22.3z");
    			add_location(path83, file$4, 0, 40954, 40954);
    			attr_dev(symbol71, "viewBox", "0 0 512 512");
    			attr_dev(symbol71, "id", "miteb");
    			attr_dev(symbol71, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol71, file$4, 0, 40878, 40878);
    			attr_dev(path84, "d", "M210.3 26.5H22.5C10 26.5-.1 36.5-.1 48.8v115.4c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V48.8c.1-12.3-10.1-22.3-22.6-22.3zm279.1 0H301.6c-12.5 0-22.6 10-22.6 22.3v231.1c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V48.8c0-12.3-10.1-22.3-22.6-22.3zM210.3 235.3H22.5c-12.5 0-22.6 10-22.6 22.3v205.6c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V257.6c.1-12.3-10.1-22.3-22.6-22.3zm279.1 114.8H301.6c-12.5 0-22.6 10-22.6 22.3v90.8c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3v-90.8c0-12.3-10.1-22.3-22.6-22.3z");
    			add_location(path84, file$4, 0, 41723, 41723);
    			attr_dev(symbol72, "viewBox", "0 0 512 512");
    			attr_dev(symbol72, "id", "miteb-solid");
    			attr_dev(symbol72, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol72, file$4, 0, 41641, 41641);
    			attr_dev(path85, "d", "M35.8 38.5H6.2c-3.5 0-6.2-2.7-6.2-6.2V2.7C0 1.2 1.2 0 2.7 0h26.1c1.6 0 2.7 1.2 2.7 2.7v29.6c0 2.4 1.8 4.2 4.2 4.2s4.2-1.8 4.2-4.2V6.2c0-.6.4-1 1-1s1 .4 1 1v26.1c.1 3.5-2.6 6.2-6.1 6.2zM2.7 2c-.5 0-.7.2-.7.7v29.6c0 2.4 1.8 4.2 4.2 4.2h25c-1-1.1-1.6-2.6-1.6-4.2V2.7c0-.5-.2-.7-.7-.7H2.7zm33.1 31.8c-.6 0-1-.4-1-1V6.2c0-.6.4-1 1-1s1 .4 1 1v26.5c0 .6-.5 1.1-1 1.1zm-10.5-4H6.2c-.6 0-1-.4-1-1s.4-1 1-1h19.1c.6 0 1 .4 1 1s-.4 1-1 1zm0-5.2H6.2c-.6 0-1-.4-1-1s.4-1 1-1h19.1c.6 0 1 .4 1 1s-.4 1-1 1zm0-5.2h-4.9c-.6 0-1-.4-1-1s.4-1 1-1h4.9c.6 0 1 .4 1 1s-.4 1-1 1zm-9.5 0H7.1c-1.1 0-1.9-.8-1.9-1.9V8.8C5.2 7.8 6 7 7.1 7h8.7c1.1 0 1.9.8 1.9 1.9v8.7c0 1-.9 1.8-1.9 1.8zm-8.6-2h8.4V9H7.2v8.4zm18.1-3.2h-4.9c-.6 0-1-.4-1-1s.4-1 1-1h4.9c.6 0 1 .4 1 1s-.4 1-1 1zm0-5.2h-4.9c-.6 0-1-.4-1-1s.4-1 1-1h4.9c.6 0 1 .4 1 1s-.4 1-1 1z");
    			add_location(path85, file$4, 0, 42380, 42380);
    			attr_dev(symbol73, "viewBox", "0 0 42 39");
    			attr_dev(symbol73, "id", "newspaper");
    			attr_dev(symbol73, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol73, file$4, 0, 42302, 42302);
    			attr_dev(path86, "d", "M218 160h-20c-3.3 0-6 2.7-6 6v180c0 3.3 2.7 6 6 6h20c3.3 0 6-2.7 6-6V166c0-3.3-2.7-6-6-6zm96 0h-20c-3.3 0-6 2.7-6 6v180c0 3.3 2.7 6 6 6h20c3.3 0 6-2.7 6-6V166c0-3.3-2.7-6-6-6zM256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 464c-118.7 0-216-96.1-216-216 0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216 0 118.7-96.1 216-216 216z");
    			add_location(path86, file$4, 0, 43294, 43294);
    			attr_dev(symbol74, "viewBox", "0 0 512 512");
    			attr_dev(symbol74, "id", "pause-circle");
    			attr_dev(symbol74, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol74, file$4, 0, 43211, 43211);
    			attr_dev(path87, "d", "M12.9 14.2h-.2c-6.3-.6-11.3-5.7-12-12 0-.5.1-.9.4-1.3.4-.3.9-.5 1.4-.5h2.3c.8 0 1.5.5 1.7 1.2l.7 2.2c.2.6 0 1.3-.4 1.8l-.4.4s-.1.1 0 .2c.7 1 1.3 1.6 2.4 2.4H9l.4-.4c.5-.5 1.2-.6 1.8-.4l2.2.7c.7.2 1.2.9 1.2 1.7v2.3c0 .5-.2 1-.6 1.3-.3.2-.7.4-1.1.4zM2.5 1.4c-.2 0-.4.1-.6.2-.1.2-.2.3-.1.5.5 5.9 5.2 10.5 11 11.1.2 0 .4 0 .5-.2.2-.1.2-.3.2-.6v-2.3c0-.3-.2-.6-.5-.7l-2.2-.7c-.3-.1-.6 0-.8.2l-.4.3c-.4.4-1 .4-1.4.1C7 8.5 6.3 7.9 5.6 6.7c-.3-.4-.2-1 .1-1.4l.4-.3c.2-.2.3-.5.2-.8l-.8-2.3c-.1-.3-.4-.5-.7-.5H2.5zM14 5.2c-.3 0-.5-.2-.5-.5 0-1.9-1.5-3.4-3.4-3.4-.3 0-.5-.2-.5-.5s.2-.5.5-.5c2.4 0 4.4 2 4.4 4.4 0 .3-.2.5-.5.5zm-2.5 0c-.3 0-.5-.2-.5-.4 0-.5-.4-.8-.8-.8-.3 0-.5-.3-.5-.5s.2-.5.5-.5c1 0 1.8.8 1.8 1.8 0 .2-.2.4-.5.4z");
    			add_location(path87, file$4, 0, 43741, 43741);
    			attr_dev(symbol75, "viewBox", "0 0 15 15");
    			attr_dev(symbol75, "id", "phone");
    			attr_dev(symbol75, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol75, file$4, 0, 43667, 43667);
    			attr_dev(path88, "d", "M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0z");
    			add_location(path88, file$4, 0, 44612, 44612);
    			attr_dev(symbol76, "class", "cysvg-inline--fa cyfa-map-marker cyfa-w-12");
    			attr_dev(symbol76, "viewBox", "0 0 384 512");
    			attr_dev(symbol76, "id", "pin-solid");
    			attr_dev(symbol76, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol76, file$4, 0, 44481, 44481);
    			attr_dev(path89, "d", "M256 504c137 0 248-111 248-248S393 8 256 8 8 119 8 256s111 248 248 248zM40 256c0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216 0 118.7-96.1 216-216 216-118.7 0-216-96.1-216-216zm331.7-18l-176-107c-15.8-8.8-35.7 2.5-35.7 21v208c0 18.4 19.8 29.8 35.7 21l176-101c16.4-9.1 16.4-32.8 0-42zM192 335.8V176.9c0-4.7 5.1-7.6 9.1-5.1l134.5 81.7c3.9 2.4 3.8 8.1-.1 10.3L201 341c-4 2.3-9-.6-9-5.2z");
    			add_location(path89, file$4, 0, 44928, 44928);
    			attr_dev(symbol77, "class", "czsvg-inline--fa czfa-play-circle czfa-w-16");
    			attr_dev(symbol77, "viewBox", "0 0 512 512");
    			attr_dev(symbol77, "id", "play-circle");
    			attr_dev(symbol77, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol77, file$4, 0, 44794, 44794);
    			attr_dev(path90, "d", "M256 340c-15.464 0-28 12.536-28 28s12.536 28 28 28 28-12.536 28-28-12.536-28-28-28zm7.67-24h-16c-6.627 0-12-5.373-12-12v-.381c0-70.343 77.44-63.619 77.44-107.408 0-20.016-17.761-40.211-57.44-40.211-29.144 0-44.265 9.649-59.211 28.692-3.908 4.98-11.054 5.995-16.248 2.376l-13.134-9.15c-5.625-3.919-6.86-11.771-2.645-17.177C185.658 133.514 210.842 116 255.67 116c52.32 0 97.44 29.751 97.44 80.211 0 67.414-77.44 63.849-77.44 107.408V304c0 6.627-5.373 12-12 12zM256 40c118.621 0 216 96.075 216 216 0 119.291-96.61 216-216 216-119.244 0-216-96.562-216-216 0-119.203 96.602-216 216-216m0-32C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8z");
    			add_location(path90, file$4, 0, 45477, 45477);
    			attr_dev(symbol78, "class", "dasvg-inline--fa dafa-question-circle dafa-w-16");
    			attr_dev(symbol78, "viewBox", "0 0 512 512");
    			attr_dev(symbol78, "id", "question-circle");
    			attr_dev(symbol78, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol78, file$4, 0, 45335, 45335);
    			attr_dev(path91, "d", "M0 9V.4h3.7c.9 0 1.6.1 2 .2.4.2.8.4 1 .8.2.5.3.9.3 1.4 0 .7-.2 1.2-.5 1.6-.4.4-1 .7-1.7.8.4.2.7.5.9.7.2.3.6.7 1 1.4l1 1.7H5.6L4.4 7.1c-.5-.6-.8-1.1-.9-1.2-.2-.2-.4-.3-.5-.4-.2-.1-.5-.1-.9-.1h-.4V9H0zm1.7-5H3c.8 0 1.4 0 1.6-.1s.4-.2.5-.4c.1-.2.2-.4.2-.6 0-.3-.1-.5-.2-.7-.2-.1-.5-.3-.7-.3H1.7V4zM8.2 6.2L9.9 6c.1.6.3 1 .6 1.2.3.3.7.4 1.3.4.6 0 1-.1 1.3-.4.3-.2.4-.5.4-.8 0-.2-.1-.4-.2-.5-.1-.1-.3-.3-.6-.4-.2-.1-.7-.2-1.4-.4-.9-.2-1.6-.5-2-.8-.5-.5-.8-1-.8-1.7 0-.4.1-.8.4-1.2.3-.3.6-.6 1.1-.8.5-.2 1-.3 1.7-.3 1.1 0 1.9.2 2.4.7.5.5.8 1.1.9 1.9l-1.7.1c-.1-.5-.3-.8-.5-1-.2-.2-.6-.3-1.1-.3-.5 0-.9.1-1.2.3-.2.1-.3.3-.3.5s.1.4.3.5c.2.2.8.4 1.6.6.8.2 1.5.4 1.9.6.4.2.7.5.9.9.2.4.3.8.3 1.4 0 .5-.1 1-.4 1.4-.3.4-.7.8-1.2 1-.5.2-1.1.3-1.9.3-1.1 0-1.9-.2-2.5-.8-.5-.5-.9-1.2-1-2.2zM16.2 6.2l1.7-.2c.1.6.3 1 .6 1.2.3.3.7.4 1.3.4.6 0 1-.1 1.3-.4.3-.2.4-.5.4-.8 0-.2-.1-.4-.2-.5-.1-.1-.3-.3-.6-.4-.2-.1-.7-.2-1.4-.4-.9-.2-1.6-.5-2-.8-.5-.5-.8-1-.8-1.7 0-.4.1-.8.4-1.2.2-.4.6-.7 1.1-.9.5-.2 1-.3 1.7-.3 1.1 0 1.9.2 2.4.7.5.5.8 1.1.9 1.9l-1.7.1c-.1-.4-.3-.7-.5-.9-.2-.2-.6-.3-1.1-.3-.5 0-.9.1-1.2.3-.2.1-.3.3-.3.5s.1.4.3.5c.2.2.8.4 1.6.6.8.2 1.5.4 1.9.6.4.2.7.5.9.9.2.4.3.8.3 1.4 0 .5-.1 1-.4 1.4-.3.4-.7.8-1.2 1-.5.2-1.1.3-1.9.3-1.1 0-1.9-.2-2.5-.8-.5-.5-.9-1.2-1-2.2z");
    			add_location(path91, file$4, 0, 46260, 46260);
    			attr_dev(symbol79, "viewBox", "0 0 24 10");
    			attr_dev(symbol79, "id", "rss");
    			attr_dev(symbol79, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol79, file$4, 0, 46188, 46188);
    			attr_dev(path92, "d", "M80 352c26.467 0 48 21.533 48 48s-21.533 48-48 48-48-21.533-48-48 21.533-48 48-48m0-32c-44.183 0-80 35.817-80 80s35.817 80 80 80 80-35.817 80-80-35.817-80-80-80zm367.996 147.615c-6.448-237.848-198.06-429.164-435.61-435.61C5.609 31.821 0 37.229 0 44.007v8.006c0 6.482 5.146 11.816 11.626 11.994 220.81 6.05 398.319 183.913 404.367 404.367.178 6.48 5.512 11.626 11.994 11.626h8.007c6.778 0 12.185-5.609 12.002-12.385zm-144.245-.05c-6.347-158.132-133.207-284.97-291.316-291.316C5.643 175.976 0 181.45 0 188.247v8.005c0 6.459 5.114 11.72 11.567 11.989 141.134 5.891 254.301 119.079 260.192 260.192.269 6.453 5.531 11.567 11.989 11.567h8.005c6.798 0 12.271-5.643 11.998-12.435z");
    			add_location(path92, file$4, 0, 47663, 47663);
    			attr_dev(symbol80, "class", "dcsvg-inline--fa dcfa-rss dcfa-w-14");
    			attr_dev(symbol80, "viewBox", "0 0 448 512");
    			attr_dev(symbol80, "id", "rss-symbol");
    			attr_dev(symbol80, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol80, file$4, 0, 47538, 47538);
    			attr_dev(path93, "d", "M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395 312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5 0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17 0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208 32s176 78.7 176 176-78.7 176-176 176z");
    			add_location(path93, file$4, 0, 48480, 48480);
    			attr_dev(symbol81, "class", "ddsvg-inline--fa ddfa-search ddfa-w-16");
    			attr_dev(symbol81, "viewBox", "0 0 512 512");
    			attr_dev(symbol81, "id", "search");
    			attr_dev(symbol81, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol81, file$4, 0, 48356, 48356);
    			attr_dev(path94, "d", "M272 0H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h224c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zM160 480c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm112-108c0 6.6-5.4 12-12 12H60c-6.6 0-12-5.4-12-12V60c0-6.6 5.4-12 12-12h200c6.6 0 12 5.4 12 12v312z");
    			add_location(path94, file$4, 0, 48909, 48909);
    			attr_dev(symbol82, "viewBox", "0 0 320 512");
    			attr_dev(symbol82, "id", "smartphone");
    			attr_dev(symbol82, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol82, file$4, 0, 48828, 48828);
    			attr_dev(path95, "d", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm16 400c0 8.8-7.2 16-16 16H48c-8.8 0-16-7.2-16-16V80c0-8.8 7.2-16 16-16h352c8.8 0 16 7.2 16 16v352z");
    			add_location(path95, file$4, 0, 49330, 49330);
    			attr_dev(symbol83, "class", "dfsvg-inline--fa dffa-square dffa-w-14");
    			attr_dev(symbol83, "viewBox", "0 0 448 512");
    			attr_dev(symbol83, "id", "square");
    			attr_dev(symbol83, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol83, file$4, 0, 49206, 49206);
    			attr_dev(path96, "d", "M528.1 171.5L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6zM405.8 317.9l27.8 162L288 403.5 142.5 480l27.8-162L52.5 203.1l162.7-23.6L288 32l72.8 147.5 162.7 23.6-117.7 114.8z");
    			add_location(path96, file$4, 0, 49675, 49675);
    			attr_dev(symbol84, "class", "dgsvg-inline--fa dgfa-star dgfa-w-18");
    			attr_dev(symbol84, "viewBox", "0 0 576 512");
    			attr_dev(symbol84, "id", "star");
    			attr_dev(symbol84, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol84, file$4, 0, 49555, 49555);
    			attr_dev(path97, "d", "M288 0c-11.4 0-22.8 5.9-28.7 17.8L194 150.2 47.9 171.4c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.1 23 46 46.4 33.7L288 439.6V0z");
    			add_location(path97, file$4, 0, 50203, 50203);
    			attr_dev(symbol85, "class", "dhsvg-inline--fa dhfa-star-half dhfa-w-18");
    			attr_dev(symbol85, "viewBox", "0 0 576 512");
    			attr_dev(symbol85, "id", "star-half-solid");
    			attr_dev(symbol85, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol85, file$4, 0, 50067, 50067);
    			attr_dev(path98, "d", "M259.3 17.8L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0z");
    			add_location(path98, file$4, 0, 50492, 50492);
    			attr_dev(symbol86, "class", "disvg-inline--fa difa-star difa-w-18");
    			attr_dev(symbol86, "viewBox", "0 0 576 512");
    			attr_dev(symbol86, "id", "star-solid");
    			attr_dev(symbol86, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol86, file$4, 0, 50366, 50366);
    			attr_dev(path99, "d", "M457.373 9.387l-50.095 50.102C365.411 27.211 312.953 8 256 8 123.228 8 14.824 112.338 8.31 243.493 7.971 250.311 13.475 256 20.301 256h10.015c6.352 0 11.647-4.949 11.977-11.293C48.159 131.913 141.389 42 256 42c47.554 0 91.487 15.512 127.02 41.75l-53.615 53.622c-20.1 20.1-5.855 54.628 22.627 54.628H480c17.673 0 32-14.327 32-32V32.015c0-28.475-34.564-42.691-54.627-22.628zM480 160H352L480 32v128zm11.699 96h-10.014c-6.353 0-11.647 4.949-11.977 11.293C463.84 380.203 370.504 470 256 470c-47.525 0-91.468-15.509-127.016-41.757l53.612-53.616c20.099-20.1 5.855-54.627-22.627-54.627H32c-17.673 0-32 14.327-32 32v127.978c0 28.614 34.615 42.641 54.627 22.627l50.092-50.096C146.587 484.788 199.046 504 256 504c132.773 0 241.176-104.338 247.69-235.493.339-6.818-5.165-12.507-11.991-12.507zM32 480V352h128L32 480z");
    			add_location(path99, file$4, 0, 50893, 50893);
    			attr_dev(symbol87, "class", "djsvg-inline--fa djfa-sync-alt djfa-w-16");
    			attr_dev(symbol87, "viewBox", "0 0 512 512");
    			attr_dev(symbol87, "id", "sync");
    			attr_dev(symbol87, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol87, file$4, 0, 50769, 50769);
    			attr_dev(path100, "d", "M400 0H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zM224 480c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm176-108c0 6.6-5.4 12-12 12H60c-6.6 0-12-5.4-12-12V60c0-6.6 5.4-12 12-12h328c6.6 0 12 5.4 12 12v312z");
    			add_location(path100, file$4, 0, 51845, 51845);
    			attr_dev(symbol88, "class", "dksvg-inline--fa dkfa-tablet-alt dkfa-w-14");
    			attr_dev(symbol88, "viewBox", "0 0 448 512");
    			attr_dev(symbol88, "id", "tablet");
    			attr_dev(symbol88, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol88, file$4, 0, 51717, 51717);
    			attr_dev(path101, "d", "M497.941 225.941L286.059 14.059A48 48 0 00252.118 0H48C21.49 0 0 21.49 0 48v204.118a48 48 0 0014.059 33.941l211.882 211.882c18.745 18.745 49.137 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zm-22.627 45.255L271.196 475.314c-6.243 6.243-16.375 6.253-22.627 0L36.686 263.431A15.895 15.895 0 0132 252.117V48c0-8.822 7.178-16 16-16h204.118c4.274 0 8.292 1.664 11.314 4.686l211.882 211.882c6.238 6.239 6.238 16.39 0 22.628zM144 124c11.028 0 20 8.972 20 20s-8.972 20-20 20-20-8.972-20-20 8.972-20 20-20m0-28c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z");
    			add_location(path101, file$4, 0, 52260, 52260);
    			attr_dev(symbol89, "class", "dlsvg-inline--fa dlfa-tag dlfa-w-16");
    			attr_dev(symbol89, "viewBox", "0 0 512 512");
    			attr_dev(symbol89, "id", "tag");
    			attr_dev(symbol89, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol89, file$4, 0, 52142, 52142);
    			attr_dev(path102, "d", "M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 010 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z");
    			add_location(path102, file$4, 0, 52999, 52999);
    			attr_dev(symbol90, "class", "dmsvg-inline--fa dmfa-tag dmfa-w-16");
    			attr_dev(symbol90, "viewBox", "0 0 512 512");
    			attr_dev(symbol90, "id", "tag-solid");
    			attr_dev(symbol90, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol90, file$4, 0, 52875, 52875);
    			attr_dev(path103, "d", "M625.941 293.823L421.823 497.941c-18.746 18.746-49.138 18.745-67.882 0l-1.775-1.775 22.627-22.627 1.775 1.775c6.253 6.253 16.384 6.243 22.627 0l204.118-204.118c6.238-6.239 6.238-16.389 0-22.627L391.431 36.686A15.895 15.895 0 00380.117 32h-19.549l-32-32h51.549a48 48 0 0133.941 14.059L625.94 225.941c18.746 18.745 18.746 49.137.001 67.882zM252.118 32H48c-8.822 0-16 7.178-16 16v204.118c0 4.274 1.664 8.292 4.686 11.314l211.882 211.882c6.253 6.253 16.384 6.243 22.627 0l204.118-204.118c6.238-6.239 6.238-16.389 0-22.627L263.431 36.686A15.895 15.895 0 00252.118 32m0-32a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.746 18.746-49.138 18.745-67.882 0L14.059 286.059A48 48 0 010 252.118V48C0 21.49 21.49 0 48 0h204.118zM144 124c-11.028 0-20 8.972-20 20s8.972 20 20 20 20-8.972 20-20-8.972-20-20-20m0-28c26.51 0 48 21.49 48 48s-21.49 48-48 48-48-21.49-48-48 21.49-48 48-48z");
    			add_location(path103, file$4, 0, 53426, 53426);
    			attr_dev(symbol91, "class", "dnsvg-inline--fa dnfa-tags dnfa-w-20");
    			attr_dev(symbol91, "viewBox", "0 0 640 512");
    			attr_dev(symbol91, "id", "tags");
    			attr_dev(symbol91, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol91, file$4, 0, 53306, 53306);
    			attr_dev(path104, "d", "M497.941 225.941L286.059 14.059A48 48 0 00252.118 0H48C21.49 0 0 21.49 0 48v204.118a48 48 0 0014.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zM112 160c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882 0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397 0h48.721a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882z");
    			add_location(path104, file$4, 0, 54491, 54491);
    			attr_dev(symbol92, "class", "dosvg-inline--fa dofa-tags dofa-w-20");
    			attr_dev(symbol92, "viewBox", "0 0 640 512");
    			attr_dev(symbol92, "id", "tags-solid");
    			attr_dev(symbol92, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol92, file$4, 0, 54365, 54365);
    			attr_dev(path105, "d", "M193.94 256L296.5 153.44l21.15-21.15c3.12-3.12 3.12-8.19 0-11.31l-22.63-22.63c-3.12-3.12-8.19-3.12-11.31 0L160 222.06 36.29 98.34c-3.12-3.12-8.19-3.12-11.31 0L2.34 120.97c-3.12 3.12-3.12 8.19 0 11.31L126.06 256 2.34 379.71c-3.12 3.12-3.12 8.19 0 11.31l22.63 22.63c3.12 3.12 8.19 3.12 11.31 0L160 289.94 262.56 392.5l21.15 21.15c3.12 3.12 8.19 3.12 11.31 0l22.63-22.63c3.12-3.12 3.12-8.19 0-11.31L193.94 256z");
    			add_location(path105, file$4, 0, 55178, 55178);
    			attr_dev(symbol93, "class", "dpsvg-inline--fa dpfa-times dpfa-w-10");
    			attr_dev(symbol93, "viewBox", "0 0 320 512");
    			attr_dev(symbol93, "id", "times");
    			attr_dev(symbol93, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol93, file$4, 0, 55056, 55056);
    			attr_dev(path106, "d", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 464c-118.7 0-216-96.1-216-216 0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216 0 118.7-96.1 216-216 216zm94.8-285.3L281.5 256l69.3 69.3c4.7 4.7 4.7 12.3 0 17l-8.5 8.5c-4.7 4.7-12.3 4.7-17 0L256 281.5l-69.3 69.3c-4.7 4.7-12.3 4.7-17 0l-8.5-8.5c-4.7-4.7-4.7-12.3 0-17l69.3-69.3-69.3-69.3c-4.7-4.7-4.7-12.3 0-17l8.5-8.5c4.7-4.7 12.3-4.7 17 0l69.3 69.3 69.3-69.3c4.7-4.7 12.3-4.7 17 0l8.5 8.5c4.6 4.7 4.6 12.3 0 17z");
    			add_location(path106, file$4, 0, 55742, 55742);
    			attr_dev(symbol94, "class", "dqsvg-inline--fa dqfa-times-circle dqfa-w-16");
    			attr_dev(symbol94, "viewBox", "0 0 512 512");
    			attr_dev(symbol94, "id", "times-circle");
    			attr_dev(symbol94, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol94, file$4, 0, 55606, 55606);
    			attr_dev(path107, "d", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z");
    			add_location(path107, file$4, 0, 56389, 56389);
    			attr_dev(symbol95, "class", "drsvg-inline--fa drfa-times-circle drfa-w-16");
    			attr_dev(symbol95, "viewBox", "0 0 512 512");
    			attr_dev(symbol95, "id", "times-circle-solid");
    			attr_dev(symbol95, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol95, file$4, 0, 56247, 56247);
    			attr_dev(path108, "d", "M384 96c42.738 0 82.917 16.643 113.137 46.863S544 213.262 544 256s-16.643 82.917-46.863 113.137S426.738 416 384 416H192c-42.738 0-82.917-16.643-113.137-46.863S32 298.738 32 256s16.643-82.917 46.863-113.137S149.262 96 192 96h192m0-32H192C85.961 64 0 149.961 0 256s85.961 192 192 192h192c106.039 0 192-85.961 192-192S490.039 64 384 64zm-192 96c52.935 0 96 43.065 96 96s-43.065 96-96 96-96-43.065-96-96 43.065-96 96-96m0-32c-70.692 0-128 57.307-128 128s57.308 128 128 128 128-57.307 128-128-57.308-128-128-128z");
    			add_location(path108, file$4, 0, 56917, 56917);
    			attr_dev(symbol96, "class", "dssvg-inline--fa dsfa-toggle-off dsfa-w-18");
    			attr_dev(symbol96, "viewBox", "0 0 576 512");
    			attr_dev(symbol96, "id", "toggle-off");
    			attr_dev(symbol96, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol96, file$4, 0, 56785, 56785);
    			attr_dev(path109, "d", "M384 64H192C86 64 0 150 0 256s86 192 192 192h192c106 0 192-86 192-192S490 64 384 64zm0 320c-70.8 0-128-57.3-128-128 0-70.8 57.3-128 128-128 70.8 0 128 57.3 128 128 0 70.8-57.3 128-128 128z");
    			add_location(path109, file$4, 0, 57575, 57575);
    			attr_dev(symbol97, "class", "dtsvg-inline--fa dtfa-toggle-on dtfa-w-18");
    			attr_dev(symbol97, "viewBox", "0 0 576 512");
    			attr_dev(symbol97, "id", "toggle-on");
    			attr_dev(symbol97, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol97, file$4, 0, 57445, 57445);
    			attr_dev(path110, "d", "M296 432h16a8 8 0 008-8V152a8 8 0 00-8-8h-16a8 8 0 00-8 8v272a8 8 0 008 8zm-160 0h16a8 8 0 008-8V152a8 8 0 00-8-8h-16a8 8 0 00-8 8v272a8 8 0 008 8zM440 64H336l-33.6-44.8A48 48 0 00264 0h-80a48 48 0 00-38.4 19.2L112 64H8a8 8 0 00-8 8v16a8 8 0 008 8h24v368a48 48 0 0048 48h288a48 48 0 0048-48V96h24a8 8 0 008-8V72a8 8 0 00-8-8zM171.2 38.4A16.1 16.1 0 01184 32h80a16.1 16.1 0 0112.8 6.4L296 64H152zM384 464a16 16 0 01-16 16H80a16 16 0 01-16-16V96h320zm-168-32h16a8 8 0 008-8V152a8 8 0 00-8-8h-16a8 8 0 00-8 8v272a8 8 0 008 8z");
    			add_location(path110, file$4, 0, 57910, 57910);
    			attr_dev(symbol98, "class", "dusvg-inline--fa dufa-trash-alt dufa-w-14");
    			attr_dev(symbol98, "viewBox", "0 0 448 512");
    			attr_dev(symbol98, "id", "trash");
    			attr_dev(symbol98, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol98, file$4, 0, 57784, 57784);
    			attr_dev(path111, "d", "M32 464a48 48 0 0048 48h288a48 48 0 0048-48V128H32zm272-256a16 16 0 0132 0v224a16 16 0 01-32 0zm-96 0a16 16 0 0132 0v224a16 16 0 01-32 0zm-96 0a16 16 0 0132 0v224a16 16 0 01-32 0zM432 32H312l-9.4-18.7A24 24 0 00281.1 0H166.8a23.72 23.72 0 00-21.4 13.3L136 32H16A16 16 0 000 48v32a16 16 0 0016 16h416a16 16 0 0016-16V48a16 16 0 00-16-16z");
    			add_location(path111, file$4, 0, 58585, 58585);
    			attr_dev(symbol99, "class", "dvsvg-inline--fa dvfa-trash-alt dvfa-w-14");
    			attr_dev(symbol99, "viewBox", "0 0 448 512");
    			attr_dev(symbol99, "id", "trash-solid");
    			attr_dev(symbol99, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol99, file$4, 0, 58453, 58453);
    			attr_dev(path112, "d", "M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z");
    			add_location(path112, file$4, 0, 59068, 59068);
    			attr_dev(symbol100, "class", "dwsvg-inline--fa dwfa-twitter dwfa-w-16");
    			attr_dev(symbol100, "viewBox", "0 0 512 512");
    			attr_dev(symbol100, "id", "twitter");
    			attr_dev(symbol100, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol100, file$4, 0, 58942, 58942);
    			attr_dev(path113, "d", "M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm128 421.6c-35.9 26.5-80.1 42.4-128 42.4s-92.1-15.9-128-42.4V416c0-35.3 28.7-64 64-64 11.1 0 27.5 11.4 64 11.4 36.6 0 52.8-11.4 64-11.4 35.3 0 64 28.7 64 64v13.6zm30.6-27.5c-6.8-46.4-46.3-82.1-94.6-82.1-20.5 0-30.4 11.4-64 11.4S204.6 320 184 320c-48.3 0-87.8 35.7-94.6 82.1C53.9 363.6 32 312.4 32 256c0-119.1 96.9-216 216-216s216 96.9 216 216c0 56.4-21.9 107.6-57.4 146.1zM248 120c-48.6 0-88 39.4-88 88s39.4 88 88 88 88-39.4 88-88-39.4-88-88-88zm0 144c-30.9 0-56-25.1-56-56s25.1-56 56-56 56 25.1 56 56-25.1 56-56 56z");
    			add_location(path113, file$4, 0, 60014, 60014);
    			attr_dev(symbol101, "class", "dxsvg-inline--fa dxfa-user-circle dxfa-w-16");
    			attr_dev(symbol101, "viewBox", "0 0 496 512");
    			attr_dev(symbol101, "id", "user-circle");
    			attr_dev(symbol101, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol101, file$4, 0, 59880, 59880);
    			attr_dev(path114, "d", "M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 96c48.6 0 88 39.4 88 88s-39.4 88-88 88-88-39.4-88-88 39.4-88 88-88zm0 344c-58.7 0-111.3-26.6-146.5-68.2 18.8-35.4 55.6-59.8 98.5-59.8 2.4 0 4.8.4 7.1 1.1 13 4.2 26.6 6.9 40.9 6.9 14.3 0 28-2.7 40.9-6.9 2.3-.7 4.7-1.1 7.1-1.1 42.9 0 79.7 24.4 98.5 59.8C359.3 421.4 306.7 448 248 448z");
    			add_location(path114, file$4, 0, 60760, 60760);
    			attr_dev(symbol102, "class", "dysvg-inline--fa dyfa-user-circle dyfa-w-16");
    			attr_dev(symbol102, "viewBox", "0 0 496 512");
    			attr_dev(symbol102, "id", "user-circle-solid");
    			attr_dev(symbol102, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol102, file$4, 0, 60620, 60620);
    			attr_dev(path115, "d", "M224 256c70.7 0 128-57.3 128-128S294.7 0 224 0 96 57.3 96 128s57.3 128 128 128zm89.6 32h-16.7c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16h-16.7C60.2 288 0 348.2 0 422.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-41.6c0-74.2-60.2-134.4-134.4-134.4z");
    			add_location(path115, file$4, 0, 61261, 61261);
    			attr_dev(symbol103, "class", "dzsvg-inline--fa dzfa-user dzfa-w-14");
    			attr_dev(symbol103, "viewBox", "0 0 448 512");
    			attr_dev(symbol103, "id", "user-solid");
    			attr_dev(symbol103, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol103, file$4, 0, 61135, 61135);
    			attr_dev(path116, "d", "M544 224c44.2 0 80-35.8 80-80s-35.8-80-80-80-80 35.8-80 80 35.8 80 80 80zm0-128c26.5 0 48 21.5 48 48s-21.5 48-48 48-48-21.5-48-48 21.5-48 48-48zM320 256c61.9 0 112-50.1 112-112S381.9 32 320 32 208 82.1 208 144s50.1 112 112 112zm0-192c44.1 0 80 35.9 80 80s-35.9 80-80 80-80-35.9-80-80 35.9-80 80-80zm244 192h-40c-15.2 0-29.3 4.8-41.1 12.9 9.4 6.4 17.9 13.9 25.4 22.4 4.9-2.1 10.2-3.3 15.7-3.3h40c24.2 0 44 21.5 44 48 0 8.8 7.2 16 16 16s16-7.2 16-16c0-44.1-34.1-80-76-80zM96 224c44.2 0 80-35.8 80-80s-35.8-80-80-80-80 35.8-80 80 35.8 80 80 80zm0-128c26.5 0 48 21.5 48 48s-21.5 48-48 48-48-21.5-48-48 21.5-48 48-48zm304.1 180c-33.4 0-41.7 12-80.1 12-38.4 0-46.7-12-80.1-12-36.3 0-71.6 16.2-92.3 46.9-12.4 18.4-19.6 40.5-19.6 64.3V432c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48v-44.8c0-23.8-7.2-45.9-19.6-64.3-20.7-30.7-56-46.9-92.3-46.9zM480 432c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16v-44.8c0-16.6 4.9-32.7 14.1-46.4 13.8-20.5 38.4-32.8 65.7-32.8 27.4 0 37.2 12 80.2 12s52.8-12 80.1-12c27.3 0 51.9 12.3 65.7 32.8 9.2 13.7 14.1 29.8 14.1 46.4V432zM157.1 268.9c-11.9-8.1-26-12.9-41.1-12.9H76c-41.9 0-76 35.9-76 80 0 8.8 7.2 16 16 16s16-7.2 16-16c0-26.5 19.8-48 44-48h40c5.5 0 10.8 1.2 15.7 3.3 7.5-8.5 16.1-16 25.4-22.4z");
    			add_location(path116, file$4, 0, 61614, 61614);
    			attr_dev(symbol104, "viewBox", "0 0 640 512");
    			attr_dev(symbol104, "id", "users");
    			attr_dev(symbol104, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol104, file$4, 0, 61538, 61538);
    			attr_dev(path117, "d", "M45 47.5H6.1C3 47.5.5 45 .5 41.9V6.1C.5 3 3 .5 6.1.5H45c3.1 0 5.6 2.5 5.6 5.6v35.8c0 3.1-2.5 5.6-5.6 5.6zM6.1 3.5c-1.4 0-2.6 1.2-2.6 2.6v35.8c0 1.4 1.2 2.6 2.6 2.6H45c1.4 0 2.6-1.2 2.6-2.6V6.1c0-1.4-1.2-2.6-2.6-2.6H6.1zm24.6 39.9c-2.1 0-3.5-1.5-3.5-3.5v-.5h-19c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5h19v-.5c0-2.1 1.5-3.5 3.5-3.5s3.5 1.5 3.5 3.5v.5H43c.8 0 1.5.7 1.5 1.5s-.7 1.5-1.5 1.5h-8.7v.5c-.1 2-1.5 3.5-3.6 3.5zm-.6-5.6v2c0 .4.1.5.5.5s.5-.1.5-.5v-4.1c0-.4-.1-.5-.5-.5s-.5.1-.5.5v2.1zm-9.9-7.5c-.5 0-.9-.1-1.3-.4-.8-.5-1.3-1.3-1.3-2.3V13.7c0-1 .6-1.9 1.4-2.4.9-.5 1.9-.4 2.6.1l12 6.9c.8.4 1.4 1.3 1.4 2.3 0 1-.6 1.9-1.4 2.4l-12 6.9h-.1c-.4.3-.9.4-1.3.4zm.6-1.6zm.1-1.1zm-.2-13.3V27l11-6.3-11-6.4zM32.2 21zm0-.6zm-12.4-6.6z");
    			add_location(path117, file$4, 0, 62931, 62931);
    			attr_dev(symbol105, "viewBox", "0 0 51 48");
    			attr_dev(symbol105, "id", "video");
    			attr_dev(symbol105, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol105, file$4, 0, 62857, 62857);
    			attr_dev(rect, "width", "26");
    			attr_dev(rect, "height", "26");
    			attr_dev(rect, "rx", "4");
    			attr_dev(rect, "fill", "#fff");
    			add_location(rect, file$4, 0, 63854, 63854);
    			attr_dev(path118, "fill-rule", "evenodd");
    			attr_dev(path118, "clip-rule", "evenodd");
    			attr_dev(path118, "d", "M8 8.587c0-1.223 1.349-1.985 2.423-1.369l7.778 4.463a1.572 1.572 0 010 2.738l-7.778 4.463C9.349 19.498 8 18.736 8 17.513V8.587z");
    			attr_dev(path118, "fill", "#000");
    			add_location(path118, file$4, 0, 63903, 63903);
    			attr_dev(symbol106, "class", "ecvideo-icon");
    			attr_dev(symbol106, "fill", "none");
    			set_style(symbol106, "box-shadow", "0 6px 15px rgba(0,0,0,.12)");
    			set_style(symbol106, "border-radius", "4px");
    			attr_dev(symbol106, "viewBox", "0 0 26 26");
    			attr_dev(symbol106, "id", "video-graphic");
    			attr_dev(symbol106, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol106, file$4, 0, 63675, 63675);
    			attr_dev(path119, "d", "M633.82 458.1l-69-53.33C592.42 360.8 608 309.68 608 256c0-95.33-47.73-183.58-127.65-236.03-11.17-7.33-26.18-4.24-33.51 6.95-7.34 11.17-4.22 26.18 6.95 33.51 66.27 43.49 105.82 116.6 105.82 195.58 0 42.78-11.96 83.59-33.22 119.06l-38.12-29.46C503.49 318.68 512 288.06 512 256c0-63.09-32.06-122.09-85.77-156.16-11.19-7.09-26.03-3.8-33.12 7.41-7.09 11.2-3.78 26.03 7.41 33.13C440.27 165.59 464 209.44 464 256c0 21.21-5.03 41.57-14.2 59.88l-39.56-30.58c3.38-9.35 5.76-19.07 5.76-29.3 0-31.88-17.53-61.33-45.77-76.88-11.58-6.33-26.19-2.16-32.61 9.45-6.39 11.61-2.16 26.2 9.45 32.61 11.76 6.46 19.12 18.18 20.4 31.06L288 190.82V88.02c0-21.46-25.96-31.98-40.97-16.97l-49.71 49.7L45.47 3.37C38.49-2.05 28.43-.8 23.01 6.18L3.37 31.45C-2.05 38.42-.8 48.47 6.18 53.9l588.36 454.73c6.98 5.43 17.03 4.17 22.46-2.81l19.64-25.27c5.41-6.97 4.16-17.02-2.82-22.45zM32 184v144c0 13.25 10.74 24 24 24h102.06l88.97 88.95c15.03 15.03 40.97 4.47 40.97-16.97V352.6L43.76 163.84C36.86 168.05 32 175.32 32 184z");
    			add_location(path119, file$4, 0, 64245, 64245);
    			attr_dev(symbol107, "class", "edsvg-inline--fa edfa-volume-slash edfa-w-20");
    			attr_dev(symbol107, "viewBox", "0 0 640 512");
    			attr_dev(symbol107, "id", "volume-muted-solid");
    			attr_dev(symbol107, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol107, file$4, 0, 64103, 64103);
    			attr_dev(path120, "d", "M215.03 71.05L126.06 160H24c-13.26 0-24 10.74-24 24v144c0 13.25 10.74 24 24 24h102.06l88.97 88.95c15.03 15.03 40.97 4.47 40.97-16.97V88.02c0-21.46-25.96-31.98-40.97-16.97zm233.32-51.08c-11.17-7.33-26.18-4.24-33.51 6.95-7.34 11.17-4.22 26.18 6.95 33.51 66.27 43.49 105.82 116.6 105.82 195.58 0 78.98-39.55 152.09-105.82 195.58-11.17 7.32-14.29 22.34-6.95 33.5 7.04 10.71 21.93 14.56 33.51 6.95C528.27 439.58 576 351.33 576 256S528.27 72.43 448.35 19.97zM480 256c0-63.53-32.06-121.94-85.77-156.24-11.19-7.14-26.03-3.82-33.12 7.46s-3.78 26.21 7.41 33.36C408.27 165.97 432 209.11 432 256s-23.73 90.03-63.48 115.42c-11.19 7.14-14.5 22.07-7.41 33.36 6.51 10.36 21.12 15.14 33.12 7.46C447.94 377.94 480 319.54 480 256zm-141.77-76.87c-11.58-6.33-26.19-2.16-32.61 9.45-6.39 11.61-2.16 26.2 9.45 32.61C327.98 228.28 336 241.63 336 256c0 14.38-8.02 27.72-20.92 34.81-11.61 6.41-15.84 21-9.45 32.61 6.43 11.66 21.05 15.8 32.61 9.45 28.23-15.55 45.77-45 45.77-76.88s-17.54-61.32-45.78-76.86z");
    			add_location(path120, file$4, 0, 65386, 65386);
    			attr_dev(symbol108, "class", "eesvg-inline--fa eefa-volume-up eefa-w-18");
    			attr_dev(symbol108, "viewBox", "0 0 576 512");
    			attr_dev(symbol108, "id", "volume-up-solid");
    			attr_dev(symbol108, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol108, file$4, 0, 65250, 65250);
    			attr_dev(path121, "d", "M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z");
    			add_location(path121, file$4, 0, 66511, 66511);
    			attr_dev(symbol109, "class", "efsvg-inline--fa effa-youtube effa-w-18");
    			attr_dev(symbol109, "viewBox", "0 0 576 512");
    			attr_dev(symbol109, "id", "youtube");
    			attr_dev(symbol109, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(symbol109, file$4, 0, 66385, 66385);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$4, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, symbol0);
    			append_dev(symbol0, path0);
    			append_dev(svg, symbol1);
    			append_dev(symbol1, path1);
    			append_dev(svg, symbol2);
    			append_dev(symbol2, path2);
    			append_dev(svg, symbol3);
    			append_dev(symbol3, path3);
    			append_dev(svg, symbol4);
    			append_dev(symbol4, path4);
    			append_dev(svg, symbol5);
    			append_dev(symbol5, path5);
    			append_dev(svg, symbol6);
    			append_dev(symbol6, path6);
    			append_dev(svg, symbol7);
    			append_dev(symbol7, path7);
    			append_dev(svg, symbol8);
    			append_dev(symbol8, path8);
    			append_dev(svg, symbol9);
    			append_dev(symbol9, path9);
    			append_dev(svg, symbol10);
    			append_dev(symbol10, path10);
    			append_dev(svg, symbol11);
    			append_dev(symbol11, path11);
    			append_dev(svg, symbol12);
    			append_dev(symbol12, path12);
    			append_dev(svg, symbol13);
    			append_dev(symbol13, path13);
    			append_dev(svg, symbol14);
    			append_dev(symbol14, path14);
    			append_dev(svg, symbol15);
    			append_dev(symbol15, path15);
    			append_dev(svg, symbol16);
    			append_dev(symbol16, path16);
    			append_dev(svg, symbol17);
    			append_dev(symbol17, path17);
    			append_dev(svg, symbol18);
    			append_dev(symbol18, path18);
    			append_dev(svg, symbol19);
    			append_dev(symbol19, path19);
    			append_dev(svg, symbol20);
    			append_dev(symbol20, path20);
    			append_dev(svg, symbol21);
    			append_dev(symbol21, path21);
    			append_dev(svg, symbol22);
    			append_dev(symbol22, path22);
    			append_dev(svg, symbol23);
    			append_dev(symbol23, path23);
    			append_dev(svg, symbol24);
    			append_dev(symbol24, path24);
    			append_dev(svg, symbol25);
    			append_dev(symbol25, path25);
    			append_dev(svg, symbol26);
    			append_dev(symbol26, path26);
    			append_dev(svg, symbol27);
    			append_dev(symbol27, path27);
    			append_dev(svg, symbol28);
    			append_dev(symbol28, path28);
    			append_dev(svg, symbol29);
    			append_dev(symbol29, path29);
    			append_dev(svg, symbol30);
    			append_dev(symbol30, path30);
    			append_dev(svg, symbol31);
    			append_dev(symbol31, path31);
    			append_dev(svg, symbol32);
    			append_dev(symbol32, path32);
    			append_dev(svg, symbol33);
    			append_dev(symbol33, path33);
    			append_dev(svg, symbol34);
    			append_dev(symbol34, path34);
    			append_dev(svg, symbol35);
    			append_dev(symbol35, path35);
    			append_dev(svg, symbol36);
    			append_dev(symbol36, path36);
    			append_dev(symbol36, path37);
    			append_dev(symbol36, path38);
    			append_dev(svg, symbol37);
    			append_dev(symbol37, path39);
    			append_dev(svg, symbol38);
    			append_dev(symbol38, path40);
    			append_dev(symbol38, path41);
    			append_dev(symbol38, path42);
    			append_dev(svg, symbol39);
    			append_dev(symbol39, path43);
    			append_dev(symbol39, path44);
    			append_dev(symbol39, path45);
    			append_dev(svg, symbol40);
    			append_dev(symbol40, path46);
    			append_dev(svg, symbol41);
    			append_dev(symbol41, path47);
    			append_dev(symbol41, path48);
    			append_dev(symbol41, path49);
    			append_dev(svg, symbol42);
    			append_dev(symbol42, path50);
    			append_dev(svg, symbol43);
    			append_dev(symbol43, path51);
    			append_dev(svg, symbol44);
    			append_dev(symbol44, path52);
    			append_dev(svg, symbol45);
    			append_dev(symbol45, path53);
    			append_dev(svg, symbol46);
    			append_dev(symbol46, path54);
    			append_dev(svg, symbol47);
    			append_dev(symbol47, path55);
    			append_dev(svg, symbol48);
    			append_dev(symbol48, path56);
    			append_dev(svg, symbol49);
    			append_dev(symbol49, path57);
    			append_dev(svg, symbol50);
    			append_dev(symbol50, path58);
    			append_dev(symbol50, path59);
    			append_dev(svg, symbol51);
    			append_dev(symbol51, path60);
    			append_dev(svg, symbol52);
    			append_dev(symbol52, path61);
    			append_dev(svg, symbol53);
    			append_dev(symbol53, path62);
    			append_dev(svg, symbol54);
    			append_dev(symbol54, path63);
    			append_dev(svg, symbol55);
    			append_dev(symbol55, path64);
    			append_dev(svg, symbol56);
    			append_dev(symbol56, path65);
    			append_dev(svg, symbol57);
    			append_dev(symbol57, path66);
    			append_dev(svg, symbol58);
    			append_dev(symbol58, path67);
    			append_dev(svg, symbol59);
    			append_dev(symbol59, path68);
    			append_dev(svg, symbol60);
    			append_dev(symbol60, path69);
    			append_dev(svg, symbol61);
    			append_dev(symbol61, path70);
    			append_dev(svg, symbol62);
    			append_dev(symbol62, path71);
    			append_dev(svg, symbol63);
    			append_dev(symbol63, path72);
    			append_dev(svg, symbol64);
    			append_dev(symbol64, path73);
    			append_dev(svg, symbol65);
    			append_dev(symbol65, path74);
    			append_dev(svg, symbol66);
    			append_dev(symbol66, path75);
    			append_dev(svg, symbol67);
    			append_dev(symbol67, path76);
    			append_dev(svg, symbol68);
    			append_dev(symbol68, path77);
    			append_dev(symbol68, path78);
    			append_dev(symbol68, path79);
    			append_dev(symbol68, path80);
    			append_dev(svg, symbol69);
    			append_dev(symbol69, path81);
    			append_dev(svg, symbol70);
    			append_dev(symbol70, path82);
    			append_dev(svg, symbol71);
    			append_dev(symbol71, path83);
    			append_dev(svg, symbol72);
    			append_dev(symbol72, path84);
    			append_dev(svg, symbol73);
    			append_dev(symbol73, path85);
    			append_dev(svg, symbol74);
    			append_dev(symbol74, path86);
    			append_dev(svg, symbol75);
    			append_dev(symbol75, path87);
    			append_dev(svg, symbol76);
    			append_dev(symbol76, path88);
    			append_dev(svg, symbol77);
    			append_dev(symbol77, path89);
    			append_dev(svg, symbol78);
    			append_dev(symbol78, path90);
    			append_dev(svg, symbol79);
    			append_dev(symbol79, path91);
    			append_dev(svg, symbol80);
    			append_dev(symbol80, path92);
    			append_dev(svg, symbol81);
    			append_dev(symbol81, path93);
    			append_dev(svg, symbol82);
    			append_dev(symbol82, path94);
    			append_dev(svg, symbol83);
    			append_dev(symbol83, path95);
    			append_dev(svg, symbol84);
    			append_dev(symbol84, path96);
    			append_dev(svg, symbol85);
    			append_dev(symbol85, path97);
    			append_dev(svg, symbol86);
    			append_dev(symbol86, path98);
    			append_dev(svg, symbol87);
    			append_dev(symbol87, path99);
    			append_dev(svg, symbol88);
    			append_dev(symbol88, path100);
    			append_dev(svg, symbol89);
    			append_dev(symbol89, path101);
    			append_dev(svg, symbol90);
    			append_dev(symbol90, path102);
    			append_dev(svg, symbol91);
    			append_dev(symbol91, path103);
    			append_dev(svg, symbol92);
    			append_dev(symbol92, path104);
    			append_dev(svg, symbol93);
    			append_dev(symbol93, path105);
    			append_dev(svg, symbol94);
    			append_dev(symbol94, path106);
    			append_dev(svg, symbol95);
    			append_dev(symbol95, path107);
    			append_dev(svg, symbol96);
    			append_dev(symbol96, path108);
    			append_dev(svg, symbol97);
    			append_dev(symbol97, path109);
    			append_dev(svg, symbol98);
    			append_dev(symbol98, path110);
    			append_dev(svg, symbol99);
    			append_dev(symbol99, path111);
    			append_dev(svg, symbol100);
    			append_dev(symbol100, path112);
    			append_dev(svg, symbol101);
    			append_dev(symbol101, path113);
    			append_dev(svg, symbol102);
    			append_dev(symbol102, path114);
    			append_dev(svg, symbol103);
    			append_dev(symbol103, path115);
    			append_dev(svg, symbol104);
    			append_dev(symbol104, path116);
    			append_dev(svg, symbol105);
    			append_dev(symbol105, path117);
    			append_dev(svg, symbol106);
    			append_dev(symbol106, rect);
    			append_dev(symbol106, path118);
    			append_dev(svg, symbol107);
    			append_dev(symbol107, path119);
    			append_dev(svg, symbol108);
    			append_dev(symbol108, path120);
    			append_dev(svg, symbol109);
    			append_dev(symbol109, path121);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Icons_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Icons_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icons_svg_rollup_plugin",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* docs_src/assets/icons/github.svg.rollup-plugin.svelte generated by Svelte v3.53.1 */

    const file$3 = "docs_src/assets/icons/github.svg.rollup-plugin.svelte";

    function create_fragment$3(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fab" },
    		{ "data-icon": "github" },
    		{
    			class: "svg-inline--fa fa-github fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 496 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z");
    			add_location(path, file$3, 0, 202, 202);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$3, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fab" },
    				{ "data-icon": "github" },
    				{
    					class: "svg-inline--fa fa-github fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 496 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Github_svg_rollup_plugin', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Github_svg_rollup_plugin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Github_svg_rollup_plugin",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* docs_src/main/Navbar.svelte generated by Svelte v3.53.1 */
    const file$2 = "docs_src/main/Navbar.svelte";

    // (16:6) <Button size="small" initial={$sourceType === 'svelte'} on:click={() => changeSourceType('svelte')}>
    function create_default_slot_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Svelte");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(16:6) <Button size=\\\"small\\\" initial={$sourceType === 'svelte'} on:click={() => changeSourceType('svelte')}>",
    		ctx
    	});

    	return block;
    }

    // (18:6) <Button size="small" initial={$sourceType === 'html'} on:click={() => changeSourceType('html')}>
    function create_default_slot_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("HTML");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(18:6) <Button size=\\\"small\\\" initial={$sourceType === 'html'} on:click={() => changeSourceType('html')}>",
    		ctx
    	});

    	return block;
    }

    // (15:4) <ButtonGroup type="secondary">
    function create_default_slot(ctx) {
    	let button0;
    	let t;
    	let button1;
    	let current;

    	button0 = new Button$1({
    			props: {
    				size: "small",
    				initial: /*$sourceType*/ ctx[0] === 'svelte',
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler*/ ctx[2]);

    	button1 = new Button$1({
    			props: {
    				size: "small",
    				initial: /*$sourceType*/ ctx[0] === 'html',
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_1*/ ctx[3]);

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t = space();
    			create_component(button1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(button1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};
    			if (dirty & /*$sourceType*/ 1) button0_changes.initial = /*$sourceType*/ ctx[0] === 'svelte';

    			if (dirty & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};
    			if (dirty & /*$sourceType*/ 1) button1_changes.initial = /*$sourceType*/ ctx[0] === 'html';

    			if (dirty & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(button1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(15:4) <ButtonGroup type=\\\"secondary\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let div;
    	let nav;
    	let a;
    	let githubicon;
    	let t0;
    	let span;
    	let t2;
    	let buttongroup;
    	let current;
    	githubicon = new Github_svg_rollup_plugin({ props: { width: 20 }, $$inline: true });

    	buttongroup = new ButtonGroup({
    			props: {
    				type: "secondary",
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			nav = element("nav");
    			a = element("a");
    			create_component(githubicon.$$.fragment);
    			t0 = space();
    			span = element("span");
    			span.textContent = "Github";
    			t2 = space();
    			create_component(buttongroup.$$.fragment);
    			attr_dev(span, "class", "flex flex-align--end padding-s--l");
    			add_location(span, file$2, 12, 6, 545);
    			attr_dev(a, "href", "https://github.com/EkstraBladetUdvikling/eb-designsystem");
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "class", "flex svelte-1bwbuf8");
    			attr_dev(a, "rel", "noreferrer");
    			add_location(a, file$2, 10, 4, 393);
    			attr_dev(nav, "class", "navmenu flex flex-justify--between flex-align--center padding-xl--rl svelte-1bwbuf8");
    			add_location(nav, file$2, 9, 2, 306);
    			attr_dev(div, "class", "navmenu-container position-fixed margin-xl--b bg-red svelte-1bwbuf8");
    			add_location(div, file$2, 8, 0, 237);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, nav);
    			append_dev(nav, a);
    			mount_component(githubicon, a, null);
    			append_dev(a, t0);
    			append_dev(a, span);
    			append_dev(nav, t2);
    			mount_component(buttongroup, nav, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const buttongroup_changes = {};

    			if (dirty & /*$$scope, $sourceType*/ 17) {
    				buttongroup_changes.$$scope = { dirty, ctx };
    			}

    			buttongroup.$set(buttongroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(githubicon.$$.fragment, local);
    			transition_in(buttongroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(githubicon.$$.fragment, local);
    			transition_out(buttongroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(githubicon);
    			destroy_component(buttongroup);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Navbar', slots, []);

    	function changeSourceType(source) {
    		sourceType.set(source);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Navbar> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => changeSourceType('svelte');
    	const click_handler_1 = () => changeSourceType('html');

    	$$self.$capture_state = () => ({
    		GithubIcon: Github_svg_rollup_plugin,
    		sourceType,
    		Button: Button$1,
    		ButtonGroup,
    		changeSourceType,
    		$sourceType
    	});

    	return [$sourceType, changeSourceType, click_handler, click_handler_1];
    }

    class Navbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navbar",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* docs_src/main/Sidebar.svelte generated by Svelte v3.53.1 */
    const file$1 = "docs_src/main/Sidebar.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (37:8) {#each group.routes as menuItem}
    function create_each_block_1(ctx) {
    	let a;
    	let t0_value = /*menuItem*/ ctx[4].title + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(a, "class", "sidebar-item width-1of1 padding-m--t padding-m--rl svelte-2rfg6s");
    			attr_dev(a, "href", "#a11y");
    			toggle_class(a, "active-item", /*menuItem*/ ctx[4].href === /*$location*/ ctx[0]);
    			add_location(a, file$1, 37, 10, 1308);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t0);
    			append_dev(a, t1);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a, {
    					disabled: false,
    					href: /*menuItem*/ ctx[4].href
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*menuItems, $location*/ 1) {
    				toggle_class(a, "active-item", /*menuItem*/ ctx[4].href === /*$location*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(37:8) {#each group.routes as menuItem}",
    		ctx
    	});

    	return block;
    }

    // (28:2) {#each menuItems as group}
    function create_each_block(ctx) {
    	let div2;
    	let div0;
    	let a;
    	let t0_value = /*group*/ ctx[1].title + "";
    	let t0;
    	let t1;
    	let div1;
    	let t2;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*group*/ ctx[1].routes;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			attr_dev(a, "href", "#a11y");
    			attr_dev(a, "class", "svelte-2rfg6s");
    			toggle_class(a, "active-item", /*group*/ ctx[1].href === /*$location*/ ctx[0]);
    			add_location(a, file$1, 30, 8, 1053);
    			attr_dev(div0, "class", "sidebar-submenu-title fontsize-small svelte-2rfg6s");
    			add_location(div0, file$1, 29, 6, 994);
    			attr_dev(div1, "class", "sidebar-submenu-items");
    			add_location(div1, file$1, 35, 6, 1221);
    			attr_dev(div2, "class", "sidebar-menuitem-container padding-l svelte-2rfg6s");
    			add_location(div2, file$1, 28, 4, 937);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, a);
    			append_dev(a, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div2, t2);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a, {
    					disabled: false,
    					href: /*group*/ ctx[1].href
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*menuItems, $location*/ 1) {
    				toggle_class(a, "active-item", /*group*/ ctx[1].href === /*$location*/ ctx[0]);
    			}

    			if (dirty & /*menuItems, $location*/ 1) {
    				each_value_1 = /*group*/ ctx[1].routes;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(28:2) {#each menuItems as group}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let div5;
    	let div2;
    	let div0;
    	let a0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div1;
    	let p;
    	let t2;
    	let div4;
    	let div3;
    	let a1;
    	let t4;
    	let mounted;
    	let dispose;
    	let each_value = menuItems;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			a0 = element("a");
    			img = element("img");
    			t0 = space();
    			div1 = element("div");
    			p = element("p");
    			p.textContent = "Design system";
    			t2 = space();
    			div4 = element("div");
    			div3 = element("div");
    			a1 = element("a");
    			a1.textContent = "Overview";
    			t4 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(img, "alt", "");
    			if (!src_url_equal(img.src, img_src_value = "ekstrabladet.svg")) attr_dev(img, "src", img_src_value);
    			set_style(img, "height", "70px");
    			add_location(img, file$1, 8, 8, 329);
    			attr_dev(a0, "href", "#/");
    			attr_dev(a0, "class", "svelte-2rfg6s");
    			add_location(a0, file$1, 7, 6, 307);
    			add_location(div0, file$1, 6, 4, 295);
    			attr_dev(p, "class", "flex--grow width-1of1 color--graa1 fontweight-bold");
    			add_location(p, file$1, 12, 6, 462);
    			attr_dev(div1, "class", "flex-item flex-item--center");
    			add_location(div1, file$1, 11, 4, 414);
    			attr_dev(div2, "class", "flex flex-justify--around sidebar-logo-container padding-m--rl svelte-2rfg6s");
    			add_location(div2, file$1, 5, 2, 214);
    			attr_dev(a1, "class", "sidebar-item width-1of1 padding-m--t padding-m--rl svelte-2rfg6s");
    			attr_dev(a1, "href", "#a11y");
    			toggle_class(a1, "active-item", '/' === /*$location*/ ctx[0]);
    			add_location(a1, file$1, 17, 6, 661);
    			attr_dev(div3, "class", "sidebar-submenu-items");
    			add_location(div3, file$1, 16, 4, 619);
    			attr_dev(div4, "class", "sidebar-menuitem-container padding-l svelte-2rfg6s");
    			add_location(div4, file$1, 15, 2, 564);
    			attr_dev(div5, "id", "sidebar-menu");
    			attr_dev(div5, "class", "sidebar-container height-100vh bg--white margin-l--r svelte-2rfg6s");
    			add_location(div5, file$1, 4, 0, 127);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div2);
    			append_dev(div2, div0);
    			append_dev(div0, a0);
    			append_dev(a0, img);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, p);
    			append_dev(div5, t2);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, a1);
    			append_dev(div5, t4);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div5, null);
    			}

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a1, { disabled: false, href: '/' }));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$location*/ 1) {
    				toggle_class(a1, "active-item", '/' === /*$location*/ ctx[0]);
    			}

    			if (dirty & /*menuItems, $location*/ 1) {
    				each_value = menuItems;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div5, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $location;
    	validate_store(location, 'location');
    	component_subscribe($$self, location, $$value => $$invalidate(0, $location = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Sidebar', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sidebar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ link, location, menuItems, $location });
    	return [$location];
    }

    class Sidebar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Sidebar",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* docs_src/App.svelte generated by Svelte v3.53.1 */
    const file = "docs_src/App.svelte";

    function create_fragment(ctx) {
    	let navbar;
    	let t0;
    	let sidebar;
    	let t1;
    	let div;
    	let router;
    	let t2;
    	let icons;
    	let current;
    	navbar = new Navbar({ $$inline: true });
    	sidebar = new Sidebar({ $$inline: true });
    	router = new Router({ props: { routes }, $$inline: true });
    	icons = new Icons_svg_rollup_plugin({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			create_component(sidebar.$$.fragment);
    			t1 = space();
    			div = element("div");
    			create_component(router.$$.fragment);
    			t2 = space();
    			create_component(icons.$$.fragment);
    			attr_dev(div, "class", "content-container padding-xl svelte-ftylog");
    			add_location(div, file, 10, 0, 305);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(sidebar, target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(router, div, null);
    			insert_dev(target, t2, anchor);
    			mount_component(icons, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(sidebar.$$.fragment, local);
    			transition_in(router.$$.fragment, local);
    			transition_in(icons.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(sidebar.$$.fragment, local);
    			transition_out(router.$$.fragment, local);
    			transition_out(icons.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(sidebar, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(router);
    			if (detaching) detach_dev(t2);
    			destroy_component(icons, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Router, routes, Icons: Icons_svg_rollup_plugin, Navbar, Sidebar });
    	return [];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
        target: document.body,
    });

    return app;

})();
