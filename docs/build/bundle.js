
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_slots(slots) {
        const result = {};
        for (const key in slots) {
            result[key] = true;
        }
        return result;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function set_svg_attributes(node, attributes) {
        for (const key in attributes) {
            attr(node, key, attributes[key]);
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }
    class HtmlTag {
        constructor() {
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.42.6' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /**
     * @typedef {Object} WrappedComponent Object returned by the `wrap` method
     * @property {SvelteComponent} component - Component to load (this is always asynchronous)
     * @property {RoutePrecondition[]} [conditions] - Route pre-conditions to validate
     * @property {Object} [props] - Optional dictionary of static props
     * @property {Object} [userData] - Optional user data dictionary
     * @property {bool} _sveltesparouter - Internal flag; always set to true
     */

    /**
     * @callback AsyncSvelteComponent
     * @returns {Promise<SvelteComponent>} Returns a Promise that resolves with a Svelte component
     */

    /**
     * @callback RoutePrecondition
     * @param {RouteDetail} detail - Route detail object
     * @returns {boolean|Promise<boolean>} If the callback returns a false-y value, it's interpreted as the precondition failed, so it aborts loading the component (and won't process other pre-condition callbacks)
     */

    /**
     * @typedef {Object} WrapOptions Options object for the call to `wrap`
     * @property {SvelteComponent} [component] - Svelte component to load (this is incompatible with `asyncComponent`)
     * @property {AsyncSvelteComponent} [asyncComponent] - Function that returns a Promise that fulfills with a Svelte component (e.g. `{asyncComponent: () => import('Foo.svelte')}`)
     * @property {SvelteComponent} [loadingComponent] - Svelte component to be displayed while the async route is loading (as a placeholder); when unset or false-y, no component is shown while component
     * @property {object} [loadingParams] - Optional dictionary passed to the `loadingComponent` component as params (for an exported prop called `params`)
     * @property {object} [userData] - Optional object that will be passed to events such as `routeLoading`, `routeLoaded`, `conditionsFailed`
     * @property {object} [props] - Optional key-value dictionary of static props that will be passed to the component. The props are expanded with {...props}, so the key in the dictionary becomes the name of the prop.
     * @property {RoutePrecondition[]|RoutePrecondition} [conditions] - Route pre-conditions to add, which will be executed in order
     */

    /**
     * Wraps a component to enable multiple capabilities:
     * 1. Using dynamically-imported component, with (e.g. `{asyncComponent: () => import('Foo.svelte')}`), which also allows bundlers to do code-splitting.
     * 2. Adding route pre-conditions (e.g. `{conditions: [...]}`)
     * 3. Adding static props that are passed to the component
     * 4. Adding custom userData, which is passed to route events (e.g. route loaded events) or to route pre-conditions (e.g. `{userData: {foo: 'bar}}`)
     * 
     * @param {WrapOptions} args - Arguments object
     * @returns {WrappedComponent} Wrapped component
     */
    function wrap$1(args) {
        if (!args) {
            throw Error('Parameter args is required')
        }

        // We need to have one and only one of component and asyncComponent
        // This does a "XNOR"
        if (!args.component == !args.asyncComponent) {
            throw Error('One and only one of component and asyncComponent is required')
        }

        // If the component is not async, wrap it into a function returning a Promise
        if (args.component) {
            args.asyncComponent = () => Promise.resolve(args.component);
        }

        // Parameter asyncComponent and each item of conditions must be functions
        if (typeof args.asyncComponent != 'function') {
            throw Error('Parameter asyncComponent must be a function')
        }
        if (args.conditions) {
            // Ensure it's an array
            if (!Array.isArray(args.conditions)) {
                args.conditions = [args.conditions];
            }
            for (let i = 0; i < args.conditions.length; i++) {
                if (!args.conditions[i] || typeof args.conditions[i] != 'function') {
                    throw Error('Invalid parameter conditions[' + i + ']')
                }
            }
        }

        // Check if we have a placeholder component
        if (args.loadingComponent) {
            args.asyncComponent.loading = args.loadingComponent;
            args.asyncComponent.loadingParams = args.loadingParams || undefined;
        }

        // Returns an object that contains all the functions to execute too
        // The _sveltesparouter flag is to confirm the object was created by this router
        const obj = {
            component: args.asyncComponent,
            userData: args.userData,
            conditions: (args.conditions && args.conditions.length) ? args.conditions : undefined,
            props: (args.props && Object.keys(args.props).length) ? args.props : {},
            _sveltesparouter: true
        };

        return obj
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    function parse(str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules/svelte-spa-router/Router.svelte generated by Svelte v3.42.6 */

    const { Error: Error_1, Object: Object_1, console: console_1$1 } = globals;

    // (251:0) {:else}
    function create_else_block$k(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$k.name,
    		type: "else",
    		source: "(251:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (244:0) {#if componentParams}
    function create_if_block$p(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ params: /*componentParams*/ ctx[1] }, /*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*componentParams, props*/ 6)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*componentParams*/ 2 && { params: /*componentParams*/ ctx[1] },
    					dirty & /*props*/ 4 && get_spread_object(/*props*/ ctx[2])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(244:0) {#if componentParams}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1o(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$p, create_else_block$k];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*componentParams*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function wrap(component, userData, ...conditions) {
    	// Use the new wrap method and show a deprecation warning
    	// eslint-disable-next-line no-console
    	console.warn('Method `wrap` from `svelte-spa-router` is deprecated and will be removed in a future version. Please use `svelte-spa-router/wrap` instead. See http://bit.ly/svelte-spa-router-upgrading');

    	return wrap$1({ component, userData, conditions });
    }

    /**
     * @typedef {Object} Location
     * @property {string} location - Location (page/view), for example `/book`
     * @property {string} [querystring] - Querystring from the hash, as a string not parsed
     */
    /**
     * Returns the current location from the hash.
     *
     * @returns {Location} Location object
     * @private
     */
    function getLocation() {
    	const hashPosition = window.location.href.indexOf('#/');

    	let location = hashPosition > -1
    	? window.location.href.substr(hashPosition + 1)
    	: '/';

    	// Check if there's a querystring
    	const qsPosition = location.indexOf('?');

    	let querystring = '';

    	if (qsPosition > -1) {
    		querystring = location.substr(qsPosition + 1);
    		location = location.substr(0, qsPosition);
    	}

    	return { location, querystring };
    }

    const loc = readable(null, // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
    	set(getLocation());

    	const update = () => {
    		set(getLocation());
    	};

    	window.addEventListener('hashchange', update, false);

    	return function stop() {
    		window.removeEventListener('hashchange', update, false);
    	};
    });

    const location = derived(loc, $loc => $loc.location);
    const querystring = derived(loc, $loc => $loc.querystring);
    const params = writable(undefined);

    async function push(location) {
    	if (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {
    		throw Error('Invalid parameter location');
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	// Note: this will include scroll state in history even when restoreScrollState is false
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	window.location.hash = (location.charAt(0) == '#' ? '' : '#') + location;
    }

    async function pop() {
    	// Execute this code when the current call stack is complete
    	await tick();

    	window.history.back();
    }

    async function replace(location) {
    	if (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {
    		throw Error('Invalid parameter location');
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	const dest = (location.charAt(0) == '#' ? '' : '#') + location;

    	try {
    		const newState = { ...history.state };
    		delete newState['__svelte_spa_router_scrollX'];
    		delete newState['__svelte_spa_router_scrollY'];
    		window.history.replaceState(newState, undefined, dest);
    	} catch(e) {
    		// eslint-disable-next-line no-console
    		console.warn('Caught exception while replacing the current page. If you\'re running this in the Svelte REPL, please note that the `replace` method might not work in this environment.');
    	}

    	// The method above doesn't trigger the hashchange event, so let's do that manually
    	window.dispatchEvent(new Event('hashchange'));
    }

    function link(node, opts) {
    	opts = linkOpts(opts);

    	// Only apply to <a> tags
    	if (!node || !node.tagName || node.tagName.toLowerCase() != 'a') {
    		throw Error('Action "link" can only be used with <a> tags');
    	}

    	updateLink(node, opts);

    	return {
    		update(updated) {
    			updated = linkOpts(updated);
    			updateLink(node, updated);
    		}
    	};
    }

    // Internal function used by the link function
    function updateLink(node, opts) {
    	let href = opts.href || node.getAttribute('href');

    	// Destination must start with '/' or '#/'
    	if (href && href.charAt(0) == '/') {
    		// Add # to the href attribute
    		href = '#' + href;
    	} else if (!href || href.length < 2 || href.slice(0, 2) != '#/') {
    		throw Error('Invalid value for "href" attribute: ' + href);
    	}

    	node.setAttribute('href', href);

    	node.addEventListener('click', event => {
    		// Prevent default anchor onclick behaviour
    		event.preventDefault();

    		if (!opts.disabled) {
    			scrollstateHistoryHandler(event.currentTarget.getAttribute('href'));
    		}
    	});
    }

    // Internal function that ensures the argument of the link action is always an object
    function linkOpts(val) {
    	if (val && typeof val == 'string') {
    		return { href: val };
    	} else {
    		return val || {};
    	}
    }

    /**
     * The handler attached to an anchor tag responsible for updating the
     * current history state with the current scroll state
     *
     * @param {string} href - Destination
     */
    function scrollstateHistoryHandler(href) {
    	// Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	// This will force an update as desired, but this time our scroll state will be attached
    	window.location.hash = href;
    }

    function instance$1o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Router', slots, []);
    	let { routes = {} } = $$props;
    	let { prefix = '' } = $$props;
    	let { restoreScrollState = false } = $$props;

    	/**
     * Container for a route: path, component
     */
    	class RouteItem {
    		/**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
     */
    		constructor(path, component) {
    			if (!component || typeof component != 'function' && (typeof component != 'object' || component._sveltesparouter !== true)) {
    				throw Error('Invalid component object');
    			}

    			// Path must be a regular or expression, or a string starting with '/' or '*'
    			if (!path || typeof path == 'string' && (path.length < 1 || path.charAt(0) != '/' && path.charAt(0) != '*') || typeof path == 'object' && !(path instanceof RegExp)) {
    				throw Error('Invalid value for "path" argument - strings must start with / or *');
    			}

    			const { pattern, keys } = parse(path);
    			this.path = path;

    			// Check if the component is wrapped and we have conditions
    			if (typeof component == 'object' && component._sveltesparouter === true) {
    				this.component = component.component;
    				this.conditions = component.conditions || [];
    				this.userData = component.userData;
    				this.props = component.props || {};
    			} else {
    				// Convert the component to a function that returns a Promise, to normalize it
    				this.component = () => Promise.resolve(component);

    				this.conditions = [];
    				this.props = {};
    			}

    			this._pattern = pattern;
    			this._keys = keys;
    		}

    		/**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    		match(path) {
    			// If there's a prefix, check if it matches the start of the path.
    			// If not, bail early, else remove it before we run the matching.
    			if (prefix) {
    				if (typeof prefix == 'string') {
    					if (path.startsWith(prefix)) {
    						path = path.substr(prefix.length) || '/';
    					} else {
    						return null;
    					}
    				} else if (prefix instanceof RegExp) {
    					const match = path.match(prefix);

    					if (match && match[0]) {
    						path = path.substr(match[0].length) || '/';
    					} else {
    						return null;
    					}
    				}
    			}

    			// Check if the pattern matches
    			const matches = this._pattern.exec(path);

    			if (matches === null) {
    				return null;
    			}

    			// If the input was a regular expression, this._keys would be false, so return matches as is
    			if (this._keys === false) {
    				return matches;
    			}

    			const out = {};
    			let i = 0;

    			while (i < this._keys.length) {
    				// In the match parameters, URL-decode all values
    				try {
    					out[this._keys[i]] = decodeURIComponent(matches[i + 1] || '') || null;
    				} catch(e) {
    					out[this._keys[i]] = null;
    				}

    				i++;
    			}

    			return out;
    		}

    		/**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {object} [userData] - Custom data passed by the user
     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
     */
    		/**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {boolean} Returns true if all the conditions succeeded
     */
    		async checkConditions(detail) {
    			for (let i = 0; i < this.conditions.length; i++) {
    				if (!await this.conditions[i](detail)) {
    					return false;
    				}
    			}

    			return true;
    		}
    	}

    	// Set up all routes
    	const routesList = [];

    	if (routes instanceof Map) {
    		// If it's a map, iterate on it right away
    		routes.forEach((route, path) => {
    			routesList.push(new RouteItem(path, route));
    		});
    	} else {
    		// We have an object, so iterate on its own properties
    		Object.keys(routes).forEach(path => {
    			routesList.push(new RouteItem(path, routes[path]));
    		});
    	}

    	// Props for the component to render
    	let component = null;

    	let componentParams = null;
    	let props = {};

    	// Event dispatcher from Svelte
    	const dispatch = createEventDispatcher();

    	// Just like dispatch, but executes on the next iteration of the event loop
    	async function dispatchNextTick(name, detail) {
    		// Execute this code when the current call stack is complete
    		await tick();

    		dispatch(name, detail);
    	}

    	// If this is set, then that means we have popped into this var the state of our last scroll position
    	let previousScrollState = null;

    	let popStateChanged = null;

    	if (restoreScrollState) {
    		popStateChanged = event => {
    			// If this event was from our history.replaceState, event.state will contain
    			// our scroll history. Otherwise, event.state will be null (like on forward
    			// navigation)
    			if (event.state && event.state.__svelte_spa_router_scrollY) {
    				previousScrollState = event.state;
    			} else {
    				previousScrollState = null;
    			}
    		};

    		// This is removed in the destroy() invocation below
    		window.addEventListener('popstate', popStateChanged);

    		afterUpdate(() => {
    			// If this exists, then this is a back navigation: restore the scroll position
    			if (previousScrollState) {
    				window.scrollTo(previousScrollState.__svelte_spa_router_scrollX, previousScrollState.__svelte_spa_router_scrollY);
    			} else {
    				// Otherwise this is a forward navigation: scroll to top
    				window.scrollTo(0, 0);
    			}
    		});
    	}

    	// Always have the latest value of loc
    	let lastLoc = null;

    	// Current object of the component loaded
    	let componentObj = null;

    	// Handle hash change events
    	// Listen to changes in the $loc store and update the page
    	// Do not use the $: syntax because it gets triggered by too many things
    	const unsubscribeLoc = loc.subscribe(async newLoc => {
    		lastLoc = newLoc;

    		// Find a route matching the location
    		let i = 0;

    		while (i < routesList.length) {
    			const match = routesList[i].match(newLoc.location);

    			if (!match) {
    				i++;
    				continue;
    			}

    			const detail = {
    				route: routesList[i].path,
    				location: newLoc.location,
    				querystring: newLoc.querystring,
    				userData: routesList[i].userData,
    				params: match && typeof match == 'object' && Object.keys(match).length
    				? match
    				: null
    			};

    			// Check if the route can be loaded - if all conditions succeed
    			if (!await routesList[i].checkConditions(detail)) {
    				// Don't display anything
    				$$invalidate(0, component = null);

    				componentObj = null;

    				// Trigger an event to notify the user, then exit
    				dispatchNextTick('conditionsFailed', detail);

    				return;
    			}

    			// Trigger an event to alert that we're loading the route
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoading', Object.assign({}, detail));

    			// If there's a component to show while we're loading the route, display it
    			const obj = routesList[i].component;

    			// Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted
    			if (componentObj != obj) {
    				if (obj.loading) {
    					$$invalidate(0, component = obj.loading);
    					componentObj = obj;
    					$$invalidate(1, componentParams = obj.loadingParams);
    					$$invalidate(2, props = {});

    					// Trigger the routeLoaded event for the loading component
    					// Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)
    					dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    						component,
    						name: component.name,
    						params: componentParams
    					}));
    				} else {
    					$$invalidate(0, component = null);
    					componentObj = null;
    				}

    				// Invoke the Promise
    				const loaded = await obj();

    				// Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile
    				if (newLoc != lastLoc) {
    					// Don't update the component, just exit
    					return;
    				}

    				// If there is a "default" property, which is used by async routes, then pick that
    				$$invalidate(0, component = loaded && loaded.default || loaded);

    				componentObj = obj;
    			}

    			// Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`
    			// Of course, this assumes that developers always add a "params" prop when they are expecting parameters
    			if (match && typeof match == 'object' && Object.keys(match).length) {
    				$$invalidate(1, componentParams = match);
    			} else {
    				$$invalidate(1, componentParams = null);
    			}

    			// Set static props, if any
    			$$invalidate(2, props = routesList[i].props);

    			// Dispatch the routeLoaded event then exit
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    				component,
    				name: component.name,
    				params: componentParams
    			})).then(() => {
    				params.set(componentParams);
    			});

    			return;
    		}

    		// If we're still here, there was no match, so show the empty component
    		$$invalidate(0, component = null);

    		componentObj = null;
    		params.set(undefined);
    	});

    	onDestroy(() => {
    		unsubscribeLoc();
    		popStateChanged && window.removeEventListener('popstate', popStateChanged);
    	});

    	const writable_props = ['routes', 'prefix', 'restoreScrollState'];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	function routeEvent_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function routeEvent_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('routes' in $$props) $$invalidate(3, routes = $$props.routes);
    		if ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    	};

    	$$self.$capture_state = () => ({
    		readable,
    		writable,
    		derived,
    		tick,
    		_wrap: wrap$1,
    		wrap,
    		getLocation,
    		loc,
    		location,
    		querystring,
    		params,
    		push,
    		pop,
    		replace,
    		link,
    		updateLink,
    		linkOpts,
    		scrollstateHistoryHandler,
    		onDestroy,
    		createEventDispatcher,
    		afterUpdate,
    		parse,
    		routes,
    		prefix,
    		restoreScrollState,
    		RouteItem,
    		routesList,
    		component,
    		componentParams,
    		props,
    		dispatch,
    		dispatchNextTick,
    		previousScrollState,
    		popStateChanged,
    		lastLoc,
    		componentObj,
    		unsubscribeLoc
    	});

    	$$self.$inject_state = $$props => {
    		if ('routes' in $$props) $$invalidate(3, routes = $$props.routes);
    		if ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    		if ('component' in $$props) $$invalidate(0, component = $$props.component);
    		if ('componentParams' in $$props) $$invalidate(1, componentParams = $$props.componentParams);
    		if ('props' in $$props) $$invalidate(2, props = $$props.props);
    		if ('previousScrollState' in $$props) previousScrollState = $$props.previousScrollState;
    		if ('popStateChanged' in $$props) popStateChanged = $$props.popStateChanged;
    		if ('lastLoc' in $$props) lastLoc = $$props.lastLoc;
    		if ('componentObj' in $$props) componentObj = $$props.componentObj;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*restoreScrollState*/ 32) {
    			// Update history.scrollRestoration depending on restoreScrollState
    			history.scrollRestoration = restoreScrollState ? 'manual' : 'auto';
    		}
    	};

    	return [
    		component,
    		componentParams,
    		props,
    		routes,
    		prefix,
    		restoreScrollState,
    		routeEvent_handler,
    		routeEvent_handler_1
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1o, create_fragment$1o, safe_not_equal, {
    			routes: 3,
    			prefix: 4,
    			restoreScrollState: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment$1o.name
    		});
    	}

    	get routes() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get restoreScrollState() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set restoreScrollState(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    if (window.Prism)
        console.warn('Prism has already been initiated. Please ensure that svelte-prism is imported first.');

    window.Prism = window.Prism || {};
    window.Prism.manual = true;

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    var prism$2 = {exports: {}};

    (function (module) {
    /* **********************************************
         Begin prism-core.js
    ********************************************** */

    /// <reference lib="WebWorker"/>

    var _self = (typeof window !== 'undefined')
    	? window   // if in browser
    	: (
    		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
    			? self // if in worker
    			: {}   // if in node js
    	);

    /**
     * Prism: Lightweight, robust, elegant syntax highlighting
     *
     * @license MIT <https://opensource.org/licenses/MIT>
     * @author Lea Verou <https://lea.verou.me>
     * @namespace
     * @public
     */
    var Prism = (function (_self) {

    	// Private helper vars
    	var lang = /\blang(?:uage)?-([\w-]+)\b/i;
    	var uniqueId = 0;

    	// The grammar object for plaintext
    	var plainTextGrammar = {};


    	var _ = {
    		/**
    		 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
    		 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
    		 * additional languages or plugins yourself.
    		 *
    		 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
    		 *
    		 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
    		 * empty Prism object into the global scope before loading the Prism script like this:
    		 *
    		 * ```js
    		 * window.Prism = window.Prism || {};
    		 * Prism.manual = true;
    		 * // add a new <script> to load Prism's script
    		 * ```
    		 *
    		 * @default false
    		 * @type {boolean}
    		 * @memberof Prism
    		 * @public
    		 */
    		manual: _self.Prism && _self.Prism.manual,
    		disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

    		/**
    		 * A namespace for utility methods.
    		 *
    		 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
    		 * change or disappear at any time.
    		 *
    		 * @namespace
    		 * @memberof Prism
    		 */
    		util: {
    			encode: function encode(tokens) {
    				if (tokens instanceof Token) {
    					return new Token(tokens.type, encode(tokens.content), tokens.alias);
    				} else if (Array.isArray(tokens)) {
    					return tokens.map(encode);
    				} else {
    					return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
    				}
    			},

    			/**
    			 * Returns the name of the type of the given value.
    			 *
    			 * @param {any} o
    			 * @returns {string}
    			 * @example
    			 * type(null)      === 'Null'
    			 * type(undefined) === 'Undefined'
    			 * type(123)       === 'Number'
    			 * type('foo')     === 'String'
    			 * type(true)      === 'Boolean'
    			 * type([1, 2])    === 'Array'
    			 * type({})        === 'Object'
    			 * type(String)    === 'Function'
    			 * type(/abc+/)    === 'RegExp'
    			 */
    			type: function (o) {
    				return Object.prototype.toString.call(o).slice(8, -1);
    			},

    			/**
    			 * Returns a unique number for the given object. Later calls will still return the same number.
    			 *
    			 * @param {Object} obj
    			 * @returns {number}
    			 */
    			objId: function (obj) {
    				if (!obj['__id']) {
    					Object.defineProperty(obj, '__id', { value: ++uniqueId });
    				}
    				return obj['__id'];
    			},

    			/**
    			 * Creates a deep clone of the given object.
    			 *
    			 * The main intended use of this function is to clone language definitions.
    			 *
    			 * @param {T} o
    			 * @param {Record<number, any>} [visited]
    			 * @returns {T}
    			 * @template T
    			 */
    			clone: function deepClone(o, visited) {
    				visited = visited || {};

    				var clone; var id;
    				switch (_.util.type(o)) {
    					case 'Object':
    						id = _.util.objId(o);
    						if (visited[id]) {
    							return visited[id];
    						}
    						clone = /** @type {Record<string, any>} */ ({});
    						visited[id] = clone;

    						for (var key in o) {
    							if (o.hasOwnProperty(key)) {
    								clone[key] = deepClone(o[key], visited);
    							}
    						}

    						return /** @type {any} */ (clone);

    					case 'Array':
    						id = _.util.objId(o);
    						if (visited[id]) {
    							return visited[id];
    						}
    						clone = [];
    						visited[id] = clone;

    						(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
    							clone[i] = deepClone(v, visited);
    						});

    						return /** @type {any} */ (clone);

    					default:
    						return o;
    				}
    			},

    			/**
    			 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
    			 *
    			 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
    			 *
    			 * @param {Element} element
    			 * @returns {string}
    			 */
    			getLanguage: function (element) {
    				while (element && !lang.test(element.className)) {
    					element = element.parentElement;
    				}
    				if (element) {
    					return (element.className.match(lang) || [, 'none'])[1].toLowerCase();
    				}
    				return 'none';
    			},

    			/**
    			 * Returns the script element that is currently executing.
    			 *
    			 * This does __not__ work for line script element.
    			 *
    			 * @returns {HTMLScriptElement | null}
    			 */
    			currentScript: function () {
    				if (typeof document === 'undefined') {
    					return null;
    				}
    				if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
    					return /** @type {any} */ (document.currentScript);
    				}

    				// IE11 workaround
    				// we'll get the src of the current script by parsing IE11's error stack trace
    				// this will not work for inline scripts

    				try {
    					throw new Error();
    				} catch (err) {
    					// Get file src url from stack. Specifically works with the format of stack traces in IE.
    					// A stack will look like this:
    					//
    					// Error
    					//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
    					//    at Global code (http://localhost/components/prism-core.js:606:1)

    					var src = (/at [^(\r\n]*\((.*):.+:.+\)$/i.exec(err.stack) || [])[1];
    					if (src) {
    						var scripts = document.getElementsByTagName('script');
    						for (var i in scripts) {
    							if (scripts[i].src == src) {
    								return scripts[i];
    							}
    						}
    					}
    					return null;
    				}
    			},

    			/**
    			 * Returns whether a given class is active for `element`.
    			 *
    			 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
    			 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
    			 * given class is just the given class with a `no-` prefix.
    			 *
    			 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
    			 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
    			 * ancestors have the given class or the negated version of it, then the default activation will be returned.
    			 *
    			 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
    			 * version of it, the class is considered active.
    			 *
    			 * @param {Element} element
    			 * @param {string} className
    			 * @param {boolean} [defaultActivation=false]
    			 * @returns {boolean}
    			 */
    			isActive: function (element, className, defaultActivation) {
    				var no = 'no-' + className;

    				while (element) {
    					var classList = element.classList;
    					if (classList.contains(className)) {
    						return true;
    					}
    					if (classList.contains(no)) {
    						return false;
    					}
    					element = element.parentElement;
    				}
    				return !!defaultActivation;
    			}
    		},

    		/**
    		 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
    		 *
    		 * @namespace
    		 * @memberof Prism
    		 * @public
    		 */
    		languages: {
    			/**
    			 * The grammar for plain, unformatted text.
    			 */
    			plain: plainTextGrammar,
    			plaintext: plainTextGrammar,
    			text: plainTextGrammar,
    			txt: plainTextGrammar,

    			/**
    			 * Creates a deep copy of the language with the given id and appends the given tokens.
    			 *
    			 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
    			 * will be overwritten at its original position.
    			 *
    			 * ## Best practices
    			 *
    			 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
    			 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
    			 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
    			 *
    			 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
    			 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
    			 *
    			 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
    			 * @param {Grammar} redef The new tokens to append.
    			 * @returns {Grammar} The new language created.
    			 * @public
    			 * @example
    			 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
    			 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
    			 *     // at its original position
    			 *     'comment': { ... },
    			 *     // CSS doesn't have a 'color' token, so this token will be appended
    			 *     'color': /\b(?:red|green|blue)\b/
    			 * });
    			 */
    			extend: function (id, redef) {
    				var lang = _.util.clone(_.languages[id]);

    				for (var key in redef) {
    					lang[key] = redef[key];
    				}

    				return lang;
    			},

    			/**
    			 * Inserts tokens _before_ another token in a language definition or any other grammar.
    			 *
    			 * ## Usage
    			 *
    			 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
    			 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
    			 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
    			 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
    			 * this:
    			 *
    			 * ```js
    			 * Prism.languages.markup.style = {
    			 *     // token
    			 * };
    			 * ```
    			 *
    			 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
    			 * before existing tokens. For the CSS example above, you would use it like this:
    			 *
    			 * ```js
    			 * Prism.languages.insertBefore('markup', 'cdata', {
    			 *     'style': {
    			 *         // token
    			 *     }
    			 * });
    			 * ```
    			 *
    			 * ## Special cases
    			 *
    			 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
    			 * will be ignored.
    			 *
    			 * This behavior can be used to insert tokens after `before`:
    			 *
    			 * ```js
    			 * Prism.languages.insertBefore('markup', 'comment', {
    			 *     'comment': Prism.languages.markup.comment,
    			 *     // tokens after 'comment'
    			 * });
    			 * ```
    			 *
    			 * ## Limitations
    			 *
    			 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
    			 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
    			 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
    			 * deleting properties which is necessary to insert at arbitrary positions.
    			 *
    			 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
    			 * Instead, it will create a new object and replace all references to the target object with the new one. This
    			 * can be done without temporarily deleting properties, so the iteration order is well-defined.
    			 *
    			 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
    			 * you hold the target object in a variable, then the value of the variable will not change.
    			 *
    			 * ```js
    			 * var oldMarkup = Prism.languages.markup;
    			 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
    			 *
    			 * assert(oldMarkup !== Prism.languages.markup);
    			 * assert(newMarkup === Prism.languages.markup);
    			 * ```
    			 *
    			 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
    			 * object to be modified.
    			 * @param {string} before The key to insert before.
    			 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
    			 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
    			 * object to be modified.
    			 *
    			 * Defaults to `Prism.languages`.
    			 * @returns {Grammar} The new grammar object.
    			 * @public
    			 */
    			insertBefore: function (inside, before, insert, root) {
    				root = root || /** @type {any} */ (_.languages);
    				var grammar = root[inside];
    				/** @type {Grammar} */
    				var ret = {};

    				for (var token in grammar) {
    					if (grammar.hasOwnProperty(token)) {

    						if (token == before) {
    							for (var newToken in insert) {
    								if (insert.hasOwnProperty(newToken)) {
    									ret[newToken] = insert[newToken];
    								}
    							}
    						}

    						// Do not insert token which also occur in insert. See #1525
    						if (!insert.hasOwnProperty(token)) {
    							ret[token] = grammar[token];
    						}
    					}
    				}

    				var old = root[inside];
    				root[inside] = ret;

    				// Update references in other language definitions
    				_.languages.DFS(_.languages, function (key, value) {
    					if (value === old && key != inside) {
    						this[key] = ret;
    					}
    				});

    				return ret;
    			},

    			// Traverse a language definition with Depth First Search
    			DFS: function DFS(o, callback, type, visited) {
    				visited = visited || {};

    				var objId = _.util.objId;

    				for (var i in o) {
    					if (o.hasOwnProperty(i)) {
    						callback.call(o, i, o[i], type || i);

    						var property = o[i];
    						var propertyType = _.util.type(property);

    						if (propertyType === 'Object' && !visited[objId(property)]) {
    							visited[objId(property)] = true;
    							DFS(property, callback, null, visited);
    						} else if (propertyType === 'Array' && !visited[objId(property)]) {
    							visited[objId(property)] = true;
    							DFS(property, callback, i, visited);
    						}
    					}
    				}
    			}
    		},

    		plugins: {},

    		/**
    		 * This is the most high-level function in Prism’s API.
    		 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
    		 * each one of them.
    		 *
    		 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
    		 *
    		 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
    		 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
    		 * @memberof Prism
    		 * @public
    		 */
    		highlightAll: function (async, callback) {
    			_.highlightAllUnder(document, async, callback);
    		},

    		/**
    		 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
    		 * {@link Prism.highlightElement} on each one of them.
    		 *
    		 * The following hooks will be run:
    		 * 1. `before-highlightall`
    		 * 2. `before-all-elements-highlight`
    		 * 3. All hooks of {@link Prism.highlightElement} for each element.
    		 *
    		 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
    		 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
    		 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
    		 * @memberof Prism
    		 * @public
    		 */
    		highlightAllUnder: function (container, async, callback) {
    			var env = {
    				callback: callback,
    				container: container,
    				selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
    			};

    			_.hooks.run('before-highlightall', env);

    			env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

    			_.hooks.run('before-all-elements-highlight', env);

    			for (var i = 0, element; (element = env.elements[i++]);) {
    				_.highlightElement(element, async === true, env.callback);
    			}
    		},

    		/**
    		 * Highlights the code inside a single element.
    		 *
    		 * The following hooks will be run:
    		 * 1. `before-sanity-check`
    		 * 2. `before-highlight`
    		 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
    		 * 4. `before-insert`
    		 * 5. `after-highlight`
    		 * 6. `complete`
    		 *
    		 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
    		 * the element's language.
    		 *
    		 * @param {Element} element The element containing the code.
    		 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
    		 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
    		 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
    		 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
    		 *
    		 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
    		 * asynchronous highlighting to work. You can build your own bundle on the
    		 * [Download page](https://prismjs.com/download.html).
    		 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
    		 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
    		 * @memberof Prism
    		 * @public
    		 */
    		highlightElement: function (element, async, callback) {
    			// Find language
    			var language = _.util.getLanguage(element);
    			var grammar = _.languages[language];

    			// Set language on the element, if not present
    			element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

    			// Set language on the parent, for styling
    			var parent = element.parentElement;
    			if (parent && parent.nodeName.toLowerCase() === 'pre') {
    				parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
    			}

    			var code = element.textContent;

    			var env = {
    				element: element,
    				language: language,
    				grammar: grammar,
    				code: code
    			};

    			function insertHighlightedCode(highlightedCode) {
    				env.highlightedCode = highlightedCode;

    				_.hooks.run('before-insert', env);

    				env.element.innerHTML = env.highlightedCode;

    				_.hooks.run('after-highlight', env);
    				_.hooks.run('complete', env);
    				callback && callback.call(env.element);
    			}

    			_.hooks.run('before-sanity-check', env);

    			// plugins may change/add the parent/element
    			parent = env.element.parentElement;
    			if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
    				parent.setAttribute('tabindex', '0');
    			}

    			if (!env.code) {
    				_.hooks.run('complete', env);
    				callback && callback.call(env.element);
    				return;
    			}

    			_.hooks.run('before-highlight', env);

    			if (!env.grammar) {
    				insertHighlightedCode(_.util.encode(env.code));
    				return;
    			}

    			if (async && _self.Worker) {
    				var worker = new Worker(_.filename);

    				worker.onmessage = function (evt) {
    					insertHighlightedCode(evt.data);
    				};

    				worker.postMessage(JSON.stringify({
    					language: env.language,
    					code: env.code,
    					immediateClose: true
    				}));
    			} else {
    				insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
    			}
    		},

    		/**
    		 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
    		 * and the language definitions to use, and returns a string with the HTML produced.
    		 *
    		 * The following hooks will be run:
    		 * 1. `before-tokenize`
    		 * 2. `after-tokenize`
    		 * 3. `wrap`: On each {@link Token}.
    		 *
    		 * @param {string} text A string with the code to be highlighted.
    		 * @param {Grammar} grammar An object containing the tokens to use.
    		 *
    		 * Usually a language definition like `Prism.languages.markup`.
    		 * @param {string} language The name of the language definition passed to `grammar`.
    		 * @returns {string} The highlighted HTML.
    		 * @memberof Prism
    		 * @public
    		 * @example
    		 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
    		 */
    		highlight: function (text, grammar, language) {
    			var env = {
    				code: text,
    				grammar: grammar,
    				language: language
    			};
    			_.hooks.run('before-tokenize', env);
    			env.tokens = _.tokenize(env.code, env.grammar);
    			_.hooks.run('after-tokenize', env);
    			return Token.stringify(_.util.encode(env.tokens), env.language);
    		},

    		/**
    		 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
    		 * and the language definitions to use, and returns an array with the tokenized code.
    		 *
    		 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
    		 *
    		 * This method could be useful in other contexts as well, as a very crude parser.
    		 *
    		 * @param {string} text A string with the code to be highlighted.
    		 * @param {Grammar} grammar An object containing the tokens to use.
    		 *
    		 * Usually a language definition like `Prism.languages.markup`.
    		 * @returns {TokenStream} An array of strings and tokens, a token stream.
    		 * @memberof Prism
    		 * @public
    		 * @example
    		 * let code = `var foo = 0;`;
    		 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
    		 * tokens.forEach(token => {
    		 *     if (token instanceof Prism.Token && token.type === 'number') {
    		 *         console.log(`Found numeric literal: ${token.content}`);
    		 *     }
    		 * });
    		 */
    		tokenize: function (text, grammar) {
    			var rest = grammar.rest;
    			if (rest) {
    				for (var token in rest) {
    					grammar[token] = rest[token];
    				}

    				delete grammar.rest;
    			}

    			var tokenList = new LinkedList();
    			addAfter(tokenList, tokenList.head, text);

    			matchGrammar(text, tokenList, grammar, tokenList.head, 0);

    			return toArray(tokenList);
    		},

    		/**
    		 * @namespace
    		 * @memberof Prism
    		 * @public
    		 */
    		hooks: {
    			all: {},

    			/**
    			 * Adds the given callback to the list of callbacks for the given hook.
    			 *
    			 * The callback will be invoked when the hook it is registered for is run.
    			 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
    			 *
    			 * One callback function can be registered to multiple hooks and the same hook multiple times.
    			 *
    			 * @param {string} name The name of the hook.
    			 * @param {HookCallback} callback The callback function which is given environment variables.
    			 * @public
    			 */
    			add: function (name, callback) {
    				var hooks = _.hooks.all;

    				hooks[name] = hooks[name] || [];

    				hooks[name].push(callback);
    			},

    			/**
    			 * Runs a hook invoking all registered callbacks with the given environment variables.
    			 *
    			 * Callbacks will be invoked synchronously and in the order in which they were registered.
    			 *
    			 * @param {string} name The name of the hook.
    			 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
    			 * @public
    			 */
    			run: function (name, env) {
    				var callbacks = _.hooks.all[name];

    				if (!callbacks || !callbacks.length) {
    					return;
    				}

    				for (var i = 0, callback; (callback = callbacks[i++]);) {
    					callback(env);
    				}
    			}
    		},

    		Token: Token
    	};
    	_self.Prism = _;


    	// Typescript note:
    	// The following can be used to import the Token type in JSDoc:
    	//
    	//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

    	/**
    	 * Creates a new token.
    	 *
    	 * @param {string} type See {@link Token#type type}
    	 * @param {string | TokenStream} content See {@link Token#content content}
    	 * @param {string|string[]} [alias] The alias(es) of the token.
    	 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
    	 * @class
    	 * @global
    	 * @public
    	 */
    	function Token(type, content, alias, matchedStr) {
    		/**
    		 * The type of the token.
    		 *
    		 * This is usually the key of a pattern in a {@link Grammar}.
    		 *
    		 * @type {string}
    		 * @see GrammarToken
    		 * @public
    		 */
    		this.type = type;
    		/**
    		 * The strings or tokens contained by this token.
    		 *
    		 * This will be a token stream if the pattern matched also defined an `inside` grammar.
    		 *
    		 * @type {string | TokenStream}
    		 * @public
    		 */
    		this.content = content;
    		/**
    		 * The alias(es) of the token.
    		 *
    		 * @type {string|string[]}
    		 * @see GrammarToken
    		 * @public
    		 */
    		this.alias = alias;
    		// Copy of the full string this token was created from
    		this.length = (matchedStr || '').length | 0;
    	}

    	/**
    	 * A token stream is an array of strings and {@link Token Token} objects.
    	 *
    	 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
    	 * them.
    	 *
    	 * 1. No adjacent strings.
    	 * 2. No empty strings.
    	 *
    	 *    The only exception here is the token stream that only contains the empty string and nothing else.
    	 *
    	 * @typedef {Array<string | Token>} TokenStream
    	 * @global
    	 * @public
    	 */

    	/**
    	 * Converts the given token or token stream to an HTML representation.
    	 *
    	 * The following hooks will be run:
    	 * 1. `wrap`: On each {@link Token}.
    	 *
    	 * @param {string | Token | TokenStream} o The token or token stream to be converted.
    	 * @param {string} language The name of current language.
    	 * @returns {string} The HTML representation of the token or token stream.
    	 * @memberof Token
    	 * @static
    	 */
    	Token.stringify = function stringify(o, language) {
    		if (typeof o == 'string') {
    			return o;
    		}
    		if (Array.isArray(o)) {
    			var s = '';
    			o.forEach(function (e) {
    				s += stringify(e, language);
    			});
    			return s;
    		}

    		var env = {
    			type: o.type,
    			content: stringify(o.content, language),
    			tag: 'span',
    			classes: ['token', o.type],
    			attributes: {},
    			language: language
    		};

    		var aliases = o.alias;
    		if (aliases) {
    			if (Array.isArray(aliases)) {
    				Array.prototype.push.apply(env.classes, aliases);
    			} else {
    				env.classes.push(aliases);
    			}
    		}

    		_.hooks.run('wrap', env);

    		var attributes = '';
    		for (var name in env.attributes) {
    			attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
    		}

    		return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
    	};

    	/**
    	 * @param {RegExp} pattern
    	 * @param {number} pos
    	 * @param {string} text
    	 * @param {boolean} lookbehind
    	 * @returns {RegExpExecArray | null}
    	 */
    	function matchPattern(pattern, pos, text, lookbehind) {
    		pattern.lastIndex = pos;
    		var match = pattern.exec(text);
    		if (match && lookbehind && match[1]) {
    			// change the match to remove the text matched by the Prism lookbehind group
    			var lookbehindLength = match[1].length;
    			match.index += lookbehindLength;
    			match[0] = match[0].slice(lookbehindLength);
    		}
    		return match;
    	}

    	/**
    	 * @param {string} text
    	 * @param {LinkedList<string | Token>} tokenList
    	 * @param {any} grammar
    	 * @param {LinkedListNode<string | Token>} startNode
    	 * @param {number} startPos
    	 * @param {RematchOptions} [rematch]
    	 * @returns {void}
    	 * @private
    	 *
    	 * @typedef RematchOptions
    	 * @property {string} cause
    	 * @property {number} reach
    	 */
    	function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
    		for (var token in grammar) {
    			if (!grammar.hasOwnProperty(token) || !grammar[token]) {
    				continue;
    			}

    			var patterns = grammar[token];
    			patterns = Array.isArray(patterns) ? patterns : [patterns];

    			for (var j = 0; j < patterns.length; ++j) {
    				if (rematch && rematch.cause == token + ',' + j) {
    					return;
    				}

    				var patternObj = patterns[j];
    				var inside = patternObj.inside;
    				var lookbehind = !!patternObj.lookbehind;
    				var greedy = !!patternObj.greedy;
    				var alias = patternObj.alias;

    				if (greedy && !patternObj.pattern.global) {
    					// Without the global flag, lastIndex won't work
    					var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
    					patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
    				}

    				/** @type {RegExp} */
    				var pattern = patternObj.pattern || patternObj;

    				for ( // iterate the token list and keep track of the current token/string position
    					var currentNode = startNode.next, pos = startPos;
    					currentNode !== tokenList.tail;
    					pos += currentNode.value.length, currentNode = currentNode.next
    				) {

    					if (rematch && pos >= rematch.reach) {
    						break;
    					}

    					var str = currentNode.value;

    					if (tokenList.length > text.length) {
    						// Something went terribly wrong, ABORT, ABORT!
    						return;
    					}

    					if (str instanceof Token) {
    						continue;
    					}

    					var removeCount = 1; // this is the to parameter of removeBetween
    					var match;

    					if (greedy) {
    						match = matchPattern(pattern, pos, text, lookbehind);
    						if (!match) {
    							break;
    						}

    						var from = match.index;
    						var to = match.index + match[0].length;
    						var p = pos;

    						// find the node that contains the match
    						p += currentNode.value.length;
    						while (from >= p) {
    							currentNode = currentNode.next;
    							p += currentNode.value.length;
    						}
    						// adjust pos (and p)
    						p -= currentNode.value.length;
    						pos = p;

    						// the current node is a Token, then the match starts inside another Token, which is invalid
    						if (currentNode.value instanceof Token) {
    							continue;
    						}

    						// find the last node which is affected by this match
    						for (
    							var k = currentNode;
    							k !== tokenList.tail && (p < to || typeof k.value === 'string');
    							k = k.next
    						) {
    							removeCount++;
    							p += k.value.length;
    						}
    						removeCount--;

    						// replace with the new match
    						str = text.slice(pos, p);
    						match.index -= pos;
    					} else {
    						match = matchPattern(pattern, 0, str, lookbehind);
    						if (!match) {
    							continue;
    						}
    					}

    					// eslint-disable-next-line no-redeclare
    					var from = match.index;
    					var matchStr = match[0];
    					var before = str.slice(0, from);
    					var after = str.slice(from + matchStr.length);

    					var reach = pos + str.length;
    					if (rematch && reach > rematch.reach) {
    						rematch.reach = reach;
    					}

    					var removeFrom = currentNode.prev;

    					if (before) {
    						removeFrom = addAfter(tokenList, removeFrom, before);
    						pos += before.length;
    					}

    					removeRange(tokenList, removeFrom, removeCount);

    					var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
    					currentNode = addAfter(tokenList, removeFrom, wrapped);

    					if (after) {
    						addAfter(tokenList, currentNode, after);
    					}

    					if (removeCount > 1) {
    						// at least one Token object was removed, so we have to do some rematching
    						// this can only happen if the current pattern is greedy

    						/** @type {RematchOptions} */
    						var nestedRematch = {
    							cause: token + ',' + j,
    							reach: reach
    						};
    						matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

    						// the reach might have been extended because of the rematching
    						if (rematch && nestedRematch.reach > rematch.reach) {
    							rematch.reach = nestedRematch.reach;
    						}
    					}
    				}
    			}
    		}
    	}

    	/**
    	 * @typedef LinkedListNode
    	 * @property {T} value
    	 * @property {LinkedListNode<T> | null} prev The previous node.
    	 * @property {LinkedListNode<T> | null} next The next node.
    	 * @template T
    	 * @private
    	 */

    	/**
    	 * @template T
    	 * @private
    	 */
    	function LinkedList() {
    		/** @type {LinkedListNode<T>} */
    		var head = { value: null, prev: null, next: null };
    		/** @type {LinkedListNode<T>} */
    		var tail = { value: null, prev: head, next: null };
    		head.next = tail;

    		/** @type {LinkedListNode<T>} */
    		this.head = head;
    		/** @type {LinkedListNode<T>} */
    		this.tail = tail;
    		this.length = 0;
    	}

    	/**
    	 * Adds a new node with the given value to the list.
    	 *
    	 * @param {LinkedList<T>} list
    	 * @param {LinkedListNode<T>} node
    	 * @param {T} value
    	 * @returns {LinkedListNode<T>} The added node.
    	 * @template T
    	 */
    	function addAfter(list, node, value) {
    		// assumes that node != list.tail && values.length >= 0
    		var next = node.next;

    		var newNode = { value: value, prev: node, next: next };
    		node.next = newNode;
    		next.prev = newNode;
    		list.length++;

    		return newNode;
    	}
    	/**
    	 * Removes `count` nodes after the given node. The given node will not be removed.
    	 *
    	 * @param {LinkedList<T>} list
    	 * @param {LinkedListNode<T>} node
    	 * @param {number} count
    	 * @template T
    	 */
    	function removeRange(list, node, count) {
    		var next = node.next;
    		for (var i = 0; i < count && next !== list.tail; i++) {
    			next = next.next;
    		}
    		node.next = next;
    		next.prev = node;
    		list.length -= i;
    	}
    	/**
    	 * @param {LinkedList<T>} list
    	 * @returns {T[]}
    	 * @template T
    	 */
    	function toArray(list) {
    		var array = [];
    		var node = list.head.next;
    		while (node !== list.tail) {
    			array.push(node.value);
    			node = node.next;
    		}
    		return array;
    	}


    	if (!_self.document) {
    		if (!_self.addEventListener) {
    			// in Node.js
    			return _;
    		}

    		if (!_.disableWorkerMessageHandler) {
    			// In worker
    			_self.addEventListener('message', function (evt) {
    				var message = JSON.parse(evt.data);
    				var lang = message.language;
    				var code = message.code;
    				var immediateClose = message.immediateClose;

    				_self.postMessage(_.highlight(code, _.languages[lang], lang));
    				if (immediateClose) {
    					_self.close();
    				}
    			}, false);
    		}

    		return _;
    	}

    	// Get current script and highlight
    	var script = _.util.currentScript();

    	if (script) {
    		_.filename = script.src;

    		if (script.hasAttribute('data-manual')) {
    			_.manual = true;
    		}
    	}

    	function highlightAutomaticallyCallback() {
    		if (!_.manual) {
    			_.highlightAll();
    		}
    	}

    	if (!_.manual) {
    		// If the document state is "loading", then we'll use DOMContentLoaded.
    		// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
    		// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
    		// might take longer one animation frame to execute which can create a race condition where only some plugins have
    		// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
    		// See https://github.com/PrismJS/prism/issues/2102
    		var readyState = document.readyState;
    		if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
    			document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
    		} else {
    			if (window.requestAnimationFrame) {
    				window.requestAnimationFrame(highlightAutomaticallyCallback);
    			} else {
    				window.setTimeout(highlightAutomaticallyCallback, 16);
    			}
    		}
    	}

    	return _;

    }(_self));

    if (module.exports) {
    	module.exports = Prism;
    }

    // hack for components to work correctly in node.js
    if (typeof commonjsGlobal !== 'undefined') {
    	commonjsGlobal.Prism = Prism;
    }

    // some additional documentation/types

    /**
     * The expansion of a simple `RegExp` literal to support additional properties.
     *
     * @typedef GrammarToken
     * @property {RegExp} pattern The regular expression of the token.
     * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
     * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
     * @property {boolean} [greedy=false] Whether the token is greedy.
     * @property {string|string[]} [alias] An optional alias or list of aliases.
     * @property {Grammar} [inside] The nested grammar of this token.
     *
     * The `inside` grammar will be used to tokenize the text value of each token of this kind.
     *
     * This can be used to make nested and even recursive language definitions.
     *
     * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
     * each another.
     * @global
     * @public
     */

    /**
     * @typedef Grammar
     * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
     * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
     * @global
     * @public
     */

    /**
     * A function which will invoked after an element was successfully highlighted.
     *
     * @callback HighlightCallback
     * @param {Element} element The element successfully highlighted.
     * @returns {void}
     * @global
     * @public
     */

    /**
     * @callback HookCallback
     * @param {Object<string, any>} env The environment variables of the hook.
     * @returns {void}
     * @global
     * @public
     */


    /* **********************************************
         Begin prism-markup.js
    ********************************************** */

    Prism.languages.markup = {
    	'comment': /<!--[\s\S]*?-->/,
    	'prolog': /<\?[\s\S]+?\?>/,
    	'doctype': {
    		// https://www.w3.org/TR/xml/#NT-doctypedecl
    		pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
    		greedy: true,
    		inside: {
    			'internal-subset': {
    				pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
    				lookbehind: true,
    				greedy: true,
    				inside: null // see below
    			},
    			'string': {
    				pattern: /"[^"]*"|'[^']*'/,
    				greedy: true
    			},
    			'punctuation': /^<!|>$|[[\]]/,
    			'doctype-tag': /^DOCTYPE/,
    			'name': /[^\s<>'"]+/
    		}
    	},
    	'cdata': /<!\[CDATA\[[\s\S]*?\]\]>/i,
    	'tag': {
    		pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
    		greedy: true,
    		inside: {
    			'tag': {
    				pattern: /^<\/?[^\s>\/]+/,
    				inside: {
    					'punctuation': /^<\/?/,
    					'namespace': /^[^\s>\/:]+:/
    				}
    			},
    			'special-attr': [],
    			'attr-value': {
    				pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
    				inside: {
    					'punctuation': [
    						{
    							pattern: /^=/,
    							alias: 'attr-equals'
    						},
    						/"|'/
    					]
    				}
    			},
    			'punctuation': /\/?>/,
    			'attr-name': {
    				pattern: /[^\s>\/]+/,
    				inside: {
    					'namespace': /^[^\s>\/:]+:/
    				}
    			}

    		}
    	},
    	'entity': [
    		{
    			pattern: /&[\da-z]{1,8};/i,
    			alias: 'named-entity'
    		},
    		/&#x?[\da-f]{1,8};/i
    	]
    };

    Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
    	Prism.languages.markup['entity'];
    Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

    // Plugin to make entity title show the real entity, idea by Roman Komarov
    Prism.hooks.add('wrap', function (env) {

    	if (env.type === 'entity') {
    		env.attributes['title'] = env.content.replace(/&amp;/, '&');
    	}
    });

    Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
    	/**
    	 * Adds an inlined language to markup.
    	 *
    	 * An example of an inlined language is CSS with `<style>` tags.
    	 *
    	 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
    	 * case insensitive.
    	 * @param {string} lang The language key.
    	 * @example
    	 * addInlined('style', 'css');
    	 */
    	value: function addInlined(tagName, lang) {
    		var includedCdataInside = {};
    		includedCdataInside['language-' + lang] = {
    			pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
    			lookbehind: true,
    			inside: Prism.languages[lang]
    		};
    		includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

    		var inside = {
    			'included-cdata': {
    				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    				inside: includedCdataInside
    			}
    		};
    		inside['language-' + lang] = {
    			pattern: /[\s\S]+/,
    			inside: Prism.languages[lang]
    		};

    		var def = {};
    		def[tagName] = {
    			pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
    			lookbehind: true,
    			greedy: true,
    			inside: inside
    		};

    		Prism.languages.insertBefore('markup', 'cdata', def);
    	}
    });
    Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
    	/**
    	 * Adds an pattern to highlight languages embedded in HTML attributes.
    	 *
    	 * An example of an inlined language is CSS with `style` attributes.
    	 *
    	 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
    	 * case insensitive.
    	 * @param {string} lang The language key.
    	 * @example
    	 * addAttribute('style', 'css');
    	 */
    	value: function (attrName, lang) {
    		Prism.languages.markup.tag.inside['special-attr'].push({
    			pattern: RegExp(
    				/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
    				'i'
    			),
    			lookbehind: true,
    			inside: {
    				'attr-name': /^[^\s=]+/,
    				'attr-value': {
    					pattern: /=[\s\S]+/,
    					inside: {
    						'value': {
    							pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
    							lookbehind: true,
    							alias: [lang, 'language-' + lang],
    							inside: Prism.languages[lang]
    						},
    						'punctuation': [
    							{
    								pattern: /^=/,
    								alias: 'attr-equals'
    							},
    							/"|'/
    						]
    					}
    				}
    			}
    		});
    	}
    });

    Prism.languages.html = Prism.languages.markup;
    Prism.languages.mathml = Prism.languages.markup;
    Prism.languages.svg = Prism.languages.markup;

    Prism.languages.xml = Prism.languages.extend('markup', {});
    Prism.languages.ssml = Prism.languages.xml;
    Prism.languages.atom = Prism.languages.xml;
    Prism.languages.rss = Prism.languages.xml;


    /* **********************************************
         Begin prism-css.js
    ********************************************** */

    (function (Prism) {

    	var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;

    	Prism.languages.css = {
    		'comment': /\/\*[\s\S]*?\*\//,
    		'atrule': {
    			pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
    			inside: {
    				'rule': /^@[\w-]+/,
    				'selector-function-argument': {
    					pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
    					lookbehind: true,
    					alias: 'selector'
    				},
    				'keyword': {
    					pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
    					lookbehind: true
    				}
    				// See rest below
    			}
    		},
    		'url': {
    			// https://drafts.csswg.org/css-values-3/#urls
    			pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
    			greedy: true,
    			inside: {
    				'function': /^url/i,
    				'punctuation': /^\(|\)$/,
    				'string': {
    					pattern: RegExp('^' + string.source + '$'),
    					alias: 'url'
    				}
    			}
    		},
    		'selector': {
    			pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
    			lookbehind: true
    		},
    		'string': {
    			pattern: string,
    			greedy: true
    		},
    		'property': {
    			pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
    			lookbehind: true
    		},
    		'important': /!important\b/i,
    		'function': {
    			pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
    			lookbehind: true
    		},
    		'punctuation': /[(){};:,]/
    	};

    	Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

    	var markup = Prism.languages.markup;
    	if (markup) {
    		markup.tag.addInlined('style', 'css');
    		markup.tag.addAttribute('style', 'css');
    	}

    }(Prism));


    /* **********************************************
         Begin prism-clike.js
    ********************************************** */

    Prism.languages.clike = {
    	'comment': [
    		{
    			pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    			lookbehind: true,
    			greedy: true
    		},
    		{
    			pattern: /(^|[^\\:])\/\/.*/,
    			lookbehind: true,
    			greedy: true
    		}
    	],
    	'string': {
    		pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    		greedy: true
    	},
    	'class-name': {
    		pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,
    		lookbehind: true,
    		inside: {
    			'punctuation': /[.\\]/
    		}
    	},
    	'keyword': /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
    	'boolean': /\b(?:true|false)\b/,
    	'function': /\b\w+(?=\()/,
    	'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    	'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    	'punctuation': /[{}[\];(),.:]/
    };


    /* **********************************************
         Begin prism-javascript.js
    ********************************************** */

    Prism.languages.javascript = Prism.languages.extend('clike', {
    	'class-name': [
    		Prism.languages.clike['class-name'],
    		{
    			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:prototype|constructor))/,
    			lookbehind: true
    		}
    	],
    	'keyword': [
    		{
    			pattern: /((?:^|\})\s*)catch\b/,
    			lookbehind: true
    		},
    		{
    			pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
    			lookbehind: true
    		},
    	],
    	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    	'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    	'number': /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
    	'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });

    Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;

    Prism.languages.insertBefore('javascript', 'keyword', {
    	'regex': {
    		// eslint-disable-next-line regexp/no-dupe-characters-character-class
    		pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
    		lookbehind: true,
    		greedy: true,
    		inside: {
    			'regex-source': {
    				pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
    				lookbehind: true,
    				alias: 'language-regex',
    				inside: Prism.languages.regex
    			},
    			'regex-delimiter': /^\/|\/$/,
    			'regex-flags': /^[a-z]+$/,
    		}
    	},
    	// This must be declared before keyword because we use "function" inside the look-forward
    	'function-variable': {
    		pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    		alias: 'function'
    	},
    	'parameter': [
    		{
    			pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
    			lookbehind: true,
    			inside: Prism.languages.javascript
    		},
    		{
    			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
    			lookbehind: true,
    			inside: Prism.languages.javascript
    		},
    		{
    			pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
    			lookbehind: true,
    			inside: Prism.languages.javascript
    		},
    		{
    			pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
    			lookbehind: true,
    			inside: Prism.languages.javascript
    		}
    	],
    	'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });

    Prism.languages.insertBefore('javascript', 'string', {
    	'hashbang': {
    		pattern: /^#!.*/,
    		greedy: true,
    		alias: 'comment'
    	},
    	'template-string': {
    		pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    		greedy: true,
    		inside: {
    			'template-punctuation': {
    				pattern: /^`|`$/,
    				alias: 'string'
    			},
    			'interpolation': {
    				pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
    				lookbehind: true,
    				inside: {
    					'interpolation-punctuation': {
    						pattern: /^\$\{|\}$/,
    						alias: 'punctuation'
    					},
    					rest: Prism.languages.javascript
    				}
    			},
    			'string': /[\s\S]+/
    		}
    	}
    });

    if (Prism.languages.markup) {
    	Prism.languages.markup.tag.addInlined('script', 'javascript');

    	// add attribute support for all DOM events.
    	// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
    	Prism.languages.markup.tag.addAttribute(
    		/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    		'javascript'
    	);
    }

    Prism.languages.js = Prism.languages.javascript;


    /* **********************************************
         Begin prism-file-highlight.js
    ********************************************** */

    (function () {

    	if (typeof Prism === 'undefined' || typeof document === 'undefined') {
    		return;
    	}

    	// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
    	if (!Element.prototype.matches) {
    		Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    	}

    	var LOADING_MESSAGE = 'Loading…';
    	var FAILURE_MESSAGE = function (status, message) {
    		return '✖ Error ' + status + ' while fetching file: ' + message;
    	};
    	var FAILURE_EMPTY_MESSAGE = '✖ Error: File does not exist or is empty';

    	var EXTENSIONS = {
    		'js': 'javascript',
    		'py': 'python',
    		'rb': 'ruby',
    		'ps1': 'powershell',
    		'psm1': 'powershell',
    		'sh': 'bash',
    		'bat': 'batch',
    		'h': 'c',
    		'tex': 'latex'
    	};

    	var STATUS_ATTR = 'data-src-status';
    	var STATUS_LOADING = 'loading';
    	var STATUS_LOADED = 'loaded';
    	var STATUS_FAILED = 'failed';

    	var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])'
    		+ ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';

    	var lang = /\blang(?:uage)?-([\w-]+)\b/i;

    	/**
    	 * Sets the Prism `language-xxxx` or `lang-xxxx` class to the given language.
    	 *
    	 * @param {HTMLElement} element
    	 * @param {string} language
    	 * @returns {void}
    	 */
    	function setLanguageClass(element, language) {
    		var className = element.className;
    		className = className.replace(lang, ' ') + ' language-' + language;
    		element.className = className.replace(/\s+/g, ' ').trim();
    	}


    	Prism.hooks.add('before-highlightall', function (env) {
    		env.selector += ', ' + SELECTOR;
    	});

    	Prism.hooks.add('before-sanity-check', function (env) {
    		var pre = /** @type {HTMLPreElement} */ (env.element);
    		if (pre.matches(SELECTOR)) {
    			env.code = ''; // fast-path the whole thing and go to complete

    			pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading

    			// add code element with loading message
    			var code = pre.appendChild(document.createElement('CODE'));
    			code.textContent = LOADING_MESSAGE;

    			var src = pre.getAttribute('data-src');

    			var language = env.language;
    			if (language === 'none') {
    				// the language might be 'none' because there is no language set;
    				// in this case, we want to use the extension as the language
    				var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
    				language = EXTENSIONS[extension] || extension;
    			}

    			// set language classes
    			setLanguageClass(code, language);
    			setLanguageClass(pre, language);

    			// preload the language
    			var autoloader = Prism.plugins.autoloader;
    			if (autoloader) {
    				autoloader.loadLanguages(language);
    			}

    			// load file
    			var xhr = new XMLHttpRequest();
    			xhr.open('GET', src, true);
    			xhr.onreadystatechange = function () {
    				if (xhr.readyState == 4) {
    					if (xhr.status < 400 && xhr.responseText) {
    						// mark as loaded
    						pre.setAttribute(STATUS_ATTR, STATUS_LOADED);

    						// highlight code
    						code.textContent = xhr.responseText;
    						Prism.highlightElement(code);

    					} else {
    						// mark as failed
    						pre.setAttribute(STATUS_ATTR, STATUS_FAILED);

    						if (xhr.status >= 400) {
    							code.textContent = FAILURE_MESSAGE(xhr.status, xhr.statusText);
    						} else {
    							code.textContent = FAILURE_EMPTY_MESSAGE;
    						}
    					}
    				}
    			};
    			xhr.send(null);
    		}
    	});

    	Prism.plugins.fileHighlight = {
    		/**
    		 * Executes the File Highlight plugin for all matching `pre` elements under the given container.
    		 *
    		 * Note: Elements which are already loaded or currently loading will not be touched by this method.
    		 *
    		 * @param {ParentNode} [container=document]
    		 */
    		highlight: function highlight(container) {
    			var elements = (container || document).querySelectorAll(SELECTOR);

    			for (var i = 0, element; (element = elements[i++]);) {
    				Prism.highlightElement(element);
    			}
    		}
    	};

    	var logged = false;
    	/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */
    	Prism.fileHighlight = function () {
    		if (!logged) {
    			console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
    			logged = true;
    		}
    		Prism.plugins.fileHighlight.highlight.apply(this, arguments);
    	};

    }());
    }(prism$2));

    var prism$1 = prism$2.exports;

    const blocks = '(if|else if|await|then|catch|each|html|debug)';

    Prism.languages.svelte = Prism.languages.extend('markup', {
    	each: {
    		pattern: new RegExp(
    			'{[#/]each' +
    				'(?:(?:\\{(?:(?:\\{(?:[^{}])*\\})|(?:[^{}]))*\\})|(?:[^{}]))*}'
    		),
    		inside: {
    			'language-javascript': [
    				{
    					pattern: /(as[\s\S]*)\([\s\S]*\)(?=\s*\})/,
    					lookbehind: true,
    					inside: Prism.languages['javascript'],
    				},
    				{
    					pattern: /(as[\s]*)[\s\S]*(?=\s*)/,
    					lookbehind: true,
    					inside: Prism.languages['javascript'],
    				},
    				{
    					pattern: /(#each[\s]*)[\s\S]*(?=as)/,
    					lookbehind: true,
    					inside: Prism.languages['javascript'],
    				},
    			],
    			keyword: /[#/]each|as/,
    			punctuation: /{|}/,
    		},
    	},
    	block: {
    		pattern: new RegExp(
    			'{[#:/@]/s' +
    				blocks +
    				'(?:(?:\\{(?:(?:\\{(?:[^{}])*\\})|(?:[^{}]))*\\})|(?:[^{}]))*}'
    		),
    		inside: {
    			punctuation: /^{|}$/,
    			keyword: [new RegExp('[#:/@]' + blocks + '( )*'), /as/, /then/],
    			'language-javascript': {
    				pattern: /[\s\S]*/,
    				inside: Prism.languages['javascript'],
    			},
    		},
    	},
    	tag: {
    		pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?:"[^"]*"|'[^']*'|{[\s\S]+?}(?=[\s/>])))|(?=[\s/>])))+)?\s*\/?>/i,
    		greedy: true,
    		inside: {
    			tag: {
    				pattern: /^<\/?[^\s>\/]+/i,
    				inside: {
    					punctuation: /^<\/?/,
    					namespace: /^[^\s>\/:]+:/,
    				},
    			},
    			'language-javascript': {
    				pattern: /\{(?:(?:\{(?:(?:\{(?:[^{}])*\})|(?:[^{}]))*\})|(?:[^{}]))*\}/,
    				inside: Prism.languages['javascript'],
    			},
    			'attr-value': {
    				pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/i,
    				inside: {
    					punctuation: [
    						/^=/,
    						{
    							pattern: /^(\s*)["']|["']$/,
    							lookbehind: true,
    						},
    					],
    					'language-javascript': {
    						pattern: /{[\s\S]+}/,
    						inside: Prism.languages['javascript'],
    					},
    				},
    			},
    			punctuation: /\/?>/,
    			'attr-name': {
    				pattern: /[^\s>\/]+/,
    				inside: {
    					namespace: /^[^\s>\/:]+:/,
    				},
    			},
    		},
    	},
    	'language-javascript': {
    		pattern: /\{(?:(?:\{(?:(?:\{(?:[^{}])*\})|(?:[^{}]))*\})|(?:[^{}]))*\}/,
    		lookbehind: true,
    		inside: Prism.languages['javascript'],
    	},
    });

    Prism.languages.svelte['tag'].inside['attr-value'].inside['entity'] =
    	Prism.languages.svelte['entity'];

    Prism.hooks.add('wrap', env => {
    	if (env.type === 'entity') {
    		env.attributes['title'] = env.content.replace(/&amp;/, '&');
    	}
    });

    Object.defineProperty(Prism.languages.svelte.tag, 'addInlined', {
    	value: function addInlined(tagName, lang) {
    		const includedCdataInside = {};
    		includedCdataInside['language-' + lang] = {
    			pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
    			lookbehind: true,
    			inside: Prism.languages[lang],
    		};
    		includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

    		const inside = {
    			'included-cdata': {
    				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
    				inside: includedCdataInside,
    			},
    		};
    		inside['language-' + lang] = {
    			pattern: /[\s\S]+/,
    			inside: Prism.languages[lang],
    		};

    		const def = {};
    		def[tagName] = {
    			pattern: RegExp(
    				/(<__[\s\S]*?>)(?:<!\[CDATA\[[\s\S]*?\]\]>\s*|[\s\S])*?(?=<\/__>)/.source.replace(
    					/__/g,
    					tagName
    				),
    				'i'
    			),
    			lookbehind: true,
    			greedy: true,
    			inside,
    		};

    		Prism.languages.insertBefore('svelte', 'cdata', def);
    	},
    });

    Prism.languages.svelte.tag.addInlined('style', 'css');
    Prism.languages.svelte.tag.addInlined('script', 'javascript');

    /* node_modules/svelte-prism/src/Prism.svelte generated by Svelte v3.42.6 */
    const file$1m = "node_modules/svelte-prism/src/Prism.svelte";

    // (37:4) {:else}
    function create_else_block$j(ctx) {
    	let html_tag;
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(/*formattedCode*/ ctx[2], target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*formattedCode*/ 4) html_tag.p(/*formattedCode*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$j.name,
    		type: "else",
    		source: "(37:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (35:4) {#if language === 'none'}
    function create_if_block$o(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*formattedCode*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*formattedCode*/ 4) set_data_dev(t, /*formattedCode*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(35:4) {#if language === 'none'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1n(ctx) {
    	let code0;
    	let t;
    	let pre;
    	let code1;
    	let code1_class_value;
    	let pre_class_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	function select_block_type(ctx, dirty) {
    		if (/*language*/ ctx[0] === 'none') return create_if_block$o;
    		return create_else_block$j;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			code0 = element("code");
    			if (default_slot) default_slot.c();
    			t = space();
    			pre = element("pre");
    			code1 = element("code");
    			if_block.c();
    			set_style(code0, "display", "none");
    			add_location(code0, file$1m, 28, 0, 766);
    			attr_dev(code1, "class", code1_class_value = "language-" + /*language*/ ctx[0]);
    			add_location(code1, file$1m, 33, 2, 902);
    			attr_dev(pre, "class", pre_class_value = "language-" + /*language*/ ctx[0]);
    			attr_dev(pre, "command-line", "");
    			attr_dev(pre, "data-output", "2-17");
    			add_location(pre, file$1m, 32, 0, 834);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, code0, anchor);

    			if (default_slot) {
    				default_slot.m(code0, null);
    			}

    			/*code0_binding*/ ctx[7](code0);
    			insert_dev(target, t, anchor);
    			insert_dev(target, pre, anchor);
    			append_dev(pre, code1);
    			if_block.m(code1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(code1, null);
    				}
    			}

    			if (!current || dirty & /*language*/ 1 && code1_class_value !== (code1_class_value = "language-" + /*language*/ ctx[0])) {
    				attr_dev(code1, "class", code1_class_value);
    			}

    			if (!current || dirty & /*language*/ 1 && pre_class_value !== (pre_class_value = "language-" + /*language*/ ctx[0])) {
    				attr_dev(pre, "class", pre_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(code0);
    			if (default_slot) default_slot.d(detaching);
    			/*code0_binding*/ ctx[7](null);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(pre);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const prism = prism$1;
    const highlight = prism$1.highlightElement;
    const globalConfig = { transform: x => x };

    function instance$1n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Prism', slots, ['default']);
    	let { language = "javascript" } = $$props;
    	let { source = "" } = $$props;
    	let { transform = x => x } = $$props;
    	let element, formattedCode;

    	function highlightCode() {
    		const grammar = prism.languages[language];
    		let body = source || element.textContent;
    		body = globalConfig.transform(body);
    		body = transform(body);

    		$$invalidate(2, formattedCode = language === "none"
    		? body
    		: prism.highlight(body, grammar, language));
    	}

    	function code0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(1, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('language' in $$new_props) $$invalidate(0, language = $$new_props.language);
    		if ('source' in $$new_props) $$invalidate(3, source = $$new_props.source);
    		if ('transform' in $$new_props) $$invalidate(4, transform = $$new_props.transform);
    		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		_prism: prism$1,
    		prism,
    		highlight,
    		globalConfig,
    		tick,
    		language,
    		source,
    		transform,
    		element,
    		formattedCode,
    		highlightCode
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    		if ('language' in $$props) $$invalidate(0, language = $$new_props.language);
    		if ('source' in $$props) $$invalidate(3, source = $$new_props.source);
    		if ('transform' in $$props) $$invalidate(4, transform = $$new_props.transform);
    		if ('element' in $$props) $$invalidate(1, element = $$new_props.element);
    		if ('formattedCode' in $$props) $$invalidate(2, formattedCode = $$new_props.formattedCode);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$props && (source || element) && highlightCode();
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		language,
    		element,
    		formattedCode,
    		source,
    		transform,
    		$$scope,
    		slots,
    		code0_binding
    	];
    }

    class Prism$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1n, create_fragment$1n, safe_not_equal, { language: 0, source: 3, transform: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Prism",
    			options,
    			id: create_fragment$1n.name
    		});
    	}

    	get language() {
    		throw new Error("<Prism>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set language(value) {
    		throw new Error("<Prism>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get source() {
    		throw new Error("<Prism>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set source(value) {
    		throw new Error("<Prism>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transform() {
    		throw new Error("<Prism>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transform(value) {
    		throw new Error("<Prism>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    greenBGClass = greendarkBGClass = void 0;
    bluedarkBGClass = void 0;
    var colorNames = Background = void 0;
    var greendarkBGClass = 'bg--greendark';
    var greenBGClass = 'bg--green';
    var bluedarkBGClass = 'bg--bluedark';
    var Background = { "bordeaux": { "background": "#8a0c36", "color": "#fff" }, "reddark": { "background": "#900", "color": "#fff" }, "red": { "background": "#bd1118", "color": "#fff" }, "pink": { "background": "#b31e61", "color": "#fff" }, "rose": { "background": "#dc7095", "color": "#fff" }, "orangedark": { "background": "#e96c0d", "color": "#fff" }, "orange": { "background": "#e5ad02", "color": "#fff" }, "yellow": { "background": "#fae500", "color": "#fff" }, "yellowlight": { "background": "#ff0", "color": "#000" }, "sand": { "background": "#cec4a6", "color": "#fff" }, "greendark": { "background": "#2f7820", "color": "#fff" }, "green": { "background": "#029e5d", "color": "#fff" }, "greenlight": { "background": "#93b923", "color": "#fff" }, "lime": { "background": "#cbfe33", "color": "#000" }, "purpledark": { "background": "#51208c", "color": "#fff" }, "bluenavy": { "background": "#1a237e", "color": "#fff" }, "bluedark": { "background": "#1058c2", "color": "#fff" }, "blue": { "background": "#31769b", "color": "#fff" }, "bluelight": { "background": "#4fa8df", "color": "#fff" }, "cyan": { "background": "#00b6d2", "color": "#fff" }, "sea": { "background": "#84a8c4", "color": "#fff" }, "black": { "background": "#000", "color": "#fff" }, "graa1": { "background": "#3c3c3c", "color": "#fff" }, "graa2": { "background": "#484848", "color": "#fff" }, "graa3": { "background": "#999", "color": "#fff" }, "graa4": { "background": "#c8c8c8", "color": "#000" }, "graa5": { "background": "#ddd", "color": "#000" }, "graa6": { "background": "#e5e5e5", "color": "#000" }, "graa7": { "background": "#efefef", "color": "#000" }, "white": { "background": "#fff", "color": "#000" }, "pastelred": { "background": "#db5040", "color": "#fff" }, "pasteldarkred": { "background": "#954839", "color": "#fff" }, "pastellightred": { "background": "#d67e9b", "color": "#fff" }, "pastelgreen": { "background": "#9fc29c", "color": "#fff" }, "pasteldarkgreen": { "background": "#91a34f", "color": "#fff" }, "pastelyellow": { "background": "#d4c564", "color": "#fff" }, "eb": { "background": "#bd1118", "color": "#fff" }, "eb2": { "background": "#900", "color": "#fff" }, "breaking": { "background": "#ff0", "color": "#000" }, "bruger": { "background": "#4fa8df", "color": "#fff" }, "live": { "background": "#000", "color": "#fff" }, "native": { "background": "#cec4a6", "color": "#fff" }, "native2": { "background": "#84a8c4", "color": "#fff" }, "facebook": { "background": "#31769b", "color": "#fff" }, "twitter": { "background": "#4fa8df", "color": "#fff" }, "flash": { "background": "#e5ad02", "color": "#fff" }, "forbrug": { "background": "#00b6d2", "color": "#fff" }, "leder": { "background": "#1a237e", "color": "#fff" }, "livescore": { "background": "#029e5d", "color": "#fff" }, "livescore2": { "background": "#cbfe33", "color": "#000" }, "nyheder": { "background": "#1058c2", "color": "#fff" }, "nyheder2": { "background": "#000", "color": "#fff" }, "sexsamliv": { "background": "#b31e61", "color": "#fff" }, "sexsamliv2": { "background": "#dc7095", "color": "#fff" }, "skolefodbold": { "background": "#93b923", "color": "#fff" }, "sport": { "background": "#029e5d", "color": "#fff" }, "tv": { "background": "#bd1118", "color": "#fff" }, "underholdning": { "background": "#51208c", "color": "#fff" } };
    colorNames = { "eb": "eb", "eb2": "eb2", "breaking": "breaking", "bruger": "bruger", "live": "live", "native": "native", "native2": "native2", "facebook": "facebook", "twitter": "twitter", "flash": "flash", "forbrug": "forbrug", "leder": "leder", "livescore": "livescore", "livescore2": "livescore2", "nyheder": "nyheder", "nyheder2": "nyheder2", "sexsamliv": "sex-samliv", "sexsamliv2": "sex-samliv2", "skolefodbold": "skolefodbold", "sport": "sport", "tv": "tv", "underholdning": "underholdning" };

    var dist = {};

    var words = {};

    Object.defineProperty(words, "__esModule", {
      value: true
    });
    words.WORDS = void 0;
    var WORDS = ["ad", "adipisicing", "aliqua", "aliquip", "amet", "anim", "aute", "cillum", "commodo", "consectetur", "consequat", "culpa", "cupidatat", "deserunt", "do", "dolor", "dolore", "duis", "ea", "eiusmod", "elit", "enim", "esse", "est", "et", "eu", "ex", "excepteur", "exercitation", "fugiat", "id", "in", "incididunt", "ipsum", "irure", "labore", "laboris", "laborum", "Lorem", "magna", "minim", "mollit", "nisi", "non", "nostrud", "nulla", "occaecat", "officia", "pariatur", "proident", "qui", "quis", "reprehenderit", "sint", "sit", "sunt", "tempor", "ullamco", "ut", "velit", "veniam", "voluptate"];
    words.WORDS = WORDS;

    var LoremIpsum$1 = {};

    var formats = {};

    Object.defineProperty(formats, "__esModule", {
      value: true
    });
    formats.FORMATS = formats.FORMAT_PLAIN = formats.FORMAT_HTML = void 0;
    var FORMAT_HTML = "html";
    formats.FORMAT_HTML = FORMAT_HTML;
    var FORMAT_PLAIN = "plain";
    formats.FORMAT_PLAIN = FORMAT_PLAIN;
    var FORMATS = [FORMAT_HTML, FORMAT_PLAIN];
    formats.FORMATS = FORMATS;

    var lineEndings = {};

    Object.defineProperty(lineEndings, "__esModule", {
      value: true
    });
    lineEndings.LINE_ENDINGS = void 0;
    var LINE_ENDINGS = {
      POSIX: "\n",
      WIN32: "\r\n"
    };
    lineEndings.LINE_ENDINGS = LINE_ENDINGS;

    var generator = {};

    var util = {};

    var capitalize$1 = {};

    Object.defineProperty(capitalize$1, "__esModule", {
      value: true
    });
    capitalize$1.default = void 0;

    /**
     * @param str  A string that may or may not be capitalized.
     * @returns    A capitalized string.
     */
    var capitalize = function capitalize(str) {
      var trimmed = str.trim();
      return trimmed.charAt(0).toUpperCase() + trimmed.slice(1);
    };

    var _default$6 = capitalize;
    capitalize$1.default = _default$6;

    var isNode = {exports: {}};

    (function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    /**
     * @returns  True if the runtime is NodeJS.
     */
    var isNode = function isNode() {
      return !!module.exports;
    };

    var _default = isNode;
    exports.default = _default;

    }(isNode, isNode.exports));

    var isReactNative$1 = {};

    Object.defineProperty(isReactNative$1, "__esModule", {
      value: true
    });
    isReactNative$1.default = void 0;

    /**
     * @returns  True if runtime is ReactNative.
     */
    var isReactNative = function isReactNative() {
      return typeof navigator !== "undefined" && navigator.product === "ReactNative";
    };

    var _default$5 = isReactNative;
    isReactNative$1.default = _default$5;

    var isWindows$1 = {};

    var platforms = {};

    Object.defineProperty(platforms, "__esModule", {
      value: true
    });
    platforms.SUPPORTED_PLATFORMS = void 0;
    var SUPPORTED_PLATFORMS = {
      DARWIN: "darwin",
      LINUX: "linux",
      WIN32: "win32"
    };
    platforms.SUPPORTED_PLATFORMS = SUPPORTED_PLATFORMS;

    Object.defineProperty(isWindows$1, "__esModule", {
      value: true
    });
    isWindows$1.default = void 0;

    var _platforms = platforms;

    /**
     * @returns True if process is windows.
     */
    var isWindows = function isWindows() {
      return typeof process !== "undefined" && process.platform === _platforms.SUPPORTED_PLATFORMS.WIN32;
    };

    var _default$4 = isWindows;
    isWindows$1.default = _default$4;

    var makeArrayOfLength$1 = {};

    Object.defineProperty(makeArrayOfLength$1, "__esModule", {
      value: true
    });
    makeArrayOfLength$1.default = void 0;

    /**
     * @param length Length "x".
     * @returns      An array of indexes of length "x".
     */
    var makeArrayOfLength = function makeArrayOfLength() {
      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return Array.apply(null, Array(length)).map(function (item, index) {
        return index;
      });
    };

    var _default$3 = makeArrayOfLength;
    makeArrayOfLength$1.default = _default$3;

    var makeArrayOfStrings$1 = {};

    Object.defineProperty(makeArrayOfStrings$1, "__esModule", {
      value: true
    });
    makeArrayOfStrings$1.default = void 0;

    var _ = util;

    /**
     * @param length  Length "x".
     * @returns       An array of strings of length "x".
     */
    var makeArrayOfStrings = function makeArrayOfStrings(length, makeString) {
      var arr = (0, _.makeArrayOfLength)(length);
      return arr.map(function () {
        return makeString();
      });
    };

    var _default$2 = makeArrayOfStrings;
    makeArrayOfStrings$1.default = _default$2;

    (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "capitalize", {
      enumerable: true,
      get: function get() {
        return _capitalize.default;
      }
    });
    Object.defineProperty(exports, "isNode", {
      enumerable: true,
      get: function get() {
        return _isNode.default;
      }
    });
    Object.defineProperty(exports, "isReactNative", {
      enumerable: true,
      get: function get() {
        return _isReactNative.default;
      }
    });
    Object.defineProperty(exports, "isWindows", {
      enumerable: true,
      get: function get() {
        return _isWindows.default;
      }
    });
    Object.defineProperty(exports, "makeArrayOfLength", {
      enumerable: true,
      get: function get() {
        return _makeArrayOfLength.default;
      }
    });
    Object.defineProperty(exports, "makeArrayOfStrings", {
      enumerable: true,
      get: function get() {
        return _makeArrayOfStrings.default;
      }
    });

    var _capitalize = _interopRequireDefault(capitalize$1);

    var _isNode = _interopRequireDefault(isNode.exports);

    var _isReactNative = _interopRequireDefault(isReactNative$1);

    var _isWindows = _interopRequireDefault(isWindows$1);

    var _makeArrayOfLength = _interopRequireDefault(makeArrayOfLength$1);

    var _makeArrayOfStrings = _interopRequireDefault(makeArrayOfStrings$1);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    }(util));

    Object.defineProperty(generator, "__esModule", {
      value: true
    });
    generator.default = void 0;

    var _words = words;

    var _util$1 = util;

    function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }

    function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    var Generator =
    /*#__PURE__*/
    function () {
      function Generator() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$sentencesPerPara = _ref.sentencesPerParagraph,
            sentencesPerParagraph = _ref$sentencesPerPara === void 0 ? {
          max: 7,
          min: 3
        } : _ref$sentencesPerPara,
            _ref$wordsPerSentence = _ref.wordsPerSentence,
            wordsPerSentence = _ref$wordsPerSentence === void 0 ? {
          max: 15,
          min: 5
        } : _ref$wordsPerSentence,
            random = _ref.random;
            _ref.seed;
            var _ref$words = _ref.words,
            words = _ref$words === void 0 ? _words.WORDS : _ref$words;

        _classCallCheck$1(this, Generator);

        _defineProperty$1(this, "sentencesPerParagraph", void 0);

        _defineProperty$1(this, "wordsPerSentence", void 0);

        _defineProperty$1(this, "random", void 0);

        _defineProperty$1(this, "words", void 0);

        if (sentencesPerParagraph.min > sentencesPerParagraph.max) {
          throw new Error("Minimum number of sentences per paragraph (".concat(sentencesPerParagraph.min, ") cannot exceed maximum (").concat(sentencesPerParagraph.max, ")."));
        }

        if (wordsPerSentence.min > wordsPerSentence.max) {
          throw new Error("Minimum number of words per sentence (".concat(wordsPerSentence.min, ") cannot exceed maximum (").concat(wordsPerSentence.max, ")."));
        }

        this.sentencesPerParagraph = sentencesPerParagraph;
        this.words = words;
        this.wordsPerSentence = wordsPerSentence;
        this.random = random || Math.random;
      }

      _createClass$1(Generator, [{
        key: "generateRandomInteger",
        value: function generateRandomInteger(min, max) {
          return Math.floor(this.random() * (max - min + 1) + min);
        }
      }, {
        key: "generateRandomWords",
        value: function generateRandomWords(num) {
          var _this = this;

          var _this$wordsPerSentenc = this.wordsPerSentence,
              min = _this$wordsPerSentenc.min,
              max = _this$wordsPerSentenc.max;
          var length = num || this.generateRandomInteger(min, max);
          return (0, _util$1.makeArrayOfLength)(length).reduce(function (accumulator, index) {
            return "".concat(_this.pluckRandomWord(), " ").concat(accumulator);
          }, "").trim();
        }
      }, {
        key: "generateRandomSentence",
        value: function generateRandomSentence(num) {
          return "".concat((0, _util$1.capitalize)(this.generateRandomWords(num)), ".");
        }
      }, {
        key: "generateRandomParagraph",
        value: function generateRandomParagraph(num) {
          var _this2 = this;

          var _this$sentencesPerPar = this.sentencesPerParagraph,
              min = _this$sentencesPerPar.min,
              max = _this$sentencesPerPar.max;
          var length = num || this.generateRandomInteger(min, max);
          return (0, _util$1.makeArrayOfLength)(length).reduce(function (accumulator, index) {
            return "".concat(_this2.generateRandomSentence(), " ").concat(accumulator);
          }, "").trim();
        }
      }, {
        key: "pluckRandomWord",
        value: function pluckRandomWord() {
          var min = 0;
          var max = this.words.length - 1;
          var index = this.generateRandomInteger(min, max);
          return this.words[index];
        }
      }]);

      return Generator;
    }();

    var _default$1 = Generator;
    generator.default = _default$1;

    Object.defineProperty(LoremIpsum$1, "__esModule", {
      value: true
    });
    LoremIpsum$1.default = void 0;

    var _formats = formats;

    var _lineEndings = lineEndings;

    var _generator = _interopRequireDefault(generator);

    var _util = util;

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    var LoremIpsum =
    /*#__PURE__*/
    function () {
      function LoremIpsum() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _formats.FORMAT_PLAIN;
        var suffix = arguments.length > 2 ? arguments[2] : undefined;

        _classCallCheck(this, LoremIpsum);

        _defineProperty(this, "generator", void 0);

        _defineProperty(this, "format", void 0);

        _defineProperty(this, "suffix", void 0);

        if (_formats.FORMATS.indexOf(format.toLowerCase()) === -1) {
          throw new Error("".concat(format, " is an invalid format. Please use ").concat(_formats.FORMATS.join(" or "), "."));
        }

        this.format = format.toLowerCase();
        this.suffix = suffix;
        this.generator = new _generator.default(options);
      }

      _createClass(LoremIpsum, [{
        key: "getLineEnding",
        value: function getLineEnding() {
          if (this.suffix) {
            return this.suffix;
          }

          if (!(0, _util.isReactNative)() && (0, _util.isNode)() && (0, _util.isWindows)()) {
            return _lineEndings.LINE_ENDINGS.WIN32;
          }

          return _lineEndings.LINE_ENDINGS.POSIX;
        }
      }, {
        key: "formatString",
        value: function formatString(str) {
          if (this.format === _formats.FORMAT_HTML) {
            return "<p>".concat(str, "</p>");
          }

          return str;
        }
      }, {
        key: "formatStrings",
        value: function formatStrings(strings) {
          var _this = this;

          return strings.map(function (str) {
            return _this.formatString(str);
          });
        }
      }, {
        key: "generateWords",
        value: function generateWords(num) {
          return this.formatString(this.generator.generateRandomWords(num));
        }
      }, {
        key: "generateSentences",
        value: function generateSentences(num) {
          return this.formatString(this.generator.generateRandomParagraph(num));
        }
      }, {
        key: "generateParagraphs",
        value: function generateParagraphs(num) {
          var makeString = this.generator.generateRandomParagraph.bind(this.generator);
          return this.formatStrings((0, _util.makeArrayOfStrings)(num, makeString)).join(this.getLineEnding());
        }
      }]);

      return LoremIpsum;
    }();

    var _default = LoremIpsum;
    LoremIpsum$1.default = _default;

    (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "LoremIpsum", {
      enumerable: true,
      get: function get() {
        return _LoremIpsum.default;
      }
    });
    exports.loremIpsum = void 0;

    var _words = words;

    var _LoremIpsum = _interopRequireDefault(LoremIpsum$1);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var loremIpsum = function loremIpsum() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$count = _ref.count,
          count = _ref$count === void 0 ? 1 : _ref$count,
          _ref$format = _ref.format,
          format = _ref$format === void 0 ? "plain" : _ref$format,
          _ref$paragraphLowerBo = _ref.paragraphLowerBound,
          paragraphLowerBound = _ref$paragraphLowerBo === void 0 ? 3 : _ref$paragraphLowerBo,
          _ref$paragraphUpperBo = _ref.paragraphUpperBound,
          paragraphUpperBound = _ref$paragraphUpperBo === void 0 ? 7 : _ref$paragraphUpperBo,
          random = _ref.random,
          _ref$sentenceLowerBou = _ref.sentenceLowerBound,
          sentenceLowerBound = _ref$sentenceLowerBou === void 0 ? 5 : _ref$sentenceLowerBou,
          _ref$sentenceUpperBou = _ref.sentenceUpperBound,
          sentenceUpperBound = _ref$sentenceUpperBou === void 0 ? 15 : _ref$sentenceUpperBou,
          _ref$units = _ref.units,
          units = _ref$units === void 0 ? "sentences" : _ref$units,
          _ref$words = _ref.words,
          words = _ref$words === void 0 ? _words.WORDS : _ref$words,
          _ref$suffix = _ref.suffix,
          suffix = _ref$suffix === void 0 ? "" : _ref$suffix;

      var options = {
        random: random,
        sentencesPerParagraph: {
          max: paragraphUpperBound,
          min: paragraphLowerBound
        },
        words: words,
        wordsPerSentence: {
          max: sentenceUpperBound,
          min: sentenceLowerBound
        }
      };
      var lorem = new _LoremIpsum.default(options, format, suffix);

      switch (units) {
        case "paragraphs":
        case "paragraph":
          return lorem.generateParagraphs(count);

        case "sentences":
        case "sentence":
          return lorem.generateSentences(count);

        case "words":
        case "word":
          return lorem.generateWords(count);

        default:
          return "";
      }
    };

    exports.loremIpsum = loremIpsum;

    }(dist));

    function rdmParagraphs(num = 3) {
        const lorem = new dist.LoremIpsum({
            sentencesPerParagraph: {
                max: 8,
                min: 4,
            },
            wordsPerSentence: {
                max: 12,
                min: 4,
            },
        }, 'html');
        return lorem.generateParagraphs(num);
    }
    function rdmArticleData(mediaWidth = 640, mediaHeight = 360) {
        const lorem = new dist.LoremIpsum({
            wordsPerSentence: {
                max: 12,
                min: 4,
            },
        });
        const colorNamesForUse = [
            colorNames.breaking,
            colorNames.bruger,
            colorNames.eb,
            colorNames.flash,
            colorNames.forbrug,
            colorNames.livescore,
            colorNames.native,
            colorNames.nyheder,
            colorNames.sexsamliv,
            colorNames.sport,
            colorNames.underholdning,
        ];
        const article = {
            breaking: Math.random() < 0.1,
            colorName: colorNamesForUse[Math.floor(Math.random() * colorNamesForUse.length)],
            media: {
                src: `https://loremflickr.com/${mediaWidth}/${mediaHeight}/city,people,nature,animal?random=${Math.random()}`,
            },
            premium: Math.random() < 0.3,
            published: randomDate().toString(),
            saved: Math.random() < 0.5,
            section: lorem.generateWords(1),
            title: lorem.generateSentences(1),
            truncateTitle: false,
            update: Math.random() < 0.5,
            url: '#',
        };
        return article;
    }
    function randomDate() {
        const start = new Date(2019, 0, 1);
        const end = new Date();
        return new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
    }

    const localeSourceType = localStorage.getItem('sourceType');
    const sourceType = writable(localeSourceType || 'html');
    sourceType.subscribe((value) => {
        localStorage.setItem('sourceType', value);
    });

    /* src/components/accordion/Accordion.svelte generated by Svelte v3.42.6 */
    const file$1l = "src/components/accordion/Accordion.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    // (8:2) {#each tabs as tab, i}
    function create_each_block$6(ctx) {
    	let div2;
    	let div0;
    	let span;
    	let t0_value = /*tab*/ ctx[5].title + "";
    	let t0;
    	let t1;
    	let i_1;
    	let t2;
    	let div1;
    	let raw_value = /*tab*/ ctx[5].content + "";
    	let t3;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[4](/*i*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			i_1 = element("i");
    			t2 = space();
    			div1 = element("div");
    			t3 = space();
    			attr_dev(span, "class", "fontweight-bold fontsize-medium");
    			add_location(span, file$1l, 15, 8, 581);
    			attr_dev(i_1, "class", "fas fa-chevron-down");
    			add_location(i_1, file$1l, 16, 8, 654);
    			attr_dev(div0, "class", "accordion-header flex flex-justify--between flex-align--center padding-m");
    			add_location(div0, file$1l, 9, 6, 377);
    			attr_dev(div1, "class", "accordion-body padding-m padding-l--rl fontsize-small");
    			add_location(div1, file$1l, 18, 6, 707);
    			attr_dev(div2, "class", "accordion-tab margin-m--b");
    			toggle_class(div2, "accordion-expanded", /*$activeTab*/ ctx[3] === /*i*/ ctx[7]);
    			add_location(div2, file$1l, 8, 4, 287);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, span);
    			append_dev(span, t0);
    			append_dev(div0, t1);
    			append_dev(div0, i_1);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			div1.innerHTML = raw_value;
    			append_dev(div2, t3);

    			if (!mounted) {
    				dispose = listen_dev(div0, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*tabs*/ 4 && t0_value !== (t0_value = /*tab*/ ctx[5].title + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*tabs*/ 4 && raw_value !== (raw_value = /*tab*/ ctx[5].content + "")) div1.innerHTML = raw_value;
    			if (dirty & /*$activeTab*/ 8) {
    				toggle_class(div2, "accordion-expanded", /*$activeTab*/ ctx[3] === /*i*/ ctx[7]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(8:2) {#each tabs as tab, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1m(ctx) {
    	let div;
    	let each_value = /*tabs*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "data-theme", /*dataTheme*/ ctx[1]);
    			attr_dev(div, "class", "accordion card-mode padding-l ff-secondary width-1of1");
    			add_location(div, file$1l, 6, 0, 167);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$activeTab, tabs, undefined*/ 12) {
    				each_value = /*tabs*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*dataTheme*/ 2) {
    				attr_dev(div, "data-theme", /*dataTheme*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1m($$self, $$props, $$invalidate) {
    	let $activeTab,
    		$$unsubscribe_activeTab = noop,
    		$$subscribe_activeTab = () => ($$unsubscribe_activeTab(), $$unsubscribe_activeTab = subscribe(activeTab, $$value => $$invalidate(3, $activeTab = $$value)), activeTab);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_activeTab());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Accordion', slots, []);
    	const activeTab = writable(undefined);
    	validate_store(activeTab, 'activeTab');
    	$$subscribe_activeTab();
    	let { dataTheme = undefined } = $$props;
    	let { tabs } = $$props;
    	const writable_props = ['dataTheme', 'tabs'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Accordion> was created with unknown prop '${key}'`);
    	});

    	const click_handler = i => {
    		set_store_value(activeTab, $activeTab = $activeTab !== i ? i : undefined, $activeTab);
    	};

    	$$self.$$set = $$props => {
    		if ('dataTheme' in $$props) $$invalidate(1, dataTheme = $$props.dataTheme);
    		if ('tabs' in $$props) $$invalidate(2, tabs = $$props.tabs);
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		activeTab,
    		dataTheme,
    		tabs,
    		$activeTab
    	});

    	$$self.$inject_state = $$props => {
    		if ('dataTheme' in $$props) $$invalidate(1, dataTheme = $$props.dataTheme);
    		if ('tabs' in $$props) $$invalidate(2, tabs = $$props.tabs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [activeTab, dataTheme, tabs, $activeTab, click_handler];
    }

    class Accordion extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1m, create_fragment$1m, safe_not_equal, { activeTab: 0, dataTheme: 1, tabs: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Accordion",
    			options,
    			id: create_fragment$1m.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*tabs*/ ctx[2] === undefined && !('tabs' in props)) {
    			console.warn("<Accordion> was created without expected prop 'tabs'");
    		}
    	}

    	get activeTab() {
    		return this.$$.ctx[0];
    	}

    	set activeTab(value) {
    		throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dataTheme() {
    		throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataTheme(value) {
    		throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabs() {
    		throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabs(value) {
    		throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function parseDate(datetime) {
        const monthNames = ['jan', 'feb', 'mar', 'apr', 'maj', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'];
        const inputdate = new Date(datetime); // UTC-time from server (Z)
        const now = new Date();
        const inputDateLocalTz = new Date(inputdate.getTime() + now.getTimezoneOffset() * 60);
        const secondsSince = Math.round((now.getTime() - inputDateLocalTz.getTime()) / 1000);
        const days = Math.floor(secondsSince / 86400);
        let output = '';
        if (days) {
            // More than 24 hours old
            const yesterday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
            if (inputDateLocalTz.getTime() > yesterday.getTime()) {
                output = 'I går';
            }
            else {
                output = `${inputDateLocalTz.getDate()}. ${monthNames[inputDateLocalTz.getMonth()]}.${now.getFullYear() !== inputDateLocalTz.getFullYear() ? ` ${inputDateLocalTz.getFullYear()}` : ''}`;
            }
        }
        else {
            // Less than 24 hours old
            const hours = Math.floor((secondsSince % 86400) / 3600);
            const minutes = Math.floor(((secondsSince % 86400) % 3600) / 60);
            const seconds = secondsSince % 60;
            if (hours) {
                output = hours === 1 ? `${hours} time` : `${hours} timer`;
            }
            else if (minutes) {
                output = `${minutes} min`;
            }
            else if (seconds) {
                output = `${seconds} sek`;
            }
        }
        return output;
    }

    /* src/components/badge/Badge.svelte generated by Svelte v3.42.6 */

    const file$1k = "src/components/badge/Badge.svelte";

    // (22:0) {:else}
    function create_else_block$i(ctx) {
    	let span;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot) default_slot.c();
    			attr_dev(span, "class", /*cssClass*/ ctx[3]);
    			attr_dev(span, "style", /*style*/ ctx[1]);
    			attr_dev(span, "data-type", /*type*/ ctx[2]);
    			add_location(span, file$1k, 22, 2, 593);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*click_handler_1*/ ctx[10], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 8) {
    				attr_dev(span, "class", /*cssClass*/ ctx[3]);
    			}

    			if (!current || dirty & /*style*/ 2) {
    				attr_dev(span, "style", /*style*/ ctx[1]);
    			}

    			if (!current || dirty & /*type*/ 4) {
    				attr_dev(span, "data-type", /*type*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$i.name,
    		type: "else",
    		source: "(22:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (18:0) {#if href}
    function create_if_block$n(ctx) {
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			attr_dev(a, "href", /*href*/ ctx[0]);
    			attr_dev(a, "class", /*cssClass*/ ctx[3]);
    			attr_dev(a, "style", /*style*/ ctx[1]);
    			attr_dev(a, "data-type", /*type*/ ctx[2]);
    			add_location(a, file$1k, 18, 2, 501);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*href*/ 1) {
    				attr_dev(a, "href", /*href*/ ctx[0]);
    			}

    			if (!current || dirty & /*cssClass*/ 8) {
    				attr_dev(a, "class", /*cssClass*/ ctx[3]);
    			}

    			if (!current || dirty & /*style*/ 2) {
    				attr_dev(a, "style", /*style*/ ctx[1]);
    			}

    			if (!current || dirty & /*type*/ 4) {
    				attr_dev(a, "data-type", /*type*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(18:0) {#if href}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1l(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$n, create_else_block$i];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*href*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1l($$self, $$props, $$invalidate) {
    	let cssClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Badge', slots, ['default']);
    	let { className = '' } = $$props;
    	let { extension = undefined } = $$props;
    	let { href = undefined } = $$props;
    	let { style = undefined } = $$props;
    	let { type = undefined } = $$props;
    	let baseClass = 'badge';

    	if (extension) {
    		if (typeof extension === 'string') {
    			baseClass = `${baseClass} badge--${extension}`;
    		} else if (Array.isArray(extension)) {
    			baseClass = `${baseClass} badge--${extension.join(' badge--')}`;
    		}
    	}

    	const writable_props = ['className', 'extension', 'href', 'style', 'type'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Badge> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('extension' in $$props) $$invalidate(5, extension = $$props.extension);
    		if ('href' in $$props) $$invalidate(0, href = $$props.href);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('type' in $$props) $$invalidate(2, type = $$props.type);
    		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		extension,
    		href,
    		style,
    		type,
    		baseClass,
    		cssClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('extension' in $$props) $$invalidate(5, extension = $$props.extension);
    		if ('href' in $$props) $$invalidate(0, href = $$props.href);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('type' in $$props) $$invalidate(2, type = $$props.type);
    		if ('baseClass' in $$props) $$invalidate(6, baseClass = $$props.baseClass);
    		if ('cssClass' in $$props) $$invalidate(3, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*baseClass, className*/ 80) {
    			$$invalidate(3, cssClass = `${baseClass} ${className}`);
    		}
    	};

    	return [
    		href,
    		style,
    		type,
    		cssClass,
    		className,
    		extension,
    		baseClass,
    		$$scope,
    		slots,
    		click_handler,
    		click_handler_1
    	];
    }

    class Badge extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1l, create_fragment$1l, safe_not_equal, {
    			className: 4,
    			extension: 5,
    			href: 0,
    			style: 1,
    			type: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Badge",
    			options,
    			id: create_fragment$1l.name
    		});
    	}

    	get className() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get extension() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set extension(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/card/Card.svelte generated by Svelte v3.42.6 */

    const file$1j = "src/components/card/Card.svelte";
    const get_footer_slot_changes_1 = dirty => ({});
    const get_footer_slot_context_1 = ctx => ({});
    const get_content_slot_changes_1 = dirty => ({});
    const get_content_slot_context_1 = ctx => ({});
    const get_media_slot_changes_1 = dirty => ({});
    const get_media_slot_context_1 = ctx => ({});
    const get_header_slot_changes_1 = dirty => ({});
    const get_header_slot_context_1 = ctx => ({});
    const get_footer_slot_changes = dirty => ({});
    const get_footer_slot_context = ctx => ({});
    const get_content_slot_changes = dirty => ({});
    const get_content_slot_context = ctx => ({});
    const get_media_slot_changes = dirty => ({});
    const get_media_slot_context = ctx => ({ class: "card-media" });
    const get_header_slot_changes = dirty => ({});
    const get_header_slot_context = ctx => ({ class: "card-header" });

    // (34:0) {:else}
    function create_else_block$h(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*$$slots*/ ctx[4].header && create_if_block_8(ctx);
    	let if_block1 = /*$$slots*/ ctx[4].media && create_if_block_7$1(ctx);
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
    	let if_block2 = /*$$slots*/ ctx[4].content && create_if_block_6$1(ctx);
    	let if_block3 = /*$$slots*/ ctx[4].footer && create_if_block_5$3(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (default_slot) default_slot.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			attr_dev(div, "class", /*cssClass*/ ctx[3]);
    			attr_dev(div, "style", /*style*/ ctx[1]);
    			add_location(div, file$1j, 34, 2, 824);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			append_dev(div, t2);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t3);
    			if (if_block3) if_block3.m(div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*click_handler_1*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*$$slots*/ ctx[4].header) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_8(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$$slots*/ ctx[4].media) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 16) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_7$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*$$slots*/ ctx[4].content) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 16) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_6$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t3);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*$$slots*/ ctx[4].footer) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 16) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_5$3(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*cssClass*/ 8) {
    				attr_dev(div, "class", /*cssClass*/ ctx[3]);
    			}

    			if (!current || dirty & /*style*/ 2) {
    				attr_dev(div, "style", /*style*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(default_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(default_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (default_slot) default_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$h.name,
    		type: "else",
    		source: "(34:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (14:0) {#if url}
    function create_if_block$m(ctx) {
    	let a;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*$$slots*/ ctx[4].header && create_if_block_4$6(ctx);
    	let if_block1 = /*$$slots*/ ctx[4].media && create_if_block_3$7(ctx);
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
    	let if_block2 = /*$$slots*/ ctx[4].content && create_if_block_2$9(ctx);
    	let if_block3 = /*$$slots*/ ctx[4].footer && create_if_block_1$d(ctx);

    	let a_levels = [
    		{ href: /*url*/ ctx[0] },
    		{ class: /*cssClass*/ ctx[3] },
    		{ style: /*style*/ ctx[1] },
    		/*dataProps*/ ctx[2]
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (default_slot) default_slot.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			set_attributes(a, a_data);
    			add_location(a, file$1j, 14, 2, 340);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			if (if_block0) if_block0.m(a, null);
    			append_dev(a, t0);
    			if (if_block1) if_block1.m(a, null);
    			append_dev(a, t1);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			append_dev(a, t2);
    			if (if_block2) if_block2.m(a, null);
    			append_dev(a, t3);
    			if (if_block3) if_block3.m(a, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*$$slots*/ ctx[4].header) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$6(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(a, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$$slots*/ ctx[4].media) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 16) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$7(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(a, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*$$slots*/ ctx[4].content) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 16) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_2$9(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(a, t3);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*$$slots*/ ctx[4].footer) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*$$slots*/ 16) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_1$d(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(a, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty & /*url*/ 1) && { href: /*url*/ ctx[0] },
    				(!current || dirty & /*cssClass*/ 8) && { class: /*cssClass*/ ctx[3] },
    				(!current || dirty & /*style*/ 2) && { style: /*style*/ ctx[1] },
    				dirty & /*dataProps*/ 4 && /*dataProps*/ ctx[2]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(default_slot, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(default_slot, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (default_slot) default_slot.d(detaching);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(14:0) {#if url}",
    		ctx
    	});

    	return block;
    }

    // (36:4) {#if $$slots.header}
    function create_if_block_8(ctx) {
    	let div;
    	let current;
    	const header_slot_template = /*#slots*/ ctx[7].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[6], get_header_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (header_slot) header_slot.c();
    			attr_dev(div, "class", "card-header");
    			add_location(div, file$1j, 36, 6, 895);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (header_slot) {
    				header_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (header_slot) {
    				if (header_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[6], dirty, get_header_slot_changes_1),
    						get_header_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(36:4) {#if $$slots.header}",
    		ctx
    	});

    	return block;
    }

    // (41:4) {#if $$slots.media}
    function create_if_block_7$1(ctx) {
    	let div;
    	let current;
    	const media_slot_template = /*#slots*/ ctx[7].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[6], get_media_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (media_slot) media_slot.c();
    			attr_dev(div, "class", "card-media");
    			add_location(div, file$1j, 41, 6, 1005);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (media_slot) {
    				media_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (media_slot) {
    				if (media_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[6], dirty, get_media_slot_changes_1),
    						get_media_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(41:4) {#if $$slots.media}",
    		ctx
    	});

    	return block;
    }

    // (47:4) {#if $$slots.content}
    function create_if_block_6$1(ctx) {
    	let div;
    	let current;
    	const content_slot_template = /*#slots*/ ctx[7].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[6], get_content_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (content_slot) content_slot.c();
    			attr_dev(div, "class", "card-content");
    			add_location(div, file$1j, 47, 6, 1128);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (content_slot) {
    				content_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (content_slot) {
    				if (content_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[6], dirty, get_content_slot_changes_1),
    						get_content_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (content_slot) content_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(47:4) {#if $$slots.content}",
    		ctx
    	});

    	return block;
    }

    // (52:4) {#if $$slots.footer}
    function create_if_block_5$3(ctx) {
    	let div;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[7].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[6], get_footer_slot_context_1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "card-footer");
    			add_location(div, file$1j, 52, 6, 1241);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[6], dirty, get_footer_slot_changes_1),
    						get_footer_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$3.name,
    		type: "if",
    		source: "(52:4) {#if $$slots.footer}",
    		ctx
    	});

    	return block;
    }

    // (16:4) {#if $$slots.header}
    function create_if_block_4$6(ctx) {
    	let current;
    	const header_slot_template = /*#slots*/ ctx[7].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[6], get_header_slot_context);

    	const block = {
    		c: function create() {
    			if (header_slot) header_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (header_slot) {
    				header_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (header_slot) {
    				if (header_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[6], dirty, get_header_slot_changes),
    						get_header_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$6.name,
    		type: "if",
    		source: "(16:4) {#if $$slots.header}",
    		ctx
    	});

    	return block;
    }

    // (19:4) {#if $$slots.media}
    function create_if_block_3$7(ctx) {
    	let current;
    	const media_slot_template = /*#slots*/ ctx[7].media;
    	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[6], get_media_slot_context);

    	const block = {
    		c: function create() {
    			if (media_slot) media_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (media_slot) {
    				media_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (media_slot) {
    				if (media_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						media_slot,
    						media_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[6], dirty, get_media_slot_changes),
    						get_media_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (media_slot) media_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$7.name,
    		type: "if",
    		source: "(19:4) {#if $$slots.media}",
    		ctx
    	});

    	return block;
    }

    // (23:4) {#if $$slots.content}
    function create_if_block_2$9(ctx) {
    	let div;
    	let current;
    	const content_slot_template = /*#slots*/ ctx[7].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[6], get_content_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (content_slot) content_slot.c();
    			attr_dev(div, "class", "card-content");
    			add_location(div, file$1j, 23, 6, 614);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (content_slot) {
    				content_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (content_slot) {
    				if (content_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[6], dirty, get_content_slot_changes),
    						get_content_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(content_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(content_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (content_slot) content_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(23:4) {#if $$slots.content}",
    		ctx
    	});

    	return block;
    }

    // (28:4) {#if $$slots.footer}
    function create_if_block_1$d(ctx) {
    	let div;
    	let current;
    	const footer_slot_template = /*#slots*/ ctx[7].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[6], get_footer_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (footer_slot) footer_slot.c();
    			attr_dev(div, "class", "card-footer");
    			add_location(div, file$1j, 28, 6, 727);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (footer_slot) {
    				footer_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (footer_slot) {
    				if (footer_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						footer_slot,
    						footer_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[6], dirty, get_footer_slot_changes),
    						get_footer_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(28:4) {#if $$slots.footer}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1k(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$m, create_else_block$h];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*url*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1k($$self, $$props, $$invalidate) {
    	let cssClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Card', slots, ['header','media','default','content','footer']);
    	const $$slots = compute_slots(slots);
    	let { className = undefined } = $$props;
    	let { url = undefined } = $$props;
    	let { style = undefined } = $$props;
    	let baseClass = 'card';
    	const dataProps = {};

    	for (const prop in $$props) {
    		if (prop.indexOf('data-') === 0) {
    			dataProps[prop] = $$props[prop];
    		}
    	}

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ('className' in $$new_props) $$invalidate(5, className = $$new_props.className);
    		if ('url' in $$new_props) $$invalidate(0, url = $$new_props.url);
    		if ('style' in $$new_props) $$invalidate(1, style = $$new_props.style);
    		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		url,
    		style,
    		baseClass,
    		dataProps,
    		cssClass
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(5, className = $$new_props.className);
    		if ('url' in $$props) $$invalidate(0, url = $$new_props.url);
    		if ('style' in $$props) $$invalidate(1, style = $$new_props.style);
    		if ('baseClass' in $$props) $$invalidate(10, baseClass = $$new_props.baseClass);
    		if ('cssClass' in $$props) $$invalidate(3, cssClass = $$new_props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 32) {
    			$$invalidate(3, cssClass = `${className} ${baseClass}`);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		url,
    		style,
    		dataProps,
    		cssClass,
    		$$slots,
    		className,
    		$$scope,
    		slots,
    		click_handler,
    		click_handler_1
    	];
    }

    class Card extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1k, create_fragment$1k, safe_not_equal, { className: 5, url: 0, style: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Card",
    			options,
    			id: create_fragment$1k.name
    		});
    	}

    	get className() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/icon/svgs/angle-down.svg.svelte generated by Svelte v3.42.6 */

    const file$1i = "src/components/icon/svgs/angle-down.svg.svelte";

    function create_fragment$1j(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "far" },
    		{ "data-icon": "angle-down" },
    		{
    			class: "svg-inline--fa fa-angle-down fa-w-10"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 320 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M151.5 347.8L3.5 201c-4.7-4.7-4.7-12.3 0-17l19.8-19.8c4.7-4.7 12.3-4.7 17 0L160 282.7l119.7-118.5c4.7-4.7 12.3-4.7 17 0l19.8 19.8c4.7 4.7 4.7 12.3 0 17l-148 146.8c-4.7 4.7-12.3 4.7-17 0z");
    			add_location(path, file$1i, 0, 210, 210);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1i, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "far" },
    				{ "data-icon": "angle-down" },
    				{
    					class: "svg-inline--fa fa-angle-down fa-w-10"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 320 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Angle_down_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Angle_down_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1j, create_fragment$1j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Angle_down_svg",
    			options,
    			id: create_fragment$1j.name
    		});
    	}
    }

    /* src/components/icon/svgs/angle-left.svg.svelte generated by Svelte v3.42.6 */

    const file$1h = "src/components/icon/svgs/angle-left.svg.svelte";

    function create_fragment$1i(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "far" },
    		{ "data-icon": "angle-left" },
    		{
    			class: "svg-inline--fa fa-angle-left fa-w-6"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 192 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M4.2 247.5L151 99.5c4.7-4.7 12.3-4.7 17 0l19.8 19.8c4.7 4.7 4.7 12.3 0 17L69.3 256l118.5 119.7c4.7 4.7 4.7 12.3 0 17L168 412.5c-4.7 4.7-12.3 4.7-17 0L4.2 264.5c-4.7-4.7-4.7-12.3 0-17z");
    			add_location(path, file$1h, 1, 2, 212);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1h, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "far" },
    				{ "data-icon": "angle-left" },
    				{
    					class: "svg-inline--fa fa-angle-left fa-w-6"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 192 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Angle_left_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Angle_left_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1i, create_fragment$1i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Angle_left_svg",
    			options,
    			id: create_fragment$1i.name
    		});
    	}
    }

    /* src/components/icon/svgs/angle-right.svg.svelte generated by Svelte v3.42.6 */

    const file$1g = "src/components/icon/svgs/angle-right.svg.svelte";

    function create_fragment$1h(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "far" },
    		{ "data-icon": "angle-right" },
    		{
    			class: "svg-inline--fa fa-angle-right fa-w-6"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 192 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M187.8 264.5L41 412.5c-4.7 4.7-12.3 4.7-17 0L4.2 392.7c-4.7-4.7-4.7-12.3 0-17L122.7 256 4.2 136.3c-4.7-4.7-4.7-12.3 0-17L24 99.5c4.7-4.7 12.3-4.7 17 0l146.8 148c4.7 4.7 4.7 12.3 0 17z");
    			add_location(path, file$1g, 0, 211, 211);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1g, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "far" },
    				{ "data-icon": "angle-right" },
    				{
    					class: "svg-inline--fa fa-angle-right fa-w-6"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 192 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Angle_right_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Angle_right_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1h, create_fragment$1h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Angle_right_svg",
    			options,
    			id: create_fragment$1h.name
    		});
    	}
    }

    /* src/components/icon/svgs/angle-up.svg.svelte generated by Svelte v3.42.6 */

    const file$1f = "src/components/icon/svgs/angle-up.svg.svelte";

    function create_fragment$1g(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "far" },
    		{ "data-icon": "angle-up" },
    		{
    			class: "svg-inline--fa fa-angle-up fa-w-10"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 320 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M168.5 164.2l148 146.8c4.7 4.7 4.7 12.3 0 17l-19.8 19.8c-4.7 4.7-12.3 4.7-17 0L160 229.3 40.3 347.8c-4.7 4.7-12.3 4.7-17 0L3.5 328c-4.7-4.7-4.7-12.3 0-17l148-146.8c4.7-4.7 12.3-4.7 17 0z");
    			add_location(path, file$1f, 0, 206, 206);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1f, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "far" },
    				{ "data-icon": "angle-up" },
    				{
    					class: "svg-inline--fa fa-angle-up fa-w-10"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 320 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Angle_up_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Angle_up_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1g, create_fragment$1g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Angle_up_svg",
    			options,
    			id: create_fragment$1g.name
    		});
    	}
    }

    /* src/components/icon/svgs/article.svg.svelte generated by Svelte v3.42.6 */

    const file$1e = "src/components/icon/svgs/article.svg.svelte";

    function create_fragment$1f(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 51 47" },
    		{
    			style: "enable-background:new 0 0 51 47;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M27,46.5h-4.5c-0.8,0-1.5-0.7-1.5-1.5s0.7-1.5,1.5-1.5H27c0.8,0,1.5,0.7,1.5,1.5S27.8,46.5,27,46.5z M15,46.5H2\n\tc-0.8,0-1.5-0.7-1.5-1.5s0.7-1.5,1.5-1.5h13c0.8,0,1.5,0.7,1.5,1.5S15.8,46.5,15,46.5z M49,35.4H2c-0.8,0-1.5-0.7-1.5-1.5\n\ts0.7-1.5,1.5-1.5h47c0.8,0,1.5,0.7,1.5,1.5S49.8,35.4,49,35.4z M49,24.3H33.5c-0.8,0-1.5-0.7-1.5-1.5s0.7-1.5,1.5-1.5H49\n\tc0.8,0,1.5,0.7,1.5,1.5S49.8,24.3,49,24.3z M22.7,24.3H3.3c-1.6,0-2.8-1.2-2.8-2.8V3c0-1.6,1.2-2.8,2.8-2.8h19.4\n\tc1.6,0,2.8,1.2,2.8,2.8v18.5C25.4,23.1,24.3,24.3,22.7,24.3z M3.5,21.3l18.9,0V3.3l-18.9,0L3.5,21.3z M49,13.2H33.5\n\tc-0.8,0-1.5-0.7-1.5-1.5s0.7-1.5,1.5-1.5H49c0.8,0,1.5,0.7,1.5,1.5S49.8,13.2,49,13.2z M49,3.3H33.5c-0.8,0-1.5-0.7-1.5-1.5\n\ts0.7-1.5,1.5-1.5H49c0.8,0,1.5,0.7,1.5,1.5S49.8,3.3,49,3.3z");
    			add_location(path, file$1e, 11, 2, 244);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1e, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 51 47" },
    				{
    					style: "enable-background:new 0 0 51 47;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Article_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Article_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1f, create_fragment$1f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Article_svg",
    			options,
    			id: create_fragment$1f.name
    		});
    	}
    }

    /* src/components/icon/svgs/at.svg.svelte generated by Svelte v3.42.6 */

    const file$1d = "src/components/icon/svgs/at.svg.svelte";

    function create_fragment$1e(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 16 16" },
    		{
    			style: "enable-background:new 0 0 16 16;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "class", "st0");
    			attr_dev(path, "d", "M8,15.6c-4.2,0-7.6-3.4-7.6-7.6S3.8,0.4,8,0.4s7.6,3.4,7.6,7.6v1.3c0,1.3-1.1,2.4-2.4,2.4c-1,0-1.8-0.6-2.2-1.4\n\tc-0.7,0.9-1.7,1.4-2.9,1.4C6,11.7,4.3,10,4.3,8C4.3,6,6,4.3,8,4.3c1.1,0,2,0.5,2.7,1.2V4.8h1v4.5c0,0.8,0.6,1.4,1.4,1.4\n\ts1.4-0.6,1.4-1.4V8c0-3.6-2.9-6.6-6.6-6.6C4.4,1.4,1.4,4.4,1.4,8c0,3.6,2.9,6.6,6.6,6.6V15.6z M8,5.3C6.5,5.3,5.3,6.5,5.3,8\n\tc0,1.5,1.2,2.7,2.7,2.7c1.5,0,2.7-1.2,2.7-2.7C10.7,6.5,9.5,5.3,8,5.3z");
    			add_location(path, file$1d, 3, 0, 226);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1d, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 16 16" },
    				{
    					style: "enable-background:new 0 0 16 16;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('At_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class At_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1e, create_fragment$1e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "At_svg",
    			options,
    			id: create_fragment$1e.name
    		});
    	}
    }

    /* src/components/icon/svgs/check.svg.svelte generated by Svelte v3.42.6 */

    const file$1c = "src/components/icon/svgs/check.svg.svelte";

    function create_fragment$1d(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 442.6 335.1" },
    		{
    			style: "enable-background:new 0 0 442.6 335.1;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M410.8,3.5l-280,280l-99-99c-4.7-4.7-12.3-4.7-17,0L3.5,195.8c-4.7,4.7-4.7,12.3,0,17l118.8,118.8c4.7,4.7,12.3,4.7,17,0\n\tL439.1,31.8c4.7-4.7,4.7-12.3,0-17L427.8,3.5C423.1-1.2,415.5-1.2,410.8,3.5L410.8,3.5z");
    			add_location(path, file$1c, 10, 2, 211);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1c, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 442.6 335.1" },
    				{
    					style: "enable-background:new 0 0 442.6 335.1;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Check_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Check_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1d, create_fragment$1d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Check_svg",
    			options,
    			id: create_fragment$1d.name
    		});
    	}
    }

    /* src/components/icon/svgs/clock.svg.svelte generated by Svelte v3.42.6 */

    const file$1b = "src/components/icon/svgs/clock.svg.svelte";

    function create_fragment$1c(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "far" },
    		{ "data-icon": "clock" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5 0-200-89.5-200-200S145.5 56 256 56s200 89.5 200 200-89.5 200-200 200zm61.8-104.4l-84.9-61.7c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h32c6.6 0 12 5.4 12 12v141.7l66.8 48.6c5.4 3.9 6.5 11.4 2.6 16.8L334.6 349c-3.9 5.3-11.4 6.5-16.8 2.6z");
    			add_location(path, file$1b, 0, 160, 160);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1b, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "far" },
    				{ "data-icon": "clock" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Clock_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Clock_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1c, create_fragment$1c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Clock_svg",
    			options,
    			id: create_fragment$1c.name
    		});
    	}
    }

    /* src/components/icon/svgs/creditcard.svg.svelte generated by Svelte v3.42.6 */

    const file$1a = "src/components/icon/svgs/creditcard.svg.svelte";

    function create_fragment$1b(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 576 448" },
    		{
    			style: "enable-background:new 0 0 576 448;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M528,0H48C21.5,0,0,21.5,0,48v352c0,26.5,21.5,48,48,48h480c26.5,0,48-21.5,48-48V48C576,21.5,554.5,0,528,0z M48,32h480\n\tc8.8,0,16,7.2,16,16v48H32V48C32,39.2,39.2,32,48,32z M528,416H48c-8.8,0-16-7.2-16-16V192h512v208C544,408.8,536.8,416,528,416z\n\t M192,332v8c0,6.6-5.4,12-12,12h-72c-6.6,0-12-5.4-12-12v-8c0-6.6,5.4-12,12-12h72C186.6,320,192,325.4,192,332z M384,332v8\n\tc0,6.6-5.4,12-12,12H236c-6.6,0-12-5.4-12-12v-8c0-6.6,5.4-12,12-12h136C378.6,320,384,325.4,384,332z");
    			add_location(path, file$1a, 10, 2, 203);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$1a, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 576 448" },
    				{
    					style: "enable-background:new 0 0 576 448;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Creditcard_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Creditcard_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1b, create_fragment$1b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Creditcard_svg",
    			options,
    			id: create_fragment$1b.name
    		});
    	}
    }

    /* src/components/icon/svgs/ebplus_icon.svg.svelte generated by Svelte v3.42.6 */

    const file$19 = "src/components/icon/svgs/ebplus_icon.svg.svelte";

    function create_fragment$1a(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 72.8 72.8" },
    		{
    			style: "enable-background:new 0 0 72.8 72.8;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M36.4,0C16.3,0,0,16.3,0,36.4s16.3,36.4,36.4,36.4s36.4-16.3,36.4-36.4S56.5,0,36.4,0z M56.5,41.9H42.2v14.2\n\tH30.6V41.9H16.3V31.4h14.2V17.2h11.7v14.1h14.2V41.9z");
    			add_location(path, file$19, 11, 2, 252);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$19, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 72.8 72.8" },
    				{
    					style: "enable-background:new 0 0 72.8 72.8;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Ebplus_icon_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Ebplus_icon_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1a, create_fragment$1a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ebplus_icon_svg",
    			options,
    			id: create_fragment$1a.name
    		});
    	}
    }

    /* src/components/icon/svgs/ebplus_sort.svg.svelte generated by Svelte v3.42.6 */

    const file$18 = "src/components/icon/svgs/ebplus_sort.svg.svelte";

    function create_fragment$19(ctx) {
    	let svg;
    	let g1;
    	let g0;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 122.1 595.3 597.4" },
    		{
    			"enable-background": "new 0 122.1 595.3 597.4"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			path = svg_element("path");
    			attr_dev(path, "d", "M237.4,122.1h120.5v238.5h237.4V481H357.9v238.5H237.4V481H0V360.5h237.4V122.1z");
    			add_location(path, file$18, 13, 6, 275);
    			add_location(g0, file$18, 12, 4, 265);
    			add_location(g1, file$18, 11, 2, 257);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$18, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g1);
    			append_dev(g1, g0);
    			append_dev(g0, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 122.1 595.3 597.4" },
    				{
    					"enable-background": "new 0 122.1 595.3 597.4"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$19.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$19($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Ebplus_sort_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Ebplus_sort_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$19, create_fragment$19, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ebplus_sort_svg",
    			options,
    			id: create_fragment$19.name
    		});
    	}
    }

    /* src/components/icon/svgs/envelope.svg.svelte generated by Svelte v3.42.6 */

    const file$17 = "src/components/icon/svgs/envelope.svg.svelte";

    function create_fragment$18(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 512 384" },
    		{
    			style: "enable-background:new 0 0 512 384;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M464,0H48C21.5,0,0,21.5,0,48v288c0,26.5,21.5,48,48,48h416c26.5,0,48-21.5,48-48V48C512,21.5,490.5,0,464,0z M48,32h416\n\tc8.8,0,16,7.2,16,16v41.4c-21.9,18.5-53.2,44-150.6,121.3c-16.9,13.4-50.2,45.7-73.4,45.3c-23.2,0.4-56.6-31.9-73.4-45.3\n\tC85.2,133.4,53.9,107.9,32,89.4V48C32,39.2,39.2,32,48,32z M464,352H48c-8.8,0-16-7.2-16-16V131c22.8,18.7,58.8,47.6,130.7,104.7\n\tc20.5,16.4,56.7,52.5,93.3,52.3c36.4,0.3,72.3-35.5,93.3-52.3c71.9-57.1,107.9-86,130.7-104.7v205C480,344.8,472.8,352,464,352z");
    			add_location(path, file$17, 10, 2, 203);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$17, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 512 384" },
    				{
    					style: "enable-background:new 0 0 512 384;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$18.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$18($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Envelope_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Envelope_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$18, create_fragment$18, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Envelope_svg",
    			options,
    			id: create_fragment$18.name
    		});
    	}
    }

    /* src/components/icon/svgs/figcaption-pin.svg.svelte generated by Svelte v3.42.6 */

    const file$16 = "src/components/icon/svgs/figcaption-pin.svg.svelte";

    function create_fragment$17(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 34 16.4" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "d", "M15.6.8c.8-.8 2-.8 2.8 0l6.7 6.7c1.9 1.9 4.4 2.9 7.1 2.9H34v6H0v-6h1.9c2.7 0 5.2-1.1 7.1-2.9L15.6.8z");
    			attr_dev(path0, "fill", "#fff");
    			add_location(path0, file$16, 0, 76, 76);
    			attr_dev(path1, "d", "M9.7 12.9l6.6-6.6c.4-.4 1-.4 1.4 0l6.6 6.6c.6.6.2 1.7-.7 1.7H10.4c-.9 0-1.3-1-.7-1.7z");
    			add_location(path1, file$16, 0, 201, 201);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$16, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 34 16.4" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$17.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$17($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Figcaption_pin_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Figcaption_pin_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$17, create_fragment$17, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Figcaption_pin_svg",
    			options,
    			id: create_fragment$17.name
    		});
    	}
    }

    /* src/components/icon/svgs/gallery.svg.svelte generated by Svelte v3.42.6 */

    const file$15 = "src/components/icon/svgs/gallery.svg.svelte";

    function create_fragment$16(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 55 55" },
    		{
    			style: "enable-background:new 0 0 55 55;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M43.7,54.5c-0.3,0-0.6,0-0.9-0.1l-32.7-6.6c-0.8-0.2-1.3-1-1.2-1.8c0.2-0.8,1-1.3,1.8-1.2l32.8,6.6c0.1,0,0.1,0,0.2,0\n\tc0.1,0,0.1,0,0.6-0.1l0.1,0c0,0,0-0.1,0.1-0.1c0-0.1,0-0.1,0-0.2l7.1-35c0-0.2,0-0.4-0.1-0.6c-0.1-0.1-0.2-0.2-0.4-0.3L46,14.3\n\tc-0.8-0.1-1.4-0.9-1.2-1.7c0.1-0.8,0.9-1.4,1.7-1.2l4.9,0.9c1,0.2,1.8,0.7,2.4,1.5c0.6,0.9,0.8,1.9,0.6,2.9l-7.1,34.9\n\tc-0.1,1-0.8,2-1.7,2.5c-0.1,0-0.1,0.1-0.2,0.1l-0.2,0.1C44.8,54.3,44.3,54.5,43.7,54.5z M39.6,43.3H4.2c-2.2,0-3.7-1.6-3.7-3.7V4.2\n\tc0-2.2,1.6-3.7,3.7-3.7h35.4c2.2,0,3.7,1.6,3.7,3.7v35.4C43.3,41.8,41.8,43.3,39.6,43.3z M3.5,36.7v2.9c0,0.5,0.2,0.7,0.7,0.7h35.4\n\tc0.5,0,0.7-0.2,0.7-0.7v-2.9H3.5z M37.7,33.7h2.6V4.2c0-0.5-0.2-0.7-0.7-0.7H4.2c-0.5,0-0.7,0.2-0.7,0.7v29.5h2.6\n\tc0.2-1.7,0.6-3.4,1.4-5.1c1.2-2.4,4.8-3.7,9.8-5.4c0.2-0.5,0.2-1.7,0-2.1c-2.1-2.4-3-5.2-2.8-8.1c0-2.2,0.6-4,1.9-5.5\n\tc1.4-1.6,3.3-2.5,5.6-2.5c2,0,3.9,0.9,5.5,2.4c0,0,0.1,0.1,0.1,0.1c1.3,1.6,1.9,3.5,1.7,5.6c0.2,3-0.8,5.9-2.7,7.9\n\tc-0.2,0.5-0.2,1.8,0,2.3c0.6,0.2,1.3,0.5,1.9,0.7c4,1.5,6.9,2.6,7.9,4.6C37.1,30.3,37.6,32,37.7,33.7z M9.1,33.7h25.6\n\tc-0.2-1.3-0.5-2.6-1.1-3.9c-0.4-0.9-3.4-2-6.2-3c-0.7-0.3-1.4-0.5-2.2-0.8c-0.5-0.2-1.2-0.7-1.5-1.8c-0.5-1.5-0.3-3.9,0.4-4.9\n\tc0.1-0.1,0.1-0.2,0.2-0.2c1.4-1.4,2.2-3.6,2-5.9c0-0.1,0-0.2,0-0.3c0.2-1.3-0.1-2.5-0.9-3.4c-0.6-0.6-1.8-1.5-3.3-1.5\n\tc-1.4,0-2.5,0.5-3.3,1.5c-0.8,1-1.2,2.2-1.2,3.7c0,0,0,0.1,0,0.1c-0.2,2.2,0.5,4.2,2.1,6c0.9,0.9,1.1,3.3,0.8,4.6\n\tc-0.4,1.6-1.3,2.1-1.8,2.3c-2.8,0.9-7.5,2.5-8.2,3.9C9.7,31.1,9.3,32.4,9.1,33.7z M17.3,21.1C17.3,21.2,17.3,21.2,17.3,21.1\n\tC17.3,21.2,17.3,21.2,17.3,21.1z");
    			add_location(path, file$15, 11, 2, 244);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$15, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 55 55" },
    				{
    					style: "enable-background:new 0 0 55 55;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$16.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$16($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Gallery_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Gallery_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$16, create_fragment$16, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Gallery_svg",
    			options,
    			id: create_fragment$16.name
    		});
    	}
    }

    /* src/components/icon/svgs/headphones.svg.svelte generated by Svelte v3.42.6 */

    const file$14 = "src/components/icon/svgs/headphones.svg.svelte";

    function create_fragment$15(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 53 53" },
    		{
    			style: "enable-background:new 0 0 53 53;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M14.9,52.7c-0.5,0-1.1-0.1-1.6-0.3c-0.9-0.4-1.6-1.2-2-2.3L6.7,38.3c-0.4-1-0.4-2.1,0.1-3c0.4-0.9,1.2-1.6,2.2-1.9l2-0.9\n\tc1-0.4,2.1-0.4,3.1,0c0.9,0.4,1.6,1.2,2,2.3l4.6,11.8c0.4,1,0.4,2.1-0.1,3c-0.4,0.9-1.2,1.6-2.2,1.9l-2,0.9\n\tC15.9,52.6,15.4,52.7,14.9,52.7z M12.5,35.1c-0.1,0-0.2,0-0.3,0.1l-2,0.9c0,0-0.1,0-0.1,0.1c-0.2,0.1-0.4,0.2-0.5,0.4\n\tc-0.1,0.2-0.1,0.4,0,0.7c0,0,0,0,0,0l4.7,11.9c0.1,0.3,0.2,0.5,0.4,0.6c0.2,0.1,0.4,0.1,0.7,0l2-0.9c0,0,0.1,0,0.1-0.1\n\tc0.2-0.1,0.4-0.2,0.5-0.4c0.1-0.2,0.1-0.4,0-0.7l-4.7-11.9c-0.1-0.3-0.2-0.5-0.4-0.6C12.7,35.1,12.6,35.1,12.5,35.1z M38,52.6\n\tc-0.5,0-0.9-0.1-1.3-0.3l-2.2-1c-1.9-0.8-2.9-3.1-2.2-5L37,34.6c0.8-2,3.1-3,5-2.2l2.2,1c0.9,0.3,1.6,1.1,2.1,2c0.5,1,0.5,2,0.1,3\n\tl-4.7,11.9c0,0,0,0,0,0c-0.4,0.9-1.1,1.7-2,2.1C39.1,52.5,38.6,52.6,38,52.6z M40.7,35.1c-0.3,0-0.7,0.3-0.9,0.6l-4.7,11.9\n\tc-0.2,0.4,0.1,0.9,0.6,1.1l2.2,1c0.3,0.1,0.9-0.2,1-0.6l4.7-11.9c0.1-0.2,0.1-0.4,0-0.6c-0.1-0.2-0.3-0.4-0.5-0.5l-2.2-1\n\tC40.8,35.1,40.7,35.1,40.7,35.1z M40.3,49.6L40.3,49.6L40.3,49.6z M44,52.5c-0.2,0-0.5-0.1-0.7-0.2c-0.7-0.4-1-1.3-0.6-2\n\tc0.1-0.1,6.8-12.6,6.8-23.8c0-12.7-10.3-23-23-23c-12.7,0-23,10.3-23,23c0,11.1,6.7,23.7,6.8,23.8c0.4,0.7,0.1,1.6-0.6,2\n\tc-0.7,0.4-1.6,0.1-2-0.6c-0.3-0.5-7.2-13.3-7.2-25.2c0-14.3,11.7-26,26-26c14.3,0,26,11.7,26,26c0,11.9-6.9,24.7-7.2,25.2\n\tC45,52.2,44.5,52.5,44,52.5z");
    			add_location(path, file$14, 2, 0, 225);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$14, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 53 53" },
    				{
    					style: "enable-background:new 0 0 53 53;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$15.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$15($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Headphones_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Headphones_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$15, create_fragment$15, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Headphones_svg",
    			options,
    			id: create_fragment$15.name
    		});
    	}
    }

    /* src/components/icon/svgs/headset.svg.svelte generated by Svelte v3.42.6 */

    const file$13 = "src/components/icon/svgs/headset.svg.svelte";

    function create_fragment$14(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M192 208c0-17.67-14.33-32-32-32h-16c-35.35 0-64 28.65-64 64v48c0 35.35 28.65 64 64 64h16c17.67 0 32-14.33 32-32V208zm176 144c35.35 0 64-28.65 64-64v-48c0-35.35-28.65-64-64-64h-16c-17.67 0-32 14.33-32 32v112c0 17.67 14.33 32 32 32h16zM256 0C113.18 0 4.58 118.83 0 256v16c0 8.84 7.16 16 16 16h16c8.84 0 16-7.16 16-16v-16c0-114.69 93.31-208 208-208s208 93.31 208 208h-.12c.08 2.43.12 165.72.12 165.72 0 23.35-18.93 42.28-42.28 42.28H320c0-26.51-21.49-48-48-48h-32c-26.51 0-48 21.49-48 48s21.49 48 48 48h181.72c49.86 0 90.28-40.42 90.28-90.28V256C507.42 118.83 398.82 0 256 0z");
    			add_location(path, file$13, 0, 76, 76);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$13, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$14.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$14($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Headset_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Headset_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$14, create_fragment$14, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Headset_svg",
    			options,
    			id: create_fragment$14.name
    		});
    	}
    }

    /* src/components/icon/svgs/history-regular.svg.svelte generated by Svelte v3.42.6 */

    const file$12 = "src/components/icon/svgs/history-regular.svg.svelte";

    function create_fragment$13(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "far" },
    		{ "data-icon": "history" },
    		{
    			class: "svg-inline--fa fa-history fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M504 255.532c.252 136.64-111.182 248.372-247.822 248.468-64.014.045-122.373-24.163-166.394-63.942-5.097-4.606-5.3-12.543-.443-17.4l16.96-16.96c4.529-4.529 11.776-4.659 16.555-.395C158.208 436.843 204.848 456 256 456c110.549 0 200-89.468 200-200 0-110.549-89.468-200-200-200-55.52 0-105.708 22.574-141.923 59.043l49.091 48.413c7.641 7.535 2.305 20.544-8.426 20.544H26.412c-6.627 0-12-5.373-12-12V45.443c0-10.651 12.843-16.023 20.426-8.544l45.097 44.474C124.866 36.067 187.15 8 256 8c136.811 0 247.747 110.781 248 247.532zm-167.058 90.173l14.116-19.409c3.898-5.36 2.713-12.865-2.647-16.763L280 259.778V116c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v168.222l88.179 64.13c5.36 3.897 12.865 2.712 16.763-2.647z");
    			add_location(path, file$12, 0, 204, 204);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$12, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "far" },
    				{ "data-icon": "history" },
    				{
    					class: "svg-inline--fa fa-history fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$13.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$13($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('History_regular_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class History_regular_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$13, create_fragment$13, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "History_regular_svg",
    			options,
    			id: create_fragment$13.name
    		});
    	}
    }

    /* src/components/icon/svgs/lightning.svg.svelte generated by Svelte v3.42.6 */

    const file$11 = "src/components/icon/svgs/lightning.svg.svelte";

    function create_fragment$12(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ viewBox: "0 0 10 16" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M3.3386 9.49129L0.487524 8.39426C-0.0111216 8.20239 -0.160746 7.59269 0.196055 7.20656L6.62062 0.25398C7.16186 -0.331744 8.15565 0.179283 7.95001 0.937577L6.43918 6.50871L9.29025 7.60574C9.7889 7.79761 9.93852 8.40731 9.58172 8.79344L3.15716 15.746C2.61592 16.3317 1.62213 15.8207 1.82777 15.0624L3.3386 9.49129Z");
    			add_location(path, file$11, 1, 0, 75);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$11, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ viewBox: "0 0 10 16" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$12.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$12($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Lightning_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Lightning_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$12, create_fragment$12, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Lightning_svg",
    			options,
    			id: create_fragment$12.name
    		});
    	}
    }

    /* src/components/icon/svgs/lock.svg.svelte generated by Svelte v3.42.6 */

    const file$10 = "src/components/icon/svgs/lock.svg.svelte";

    function create_fragment$11(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 448 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M400 192h-32v-46.6C368 65.8 304 .2 224.4 0 144.8-.2 80 64.5 80 144v48H48c-26.5 0-48 21.5-48 48v224c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V240c0-26.5-21.5-48-48-48zm-272-48c0-52.9 43.1-96 96-96s96 43.1 96 96v48H128v-48zm272 320H48V240h352v224z");
    			add_location(path, file$10, 0, 76, 76);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$10, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 448 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$11($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Lock_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Lock_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$11, create_fragment$11, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Lock_svg",
    			options,
    			id: create_fragment$11.name
    		});
    	}
    }

    /* src/components/icon/svgs/medielogin.svg.svelte generated by Svelte v3.42.6 */

    const file$$ = "src/components/icon/svgs/medielogin.svg.svelte";

    function create_fragment$10(ctx) {
    	let svg;
    	let g;
    	let rect;
    	let polygon0;
    	let path;
    	let polygon1;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 63.6 81.5" },
    		{
    			style: "enable-background:new 0 0 63.6 81.5;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g = svg_element("g");
    			rect = svg_element("rect");
    			polygon0 = svg_element("polygon");
    			path = svg_element("path");
    			polygon1 = svg_element("polygon");
    			attr_dev(rect, "y", "70.7");
    			attr_dev(rect, "width", "63.3");
    			attr_dev(rect, "height", "10.9");
    			add_location(rect, file$$, 12, 4, 260);
    			attr_dev(polygon0, "points", "0,81.5 21.2,61.8 21.2,47.8 0,67.5 \t");
    			add_location(polygon0, file$$, 13, 4, 309);
    			attr_dev(path, "d", "M31.8,0C14.2,0,0,14.2,0,31.8c0,13.8,8.9,25.6,21.2,30v-14c-5.2-3.4-8.6-9.3-8.6-16c0-10.6,8.6-19.2,19.2-19.2\n\t\tS51,21.2,51,31.8c0,6.7-3.4,12.5-8.6,16v14c12.3-4.4,21.2-16.1,21.2-30C63.6,14.2,49.3,0,31.8,0z");
    			add_location(path, file$$, 14, 4, 370);
    			attr_dev(polygon1, "points", "63.6,81.5 42.4,61.7 42.4,47.8 63.6,67.5 \t");
    			add_location(polygon1, file$$, 18, 4, 600);
    			add_location(g, file$$, 11, 2, 252);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$$, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g);
    			append_dev(g, rect);
    			append_dev(g, polygon0);
    			append_dev(g, path);
    			append_dev(g, polygon1);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 63.6 81.5" },
    				{
    					style: "enable-background:new 0 0 63.6 81.5;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$10($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Medielogin_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Medielogin_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$10, create_fragment$10, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Medielogin_svg",
    			options,
    			id: create_fragment$10.name
    		});
    	}
    }

    /* src/components/icon/svgs/menu-bars.svg.svelte generated by Svelte v3.42.6 */

    const file$_ = "src/components/icon/svgs/menu-bars.svg.svelte";

    function create_fragment$$(ctx) {
    	let svg;
    	let g1;
    	let g0;
    	let rect0;
    	let g3;
    	let g2;
    	let rect1;
    	let g5;
    	let g4;
    	let rect2;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Lag_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 30 30" },
    		{ "enable-background": "new 0 0 30 30" },
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			rect0 = svg_element("rect");
    			g3 = svg_element("g");
    			g2 = svg_element("g");
    			rect1 = svg_element("rect");
    			g5 = svg_element("g");
    			g4 = svg_element("g");
    			rect2 = svg_element("rect");
    			attr_dev(rect0, "y", "4.3");
    			attr_dev(rect0, "width", "30");
    			attr_dev(rect0, "height", "4");
    			add_location(rect0, file$_, 13, 6, 253);
    			add_location(g0, file$_, 12, 4, 243);
    			add_location(g1, file$_, 11, 2, 235);
    			attr_dev(rect1, "y", "12.3");
    			attr_dev(rect1, "width", "30");
    			attr_dev(rect1, "height", "4");
    			add_location(rect1, file$_, 18, 6, 328);
    			add_location(g2, file$_, 17, 4, 318);
    			add_location(g3, file$_, 16, 2, 310);
    			attr_dev(rect2, "y", "20.3");
    			attr_dev(rect2, "width", "30");
    			attr_dev(rect2, "height", "4");
    			add_location(rect2, file$_, 23, 6, 404);
    			add_location(g4, file$_, 22, 4, 394);
    			add_location(g5, file$_, 21, 2, 386);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$_, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g1);
    			append_dev(g1, g0);
    			append_dev(g0, rect0);
    			append_dev(svg, g3);
    			append_dev(g3, g2);
    			append_dev(g2, rect1);
    			append_dev(svg, g5);
    			append_dev(g5, g4);
    			append_dev(g4, rect2);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Lag_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 30 30" },
    				{ "enable-background": "new 0 0 30 30" },
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Menu_bars_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Menu_bars_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$$, create_fragment$$, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Menu_bars_svg",
    			options,
    			id: create_fragment$$.name
    		});
    	}
    }

    /* src/components/icon/svgs/miteb-regular.svg.svelte generated by Svelte v3.42.6 */

    const file$Z = "src/components/icon/svgs/miteb-regular.svg.svelte";

    function create_fragment$_(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "miteb-regular" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0" },
    		{ y: "0" },
    		{ viewBox: "0 0 512 512" },
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M210.3 26.5H22.5C10 26.5-.1 36.5-.1 48.8v115.4c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V48.8c.1-12.3-10.1-22.3-22.6-22.3zm-23.3 115H45.8V71.7H187v69.8zM489.4 26.5H301.6c-12.5 0-22.6 10-22.6 22.3v231.1c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V48.8c0-12.3-10.1-22.3-22.6-22.3zm-23.3 230.7H324.9V71.7h141.2v185.5zM210.3 235.3H22.5c-12.5 0-22.6 10-22.6 22.3v205.6c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V257.6c.1-12.3-10.1-22.3-22.6-22.3zM187 440.5H45.8v-160H187v160zM489.4 350.1H301.6c-12.5 0-22.6 10-22.6 22.3v90.8c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3v-90.8c0-12.3-10.1-22.3-22.6-22.3zm-23.3 90.4H324.9v-45.2h141.2v45.2z");
    			add_location(path, file$Z, 0, 185, 185);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$Z, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "miteb-regular" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0" },
    				{ y: "0" },
    				{ viewBox: "0 0 512 512" },
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$_($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Miteb_regular_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Miteb_regular_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$_, create_fragment$_, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Miteb_regular_svg",
    			options,
    			id: create_fragment$_.name
    		});
    	}
    }

    /* src/components/icon/svgs/miteb-solid.svg.svelte generated by Svelte v3.42.6 */

    const file$Y = "src/components/icon/svgs/miteb-solid.svg.svelte";

    function create_fragment$Z(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "miteb-solid" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0" },
    		{ y: "0" },
    		{ viewBox: "0 0 512 512" },
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M210.3 26.5H22.5C10 26.5-.1 36.5-.1 48.8v115.4c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V48.8c.1-12.3-10.1-22.3-22.6-22.3zM489.4 26.5H301.6c-12.5 0-22.6 10-22.6 22.3v231.1c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V48.8c0-12.3-10.1-22.3-22.6-22.3zM210.3 235.3H22.5c-12.5 0-22.6 10-22.6 22.3v205.6c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3V257.6c.1-12.3-10.1-22.3-22.6-22.3zM489.4 350.1H301.6c-12.5 0-22.6 10-22.6 22.3v90.8c0 12.3 10.1 22.3 22.6 22.3h187.8c12.5 0 22.6-10 22.6-22.3v-90.8c0-12.3-10.1-22.3-22.6-22.3z");
    			add_location(path, file$Y, 0, 183, 183);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$Y, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "miteb-solid" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0" },
    				{ y: "0" },
    				{ viewBox: "0 0 512 512" },
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Miteb_solid_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Miteb_solid_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Miteb_solid_svg",
    			options,
    			id: create_fragment$Z.name
    		});
    	}
    }

    /* src/components/icon/svgs/newspaper.svg.svelte generated by Svelte v3.42.6 */

    const file$X = "src/components/icon/svgs/newspaper.svg.svelte";

    function create_fragment$Y(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 42 39" },
    		{
    			style: "enable-background:new 0 0 42 39;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M35.8,38.5H6.2c-3.5,0-6.2-2.7-6.2-6.2V2.7C0,1.2,1.2,0,2.7,0h26.1c1.6,0,2.7,1.2,2.7,2.7v29.6c0,2.4,1.8,4.2,4.2,4.2\n\ts4.2-1.8,4.2-4.2V6.2c0-0.6,0.4-1,1-1s1,0.4,1,1v26.1C42,35.8,39.3,38.5,35.8,38.5z M2.7,2C2.2,2,2,2.2,2,2.7v29.6\n\tc0,2.4,1.8,4.2,4.2,4.2h25c-1-1.1-1.6-2.6-1.6-4.2V2.7c0-0.5-0.2-0.7-0.7-0.7H2.7z M35.8,33.8c-0.6,0-1-0.4-1-1V6.2c0-0.6,0.4-1,1-1\n\ts1,0.4,1,1v26.5C36.8,33.3,36.3,33.8,35.8,33.8z M25.3,29.8H6.2c-0.6,0-1-0.4-1-1s0.4-1,1-1h19.1c0.6,0,1,0.4,1,1\n\tS25.9,29.8,25.3,29.8z M25.3,24.6H6.2c-0.6,0-1-0.4-1-1s0.4-1,1-1h19.1c0.6,0,1,0.4,1,1S25.9,24.6,25.3,24.6z M25.3,19.4h-4.9\n\tc-0.6,0-1-0.4-1-1s0.4-1,1-1h4.9c0.6,0,1,0.4,1,1S25.9,19.4,25.3,19.4z M15.8,19.4H7.1c-1.1,0-1.9-0.8-1.9-1.9V8.8\n\tC5.2,7.8,6,7,7.1,7h8.7c1.1,0,1.9,0.8,1.9,1.9v8.7C17.7,18.6,16.8,19.4,15.8,19.4z M7.2,17.4l8.4,0V9L7.2,9L7.2,17.4z M25.3,14.2\n\th-4.9c-0.6,0-1-0.4-1-1s0.4-1,1-1h4.9c0.6,0,1,0.4,1,1S25.9,14.2,25.3,14.2z M25.3,9h-4.9c-0.6,0-1-0.4-1-1s0.4-1,1-1h4.9\n\tc0.6,0,1,0.4,1,1S25.9,9,25.3,9z");
    			add_location(path, file$X, 11, 2, 244);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$X, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 42 39" },
    				{
    					style: "enable-background:new 0 0 42 39;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Newspaper_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Newspaper_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Newspaper_svg",
    			options,
    			id: create_fragment$Y.name
    		});
    	}
    }

    /* src/components/icon/svgs/phone.svg.svelte generated by Svelte v3.42.6 */

    const file$W = "src/components/icon/svgs/phone.svg.svelte";

    function create_fragment$X(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 15 15" },
    		{
    			style: "enable-background:new 0 0 15 15;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M12.9,14.2c-0.1,0-0.1,0-0.2,0v0c-6.3-0.6-11.3-5.7-12-12c0-0.5,0.1-0.9,0.4-1.3C1.5,0.6,2,0.4,2.5,0.4h2.3\n\tc0.8,0,1.5,0.5,1.7,1.2l0.7,2.2c0.2,0.6,0,1.3-0.4,1.8L6.4,6c0,0-0.1,0.1,0,0.2c0.7,1,1.3,1.6,2.4,2.4c0.1,0,0.1,0,0.2,0l0.4-0.4\n\tc0.5-0.5,1.2-0.6,1.8-0.4l2.2,0.7c0.7,0.2,1.2,0.9,1.2,1.7v2.3c0,0.5-0.2,1-0.6,1.3C13.7,14,13.3,14.2,12.9,14.2z M2.5,1.4\n\tc-0.2,0-0.4,0.1-0.6,0.2C1.8,1.8,1.7,1.9,1.8,2.1C2.3,8,7,12.6,12.8,13.2l0,0c0.2,0,0.4,0,0.5-0.2c0.2-0.1,0.2-0.3,0.2-0.6v-2.3\n\tc0-0.3-0.2-0.6-0.5-0.7l-2.2-0.7c-0.3-0.1-0.6,0-0.8,0.2L9.6,9.2c-0.4,0.4-1,0.4-1.4,0.1C7,8.5,6.3,7.9,5.6,6.7\n\tc-0.3-0.4-0.2-1,0.1-1.4L6.1,5c0.2-0.2,0.3-0.5,0.2-0.8L5.5,1.9C5.4,1.6,5.1,1.4,4.8,1.4H2.5z M14,5.2c-0.3,0-0.5-0.2-0.5-0.5\n\tc0-1.9-1.5-3.4-3.4-3.4c-0.3,0-0.5-0.2-0.5-0.5s0.2-0.5,0.5-0.5c2.4,0,4.4,2,4.4,4.4C14.5,5,14.3,5.2,14,5.2z M11.5,5.2\n\tC11.2,5.2,11,5,11,4.8C11,4.3,10.6,4,10.2,4C9.9,4,9.7,3.7,9.7,3.5S9.9,3,10.2,3c1,0,1.8,0.8,1.8,1.8C12,5,11.8,5.2,11.5,5.2z");
    			add_location(path, file$W, 2, 0, 225);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$W, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 15 15" },
    				{
    					style: "enable-background:new 0 0 15 15;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Phone_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Phone_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$X, create_fragment$X, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Phone_svg",
    			options,
    			id: create_fragment$X.name
    		});
    	}
    }

    /* src/components/icon/svgs/play.svg.svelte generated by Svelte v3.42.6 */

    const file$V = "src/components/icon/svgs/play.svg.svelte";

    function create_fragment$W(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fal" },
    		{ "data-icon": "play-circle" },
    		{
    			class: "svg-inline--fa fa-play-circle fa-w-16"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M256 504c137 0 248-111 248-248S393 8 256 8 8 119 8 256s111 248 248 248zM40 256c0-118.7 96.1-216 216-216 118.7 0 216 96.1 216 216 0 118.7-96.1 216-216 216-118.7 0-216-96.1-216-216zm331.7-18l-176-107c-15.8-8.8-35.7 2.5-35.7 21v208c0 18.4 19.8 29.8 35.7 21l176-101c16.4-9.1 16.4-32.8 0-42zM192 335.8V176.9c0-4.7 5.1-7.6 9.1-5.1l134.5 81.7c3.9 2.4 3.8 8.1-.1 10.3L201 341c-4 2.3-9-.6-9-5.2z");
    			add_location(path, file$V, 0, 212, 212);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$V, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fal" },
    				{ "data-icon": "play-circle" },
    				{
    					class: "svg-inline--fa fa-play-circle fa-w-16"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Play_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Play_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$W, create_fragment$W, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Play_svg",
    			options,
    			id: create_fragment$W.name
    		});
    	}
    }

    /* src/components/icon/svgs/rss.svg.svelte generated by Svelte v3.42.6 */

    const file$U = "src/components/icon/svgs/rss.svg.svelte";

    function create_fragment$V(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let path2;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 24 10" },
    		{
    			style: "enable-background:new 0 0 24 10;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			attr_dev(path0, "d", "M0,9V0.4h3.7c0.9,0,1.6,0.1,2,0.2c0.4,0.2,0.8,0.4,1,0.8C6.9,1.9,7,2.3,7,2.8C7,3.5,6.8,4,6.5,4.4C6.1,4.8,5.5,5.1,4.8,5.2\n\tc0.4,0.2,0.7,0.5,0.9,0.7c0.2,0.3,0.6,0.7,1,1.4l1,1.7H5.6L4.4,7.1C3.9,6.5,3.6,6,3.5,5.9C3.3,5.7,3.1,5.6,3,5.5\n\tC2.8,5.4,2.5,5.4,2.1,5.4H1.7V9H0z M1.7,4H3c0.8,0,1.4,0,1.6-0.1s0.4-0.2,0.5-0.4c0.1-0.2,0.2-0.4,0.2-0.6c0-0.3-0.1-0.5-0.2-0.7\n\tC4.9,2.1,4.6,1.9,4.4,1.9c-0.1,0-0.6,0-1.3,0H1.7V4z");
    			add_location(path0, file$U, 2, 0, 225);
    			attr_dev(path1, "d", "M8.2,6.2L9.9,6c0.1,0.6,0.3,1,0.6,1.2c0.3,0.3,0.7,0.4,1.3,0.4c0.6,0,1-0.1,1.3-0.4c0.3-0.2,0.4-0.5,0.4-0.8\n\tc0-0.2-0.1-0.4-0.2-0.5c-0.1-0.1-0.3-0.3-0.6-0.4c-0.2-0.1-0.7-0.2-1.4-0.4c-0.9-0.2-1.6-0.5-2-0.8c-0.5-0.5-0.8-1-0.8-1.7\n\tc0-0.4,0.1-0.8,0.4-1.2C9.2,1.1,9.5,0.8,10,0.6c0.5-0.2,1-0.3,1.7-0.3c1.1,0,1.9,0.2,2.4,0.7c0.5,0.5,0.8,1.1,0.9,1.9l-1.7,0.1\n\tC13.2,2.5,13,2.2,12.8,2c-0.2-0.2-0.6-0.3-1.1-0.3c-0.5,0-0.9,0.1-1.2,0.3c-0.2,0.1-0.3,0.3-0.3,0.5c0,0.2,0.1,0.4,0.3,0.5\n\tc0.2,0.2,0.8,0.4,1.6,0.6c0.8,0.2,1.5,0.4,1.9,0.6c0.4,0.2,0.7,0.5,0.9,0.9c0.2,0.4,0.3,0.8,0.3,1.4c0,0.5-0.1,1-0.4,1.4\n\tc-0.3,0.4-0.7,0.8-1.2,1c-0.5,0.2-1.1,0.3-1.9,0.3c-1.1,0-1.9-0.2-2.5-0.8C8.7,7.9,8.3,7.2,8.2,6.2z");
    			add_location(path1, file$U, 6, 0, 644);
    			attr_dev(path2, "d", "M16.2,6.2L17.9,6c0.1,0.6,0.3,1,0.6,1.2c0.3,0.3,0.7,0.4,1.3,0.4c0.6,0,1-0.1,1.3-0.4c0.3-0.2,0.4-0.5,0.4-0.8\n\tc0-0.2-0.1-0.4-0.2-0.5c-0.1-0.1-0.3-0.3-0.6-0.4c-0.2-0.1-0.7-0.2-1.4-0.4c-0.9-0.2-1.6-0.5-2-0.8c-0.5-0.5-0.8-1-0.8-1.7\n\tc0-0.4,0.1-0.8,0.4-1.2c0.2-0.4,0.6-0.7,1.1-0.9c0.5-0.2,1-0.3,1.7-0.3c1.1,0,1.9,0.2,2.4,0.7c0.5,0.5,0.8,1.1,0.9,1.9l-1.7,0.1\n\tC21.2,2.5,21,2.2,20.8,2c-0.2-0.2-0.6-0.3-1.1-0.3c-0.5,0-0.9,0.1-1.2,0.3c-0.2,0.1-0.3,0.3-0.3,0.5c0,0.2,0.1,0.4,0.3,0.5\n\tc0.2,0.2,0.8,0.4,1.6,0.6c0.8,0.2,1.5,0.4,1.9,0.6c0.4,0.2,0.7,0.5,0.9,0.9c0.2,0.4,0.3,0.8,0.3,1.4c0,0.5-0.1,1-0.4,1.4\n\tc-0.3,0.4-0.7,0.8-1.2,1c-0.5,0.2-1.1,0.3-1.9,0.3c-1.1,0-1.9-0.2-2.5-0.8C16.7,7.9,16.3,7.2,16.2,6.2z");
    			add_location(path2, file$U, 12, 0, 1341);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$U, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, path2);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 24 10" },
    				{
    					style: "enable-background:new 0 0 24 10;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Rss_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Rss_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$V, create_fragment$V, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Rss_svg",
    			options,
    			id: create_fragment$V.name
    		});
    	}
    }

    /* src/components/icon/svgs/smartphone.svg.svelte generated by Svelte v3.42.6 */

    const file$T = "src/components/icon/svgs/smartphone.svg.svelte";

    function create_fragment$U(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 320 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M272 0H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h224c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zM160 480c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm112-108c0 6.6-5.4 12-12 12H60c-6.6 0-12-5.4-12-12V60c0-6.6 5.4-12 12-12h200c6.6 0 12 5.4 12 12v312z");
    			add_location(path, file$T, 0, 76, 76);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$T, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 320 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Smartphone_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Smartphone_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$U, create_fragment$U, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Smartphone_svg",
    			options,
    			id: create_fragment$U.name
    		});
    	}
    }

    /* src/components/icon/svgs/star-regular.svg.svelte generated by Svelte v3.42.6 */

    const file$S = "src/components/icon/svgs/star-regular.svg.svelte";

    function create_fragment$T(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "far" },
    		{ "data-icon": "star" },
    		{ class: "svg-inline--fa fa-star fa-w-18" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M528.1 171.5L382 150.2 316.7 17.8c-11.7-23.6-45.6-23.9-57.4 0L194 150.2 47.9 171.5c-26.2 3.8-36.7 36.1-17.7 54.6l105.7 103-25 145.5c-4.5 26.3 23.2 46 46.4 33.7L288 439.6l130.7 68.7c23.2 12.2 50.9-7.4 46.4-33.7l-25-145.5 105.7-103c19-18.5 8.5-50.8-17.7-54.6zM388.6 312.3l23.7 138.4L288 385.4l-124.3 65.3 23.7-138.4-100.6-98 139-20.2 62.2-126 62.2 126 139 20.2-100.6 98z");
    			add_location(path, file$S, 0, 198, 198);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$S, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "far" },
    				{ "data-icon": "star" },
    				{ class: "svg-inline--fa fa-star fa-w-18" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Star_regular_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Star_regular_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$T, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Star_regular_svg",
    			options,
    			id: create_fragment$T.name
    		});
    	}
    }

    /* src/components/icon/svgs/tag-regular.svg.svelte generated by Svelte v3.42.6 */

    const file$R = "src/components/icon/svgs/tag-regular.svg.svelte";

    function create_fragment$S(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ id: "tag-regular" },
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "far" },
    		{ "data-icon": "tag" },
    		{ class: "svg-inline--fa fa-tag fa-w-16" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M497.941 225.941L286.059 14.059A48 48 0 0 0 252.118 0H48C21.49 0 0 21.49 0 48v204.118a47.998 47.998 0 0 0 14.059 33.941l211.882 211.882c18.745 18.745 49.137 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zM259.886 463.996L48 252.118V48h204.118L464 259.882 259.886 463.996zM192 144c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48z");
    			add_location(path, file$R, 0, 213, 213);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$R, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ id: "tag-regular" },
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "far" },
    				{ "data-icon": "tag" },
    				{ class: "svg-inline--fa fa-tag fa-w-16" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tag_regular_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Tag_regular_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$S, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tag_regular_svg",
    			options,
    			id: create_fragment$S.name
    		});
    	}
    }

    /* src/components/icon/svgs/tag-solid.svg.svelte generated by Svelte v3.42.6 */

    const file$Q = "src/components/icon/svgs/tag-solid.svg.svelte";

    function create_fragment$R(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ id: "tag-solid" },
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "tag" },
    		{ class: "svg-inline--fa fa-tag fa-w-16" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 512 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M0 252.118V48C0 21.49 21.49 0 48 0h204.118a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882L293.823 497.941c-18.745 18.745-49.137 18.745-67.882 0L14.059 286.059A48 48 0 0 1 0 252.118zM112 64c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z");
    			add_location(path, file$Q, 0, 211, 211);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$Q, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ id: "tag-solid" },
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "tag" },
    				{ class: "svg-inline--fa fa-tag fa-w-16" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 512 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tag_solid_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Tag_solid_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$R, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tag_solid_svg",
    			options,
    			id: create_fragment$R.name
    		});
    	}
    }

    /* src/components/icon/svgs/tags-regular.svg.svelte generated by Svelte v3.42.6 */

    const file$P = "src/components/icon/svgs/tags-regular.svg.svelte";

    function create_fragment$Q(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ id: "tags-regular" },
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "far" },
    		{ "data-icon": "tags" },
    		{ class: "svg-inline--fa fa-tags fa-w-20" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 640 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M625.941 293.823L421.823 497.941c-18.746 18.746-49.138 18.745-67.882 0l-.36-.36L592 259.882 331.397 0h48.721a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882zm-128 0L293.823 497.941C284.451 507.314 272.166 512 259.882 512c-12.284 0-24.569-4.686-33.941-14.059L14.059 286.059A48 48 0 0 1 0 252.118V48C0 21.49 21.49 0 48 0h204.118a47.998 47.998 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882zM464 259.882L252.118 48H48v204.118l211.886 211.878L464 259.882zM144 96c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48z");
    			add_location(path, file$P, 0, 216, 216);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$P, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ id: "tags-regular" },
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "far" },
    				{ "data-icon": "tags" },
    				{ class: "svg-inline--fa fa-tags fa-w-20" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 640 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tags_regular_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Tags_regular_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tags_regular_svg",
    			options,
    			id: create_fragment$Q.name
    		});
    	}
    }

    /* src/components/icon/svgs/tags-solid.svg.svelte generated by Svelte v3.42.6 */

    const file$O = "src/components/icon/svgs/tags-solid.svg.svelte";

    function create_fragment$P(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ id: "tags-solid" },
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "fas" },
    		{ "data-icon": "tags" },
    		{ class: "svg-inline--fa fa-tags fa-w-20" },
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 640 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M497.941 225.941L286.059 14.059A48 48 0 0 0 252.118 0H48C21.49 0 0 21.49 0 48v204.118a48 48 0 0 0 14.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882 0l204.118-204.118c18.745-18.745 18.745-49.137 0-67.882zM112 160c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882 0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397 0h48.721a48 48 0 0 1 33.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137 0 67.882z");
    			add_location(path, file$O, 0, 214, 214);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$O, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ id: "tags-solid" },
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "fas" },
    				{ "data-icon": "tags" },
    				{ class: "svg-inline--fa fa-tags fa-w-20" },
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 640 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tags_solid_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Tags_solid_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$P, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tags_solid_svg",
    			options,
    			id: create_fragment$P.name
    		});
    	}
    }

    /* src/components/icon/svgs/toggle-off.svg.svelte generated by Svelte v3.42.6 */

    const file$N = "src/components/icon/svgs/toggle-off.svg.svelte";

    function create_fragment$O(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "far" },
    		{ "data-icon": "toggle-off" },
    		{
    			class: "svg-inline--fa fa-toggle-off fa-w-18"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M384 64H192C85.961 64 0 149.961 0 256s85.961 192 192 192h192c106.039 0 192-85.961 192-192S490.039 64 384 64zM48 256c0-79.583 64.404-144 144-144 79.582 0 144 64.404 144 144 0 79.582-64.404 144-144 144-79.582 0-144-64.404-144-144zm336 144h-65.02c86.704-76.515 86.683-211.504 0-288H384c79.582 0 144 64.404 144 144 0 79.582-64.404 144-144 144z");
    			add_location(path, file$N, 0, 210, 210);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$N, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "far" },
    				{ "data-icon": "toggle-off" },
    				{
    					class: "svg-inline--fa fa-toggle-off fa-w-18"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Toggle_off_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Toggle_off_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$O, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Toggle_off_svg",
    			options,
    			id: create_fragment$O.name
    		});
    	}
    }

    /* src/components/icon/svgs/toggle-on.svg.svelte generated by Svelte v3.42.6 */

    const file$M = "src/components/icon/svgs/toggle-on.svg.svelte";

    function create_fragment$N(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ "aria-hidden": "true" },
    		{ focusable: "false" },
    		{ "data-prefix": "far" },
    		{ "data-icon": "toggle-on" },
    		{
    			class: "svg-inline--fa fa-toggle-on fa-w-18"
    		},
    		{ role: "img" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 576 512" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M384 64H192C86 64 0 150 0 256s86 192 192 192h192c106 0 192-86 192-192S490 64 384 64zm0 336c-79.6 0-144-64.4-144-144s64.4-144 144-144 144 64.4 144 144-64.4 144-144 144z");
    			add_location(path, file$M, 0, 208, 208);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$M, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "aria-hidden": "true" },
    				{ focusable: "false" },
    				{ "data-prefix": "far" },
    				{ "data-icon": "toggle-on" },
    				{
    					class: "svg-inline--fa fa-toggle-on fa-w-18"
    				},
    				{ role: "img" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 576 512" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Toggle_on_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Toggle_on_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$N, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Toggle_on_svg",
    			options,
    			id: create_fragment$N.name
    		});
    	}
    }

    /* src/components/icon/svgs/video.svg.svelte generated by Svelte v3.42.6 */

    const file$L = "src/components/icon/svgs/video.svg.svelte";

    function create_fragment$M(ctx) {
    	let svg;
    	let path;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "Layer_1" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 51 48" },
    		{
    			style: "enable-background:new 0 0 51 48;"
    		},
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M45,47.5H6.1c-3.1,0-5.6-2.5-5.6-5.6V6.1C0.5,3,3,0.5,6.1,0.5H45c3.1,0,5.6,2.5,5.6,5.6v35.8\n\tC50.6,45,48.1,47.5,45,47.5z M6.1,3.5c-1.4,0-2.6,1.2-2.6,2.6v35.8c0,1.4,1.2,2.6,2.6,2.6H45c1.4,0,2.6-1.2,2.6-2.6V6.1\n\tc0-1.4-1.2-2.6-2.6-2.6H6.1z M30.7,43.4c-2.1,0-3.5-1.5-3.5-3.5v-0.5h-19c-0.8,0-1.5-0.7-1.5-1.5s0.7-1.5,1.5-1.5h19v-0.5\n\tc0-2.1,1.5-3.5,3.5-3.5s3.5,1.5,3.5,3.5v0.5H43c0.8,0,1.5,0.7,1.5,1.5s-0.7,1.5-1.5,1.5h-8.7v0.5C34.2,41.9,32.8,43.4,30.7,43.4z\n\t M30.1,37.8v2c0,0.4,0.1,0.5,0.5,0.5s0.5-0.1,0.5-0.5v-4.1c0-0.4-0.1-0.5-0.5-0.5s-0.5,0.1-0.5,0.5V37.8z M20.2,30.3\n\tc-0.5,0-0.9-0.1-1.3-0.4c-0.8-0.5-1.3-1.3-1.3-2.3V13.7c0-1,0.6-1.9,1.4-2.4c0.9-0.5,1.9-0.4,2.6,0.1l12,6.9\n\tc0.8,0.4,1.4,1.3,1.4,2.3c0,1-0.6,1.9-1.4,2.4l-12,6.9c0,0-0.1,0-0.1,0C21.1,30.2,20.6,30.3,20.2,30.3z M20.8,28.7L20.8,28.7\n\tL20.8,28.7z M20.9,27.6C20.9,27.6,20.9,27.6,20.9,27.6C20.9,27.6,20.9,27.6,20.9,27.6z M20.7,14.3V27l11-6.3L20.7,14.3z M32.2,21\n\tC32.2,21,32.2,21,32.2,21L32.2,21z M32.2,20.4C32.2,20.4,32.2,20.4,32.2,20.4L32.2,20.4z M19.8,13.8C19.8,13.8,19.8,13.8,19.8,13.8\n\tC19.8,13.8,19.8,13.8,19.8,13.8z");
    			add_location(path, file$L, 11, 2, 244);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$L, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "Layer_1" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 51 48" },
    				{
    					style: "enable-background:new 0 0 51 48;"
    				},
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Video_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Video_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Video_svg",
    			options,
    			id: create_fragment$M.name
    		});
    	}
    }

    /* src/components/icon/graphics/ekstrabladet.svg.svelte generated by Svelte v3.42.6 */

    const file$K = "src/components/icon/graphics/ekstrabladet.svg.svelte";

    function create_fragment$L(ctx) {
    	let svg;
    	let g;
    	let path0;
    	let polygon0;
    	let polygon1;
    	let path1;
    	let path2;
    	let path3;
    	let path4;
    	let path5;
    	let rect;
    	let path6;
    	let path7;
    	let path8;
    	let path9;

    	let svg_levels = [
    		{ version: "1.1" },
    		{ id: "logo" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{
    			"xmlns:xlink": "http://www.w3.org/1999/xlink"
    		},
    		{ x: "0px" },
    		{ y: "0px" },
    		{ viewBox: "0 0 100 88" },
    		{ "enable-background": "new 0 0 100 88" },
    		{ "xml:space": "preserve" },
    		/*$$props*/ ctx[0]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g = svg_element("g");
    			path0 = svg_element("path");
    			polygon0 = svg_element("polygon");
    			polygon1 = svg_element("polygon");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			path5 = svg_element("path");
    			rect = svg_element("rect");
    			path6 = svg_element("path");
    			path7 = svg_element("path");
    			path8 = svg_element("path");
    			path9 = svg_element("path");
    			attr_dev(path0, "fill", "#B30000");
    			attr_dev(path0, "d", "M0-0.9h100V78l-49.5,9.5L0,77.6V-0.9L0-0.9z");
    			add_location(path0, file$K, 4, 1, 223);
    			attr_dev(polygon0, "fill", "#FFFFFF");
    			attr_dev(polygon0, "points", "23,42.3 10.6,42.3 10.6,37.8 20.4,37.8 20.4,34.4 10.6,34.4 10.6,29.8 22.1,29.8 22.1,26.5\n\t\t6.1,26.5 6.1,46.1 23.1,46.1 \t\t");
    			add_location(polygon0, file$K, 6, 1, 295);
    			attr_dev(polygon1, "fill", "#FFFFFF");
    			attr_dev(polygon1, "points", "39.7,46.1 33.7,37.3 38.7,31.9 33.9,31.9 28.7,37.5 28.7,26.5 24.8,26.5 24.8,46.1 28.7,46.1\n\t\t28.7,42.2 31,39.9 34.8,46.1 \t\t");
    			add_location(polygon1, file$K, 8, 1, 462);
    			attr_dev(path1, "fill", "#FFFFFF");
    			attr_dev(path1, "d", "M46.3,43.9c-2.4,0-3.1-0.5-3.5-2h-3.7c0,3.1,2.5,4.9,6.7,4.9c4.7,0,7.5-1.8,7.5-4.8c0-2-1.6-3.7-3.6-4.1\n\t\tL44.1,37c-0.6-0.1-1.2-0.7-1.2-1.4c0-0.8,0.8-1.4,2.3-1.4c3,0,3.5,0.4,3.6,2h3.8v-0.5c0-2.4-2.8-4.5-6.5-4.5\n\t\tc-4.2,0-6.9,1.8-6.9,4.9c0,1.8,1.3,3.6,3,3.8l5.8,1c0.8,0.1,1.3,0.5,1.3,1.2C49.4,43.3,48.5,43.9,46.3,43.9z");
    			add_location(path1, file$K, 10, 1, 631);
    			attr_dev(path2, "fill", "#FFFFFF");
    			attr_dev(path2, "d", "M56.5,42.6c0,2.6,1.7,4.2,4.7,4.2c1.1,0,2-0.2,3.6-1v-1.9c-0.7,0.1-1.7,0.1-2,0.1c-1.6,0-2.2-0.6-2.2-1.8\n\t\tv-7.6h3.8V32h-3.8v-5.4h-2.9l-0.1,1.2C57,31.6,56.9,32,55.8,32h-2.5v2.6h3.4L56.5,42.6z");
    			add_location(path2, file$K, 13, 1, 984);
    			attr_dev(path3, "fill", "#FFFFFF");
    			attr_dev(path3, "d", "M70.8,39.9c0-3.1,1.7-4.8,4.7-4.8h1.7v-3.6H76c-2.3,0-4.1,1.1-5.3,3.2V32h-3.8v14.2h4V39.9z");
    			add_location(path3, file$K, 17, 1, 1213);
    			attr_dev(path4, "fill", "#FFFFFF");
    			attr_dev(path4, "d", "M91,41.5v-3.1v-2.8c0-1.7-0.2-2.3-1-2.8c-1.3-1.1-3.4-1.6-5.8-1.6c-4.3,0-6.3,1.4-6.6,4.8h3.7\n\t\tc0.2-1.6,1-2,3-2c2.2,0,2.9,0.6,2.9,2.3c0,0.7-0.2,1-1.1,1.1l-4.1,0.5c-4.1,0.5-5.6,1.8-5.6,4.6c0,2.6,2,4.2,5.4,4.2\n\t\tc2.5,0,4.1-0.8,5.5-2.9c0.8,2.2,1.8,2.9,3.7,2.9c1,0,1.8-0.2,3.4-1.1v-1.8c-0.8,0.1-1.4,0.1-1.7,0.1C91.5,43.9,91,43.2,91,41.5z\n\t\t M83,43.9c-1.4,0-2.3-0.7-2.3-1.8c0-1.6,0.7-1.9,5.3-2.8l1.2-0.2C87.2,42.3,85.9,43.9,83,43.9z");
    			add_location(path4, file$K, 19, 1, 1341);
    			attr_dev(path5, "fill", "#FFFFFF");
    			attr_dev(path5, "d", "M20.1,58.8c2.8-0.6,4.2-2.2,4.2-4.4c0-2.6-2.4-4.7-5.5-4.7H6.1v19.5h12.5c3.7,0,6.4-2.2,6.4-5.3\n\t\tC25,61.2,23.4,59.7,20.1,58.8z M10.6,52.8h5.9c2.3,0,3.1,0.6,3.1,2.3c0,1.8-0.8,2.4-3.1,2.4h-5.9V52.8z M16.5,65.7h-6v-5.3h6\n\t\tc2.4,0,3.5,0.8,3.5,2.6C20,65.1,19.1,65.7,16.5,65.7z");
    			add_location(path5, file$K, 25, 2, 1808);
    			attr_dev(rect, "x", "26.9");
    			attr_dev(rect, "y", "49.8");
    			attr_dev(rect, "fill", "#FFFFFF");
    			attr_dev(rect, "width", "4.1");
    			attr_dev(rect, "height", "19.5");
    			add_location(rect, file$K, 29, 1, 2117);
    			attr_dev(path6, "fill", "#FFFFFF");
    			attr_dev(path6, "d", "M47.4,64.9l-0.1-6.9c-0.1-2.3-2.5-3.6-6.6-3.6c-5.1,0-6.9,1.2-7.1,4.8h3.8c0.2-1.4,0.8-1.9,2.9-1.9\n\t\tc2.4,0,3.1,0.5,3.1,2.2c0,0.7-0.4,1-1.2,1.1c-0.2,0-1.9,0.1-4.1,0.5c-3.8,0.5-5.4,1.8-5.4,4.6c0,2.6,1.9,4.2,5.3,4.2\n\t\tc2.6,0,4.1-0.7,5.6-2.9c0.7,2,1.8,2.9,3.9,2.9c1,0,1.7-0.2,2.9-0.8v-2c-0.5,0.1-0.8,0.1-1.2,0.1C47.9,67.1,47.4,66.5,47.4,64.9z\n\t\t M39.4,67c-1.7,0-2.5-0.6-2.5-1.7c0-1.3,1-2,3.1-2.4c1.9-0.2,1.8-0.2,3.2-0.6C43.3,65.4,42,67,39.4,67z");
    			add_location(path6, file$K, 31, 1, 2196);
    			attr_dev(path7, "fill", "#FFFFFF");
    			attr_dev(path7, "d", "M61.7,57.3c-1.3-1.9-2.8-2.8-4.9-2.8c-3.8,0-6.7,3.2-6.7,7.6c0,4.8,2.5,7.8,6.6,7.8c2.3,0,3.4-0.6,5.2-2.8\n\t\tv2.3h3.9V49.8h-4V57.3z M57.6,67.1c-2.4,0-3.5-1.7-3.5-4.9c0-3,1.2-4.7,3.5-4.7c2.2,0,3.6,1.9,3.6,4.7\n\t\tC61.2,65.2,59.8,67.1,57.6,67.1z");
    			add_location(path7, file$K, 35, 1, 2673);
    			attr_dev(path8, "fill", "#FFFFFF");
    			attr_dev(path8, "d", "M75.5,54.6c-4.5,0-7.8,3.4-7.8,7.7c0,4.6,3.2,7.8,7.8,7.8c4.4,0,7.2-1.8,7.7-5.1h-3.8\n\t\tc-0.5,1.6-1.3,2-3.4,2c-2.8,0-4.1-1.3-4.1-4h11.3C83.2,58,80.2,54.6,75.5,54.6z M72,60.9c0.2-2.3,1.3-3.5,3.4-3.5\n\t\tc2.2,0,3.2,1.1,3.4,3.5H72z");
    			add_location(path8, file$K, 39, 1, 2950);
    			attr_dev(path9, "fill", "#FFFFFF");
    			attr_dev(path9, "d", "M90.3,65.7v-7.6h4v-2.9h-4v-5.3h-2.9L87.3,51c-0.7,4.2-0.6,4.2-1.7,4.2h-2.3v2.9h3l-0.1,6.9v0.5\n\t\tc0,3.2,1.4,4.7,4.6,4.7c1.6,0,2.4-0.1,3.7-0.8v-2.2c-0.8,0.1-1.7,0.1-2,0.1C90.9,67.2,90.3,66.8,90.3,65.7z");
    			add_location(path9, file$K, 43, 1, 3213);
    			add_location(g, file$K, 2, 0, 217);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$K, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g);
    			append_dev(g, path0);
    			append_dev(g, polygon0);
    			append_dev(g, polygon1);
    			append_dev(g, path1);
    			append_dev(g, path2);
    			append_dev(g, path3);
    			append_dev(g, path4);
    			append_dev(g, path5);
    			append_dev(g, rect);
    			append_dev(g, path6);
    			append_dev(g, path7);
    			append_dev(g, path8);
    			append_dev(g, path9);
    		},
    		p: function update(ctx, [dirty]) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ version: "1.1" },
    				{ id: "logo" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{
    					"xmlns:xlink": "http://www.w3.org/1999/xlink"
    				},
    				{ x: "0px" },
    				{ y: "0px" },
    				{ viewBox: "0 0 100 88" },
    				{ "enable-background": "new 0 0 100 88" },
    				{ "xml:space": "preserve" },
    				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Ekstrabladet_svg', slots, []);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props];
    }

    class Ekstrabladet_svg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ekstrabladet_svg",
    			options,
    			id: create_fragment$L.name
    		});
    	}
    }

    var IconSVGS = /*#__PURE__*/Object.freeze({
        __proto__: null,
        angledown: Angle_down_svg,
        angleleft: Angle_left_svg,
        angleright: Angle_right_svg,
        angleup: Angle_up_svg,
        article: Article_svg,
        at: At_svg,
        check: Check_svg,
        clock: Clock_svg,
        creditcard: Creditcard_svg,
        ebplus_icon: Ebplus_icon_svg,
        ebplus_sort: Ebplus_sort_svg,
        envelope: Envelope_svg,
        figcaptionpin: Figcaption_pin_svg,
        gallery: Gallery_svg,
        headphones: Headphones_svg,
        headset: Headset_svg,
        historyregular: History_regular_svg,
        lightning: Lightning_svg,
        lock: Lock_svg,
        medielogin: Medielogin_svg,
        menubars: Menu_bars_svg,
        mitebregular: Miteb_regular_svg,
        mitebsolid: Miteb_solid_svg,
        newspaper: Newspaper_svg,
        phone: Phone_svg,
        play: Play_svg,
        rss: Rss_svg,
        smartphone: Smartphone_svg,
        starregular: Star_regular_svg,
        tagregular: Tag_regular_svg,
        tagsolid: Tag_solid_svg,
        tagsregular: Tags_regular_svg,
        tagssolid: Tags_solid_svg,
        toggleoff: Toggle_off_svg,
        toggleon: Toggle_on_svg,
        video: Video_svg,
        ekstrabladet: Ekstrabladet_svg
    });

    /* src/components/icon/Icon.svelte generated by Svelte v3.42.6 */
    const file$J = "src/components/icon/Icon.svelte";

    // (17:0) {:else}
    function create_else_block$g(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", /*className*/ ctx[1]);
    			attr_dev(i, "style", /*style*/ ctx[0]);
    			attr_dev(i, "aria-hidden", "true");
    			add_location(i, file$J, 17, 2, 644);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*className*/ 2) {
    				attr_dev(i, "class", /*className*/ ctx[1]);
    			}

    			if (dirty & /*style*/ 1) {
    				attr_dev(i, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$g.name,
    		type: "else",
    		source: "(17:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (15:0) {#if type === 'svg'}
    function create_if_block$l(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = IconSVGS[/*name*/ ctx[2].replace('-', '')];

    	function switch_props(ctx) {
    		return {
    			props: {
    				style: /*style*/ ctx[0],
    				class: /*baseClass*/ ctx[4]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		switch_instance.$on("click", /*click_handler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*style*/ 1) switch_instance_changes.style = /*style*/ ctx[0];

    			if (switch_value !== (switch_value = IconSVGS[/*name*/ ctx[2].replace('-', '')])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					switch_instance.$on("click", /*click_handler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(15:0) {#if type === 'svg'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$l, create_else_block$g];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*type*/ ctx[3] === 'svg') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Icon', slots, []);
    	let { className = undefined } = $$props;
    	let { name = undefined } = $$props;
    	let { type = 'svg' } = $$props;
    	let { width = 36 } = $$props;
    	let { style = undefined } = $$props;

    	const defaultStyle = type === 'svg'
    	? `width: ${width}px; height: ${width}px;`
    	: '';

    	let baseClass = className ? `icon-svg ${className}` : 'icon-svg';
    	const writable_props = ['className', 'name', 'type', 'width', 'style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Icon> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(1, className = $$props.className);
    		if ('name' in $$props) $$invalidate(2, name = $$props.name);
    		if ('type' in $$props) $$invalidate(3, type = $$props.type);
    		if ('width' in $$props) $$invalidate(5, width = $$props.width);
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({
    		IconSVGS,
    		className,
    		name,
    		type,
    		width,
    		style,
    		defaultStyle,
    		baseClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(1, className = $$props.className);
    		if ('name' in $$props) $$invalidate(2, name = $$props.name);
    		if ('type' in $$props) $$invalidate(3, type = $$props.type);
    		if ('width' in $$props) $$invalidate(5, width = $$props.width);
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    		if ('baseClass' in $$props) $$invalidate(4, baseClass = $$props.baseClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*style*/ 1) {
    			$$invalidate(0, style = style ? `${defaultStyle} ${style}` : defaultStyle);
    		}
    	};

    	return [style, className, name, type, baseClass, width, click_handler];
    }

    class Icon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$K, create_fragment$K, safe_not_equal, {
    			className: 1,
    			name: 2,
    			type: 3,
    			width: 5,
    			style: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon",
    			options,
    			id: create_fragment$K.name
    		});
    	}

    	get className() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/toggler/Toggler.svelte generated by Svelte v3.42.6 */
    const file$I = "src/components/toggler/Toggler.svelte";
    const get_off_slot_changes_1 = dirty => ({});
    const get_off_slot_context_1 = ctx => ({});
    const get_on_slot_changes_1 = dirty => ({});
    const get_on_slot_context_1 = ctx => ({});
    const get_off_slot_changes = dirty => ({});
    const get_off_slot_context = ctx => ({});
    const get_on_slot_changes = dirty => ({});
    const get_on_slot_context = ctx => ({});

    // (33:0) {:else}
    function create_else_block$f(ctx) {
    	let button;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1$c, create_else_block_1$9];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*itsOn*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if_block.c();
    			attr_dev(button, "class", /*baseClass*/ ctx[1]);
    			add_location(button, file$I, 33, 2, 1136);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			if_blocks[current_block_type_index].m(button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*toggle*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(button, null);
    			}

    			if (!current || dirty & /*baseClass*/ 2) {
    				attr_dev(button, "class", /*baseClass*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$f.name,
    		type: "else",
    		source: "(33:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (23:0) {#if isSwitch}
    function create_if_block$k(ctx) {
    	let div;
    	let button0;
    	let button0_class_value;
    	let t0;
    	let icon;
    	let updating_name;
    	let t1;
    	let button1;
    	let button1_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const on_slot_template = /*#slots*/ ctx[8].on;
    	const on_slot = create_slot(on_slot_template, ctx, /*$$scope*/ ctx[7], get_on_slot_context);

    	function icon_name_binding(value) {
    		/*icon_name_binding*/ ctx[10](value);
    	}

    	let icon_props = {
    		className: "margin-s--rl",
    		width: "20",
    		style: "cursor: pointer;"
    	};

    	if (/*name*/ ctx[3] !== void 0) {
    		icon_props.name = /*name*/ ctx[3];
    	}

    	icon = new Icon({ props: icon_props, $$inline: true });
    	binding_callbacks.push(() => bind(icon, 'name', icon_name_binding));
    	icon.$on("click", /*toggle*/ ctx[4]);
    	const off_slot_template = /*#slots*/ ctx[8].off;
    	const off_slot = create_slot(off_slot_template, ctx, /*$$scope*/ ctx[7], get_off_slot_context);

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			if (on_slot) on_slot.c();
    			t0 = space();
    			create_component(icon.$$.fragment);
    			t1 = space();
    			button1 = element("button");
    			if (off_slot) off_slot.c();
    			attr_dev(button0, "data-status", /*itsOn*/ ctx[2]);
    			attr_dev(button0, "class", button0_class_value = "toggle--switch " + /*baseClass*/ ctx[1]);
    			add_location(button0, file$I, 24, 4, 727);
    			attr_dev(button1, "data-status", /*itsOn*/ ctx[2]);
    			attr_dev(button1, "class", button1_class_value = "toggle--switch " + /*baseClass*/ ctx[1]);
    			add_location(button1, file$I, 28, 4, 974);
    			attr_dev(div, "class", "flex flex-align--center");
    			add_location(div, file$I, 23, 2, 685);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);

    			if (on_slot) {
    				on_slot.m(button0, null);
    			}

    			append_dev(div, t0);
    			mount_component(icon, div, null);
    			append_dev(div, t1);
    			append_dev(div, button1);

    			if (off_slot) {
    				off_slot.m(button1, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (on_slot) {
    				if (on_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						on_slot,
    						on_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(on_slot_template, /*$$scope*/ ctx[7], dirty, get_on_slot_changes),
    						get_on_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*itsOn*/ 4) {
    				attr_dev(button0, "data-status", /*itsOn*/ ctx[2]);
    			}

    			if (!current || dirty & /*baseClass*/ 2 && button0_class_value !== (button0_class_value = "toggle--switch " + /*baseClass*/ ctx[1])) {
    				attr_dev(button0, "class", button0_class_value);
    			}

    			const icon_changes = {};

    			if (!updating_name && dirty & /*name*/ 8) {
    				updating_name = true;
    				icon_changes.name = /*name*/ ctx[3];
    				add_flush_callback(() => updating_name = false);
    			}

    			icon.$set(icon_changes);

    			if (off_slot) {
    				if (off_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						off_slot,
    						off_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(off_slot_template, /*$$scope*/ ctx[7], dirty, get_off_slot_changes),
    						get_off_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*itsOn*/ 4) {
    				attr_dev(button1, "data-status", /*itsOn*/ ctx[2]);
    			}

    			if (!current || dirty & /*baseClass*/ 2 && button1_class_value !== (button1_class_value = "toggle--switch " + /*baseClass*/ ctx[1])) {
    				attr_dev(button1, "class", button1_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(on_slot, local);
    			transition_in(icon.$$.fragment, local);
    			transition_in(off_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(on_slot, local);
    			transition_out(icon.$$.fragment, local);
    			transition_out(off_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (on_slot) on_slot.d(detaching);
    			destroy_component(icon);
    			if (off_slot) off_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(23:0) {#if isSwitch}",
    		ctx
    	});

    	return block;
    }

    // (37:4) {:else}
    function create_else_block_1$9(ctx) {
    	let current;
    	const off_slot_template = /*#slots*/ ctx[8].off;
    	const off_slot = create_slot(off_slot_template, ctx, /*$$scope*/ ctx[7], get_off_slot_context_1);

    	const block = {
    		c: function create() {
    			if (off_slot) off_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (off_slot) {
    				off_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (off_slot) {
    				if (off_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						off_slot,
    						off_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(off_slot_template, /*$$scope*/ ctx[7], dirty, get_off_slot_changes_1),
    						get_off_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(off_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(off_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (off_slot) off_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$9.name,
    		type: "else",
    		source: "(37:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (35:4) {#if itsOn}
    function create_if_block_1$c(ctx) {
    	let current;
    	const on_slot_template = /*#slots*/ ctx[8].on;
    	const on_slot = create_slot(on_slot_template, ctx, /*$$scope*/ ctx[7], get_on_slot_context_1);

    	const block = {
    		c: function create() {
    			if (on_slot) on_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (on_slot) {
    				on_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (on_slot) {
    				if (on_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						on_slot,
    						on_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(on_slot_template, /*$$scope*/ ctx[7], dirty, get_on_slot_changes_1),
    						get_on_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(on_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(on_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (on_slot) on_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(35:4) {#if itsOn}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$k, create_else_block$f];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isSwitch*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Toggler', slots, ['on','off']);
    	let { className = undefined } = $$props;
    	let { defaultState = true } = $$props;
    	let { isSwitch = false } = $$props;
    	let baseClass = `toggle-button`;
    	if (className) baseClass = `${className} ${baseClass}`;

    	/**
     * Handle user click on toggle element
     */
    	let itsOn = defaultState;

    	let name = itsOn ? 'toggleon' : 'toggleoff';
    	const dispatch = createEventDispatcher();

    	function toggle(evt, status) {
    		evt.preventDefault();
    		$$invalidate(2, itsOn = status !== null && status !== void 0 ? status : !itsOn);
    		$$invalidate(3, name = itsOn ? 'toggleon' : 'toggleoff');
    		dispatch('toggle', itsOn);
    	}

    	const writable_props = ['className', 'defaultState', 'isSwitch'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Toggler> was created with unknown prop '${key}'`);
    	});

    	const click_handler = evt => toggle(evt, true);

    	function icon_name_binding(value) {
    		name = value;
    		$$invalidate(3, name);
    	}

    	const click_handler_1 = evt => toggle(evt, false);

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(5, className = $$props.className);
    		if ('defaultState' in $$props) $$invalidate(6, defaultState = $$props.defaultState);
    		if ('isSwitch' in $$props) $$invalidate(0, isSwitch = $$props.isSwitch);
    		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		Icon,
    		className,
    		defaultState,
    		isSwitch,
    		baseClass,
    		itsOn,
    		name,
    		dispatch,
    		toggle
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(5, className = $$props.className);
    		if ('defaultState' in $$props) $$invalidate(6, defaultState = $$props.defaultState);
    		if ('isSwitch' in $$props) $$invalidate(0, isSwitch = $$props.isSwitch);
    		if ('baseClass' in $$props) $$invalidate(1, baseClass = $$props.baseClass);
    		if ('itsOn' in $$props) $$invalidate(2, itsOn = $$props.itsOn);
    		if ('name' in $$props) $$invalidate(3, name = $$props.name);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		isSwitch,
    		baseClass,
    		itsOn,
    		name,
    		toggle,
    		className,
    		defaultState,
    		$$scope,
    		slots,
    		click_handler,
    		icon_name_binding,
    		click_handler_1
    	];
    }

    class Toggler extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$J, create_fragment$J, safe_not_equal, {
    			className: 5,
    			defaultState: 6,
    			isSwitch: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Toggler",
    			options,
    			id: create_fragment$J.name
    		});
    	}

    	get className() {
    		throw new Error("<Toggler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Toggler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get defaultState() {
    		throw new Error("<Toggler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set defaultState(value) {
    		throw new Error("<Toggler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isSwitch() {
    		throw new Error("<Toggler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isSwitch(value) {
    		throw new Error("<Toggler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/articlecard/ArticleCard.svelte generated by Svelte v3.42.6 */
    const file$H = "src/components/articlecard/ArticleCard.svelte";
    const get_default_slot_changes_1$1 = dirty => ({});
    const get_default_slot_context_1$1 = ctx => ({ slot: "on" });
    const get_default_slot_changes$1 = dirty => ({});
    const get_default_slot_context$1 = ctx => ({ slot: "off" });

    // (60:4) {#if loading}
    function create_if_block_7(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", "card-image bg--graa4");
    			attr_dev(div0, "style", /*loadingStyle*/ ctx[12]);
    			add_location(div0, file$H, 61, 8, 2079);
    			attr_dev(div1, "class", "card-media");
    			add_location(div1, file$H, 60, 6, 2046);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*loadingStyle*/ 4096) {
    				attr_dev(div0, "style", /*loadingStyle*/ ctx[12]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(60:4) {#if loading}",
    		ctx
    	});

    	return block;
    }

    // (65:4) {#if media}
    function create_if_block_5$2(ctx) {
    	let div;
    	let t;
    	let img;
    	let img_src_value;
    	let img_height_value;
    	let img_width_value;
    	let div_class_value;
    	let current;
    	let if_block = /*update*/ ctx[4] && create_if_block_6(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			img = element("img");
    			attr_dev(img, "alt", /*title*/ ctx[0]);
    			attr_dev(img, "class", "card-image");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[5].src)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "height", img_height_value = /*media*/ ctx[5].height);
    			attr_dev(img, "width", img_width_value = /*media*/ ctx[5].width);
    			add_location(img, file$H, 80, 8, 2718);
    			attr_dev(div, "class", div_class_value = "card-media " + /*media*/ ctx[5].className);
    			add_location(div, file$H, 65, 6, 2182);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);
    			append_dev(div, img);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*update*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*update*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*title*/ 1) {
    				attr_dev(img, "alt", /*title*/ ctx[0]);
    			}

    			if (!current || dirty & /*media*/ 32 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[5].src)) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (!current || dirty & /*media*/ 32 && img_height_value !== (img_height_value = /*media*/ ctx[5].height)) {
    				attr_dev(img, "height", img_height_value);
    			}

    			if (!current || dirty & /*media*/ 32 && img_width_value !== (img_width_value = /*media*/ ctx[5].width)) {
    				attr_dev(img, "width", img_width_value);
    			}

    			if (!current || dirty & /*media*/ 32 && div_class_value !== (div_class_value = "card-media " + /*media*/ ctx[5].className)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(65:4) {#if media}",
    		ctx
    	});

    	return block;
    }

    // (67:8) {#if update}
    function create_if_block_6(ctx) {
    	let badge;
    	let current;

    	badge = new Badge({
    			props: {
    				className: "margin-s position-absolute padding-none padding-s--r card--shadow bg--black fontsize-small",
    				style: "bottom: 5px;  left: 5px;",
    				$$slots: { default: [create_default_slot_1$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(badge.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(badge, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge_changes = {};

    			if (dirty & /*$$scope, colorName*/ 67108868) {
    				badge_changes.$$scope = { dirty, ctx };
    			}

    			badge.$set(badge_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(badge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(badge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(badge, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(67:8) {#if update}",
    		ctx
    	});

    	return block;
    }

    // (68:10) <Badge             className="margin-s position-absolute padding-none padding-s--r card--shadow bg--black fontsize-small"             style="bottom: 5px;  left: 5px;"           >
    function create_default_slot_1$p(ctx) {
    	let icon;
    	let t;
    	let current;

    	icon = new Icon({
    			props: {
    				name: "lightning",
    				className: "bg--white color--" + /*colorName*/ ctx[2] + " border-radius-s padding-s margin-s--r",
    				style: "margin-left: -1px;",
    				width: "15"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    			t = text("\n            UPDATE");
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};
    			if (dirty & /*colorName*/ 4) icon_changes.className = "bg--white color--" + /*colorName*/ ctx[2] + " border-radius-s padding-s margin-s--r";
    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$p.name,
    		type: "slot",
    		source: "(68:10) <Badge             className=\\\"margin-s position-absolute padding-none padding-s--r card--shadow bg--black fontsize-small\\\"             style=\\\"bottom: 5px;  left: 5px;\\\"           >",
    		ctx
    	});

    	return block;
    }

    // (86:8) {#if premium}
    function create_if_block_4$5(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: { name: "ebplus_icon", width: "20" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$5.name,
    		type: "if",
    		source: "(86:8) {#if premium}",
    		ctx
    	});

    	return block;
    }

    // (91:8) {#if saved !== undefined}
    function create_if_block_3$6(ctx) {
    	let toggler;
    	let current;

    	toggler = new Toggler({
    			props: {
    				className: "card-save-toggle",
    				defaultState: /*saved*/ ctx[8],
    				$$slots: {
    					off: [create_off_slot$1],
    					on: [create_on_slot$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	toggler.$on("toggle", /*toggleSave*/ ctx[17]);

    	const block = {
    		c: function create() {
    			create_component(toggler.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(toggler, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const toggler_changes = {};
    			if (dirty & /*saved*/ 256) toggler_changes.defaultState = /*saved*/ ctx[8];

    			if (dirty & /*$$scope, breaking, colorName*/ 67108870) {
    				toggler_changes.$$scope = { dirty, ctx };
    			}

    			toggler.$set(toggler_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toggler.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toggler.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(toggler, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(91:8) {#if saved !== undefined}",
    		ctx
    	});

    	return block;
    }

    // (93:28)                
    function fallback_block_1$1(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: {
    				type: "fa",
    				className: "fas fa-star",
    				style: "color: var(--fgcolor--" + (/*breaking*/ ctx[1]
    				? colorNames.breaking
    				: /*colorName*/ ctx[2]) + ");"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};

    			if (dirty & /*breaking, colorName*/ 6) icon_changes.style = "color: var(--fgcolor--" + (/*breaking*/ ctx[1]
    			? colorNames.breaking
    			: /*colorName*/ ctx[2]) + ");";

    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1$1.name,
    		type: "fallback",
    		source: "(93:28)                ",
    		ctx
    	});

    	return block;
    }

    // (93:12) 
    function create_on_slot$1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[24].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[26], get_default_slot_context_1$1);
    	const default_slot_or_fallback = default_slot || fallback_block_1$1(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 67108864)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[26],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[26])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[26], dirty, get_default_slot_changes_1$1),
    						get_default_slot_context_1$1
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*breaking, colorName*/ 6)) {
    					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_on_slot$1.name,
    		type: "slot",
    		source: "(93:12) ",
    		ctx
    	});

    	return block;
    }

    // (100:29)                
    function fallback_block$1(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: {
    				type: "fa",
    				className: "far fa-star",
    				style: "color: var(--fgcolor--" + (/*breaking*/ ctx[1]
    				? colorNames.breaking
    				: /*colorName*/ ctx[2]) + ");"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};

    			if (dirty & /*breaking, colorName*/ 6) icon_changes.style = "color: var(--fgcolor--" + (/*breaking*/ ctx[1]
    			? colorNames.breaking
    			: /*colorName*/ ctx[2]) + ");";

    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(100:29)                ",
    		ctx
    	});

    	return block;
    }

    // (100:12) 
    function create_off_slot$1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[24].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[26], get_default_slot_context$1);
    	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 67108864)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[26],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[26])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[26], dirty, get_default_slot_changes$1),
    						get_default_slot_context$1
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*breaking, colorName*/ 6)) {
    					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_off_slot$1.name,
    		type: "slot",
    		source: "(100:12) ",
    		ctx
    	});

    	return block;
    }

    // (109:8) {#if section || published}
    function create_if_block$j(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block0 = /*section*/ ctx[9] && create_if_block_2$8(ctx);
    	let if_block1 = /*published*/ ctx[7] && create_if_block_1$b(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "card-meta flex fontsize-xxsmall padding-s--b");
    			add_location(div, file$H, 109, 10, 3759);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*section*/ ctx[9]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*section*/ 512) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$8(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*published*/ ctx[7]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*published*/ 128) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$b(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(109:8) {#if section || published}",
    		ctx
    	});

    	return block;
    }

    // (111:12) {#if section}
    function create_if_block_2$8(ctx) {
    	let div;
    	let span1;
    	let icon;
    	let t0;
    	let span0;
    	let t1;
    	let current;

    	icon = new Icon({
    			props: { name: "tagregular", width: "12" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			span1 = element("span");
    			create_component(icon.$$.fragment);
    			t0 = space();
    			span0 = element("span");
    			t1 = text(/*section*/ ctx[9]);
    			attr_dev(span0, "class", "padding-s--l");
    			add_location(span0, file$H, 114, 18, 4018);
    			attr_dev(span1, "class", "flex flex-justify--center");
    			add_location(span1, file$H, 112, 16, 3903);
    			attr_dev(div, "class", "card-meta-item");
    			add_location(div, file$H, 111, 14, 3858);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span1);
    			mount_component(icon, span1, null);
    			append_dev(span1, t0);
    			append_dev(span1, span0);
    			append_dev(span0, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*section*/ 512) set_data_dev(t1, /*section*/ ctx[9]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(111:12) {#if section}",
    		ctx
    	});

    	return block;
    }

    // (119:12) {#if published}
    function create_if_block_1$b(ctx) {
    	let div;
    	let icon;
    	let t0;
    	let span;
    	let t1_value = parseDate(/*published*/ ctx[7]) + "";
    	let t1;
    	let current;

    	icon = new Icon({
    			props: { name: "clock", width: "12" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(icon.$$.fragment);
    			t0 = space();
    			span = element("span");
    			t1 = text(t1_value);
    			attr_dev(span, "class", "padding-s--l");
    			add_location(span, file$H, 121, 16, 4261);
    			attr_dev(div, "class", "card-meta-item");
    			add_location(div, file$H, 119, 14, 4167);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(icon, div, null);
    			append_dev(div, t0);
    			append_dev(div, span);
    			append_dev(span, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*published*/ 128) && t1_value !== (t1_value = parseDate(/*published*/ ctx[7]) + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(119:12) {#if published}",
    		ctx
    	});

    	return block;
    }

    // (58:0) <Card {url} className={cssClass} style={styleProp} data-breaking={breaking} on:click>
    function create_default_slot$r(ctx) {
    	let div3;
    	let t0;
    	let t1;
    	let div2;
    	let div0;
    	let t2;
    	let div1;
    	let t3;
    	let t4;
    	let h2;
    	let t5;
    	let h2_class_value;
    	let current;
    	let if_block0 = /*loading*/ ctx[3] && create_if_block_7(ctx);
    	let if_block1 = /*media*/ ctx[5] && create_if_block_5$2(ctx);
    	let if_block2 = /*premium*/ ctx[6] && create_if_block_4$5(ctx);
    	let if_block3 = /*saved*/ ctx[8] !== undefined && create_if_block_3$6(ctx);
    	let if_block4 = (/*section*/ ctx[9] || /*published*/ ctx[7]) && create_if_block$j(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			div2 = element("div");
    			div0 = element("div");
    			if (if_block2) if_block2.c();
    			t2 = space();
    			div1 = element("div");
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			h2 = element("h2");
    			t5 = text(/*title*/ ctx[0]);
    			attr_dev(div0, "class", "card-icon flex flex-justify--end");
    			add_location(div0, file$H, 84, 6, 2883);
    			attr_dev(h2, "class", h2_class_value = "card-title " + (/*truncateTitle*/ ctx[10] ? 'card-title--truncated' : ''));
    			attr_dev(h2, "style", /*titleStyle*/ ctx[16]);
    			add_location(h2, file$H, 126, 8, 4396);
    			attr_dev(div1, "class", "card-content");
    			add_location(div1, file$H, 89, 6, 3034);
    			attr_dev(div2, "class", "card-content-wrapper");
    			add_location(div2, file$H, 83, 4, 2842);
    			attr_dev(div3, "class", /*innerClass*/ ctx[13]);
    			add_location(div3, file$H, 58, 2, 1997);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			if (if_block0) if_block0.m(div3, null);
    			append_dev(div3, t0);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			if (if_block2) if_block2.m(div0, null);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			if (if_block3) if_block3.m(div1, null);
    			append_dev(div1, t3);
    			if (if_block4) if_block4.m(div1, null);
    			append_dev(div1, t4);
    			append_dev(div1, h2);
    			append_dev(h2, t5);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*loading*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_7(ctx);
    					if_block0.c();
    					if_block0.m(div3, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*media*/ ctx[5]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*media*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_5$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div3, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*premium*/ ctx[6]) {
    				if (if_block2) {
    					if (dirty & /*premium*/ 64) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_4$5(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div0, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*saved*/ ctx[8] !== undefined) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*saved*/ 256) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_3$6(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div1, t3);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*section*/ ctx[9] || /*published*/ ctx[7]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty & /*section, published*/ 640) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block$j(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div1, t4);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*title*/ 1) set_data_dev(t5, /*title*/ ctx[0]);

    			if (!current || dirty & /*truncateTitle*/ 1024 && h2_class_value !== (h2_class_value = "card-title " + (/*truncateTitle*/ ctx[10] ? 'card-title--truncated' : ''))) {
    				attr_dev(h2, "class", h2_class_value);
    			}

    			if (!current || dirty & /*innerClass*/ 8192) {
    				attr_dev(div3, "class", /*innerClass*/ ctx[13]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$r.name,
    		type: "slot",
    		source: "(58:0) <Card {url} className={cssClass} style={styleProp} data-breaking={breaking} on:click>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let card;
    	let current;

    	card = new Card({
    			props: {
    				url: /*url*/ ctx[11],
    				className: /*cssClass*/ ctx[14],
    				style: /*styleProp*/ ctx[15],
    				"data-breaking": /*breaking*/ ctx[1],
    				$$slots: { default: [create_default_slot$r] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card.$on("click", /*click_handler*/ ctx[25]);

    	const block = {
    		c: function create() {
    			create_component(card.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(card, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const card_changes = {};
    			if (dirty & /*url*/ 2048) card_changes.url = /*url*/ ctx[11];
    			if (dirty & /*cssClass*/ 16384) card_changes.className = /*cssClass*/ ctx[14];
    			if (dirty & /*styleProp*/ 32768) card_changes.style = /*styleProp*/ ctx[15];
    			if (dirty & /*breaking*/ 2) card_changes["data-breaking"] = /*breaking*/ ctx[1];

    			if (dirty & /*$$scope, innerClass, truncateTitle, title, published, section, saved, breaking, colorName, premium, media, update, loadingStyle, loading*/ 67123199) {
    				card_changes.$$scope = { dirty, ctx };
    			}

    			card.$set(card_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(card, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let styleProp;
    	let cssClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ArticleCard', slots, ['default']);
    	let { title } = $$props;
    	let { breaking = false } = $$props;
    	let { cardType = undefined } = $$props;
    	let { className = undefined } = $$props;
    	let { colorName = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { loading = false } = $$props;
    	let { update = false } = $$props;
    	let { maxLines = undefined } = $$props;
    	let { media = undefined } = $$props;
    	let { premium = false } = $$props;
    	let { published = undefined } = $$props;
    	let { saved = undefined } = $$props;
    	let { section = undefined } = $$props;
    	let { style = '' } = $$props;
    	let { truncateTitle = false } = $$props;
    	let { url = undefined } = $$props;
    	const dispatch = createEventDispatcher();
    	let baseClass = `card-mode card-mode--article`;
    	let loadingStyle = 'padding-top: 56.25%; width: 100%;';

    	if (loading) {
    		baseClass = `${baseClass} animation-fogwave`;
    		title = 'Loading';

    		switch (cardType) {
    			case 'small-media':
    			case 'small-media--reverse':
    				loadingStyle = 'width: 200px;height: 115px;';
    				break;
    		}
    	}

    	let innerClass = 'card-inner';

    	switch (cardType) {
    		case 'small-media':
    			innerClass = `${innerClass} card--small-media`;
    			break;
    		case 'small-media--reverse':
    			innerClass = `${innerClass} card--small-media card--small-media--reverse`;
    			break;
    	}

    	const titleStyle = maxLines ? `--max-lines: ${maxLines};` : undefined;

    	function toggleSave(evt) {
    		dispatch('save', { id, save: evt.detail });
    	}

    	const writable_props = [
    		'title',
    		'breaking',
    		'cardType',
    		'className',
    		'colorName',
    		'id',
    		'loading',
    		'update',
    		'maxLines',
    		'media',
    		'premium',
    		'published',
    		'saved',
    		'section',
    		'style',
    		'truncateTitle',
    		'url'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArticleCard> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('breaking' in $$props) $$invalidate(1, breaking = $$props.breaking);
    		if ('cardType' in $$props) $$invalidate(18, cardType = $$props.cardType);
    		if ('className' in $$props) $$invalidate(19, className = $$props.className);
    		if ('colorName' in $$props) $$invalidate(2, colorName = $$props.colorName);
    		if ('id' in $$props) $$invalidate(20, id = $$props.id);
    		if ('loading' in $$props) $$invalidate(3, loading = $$props.loading);
    		if ('update' in $$props) $$invalidate(4, update = $$props.update);
    		if ('maxLines' in $$props) $$invalidate(21, maxLines = $$props.maxLines);
    		if ('media' in $$props) $$invalidate(5, media = $$props.media);
    		if ('premium' in $$props) $$invalidate(6, premium = $$props.premium);
    		if ('published' in $$props) $$invalidate(7, published = $$props.published);
    		if ('saved' in $$props) $$invalidate(8, saved = $$props.saved);
    		if ('section' in $$props) $$invalidate(9, section = $$props.section);
    		if ('style' in $$props) $$invalidate(22, style = $$props.style);
    		if ('truncateTitle' in $$props) $$invalidate(10, truncateTitle = $$props.truncateTitle);
    		if ('url' in $$props) $$invalidate(11, url = $$props.url);
    		if ('$$scope' in $$props) $$invalidate(26, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		parseDate,
    		Badge,
    		Card,
    		Icon,
    		Toggler,
    		colorNames,
    		title,
    		breaking,
    		cardType,
    		className,
    		colorName,
    		id,
    		loading,
    		update,
    		maxLines,
    		media,
    		premium,
    		published,
    		saved,
    		section,
    		style,
    		truncateTitle,
    		url,
    		dispatch,
    		baseClass,
    		loadingStyle,
    		innerClass,
    		titleStyle,
    		toggleSave,
    		cssClass,
    		styleProp
    	});

    	$$self.$inject_state = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('breaking' in $$props) $$invalidate(1, breaking = $$props.breaking);
    		if ('cardType' in $$props) $$invalidate(18, cardType = $$props.cardType);
    		if ('className' in $$props) $$invalidate(19, className = $$props.className);
    		if ('colorName' in $$props) $$invalidate(2, colorName = $$props.colorName);
    		if ('id' in $$props) $$invalidate(20, id = $$props.id);
    		if ('loading' in $$props) $$invalidate(3, loading = $$props.loading);
    		if ('update' in $$props) $$invalidate(4, update = $$props.update);
    		if ('maxLines' in $$props) $$invalidate(21, maxLines = $$props.maxLines);
    		if ('media' in $$props) $$invalidate(5, media = $$props.media);
    		if ('premium' in $$props) $$invalidate(6, premium = $$props.premium);
    		if ('published' in $$props) $$invalidate(7, published = $$props.published);
    		if ('saved' in $$props) $$invalidate(8, saved = $$props.saved);
    		if ('section' in $$props) $$invalidate(9, section = $$props.section);
    		if ('style' in $$props) $$invalidate(22, style = $$props.style);
    		if ('truncateTitle' in $$props) $$invalidate(10, truncateTitle = $$props.truncateTitle);
    		if ('url' in $$props) $$invalidate(11, url = $$props.url);
    		if ('baseClass' in $$props) $$invalidate(23, baseClass = $$props.baseClass);
    		if ('loadingStyle' in $$props) $$invalidate(12, loadingStyle = $$props.loadingStyle);
    		if ('innerClass' in $$props) $$invalidate(13, innerClass = $$props.innerClass);
    		if ('cssClass' in $$props) $$invalidate(14, cssClass = $$props.cssClass);
    		if ('styleProp' in $$props) $$invalidate(15, styleProp = $$props.styleProp);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*style, colorName*/ 4194308) {
    			$$invalidate(15, styleProp = `${style}; --color--list-hover: var(--color--${colorName}); --fgcolor--list-hover: var(--fgcolor--${colorName});`);
    		}

    		if ($$self.$$.dirty & /*className, baseClass*/ 8912896) {
    			$$invalidate(14, cssClass = className ? `${className} ${baseClass}` : baseClass);
    		}
    	};

    	return [
    		title,
    		breaking,
    		colorName,
    		loading,
    		update,
    		media,
    		premium,
    		published,
    		saved,
    		section,
    		truncateTitle,
    		url,
    		loadingStyle,
    		innerClass,
    		cssClass,
    		styleProp,
    		titleStyle,
    		toggleSave,
    		cardType,
    		className,
    		id,
    		maxLines,
    		style,
    		baseClass,
    		slots,
    		click_handler,
    		$$scope
    	];
    }

    class ArticleCard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$I, create_fragment$I, safe_not_equal, {
    			title: 0,
    			breaking: 1,
    			cardType: 18,
    			className: 19,
    			colorName: 2,
    			id: 20,
    			loading: 3,
    			update: 4,
    			maxLines: 21,
    			media: 5,
    			premium: 6,
    			published: 7,
    			saved: 8,
    			section: 9,
    			style: 22,
    			truncateTitle: 10,
    			url: 11
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ArticleCard",
    			options,
    			id: create_fragment$I.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*title*/ ctx[0] === undefined && !('title' in props)) {
    			console.warn("<ArticleCard> was created without expected prop 'title'");
    		}
    	}

    	get title() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get breaking() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set breaking(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cardType() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cardType(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get colorName() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colorName(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get update() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set update(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maxLines() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxLines(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get media() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set media(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get premium() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set premium(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get published() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set published(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get saved() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set saved(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get section() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set section(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get truncateTitle() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set truncateTitle(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error("<ArticleCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<ArticleCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/buttongroup/ButtonGroup.svelte generated by Svelte v3.42.6 */

    const { console: console_1 } = globals;
    const file$G = "src/components/buttongroup/ButtonGroup.svelte";

    function create_fragment$H(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", /*cssClass*/ ctx[1]);
    			attr_dev(div, "style", /*style*/ ctx[0]);
    			add_location(div, file$G, 59, 0, 2137);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 2) {
    				attr_dev(div, "class", /*cssClass*/ ctx[1]);
    			}

    			if (!current || dirty & /*style*/ 1) {
    				attr_dev(div, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const BUTTONS$1 = {};

    function instance$H($$self, $$props, $$invalidate) {
    	let cssClass;
    	let style;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ButtonGroup', slots, ['default']);
    	const selectedId = writable(0);
    	const selectedButton = writable(null);
    	const buttons = [];

    	selectedId.subscribe(i => {
    		selectedButton.set(buttons[i]);
    	});

    	setContext(BUTTONS$1, {
    		createContextButton: () => {
    			return { button: buttons.length };
    		},
    		registerButton: button => {
    			console.log('registerTab', button);
    			buttons.push(button);
    			selectedButton.update(current => current || button);

    			onDestroy(() => {
    				const i = buttons.indexOf(button);
    				buttons.splice(i, 1);

    				selectedButton.update(current => current === button
    				? buttons[i] || buttons[buttons.length - 1]
    				: current);
    			});
    		},
    		selectButton: button => {
    			console.log('selectButton', button);
    			const i = buttons.indexOf(button);
    			selectedId.set(i);
    		},
    		selectedButton
    	});

    	let { className = undefined } = $$props;
    	let { type = undefined } = $$props;
    	let { color = undefined } = $$props;
    	let { colorHover = undefined } = $$props;
    	let { solid = false } = $$props;
    	let baseClass = `buttongroup`;

    	if (solid) {
    		baseClass = `${baseClass} buttongroup--solid`;
    	}

    	if (type) {
    		baseClass = `${baseClass} buttongroup--${type}`;
    	}

    	const { background: colorBackground, color: colorForeground } = Background[color]
    	? Background[color]
    	: Background['bruger'];

    	/**
     * If hovercolor is not specified, use color and utimately fall back to "Bruger"
     */
    	colorHover = color && !colorHover ? color : colorHover;

    	const { background: hoverColor, color: hoverColorForeground } = Background[colorHover]
    	? Background[colorHover]
    	: Background['bruger'];

    	const writable_props = ['className', 'type', 'color', 'colorHover', 'solid'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<ButtonGroup> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('type' in $$props) $$invalidate(5, type = $$props.type);
    		if ('color' in $$props) $$invalidate(6, color = $$props.color);
    		if ('colorHover' in $$props) $$invalidate(2, colorHover = $$props.colorHover);
    		if ('solid' in $$props) $$invalidate(7, solid = $$props.solid);
    		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		BUTTONS: BUTTONS$1,
    		setContext,
    		onDestroy,
    		writable,
    		Background,
    		selectedId,
    		selectedButton,
    		buttons,
    		className,
    		type,
    		color,
    		colorHover,
    		solid,
    		baseClass,
    		colorBackground,
    		colorForeground,
    		hoverColor,
    		hoverColorForeground,
    		style,
    		cssClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('type' in $$props) $$invalidate(5, type = $$props.type);
    		if ('color' in $$props) $$invalidate(6, color = $$props.color);
    		if ('colorHover' in $$props) $$invalidate(2, colorHover = $$props.colorHover);
    		if ('solid' in $$props) $$invalidate(7, solid = $$props.solid);
    		if ('baseClass' in $$props) $$invalidate(8, baseClass = $$props.baseClass);
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    		if ('cssClass' in $$props) $$invalidate(1, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, baseClass*/ 272) {
    			$$invalidate(1, cssClass = className ? `${className} ${baseClass}` : baseClass);
    		}
    	};

    	$$invalidate(0, style = `--buttongroup-color: ${colorBackground}; --buttongroup-fgcolor: ${colorForeground}; --buttongroup-color--hover: ${hoverColor}; --buttongroup-fgcolor--hover: ${hoverColorForeground};`);

    	return [
    		style,
    		cssClass,
    		colorHover,
    		selectedId,
    		className,
    		type,
    		color,
    		solid,
    		baseClass,
    		$$scope,
    		slots
    	];
    }

    class ButtonGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {
    			selectedId: 3,
    			className: 4,
    			type: 5,
    			color: 6,
    			colorHover: 2,
    			solid: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ButtonGroup",
    			options,
    			id: create_fragment$H.name
    		});
    	}

    	get selectedId() {
    		return this.$$.ctx[3];
    	}

    	set selectedId(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get colorHover() {
    		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colorHover(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get solid() {
    		throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set solid(value) {
    		throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/button/Button.svelte generated by Svelte v3.42.6 */
    const file$F = "src/components/button/Button.svelte";

    // (53:0) {:else}
    function create_else_block$e(ctx) {
    	let button;
    	let button_data_selected_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();
    			attr_dev(button, "class", /*cssClass*/ ctx[5]);
    			button.disabled = /*disabled*/ ctx[0];
    			attr_dev(button, "data-selected", button_data_selected_value = /*$selectedButton*/ ctx[6] === /*contextButton*/ ctx[3]);
    			add_location(button, file$F, 53, 2, 1520);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			/*button_binding*/ ctx[18](button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[16], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 32) {
    				attr_dev(button, "class", /*cssClass*/ ctx[5]);
    			}

    			if (!current || dirty & /*disabled*/ 1) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[0]);
    			}

    			if (!current || dirty & /*$selectedButton, contextButton*/ 72 && button_data_selected_value !== (button_data_selected_value = /*$selectedButton*/ ctx[6] === /*contextButton*/ ctx[3])) {
    				attr_dev(button, "data-selected", button_data_selected_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			/*button_binding*/ ctx[18](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$e.name,
    		type: "else",
    		source: "(53:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (49:0) {#if href}
    function create_if_block$i(ctx) {
    	let a;
    	let a_data_selected_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			attr_dev(a, "href", /*href*/ ctx[1]);
    			attr_dev(a, "class", /*cssClass*/ ctx[5]);
    			attr_dev(a, "disabled", /*disabled*/ ctx[0]);
    			attr_dev(a, "data-selected", a_data_selected_value = /*$selectedButton*/ ctx[6] === /*contextButton*/ ctx[3]);
    			add_location(a, file$F, 49, 2, 1371);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			/*a_binding*/ ctx[17](a);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[15], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*href*/ 2) {
    				attr_dev(a, "href", /*href*/ ctx[1]);
    			}

    			if (!current || dirty & /*cssClass*/ 32) {
    				attr_dev(a, "class", /*cssClass*/ ctx[5]);
    			}

    			if (!current || dirty & /*disabled*/ 1) {
    				attr_dev(a, "disabled", /*disabled*/ ctx[0]);
    			}

    			if (!current || dirty & /*$selectedButton, contextButton*/ 72 && a_data_selected_value !== (a_data_selected_value = /*$selectedButton*/ ctx[6] === /*contextButton*/ ctx[3])) {
    				attr_dev(a, "data-selected", a_data_selected_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			/*a_binding*/ ctx[17](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(49:0) {#if href}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$i, create_else_block$e];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*href*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let cssClass;

    	let $selectedButton,
    		$$unsubscribe_selectedButton = noop,
    		$$subscribe_selectedButton = () => ($$unsubscribe_selectedButton(), $$unsubscribe_selectedButton = subscribe(selectedButton, $$value => $$invalidate(6, $selectedButton = $$value)), selectedButton);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_selectedButton());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, ['default']);
    	let { className = undefined } = $$props;
    	let { disabled = false } = $$props;
    	let { extension = undefined } = $$props;
    	let { href = undefined } = $$props;
    	let { size = undefined } = $$props;
    	let { type = undefined } = $$props;
    	let baseClass = 'button';

    	if (extension) {
    		let extSplit = extension.split(' ');

    		extSplit.forEach(extClass => {
    			$$invalidate(12, baseClass = `${baseClass} button--${extClass}`);
    		});
    	}

    	if (size) {
    		baseClass = `${baseClass} button--${size}`;
    	}

    	if (type) {
    		baseClass = `${baseClass} button--${type}`;
    	}

    	let buttonEl;
    	let { initial = false } = $$props;
    	let contextButton;
    	let selectButton;
    	let selectedButton;
    	const contextButtons = getContext(BUTTONS$1);

    	if (contextButtons) {
    		const registerButton = contextButtons.registerButton;
    		contextButton = contextButtons.createContextButton();
    		selectButton = contextButtons.selectButton;
    		$$subscribe_selectedButton(selectedButton = contextButtons.selectedButton);
    		registerButton(contextButton);

    		if (initial) {
    			selectButton(contextButton);
    		}
    	}

    	onMount(() => {
    		if (typeof selectButton !== 'undefined') {
    			buttonEl.addEventListener('click', () => selectButton(contextButton));
    		}
    	});

    	const writable_props = ['className', 'disabled', 'extension', 'href', 'size', 'type', 'initial'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Button> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			buttonEl = $$value;
    			$$invalidate(2, buttonEl);
    		});
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			buttonEl = $$value;
    			$$invalidate(2, buttonEl);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(7, className = $$props.className);
    		if ('disabled' in $$props) $$invalidate(0, disabled = $$props.disabled);
    		if ('extension' in $$props) $$invalidate(8, extension = $$props.extension);
    		if ('href' in $$props) $$invalidate(1, href = $$props.href);
    		if ('size' in $$props) $$invalidate(9, size = $$props.size);
    		if ('type' in $$props) $$invalidate(10, type = $$props.type);
    		if ('initial' in $$props) $$invalidate(11, initial = $$props.initial);
    		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		disabled,
    		extension,
    		href,
    		size,
    		type,
    		baseClass,
    		buttonEl,
    		getContext,
    		onMount,
    		BUTTONS: BUTTONS$1,
    		initial,
    		contextButton,
    		selectButton,
    		selectedButton,
    		contextButtons,
    		cssClass,
    		$selectedButton
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(7, className = $$props.className);
    		if ('disabled' in $$props) $$invalidate(0, disabled = $$props.disabled);
    		if ('extension' in $$props) $$invalidate(8, extension = $$props.extension);
    		if ('href' in $$props) $$invalidate(1, href = $$props.href);
    		if ('size' in $$props) $$invalidate(9, size = $$props.size);
    		if ('type' in $$props) $$invalidate(10, type = $$props.type);
    		if ('baseClass' in $$props) $$invalidate(12, baseClass = $$props.baseClass);
    		if ('buttonEl' in $$props) $$invalidate(2, buttonEl = $$props.buttonEl);
    		if ('initial' in $$props) $$invalidate(11, initial = $$props.initial);
    		if ('contextButton' in $$props) $$invalidate(3, contextButton = $$props.contextButton);
    		if ('selectButton' in $$props) selectButton = $$props.selectButton;
    		if ('selectedButton' in $$props) $$subscribe_selectedButton($$invalidate(4, selectedButton = $$props.selectedButton));
    		if ('cssClass' in $$props) $$invalidate(5, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, baseClass*/ 4224) {
    			$$invalidate(5, cssClass = className ? `${baseClass} ${className}` : baseClass);
    		}
    	};

    	return [
    		disabled,
    		href,
    		buttonEl,
    		contextButton,
    		selectedButton,
    		cssClass,
    		$selectedButton,
    		className,
    		extension,
    		size,
    		type,
    		initial,
    		baseClass,
    		$$scope,
    		slots,
    		click_handler,
    		click_handler_1,
    		a_binding,
    		button_binding
    	];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$G, create_fragment$G, safe_not_equal, {
    			className: 7,
    			disabled: 0,
    			extension: 8,
    			href: 1,
    			size: 9,
    			type: 10,
    			initial: 11
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$G.name
    		});
    	}

    	get className() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get extension() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set extension(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get initial() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set initial(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/form-elements/Checkbox.svelte generated by Svelte v3.42.6 */

    const file$E = "src/components/form-elements/Checkbox.svelte";

    // (19:4) {:else}
    function create_else_block$d(ctx) {
    	let i0;
    	let t;
    	let i1;

    	const block = {
    		c: function create() {
    			i0 = element("i");
    			t = space();
    			i1 = element("i");
    			attr_dev(i0, "class", "far fa-check-circle form-checkbox-toggle--on");
    			attr_dev(i0, "aria-hidden", "true");
    			add_location(i0, file$E, 19, 6, 672);
    			attr_dev(i1, "class", "far fa-circle form-checkbox-toggle--off");
    			attr_dev(i1, "aria-hidden", "true");
    			add_location(i1, file$E, 20, 6, 756);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i0, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, i1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(i1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$d.name,
    		type: "else",
    		source: "(19:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (16:4) {#if inputtype === 'checkbox'}
    function create_if_block$h(ctx) {
    	let i0;
    	let t;
    	let i1;

    	const block = {
    		c: function create() {
    			i0 = element("i");
    			t = space();
    			i1 = element("i");
    			attr_dev(i0, "class", "far fa-check-square form-checkbox-toggle--on");
    			attr_dev(i0, "aria-hidden", "true");
    			add_location(i0, file$E, 16, 6, 497);
    			attr_dev(i1, "class", "far fa-square form-checkbox-toggle--off");
    			attr_dev(i1, "aria-hidden", "true");
    			add_location(i1, file$E, 17, 6, 581);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i0, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, i1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(i1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(16:4) {#if inputtype === 'checkbox'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let label_1;
    	let input;
    	let t0;
    	let span;
    	let t1;
    	let t2;

    	function select_block_type(ctx, dirty) {
    		if (/*inputtype*/ ctx[3] === 'checkbox') return create_if_block$h;
    		return create_else_block$d;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			label_1 = element("label");
    			input = element("input");
    			t0 = space();
    			span = element("span");
    			t1 = text(/*label*/ ctx[2]);
    			t2 = space();
    			if_block.c();
    			attr_dev(input, "type", /*inputtype*/ ctx[3]);
    			attr_dev(input, "class", /*baseClass*/ ctx[5]);
    			attr_dev(input, "name", /*fieldName*/ ctx[0]);
    			attr_dev(input, "group", /*group*/ ctx[1]);
    			input.value = /*value*/ ctx[4];
    			add_location(input, file$E, 12, 2, 338);
    			attr_dev(span, "class", "form-label");
    			add_location(span, file$E, 13, 2, 418);
    			add_location(label_1, file$E, 11, 0, 328);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label_1, anchor);
    			append_dev(label_1, input);
    			append_dev(label_1, t0);
    			append_dev(label_1, span);
    			append_dev(span, t1);
    			append_dev(span, t2);
    			if_block.m(span, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*inputtype*/ 8) {
    				attr_dev(input, "type", /*inputtype*/ ctx[3]);
    			}

    			if (dirty & /*baseClass*/ 32) {
    				attr_dev(input, "class", /*baseClass*/ ctx[5]);
    			}

    			if (dirty & /*fieldName*/ 1) {
    				attr_dev(input, "name", /*fieldName*/ ctx[0]);
    			}

    			if (dirty & /*group*/ 2) {
    				attr_dev(input, "group", /*group*/ ctx[1]);
    			}

    			if (dirty & /*value*/ 16 && input.value !== /*value*/ ctx[4]) {
    				prop_dev(input, "value", /*value*/ ctx[4]);
    			}

    			if (dirty & /*label*/ 4) set_data_dev(t1, /*label*/ ctx[2]);

    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(span, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label_1);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Checkbox', slots, []);
    	let { fieldName = undefined } = $$props;
    	let { group = undefined } = $$props;
    	let { label = undefined } = $$props;
    	let { inputtype = 'checkbox' } = $$props;
    	let { value = '' } = $$props;
    	let { className = undefined } = $$props;
    	let baseClass = `form-checkbox form-checkbox--icon`;
    	if (className) baseClass = `${className} ${baseClass}`;
    	const writable_props = ['fieldName', 'group', 'label', 'inputtype', 'value', 'className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Checkbox> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('fieldName' in $$props) $$invalidate(0, fieldName = $$props.fieldName);
    		if ('group' in $$props) $$invalidate(1, group = $$props.group);
    		if ('label' in $$props) $$invalidate(2, label = $$props.label);
    		if ('inputtype' in $$props) $$invalidate(3, inputtype = $$props.inputtype);
    		if ('value' in $$props) $$invalidate(4, value = $$props.value);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    	};

    	$$self.$capture_state = () => ({
    		fieldName,
    		group,
    		label,
    		inputtype,
    		value,
    		className,
    		baseClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('fieldName' in $$props) $$invalidate(0, fieldName = $$props.fieldName);
    		if ('group' in $$props) $$invalidate(1, group = $$props.group);
    		if ('label' in $$props) $$invalidate(2, label = $$props.label);
    		if ('inputtype' in $$props) $$invalidate(3, inputtype = $$props.inputtype);
    		if ('value' in $$props) $$invalidate(4, value = $$props.value);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('baseClass' in $$props) $$invalidate(5, baseClass = $$props.baseClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [fieldName, group, label, inputtype, value, baseClass, className];
    }

    class Checkbox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$F, create_fragment$F, safe_not_equal, {
    			fieldName: 0,
    			group: 1,
    			label: 2,
    			inputtype: 3,
    			value: 4,
    			className: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Checkbox",
    			options,
    			id: create_fragment$F.name
    		});
    	}

    	get fieldName() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fieldName(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputtype() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputtype(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/form-elements/Select.svelte generated by Svelte v3.42.6 */

    const file$D = "src/components/form-elements/Select.svelte";

    function create_fragment$E(ctx) {
    	let label_1;
    	let t0;
    	let t1;
    	let select;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			label_1 = element("label");
    			t0 = text(/*label*/ ctx[0]);
    			t1 = space();
    			select = element("select");
    			if (default_slot) default_slot.c();
    			attr_dev(label_1, "class", "form-label");
    			attr_dev(label_1, "for", "select");
    			add_location(label_1, file$D, 8, 0, 239);
    			attr_dev(select, "classname", /*baseClass*/ ctx[1]);
    			attr_dev(select, "id", "select");
    			add_location(select, file$D, 9, 0, 294);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label_1, anchor);
    			append_dev(label_1, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, select, anchor);

    			if (default_slot) {
    				default_slot.m(select, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*label*/ 1) set_data_dev(t0, /*label*/ ctx[0]);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*baseClass*/ 2) {
    				attr_dev(select, "classname", /*baseClass*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label_1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(select);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Select', slots, ['default']);
    	let { inputtype = 'text' } = $$props;
    	let { label = undefined } = $$props;
    	let { className = undefined } = $$props;
    	let baseClass = `form-input form-input--${inputtype}`;
    	if (className) baseClass = `${className} ${baseClass}`;
    	const writable_props = ['inputtype', 'label', 'className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Select> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('inputtype' in $$props) $$invalidate(2, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(0, label = $$props.label);
    		if ('className' in $$props) $$invalidate(3, className = $$props.className);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ inputtype, label, className, baseClass });

    	$$self.$inject_state = $$props => {
    		if ('inputtype' in $$props) $$invalidate(2, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(0, label = $$props.label);
    		if ('className' in $$props) $$invalidate(3, className = $$props.className);
    		if ('baseClass' in $$props) $$invalidate(1, baseClass = $$props.baseClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [label, baseClass, inputtype, className, $$scope, slots];
    }

    class Select extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, { inputtype: 2, label: 0, className: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select",
    			options,
    			id: create_fragment$E.name
    		});
    	}

    	get inputtype() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputtype(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/form-elements/TextInput.svelte generated by Svelte v3.42.6 */
    const file$C = "src/components/form-elements/TextInput.svelte";

    // (28:2) {#if label}
    function create_if_block$g(ctx) {
    	let span;
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(/*label*/ ctx[1]);
    			t1 = text(":");
    			attr_dev(span, "class", "hidden");
    			add_location(span, file$C, 28, 4, 954);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			/*span_binding*/ ctx[8](span);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 2) set_data_dev(t0, /*label*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			/*span_binding*/ ctx[8](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(28:2) {#if label}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let div;
    	let t;
    	let input;
    	let div_class_value;
    	let mounted;
    	let dispose;
    	let if_block = /*label*/ ctx[1] && create_if_block$g(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			input = element("input");
    			attr_dev(input, "type", /*inputtype*/ ctx[0]);
    			attr_dev(input, "placeholder", /*label*/ ctx[1]);
    			attr_dev(input, "class", /*baseClass*/ ctx[5]);
    			add_location(input, file$C, 30, 2, 1026);
    			attr_dev(div, "class", div_class_value = `form-input-container flex border-radius padding-m--rl ${/*size*/ ctx[2]}`);
    			add_location(div, file$C, 26, 0, 858);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);
    			append_dev(div, input);
    			/*input_binding*/ ctx[9](input);

    			if (!mounted) {
    				dispose = listen_dev(input, "focus", /*focus_handler*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*label*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$g(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*inputtype*/ 1) {
    				attr_dev(input, "type", /*inputtype*/ ctx[0]);
    			}

    			if (dirty & /*label*/ 2) {
    				attr_dev(input, "placeholder", /*label*/ ctx[1]);
    			}

    			if (dirty & /*baseClass*/ 32) {
    				attr_dev(input, "class", /*baseClass*/ ctx[5]);
    			}

    			if (dirty & /*size*/ 4 && div_class_value !== (div_class_value = `form-input-container flex border-radius padding-m--rl ${/*size*/ ctx[2]}`)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			/*input_binding*/ ctx[9](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TextInput', slots, []);
    	let { inputtype = 'text' } = $$props;
    	let { label = undefined } = $$props;
    	let { className = undefined } = $$props;
    	let { size = "padding-m--tb" } = $$props;
    	let inputEl;
    	let inputLabelEl;
    	let baseClass = `form-input form-input--${inputtype} width-1of1`;
    	if (className) baseClass = `${className} ${baseClass}`;

    	/* focus effect on form elements */
    	onMount(() => {
    		inputEl.addEventListener('focus', () => {
    			inputEl.parentElement.setAttribute('data-focus', 'true');
    			const inputLabel = inputEl.previousElementSibling;
    			inputLabel.classList.remove('hidden');
    		});

    		inputEl.addEventListener('focusout', () => {
    			inputEl.parentElement.setAttribute('data-focus', 'false');

    			if (inputEl.value.length === 0) {
    				inputLabelEl.classList.add('hidden');
    			}
    		});
    	});

    	const writable_props = ['inputtype', 'label', 'className', 'size'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TextInput> was created with unknown prop '${key}'`);
    	});

    	function focus_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function span_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputLabelEl = $$value;
    			$$invalidate(4, inputLabelEl);
    		});
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inputEl = $$value;
    			$$invalidate(3, inputEl);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('inputtype' in $$props) $$invalidate(0, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('size' in $$props) $$invalidate(2, size = $$props.size);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		inputtype,
    		label,
    		className,
    		size,
    		inputEl,
    		inputLabelEl,
    		baseClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('inputtype' in $$props) $$invalidate(0, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(1, label = $$props.label);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('size' in $$props) $$invalidate(2, size = $$props.size);
    		if ('inputEl' in $$props) $$invalidate(3, inputEl = $$props.inputEl);
    		if ('inputLabelEl' in $$props) $$invalidate(4, inputLabelEl = $$props.inputLabelEl);
    		if ('baseClass' in $$props) $$invalidate(5, baseClass = $$props.baseClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		inputtype,
    		label,
    		size,
    		inputEl,
    		inputLabelEl,
    		baseClass,
    		className,
    		focus_handler,
    		span_binding,
    		input_binding
    	];
    }

    class TextInput extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$D, create_fragment$D, safe_not_equal, {
    			inputtype: 0,
    			label: 1,
    			className: 6,
    			size: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TextInput",
    			options,
    			id: create_fragment$D.name
    		});
    	}

    	get inputtype() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputtype(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/form-elements/TextArea.svelte generated by Svelte v3.42.6 */
    const file$B = "src/components/form-elements/TextArea.svelte";

    // (28:2) {#if label}
    function create_if_block$f(ctx) {
    	let span;
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(/*label*/ ctx[0]);
    			t1 = text(":");
    			attr_dev(span, "class", "hidden");
    			add_location(span, file$B, 28, 4, 998);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			/*span_binding*/ ctx[8](span);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 1) set_data_dev(t0, /*label*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			/*span_binding*/ ctx[8](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(28:2) {#if label}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let div;
    	let t;
    	let textarea;
    	let div_class_value;
    	let mounted;
    	let dispose;
    	let if_block = /*label*/ ctx[0] && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			textarea = element("textarea");
    			attr_dev(textarea, "class", /*baseClass*/ ctx[4]);
    			attr_dev(textarea, "placeholder", /*label*/ ctx[0]);
    			add_location(textarea, file$B, 30, 2, 1073);
    			attr_dev(div, "class", div_class_value = `form-input-container flex flex--column border-radius padding-m--rl ${/*size*/ ctx[1]}`);
    			add_location(div, file$B, 26, 0, 889);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);
    			append_dev(div, textarea);
    			/*textarea_binding*/ ctx[9](textarea);

    			if (!mounted) {
    				dispose = listen_dev(textarea, "focus", /*focus_handler*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*label*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*baseClass*/ 16) {
    				attr_dev(textarea, "class", /*baseClass*/ ctx[4]);
    			}

    			if (dirty & /*label*/ 1) {
    				attr_dev(textarea, "placeholder", /*label*/ ctx[0]);
    			}

    			if (dirty & /*size*/ 2 && div_class_value !== (div_class_value = `form-input-container flex flex--column border-radius padding-m--rl ${/*size*/ ctx[1]}`)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			/*textarea_binding*/ ctx[9](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TextArea', slots, []);
    	let { inputtype = 'textarea' } = $$props;
    	let { label = undefined } = $$props;
    	let { className = undefined } = $$props;
    	let { size = "padding-m--tb" } = $$props;
    	let textareaEl;
    	let textareaLabelEl;
    	let baseClass = `form-input form-input--${inputtype} width-1of1`;
    	if (className) baseClass = `${className} ${baseClass}`;

    	/* focus effect on form elements */
    	onMount(() => {
    		textareaEl.addEventListener('focus', () => {
    			textareaEl.parentElement.setAttribute('data-focus', 'true');
    			const inputLabel = textareaEl.previousElementSibling;
    			inputLabel.classList.remove('hidden');
    		});

    		textareaEl.addEventListener('focusout', () => {
    			textareaEl.parentElement.setAttribute('data-focus', 'false');

    			if (textareaEl.value.length === 0) {
    				textareaLabelEl.classList.add('hidden');
    			}
    		});
    	});

    	const writable_props = ['inputtype', 'label', 'className', 'size'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TextArea> was created with unknown prop '${key}'`);
    	});

    	function focus_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function span_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			textareaLabelEl = $$value;
    			$$invalidate(3, textareaLabelEl);
    		});
    	}

    	function textarea_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			textareaEl = $$value;
    			$$invalidate(2, textareaEl);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('inputtype' in $$props) $$invalidate(5, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(0, label = $$props.label);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		inputtype,
    		label,
    		className,
    		size,
    		textareaEl,
    		textareaLabelEl,
    		baseClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('inputtype' in $$props) $$invalidate(5, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(0, label = $$props.label);
    		if ('className' in $$props) $$invalidate(6, className = $$props.className);
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    		if ('textareaEl' in $$props) $$invalidate(2, textareaEl = $$props.textareaEl);
    		if ('textareaLabelEl' in $$props) $$invalidate(3, textareaLabelEl = $$props.textareaLabelEl);
    		if ('baseClass' in $$props) $$invalidate(4, baseClass = $$props.baseClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		label,
    		size,
    		textareaEl,
    		textareaLabelEl,
    		baseClass,
    		inputtype,
    		className,
    		focus_handler,
    		span_binding,
    		textarea_binding
    	];
    }

    class TextArea extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$C, create_fragment$C, safe_not_equal, {
    			inputtype: 5,
    			label: 0,
    			className: 6,
    			size: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TextArea",
    			options,
    			id: create_fragment$C.name
    		});
    	}

    	get inputtype() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputtype(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/form-elements/FormElement.svelte generated by Svelte v3.42.6 */
    const file$A = "src/components/form-elements/FormElement.svelte";

    // (42:2) <svelte:component this={component} class={className} {size} {label} {inputtype} {group} {value} name={fieldName}>
    function create_default_slot$q(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$q.name,
    		type: "slot",
    		source: "(42:2) <svelte:component this={component} class={className} {size} {label} {inputtype} {group} {value} name={fieldName}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	var switch_value = /*component*/ ctx[7];

    	function switch_props(ctx) {
    		return {
    			props: {
    				class: /*className*/ ctx[1],
    				size: /*size*/ ctx[0],
    				label: /*label*/ ctx[5],
    				inputtype: /*inputtype*/ ctx[4],
    				group: /*group*/ ctx[3],
    				value: /*value*/ ctx[6],
    				name: /*fieldName*/ ctx[2],
    				$$slots: { default: [create_default_slot$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "form-element margin-l--b");
    			add_location(div, file$A, 40, 0, 905);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*className*/ 2) switch_instance_changes.class = /*className*/ ctx[1];
    			if (dirty & /*size*/ 1) switch_instance_changes.size = /*size*/ ctx[0];
    			if (dirty & /*label*/ 32) switch_instance_changes.label = /*label*/ ctx[5];
    			if (dirty & /*inputtype*/ 16) switch_instance_changes.inputtype = /*inputtype*/ ctx[4];
    			if (dirty & /*group*/ 8) switch_instance_changes.group = /*group*/ ctx[3];
    			if (dirty & /*value*/ 64) switch_instance_changes.value = /*value*/ ctx[6];
    			if (dirty & /*fieldName*/ 4) switch_instance_changes.name = /*fieldName*/ ctx[2];

    			if (dirty & /*$$scope*/ 512) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*component*/ ctx[7])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FormElement', slots, ['default']);
    	let { className = undefined } = $$props;
    	let { fieldName = undefined } = $$props;
    	let { group = undefined } = $$props;
    	let { inputtype = 'text' } = $$props;
    	let { label = undefined } = $$props;
    	let { value = '' } = $$props;
    	let { size = 'medium' } = $$props;
    	let component = TextInput;

    	switch (inputtype) {
    		case 'select':
    			component = Select;
    			break;
    		case 'checkbox':
    		case 'radio':
    			component = Checkbox;
    			break;
    		case 'textarea':
    			component = TextArea;
    			break;
    	}

    	switch (size) {
    		case 'small':
    			{
    				size = 'padding-s--tb';
    				break;
    			}
    		case 'medium':
    			{
    				size = 'padding-m--tb';
    				break;
    			}
    		case 'large':
    			{
    				size = 'padding-l--tb';
    				break;
    			}
    	}

    	const writable_props = ['className', 'fieldName', 'group', 'inputtype', 'label', 'value', 'size'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FormElement> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(1, className = $$props.className);
    		if ('fieldName' in $$props) $$invalidate(2, fieldName = $$props.fieldName);
    		if ('group' in $$props) $$invalidate(3, group = $$props.group);
    		if ('inputtype' in $$props) $$invalidate(4, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(5, label = $$props.label);
    		if ('value' in $$props) $$invalidate(6, value = $$props.value);
    		if ('size' in $$props) $$invalidate(0, size = $$props.size);
    		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Checkbox,
    		Select,
    		TextInput,
    		TextArea,
    		className,
    		fieldName,
    		group,
    		inputtype,
    		label,
    		value,
    		size,
    		component
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(1, className = $$props.className);
    		if ('fieldName' in $$props) $$invalidate(2, fieldName = $$props.fieldName);
    		if ('group' in $$props) $$invalidate(3, group = $$props.group);
    		if ('inputtype' in $$props) $$invalidate(4, inputtype = $$props.inputtype);
    		if ('label' in $$props) $$invalidate(5, label = $$props.label);
    		if ('value' in $$props) $$invalidate(6, value = $$props.value);
    		if ('size' in $$props) $$invalidate(0, size = $$props.size);
    		if ('component' in $$props) $$invalidate(7, component = $$props.component);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		size,
    		className,
    		fieldName,
    		group,
    		inputtype,
    		label,
    		value,
    		component,
    		slots,
    		$$scope
    	];
    }

    class FormElement extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$B, create_fragment$B, safe_not_equal, {
    			className: 1,
    			fieldName: 2,
    			group: 3,
    			inputtype: 4,
    			label: 5,
    			value: 6,
    			size: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FormElement",
    			options,
    			id: create_fragment$B.name
    		});
    	}

    	get className() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fieldName() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fieldName(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputtype() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputtype(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<FormElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<FormElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function throttle(callback, wait) {
        let inThrottle;
        return function () {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                callback.apply(context, args);
                inThrottle = true;
                setTimeout(() => (inThrottle = false), wait);
            }
        };
    }

    /* src/components/horizontalScroll/HorizontalScroll.svelte generated by Svelte v3.42.6 */
    const file$z = "src/components/horizontalScroll/HorizontalScroll.svelte";

    // (122:2) <Button on:click={prevScroll} className="horizontal-scroll-nav button-prev bg--white" extension="icon">
    function create_default_slot_1$o(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fa fa-chevron-left");
    			add_location(i, file$z, 122, 4, 3857);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$o.name,
    		type: "slot",
    		source: "(122:2) <Button on:click={prevScroll} className=\\\"horizontal-scroll-nav button-prev bg--white\\\" extension=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (125:2) <Button on:click={nextScroll} className="horizontal-scroll-nav button-next bg--white" extension="icon">
    function create_default_slot$p(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fa fa-chevron-right");
    			add_location(i, file$z, 125, 4, 4012);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$p.name,
    		type: "slot",
    		source: "(125:2) <Button on:click={nextScroll} className=\\\"horizontal-scroll-nav button-next bg--white\\\" extension=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let div1;
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let div0;
    	let current;

    	button0 = new Button({
    			props: {
    				className: "horizontal-scroll-nav button-prev bg--white",
    				extension: "icon",
    				$$slots: { default: [create_default_slot_1$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*prevScroll*/ ctx[3]);

    	button1 = new Button({
    			props: {
    				className: "horizontal-scroll-nav button-next bg--white",
    				extension: "icon",
    				$$slots: { default: [create_default_slot$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*nextScroll*/ ctx[2]);
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", "horizontal-scroll-items flex position-relative");
    			attr_dev(div0, "data-horizontallist", "horizontallist");
    			add_location(div0, file$z, 127, 2, 4060);
    			attr_dev(div1, "class", "horizontal-scroll-container position-relative");
    			add_location(div1, file$z, 120, 0, 3659);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(button0, div1, null);
    			append_dev(div1, t0);
    			mount_component(button1, div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			/*div0_binding*/ ctx[6](div0);
    			/*div1_binding*/ ctx[7](div1);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[8],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(button0);
    			destroy_component(button1);
    			if (default_slot) default_slot.d(detaching);
    			/*div0_binding*/ ctx[6](null);
    			/*div1_binding*/ ctx[7](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('HorizontalScroll', slots, ['default']);
    	let { className = undefined } = $$props;
    	let baseClass = `horizontal-scroll-container position-relative`;
    	if (className) baseClass = `${className} ${baseClass}`;

    	/* Horizontial Scroll elements */
    	let scrollContainer;

    	let scrollItemContainer;
    	let listCurrent = 0;
    	let children;
    	let maxLength;
    	let listLength;

    	function updateDataSet(pos, fromScroll = false) {
    		switch (pos) {
    			case 'neutral':
    				$$invalidate(0, scrollContainer.dataset.atstart = 'false', scrollContainer);
    				$$invalidate(0, scrollContainer.dataset.atend = 'false', scrollContainer);
    				if (fromScroll) listCurrent = 1;
    				break;
    			case 'end':
    				$$invalidate(0, scrollContainer.dataset.atstart = 'false', scrollContainer);
    				$$invalidate(0, scrollContainer.dataset.atend = 'true', scrollContainer);
    				listCurrent = maxLength;
    				break;
    			case 'start':
    				$$invalidate(0, scrollContainer.dataset.atstart = 'true', scrollContainer);
    				$$invalidate(0, scrollContainer.dataset.atend = 'false', scrollContainer);
    				listCurrent = 0;
    				break;
    			case 'disabled':
    				$$invalidate(0, scrollContainer.dataset.atstart = 'true', scrollContainer);
    				$$invalidate(0, scrollContainer.dataset.atend = 'true', scrollContainer);
    				break;
    		}
    	}

    	function updateButtons() {
    		if (listCurrent === 0) {
    			updateDataSet('start');
    		} else if (listCurrent === maxLength) {
    			updateDataSet('end');
    		} else {
    			updateDataSet('neutral');
    		}
    	}

    	function updateButtonsThroughScroll() {
    		const childLeft = children[0].getBoundingClientRect().left;
    		const wrapLeft = scrollItemContainer.getBoundingClientRect().left;
    		const childRight = children[listLength - 1].getBoundingClientRect().right;
    		const wrapRight = scrollItemContainer.getBoundingClientRect().right;
    		const childrenHiddenLeft = childLeft < wrapLeft;
    		const childrenHiddenRight = childRight > wrapRight;

    		if (childrenHiddenLeft && childrenHiddenRight) {
    			updateDataSet('neutral', true);
    		} else if (childrenHiddenLeft) {
    			updateDataSet('end', true);
    		} else if (childrenHiddenRight) {
    			updateDataSet('start', true);
    		} else {
    			updateDataSet('disabled', true);
    		}
    	}

    	/**
     * Advance scroll to make next or previous element visible
     */
    	function scroll(listCurrent) {
    		const newPos = children[listCurrent];

    		scrollItemContainer.scrollTo({
    			behavior: 'smooth',
    			left: newPos.offsetLeft,
    			top: 0
    		});

    		updateButtons();
    	}

    	function nextScroll(_ev) {
    		if (listCurrent !== maxLength) {
    			listCurrent = listCurrent + 1;
    			scroll(listCurrent);
    		}
    	}

    	function prevScroll(_ev) {
    		if (listCurrent !== 0) {
    			listCurrent = listCurrent - 1;
    			scroll(listCurrent);
    		}
    	}

    	onMount(() => {
    		scrollItemContainer.addEventListener('wheel', throttle(
    			() => {
    				updateButtonsThroughScroll();
    			},
    			150
    		));
    	});

    	afterUpdate(() => {
    		if (listLength === scrollItemContainer.children.length) return;
    		children = scrollItemContainer.children;
    		listLength = children.length;
    		const containerBBox = scrollContainer.getBoundingClientRect();

    		/**
     * Find how many visible elements we have
     */
    		let visibleChildren = Array.from(children).filter(child => child.getBoundingClientRect().left >= containerBBox.left && child.getBoundingClientRect().right <= containerBBox.right).length;

    		maxLength = listLength - visibleChildren;

    		if (maxLength) {
    			// Some children not visible - enable scroling
    			updateButtons();
    		} else {
    			updateDataSet('disabled');
    		}
    	});

    	const writable_props = ['className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<HorizontalScroll> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			scrollItemContainer = $$value;
    			$$invalidate(1, scrollItemContainer);
    		});
    	}

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			scrollContainer = $$value;
    			$$invalidate(0, scrollContainer);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		afterUpdate,
    		onMount,
    		throttle,
    		Button,
    		className,
    		baseClass,
    		scrollContainer,
    		scrollItemContainer,
    		listCurrent,
    		children,
    		maxLength,
    		listLength,
    		updateDataSet,
    		updateButtons,
    		updateButtonsThroughScroll,
    		scroll,
    		nextScroll,
    		prevScroll
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('baseClass' in $$props) baseClass = $$props.baseClass;
    		if ('scrollContainer' in $$props) $$invalidate(0, scrollContainer = $$props.scrollContainer);
    		if ('scrollItemContainer' in $$props) $$invalidate(1, scrollItemContainer = $$props.scrollItemContainer);
    		if ('listCurrent' in $$props) listCurrent = $$props.listCurrent;
    		if ('children' in $$props) children = $$props.children;
    		if ('maxLength' in $$props) maxLength = $$props.maxLength;
    		if ('listLength' in $$props) listLength = $$props.listLength;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		scrollContainer,
    		scrollItemContainer,
    		nextScroll,
    		prevScroll,
    		className,
    		slots,
    		div0_binding,
    		div1_binding,
    		$$scope
    	];
    }

    class HorizontalScroll extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, { className: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HorizontalScroll",
    			options,
    			id: create_fragment$A.name
    		});
    	}

    	get className() {
    		throw new Error("<HorizontalScroll>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<HorizontalScroll>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/spinner/Spinner.svelte generated by Svelte v3.42.6 */

    const file$y = "src/components/spinner/Spinner.svelte";

    // (4:0) {#if isLoading}
    function create_if_block$e(ctx) {
    	let div;
    	let i0;
    	let t0;
    	let i1;
    	let t1;
    	let i2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			i0 = element("i");
    			t0 = space();
    			i1 = element("i");
    			t1 = space();
    			i2 = element("i");
    			attr_dev(i0, "class", "fas fa-circle bounce bounce1");
    			add_location(i0, file$y, 5, 4, 120);
    			attr_dev(i1, "class", "fas fa-circle bounce bounce2");
    			add_location(i1, file$y, 6, 4, 167);
    			attr_dev(i2, "class", "fas fa-circle bounce bounce3");
    			add_location(i2, file$y, 7, 4, 214);
    			attr_dev(div, "class", "loader flex flex--center");
    			add_location(div, file$y, 4, 2, 77);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, i0);
    			append_dev(div, t0);
    			append_dev(div, i1);
    			append_dev(div, t1);
    			append_dev(div, i2);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(4:0) {#if isLoading}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let if_block_anchor;
    	let if_block = /*isLoading*/ ctx[0] && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isLoading*/ ctx[0]) {
    				if (if_block) ; else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Spinner', slots, []);
    	let { isLoading = false } = $$props;
    	const writable_props = ['isLoading'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Spinner> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('isLoading' in $$props) $$invalidate(0, isLoading = $$props.isLoading);
    	};

    	$$self.$capture_state = () => ({ isLoading });

    	$$self.$inject_state = $$props => {
    		if ('isLoading' in $$props) $$invalidate(0, isLoading = $$props.isLoading);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isLoading];
    }

    class Spinner extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, { isLoading: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Spinner",
    			options,
    			id: create_fragment$z.name
    		});
    	}

    	get isLoading() {
    		throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isLoading(value) {
    		throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/tabs/Tabs.svelte generated by Svelte v3.42.6 */
    const file$x = "src/components/tabs/Tabs.svelte";

    function create_fragment$y(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", /*className*/ ctx[0]);
    			add_location(div, file$x, 43, 0, 1395);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*className*/ 1) {
    				attr_dev(div, "class", /*className*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const BUTTONS = {};

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tabs', slots, ['default']);
    	const selectedId = writable(0);
    	const buttons = [];
    	const panels = [];
    	const selectedButton = writable(null);
    	const selectedPanel = writable(null);

    	selectedId.subscribe(i => {
    		selectedButton.set(buttons[i]);
    		selectedPanel.set(panels[i]);
    	});

    	setContext(BUTTONS, {
    		registerTab: button => {
    			buttons.push(button);
    			selectedButton.update(current => current || button);

    			onDestroy(() => {
    				const i = buttons.indexOf(button);
    				buttons.splice(i, 1);

    				selectedButton.update(current => current === button
    				? buttons[i] || buttons[buttons.length - 1]
    				: current);
    			});
    		},
    		registerPanel: panel => {
    			panels.push(panel);
    			selectedPanel.update(current => current || panel);

    			onDestroy(() => {
    				const i = panels.indexOf(panel);
    				panels.splice(i, 1);

    				selectedPanel.update(current => current === panel
    				? panels[i] || panels[panels.length - 1]
    				: current);
    			});
    		},
    		selectButton: button => {
    			const i = buttons.indexOf(button);
    			selectedId.set(i);
    		},
    		selectedButton,
    		selectedPanel
    	});

    	let { className = undefined } = $$props;
    	const writable_props = ['className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tabs> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(0, className = $$props.className);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		BUTTONS,
    		setContext,
    		onDestroy,
    		writable,
    		selectedId,
    		buttons,
    		panels,
    		selectedButton,
    		selectedPanel,
    		className
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(0, className = $$props.className);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [className, selectedId, $$scope, slots];
    }

    class Tabs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, { selectedId: 1, className: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabs",
    			options,
    			id: create_fragment$y.name
    		});
    	}

    	get selectedId() {
    		return this.$$.ctx[1];
    	}

    	set selectedId(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/tabs/Tab.svelte generated by Svelte v3.42.6 */
    const file$w = "src/components/tabs/Tab.svelte";

    function create_fragment$x(ctx) {
    	let button_1;
    	let button_1_data_selected_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

    	const block = {
    		c: function create() {
    			button_1 = element("button");
    			if (default_slot) default_slot.c();
    			attr_dev(button_1, "class", /*cssClass*/ ctx[0]);
    			attr_dev(button_1, "data-selected", button_1_data_selected_value = /*$selectedButton*/ ctx[1] === /*button*/ ctx[2]);
    			add_location(button_1, file$w, 10, 0, 349);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button_1, anchor);

    			if (default_slot) {
    				default_slot.m(button_1, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button_1, "click", /*click_handler*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 1) {
    				attr_dev(button_1, "class", /*cssClass*/ ctx[0]);
    			}

    			if (!current || dirty & /*$selectedButton*/ 2 && button_1_data_selected_value !== (button_1_data_selected_value = /*$selectedButton*/ ctx[1] === /*button*/ ctx[2])) {
    				attr_dev(button_1, "data-selected", button_1_data_selected_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button_1);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let cssClass;
    	let $selectedButton;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tab', slots, ['default']);
    	const button = {};
    	const { registerTab, selectButton, selectedButton } = getContext(BUTTONS);
    	validate_store(selectedButton, 'selectedButton');
    	component_subscribe($$self, selectedButton, value => $$invalidate(1, $selectedButton = value));
    	registerTab(button);
    	let { className = undefined } = $$props;
    	let baseClass = `button`;
    	const writable_props = ['className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tab> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => selectButton(button);

    	$$self.$$set = $$props => {
    		if ('className' in $$props) $$invalidate(5, className = $$props.className);
    		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		BUTTONS,
    		button,
    		registerTab,
    		selectButton,
    		selectedButton,
    		className,
    		baseClass,
    		cssClass,
    		$selectedButton
    	});

    	$$self.$inject_state = $$props => {
    		if ('className' in $$props) $$invalidate(5, className = $$props.className);
    		if ('baseClass' in $$props) $$invalidate(10, baseClass = $$props.baseClass);
    		if ('cssClass' in $$props) $$invalidate(0, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 32) {
    			$$invalidate(0, cssClass = className ? `${baseClass} ${className}` : baseClass);
    		}
    	};

    	return [
    		cssClass,
    		$selectedButton,
    		button,
    		selectButton,
    		selectedButton,
    		className,
    		$$scope,
    		slots,
    		click_handler
    	];
    }

    class Tab extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, { className: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tab",
    			options,
    			id: create_fragment$x.name
    		});
    	}

    	get className() {
    		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/tabs/TabContent.svelte generated by Svelte v3.42.6 */

    // (8:0) {#if $selectedPanel === panel}
    function create_if_block$d(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(8:0) {#if $selectedPanel === panel}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$selectedPanel*/ ctx[0] === /*panel*/ ctx[1] && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$selectedPanel*/ ctx[0] === /*panel*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$selectedPanel*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let $selectedPanel;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TabContent', slots, ['default']);
    	const panel = {};
    	const { registerPanel, selectedPanel } = getContext(BUTTONS);
    	validate_store(selectedPanel, 'selectedPanel');
    	component_subscribe($$self, selectedPanel, value => $$invalidate(0, $selectedPanel = value));
    	registerPanel(panel);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TabContent> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		BUTTONS,
    		panel,
    		registerPanel,
    		selectedPanel,
    		$selectedPanel
    	});

    	return [$selectedPanel, panel, selectedPanel, $$scope, slots];
    }

    class TabContent extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabContent",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    /* src/components/tabs/TabList.svelte generated by Svelte v3.42.6 */

    const file$v = "src/components/tabs/TabList.svelte";

    function create_fragment$v(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", /*cssClass*/ ctx[0]);
    			add_location(div, file$v, 14, 0, 357);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 1) {
    				attr_dev(div, "class", /*cssClass*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let cssClass;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TabList', slots, ['default']);
    	let { type = 'tabs' } = $$props;
    	let { className = undefined } = $$props;
    	let baseClass = '';

    	switch (type) {
    		case 'tabs':
    			baseClass = 'tabs';
    			break;
    		case 'pillnavigation':
    			baseClass = 'pillnavigation toggle toggle--buttons';
    			break;
    	}

    	const writable_props = ['type', 'className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TabList> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('type' in $$props) $$invalidate(1, type = $$props.type);
    		if ('className' in $$props) $$invalidate(2, className = $$props.className);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ type, className, baseClass, cssClass });

    	$$self.$inject_state = $$props => {
    		if ('type' in $$props) $$invalidate(1, type = $$props.type);
    		if ('className' in $$props) $$invalidate(2, className = $$props.className);
    		if ('baseClass' in $$props) $$invalidate(3, baseClass = $$props.baseClass);
    		if ('cssClass' in $$props) $$invalidate(0, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, baseClass*/ 12) {
    			$$invalidate(0, cssClass = className ? `${baseClass} ${className}` : baseClass);
    		}
    	};

    	return [cssClass, type, className, baseClass, $$scope, slots];
    }

    class TabList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, { type: 1, className: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabList",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get type() {
    		throw new Error("<TabList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<TabList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<TabList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<TabList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/tooltip/Tooltip.svelte generated by Svelte v3.42.6 */

    const file$u = "src/components/tooltip/Tooltip.svelte";

    function create_fragment$u(ctx) {
    	let label;
    	let input;
    	let t0;
    	let div0;
    	let i0;
    	let i0_class_value;
    	let t1;
    	let div2;
    	let i1;
    	let i1_class_value;
    	let t2;
    	let div1;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			label = element("label");
    			input = element("input");
    			t0 = space();
    			div0 = element("div");
    			i0 = element("i");
    			t1 = space();
    			div2 = element("div");
    			i1 = element("i");
    			t2 = space();
    			div1 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(input, "type", "checkbox");
    			input.hidden = true;
    			attr_dev(input, "class", "tooltip-input");
    			add_location(input, file$u, 10, 2, 287);
    			attr_dev(i0, "class", i0_class_value = "tooltip-toggle fas fa-" + /*iconOff*/ ctx[1]);
    			add_location(i0, file$u, 12, 4, 374);
    			attr_dev(div0, "class", "tooltip-off");
    			add_location(div0, file$u, 11, 2, 344);
    			attr_dev(i1, "class", i1_class_value = "tooltip-toggle fas fa-" + /*iconOn*/ ctx[0]);
    			add_location(i1, file$u, 15, 4, 460);
    			attr_dev(div1, "class", "padding-s");
    			add_location(div1, file$u, 16, 4, 509);
    			attr_dev(div2, "class", "tooltip-on");
    			add_location(div2, file$u, 14, 2, 431);
    			attr_dev(label, "class", /*cssClass*/ ctx[2]);
    			add_location(label, file$u, 9, 0, 260);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, input);
    			append_dev(label, t0);
    			append_dev(label, div0);
    			append_dev(div0, i0);
    			append_dev(label, t1);
    			append_dev(label, div2);
    			append_dev(div2, i1);
    			append_dev(div2, t2);
    			append_dev(div2, div1);

    			if (default_slot) {
    				default_slot.m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*iconOff*/ 2 && i0_class_value !== (i0_class_value = "tooltip-toggle fas fa-" + /*iconOff*/ ctx[1])) {
    				attr_dev(i0, "class", i0_class_value);
    			}

    			if (!current || dirty & /*iconOn*/ 1 && i1_class_value !== (i1_class_value = "tooltip-toggle fas fa-" + /*iconOn*/ ctx[0])) {
    				attr_dev(i1, "class", i1_class_value);
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*cssClass*/ 4) {
    				attr_dev(label, "class", /*cssClass*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tooltip', slots, ['default']);
    	let { iconOn = 'times' } = $$props;
    	let { iconOff = 'question' } = $$props;
    	let { position = 'left' } = $$props;
    	let { className = undefined } = $$props;
    	let cssClass = `tooltip tooltip--${position}`;
    	if (className) cssClass = `${cssClass} ${className}`;
    	const writable_props = ['iconOn', 'iconOff', 'position', 'className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tooltip> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('iconOn' in $$props) $$invalidate(0, iconOn = $$props.iconOn);
    		if ('iconOff' in $$props) $$invalidate(1, iconOff = $$props.iconOff);
    		if ('position' in $$props) $$invalidate(3, position = $$props.position);
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		iconOn,
    		iconOff,
    		position,
    		className,
    		cssClass
    	});

    	$$self.$inject_state = $$props => {
    		if ('iconOn' in $$props) $$invalidate(0, iconOn = $$props.iconOn);
    		if ('iconOff' in $$props) $$invalidate(1, iconOff = $$props.iconOff);
    		if ('position' in $$props) $$invalidate(3, position = $$props.position);
    		if ('className' in $$props) $$invalidate(4, className = $$props.className);
    		if ('cssClass' in $$props) $$invalidate(2, cssClass = $$props.cssClass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [iconOn, iconOff, cssClass, position, className, $$scope, slots];
    }

    class Tooltip extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$u, create_fragment$u, safe_not_equal, {
    			iconOn: 0,
    			iconOff: 1,
    			position: 3,
    			className: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tooltip",
    			options,
    			id: create_fragment$u.name
    		});
    	}

    	get iconOn() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconOn(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconOff() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconOff(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get position() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set position(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* docs_src/components/Accordion.svelte generated by Svelte v3.42.6 */
    const file$t = "docs_src/components/Accordion.svelte";

    // (16:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$a(ctx) {
    	let prism;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t13;
    	let td3;
    	let t14;
    	let badge;
    	let t15;
    	let t16;
    	let tr2;
    	let th4;
    	let t18;
    	let tr3;
    	let td4;
    	let t20;
    	let td5;
    	let t22;
    	let td6;
    	let t23;
    	let td7;
    	let t24;
    	let tr4;
    	let td8;
    	let t26;
    	let td9;
    	let t28;
    	let td10;
    	let t29;
    	let td11;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_4$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	badge = new Badge({
    			props: {
    				type: "secondary",
    				extension: "small",
    				$$slots: { default: [create_default_slot_3$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "tabs";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "ITabsConfig[]";
    			t12 = space();
    			td2 = element("td");
    			t13 = space();
    			td3 = element("td");
    			t14 = text("Array of tab data. See ");
    			create_component(badge.$$.fragment);
    			t15 = text(" props below for details");
    			t16 = space();
    			tr2 = element("tr");
    			th4 = element("th");
    			th4.textContent = "Tab";
    			t18 = space();
    			tr3 = element("tr");
    			td4 = element("td");
    			td4.textContent = "content";
    			t20 = space();
    			td5 = element("td");
    			td5.textContent = "string / html";
    			t22 = space();
    			td6 = element("td");
    			t23 = space();
    			td7 = element("td");
    			t24 = space();
    			tr4 = element("tr");
    			td8 = element("td");
    			td8.textContent = "title";
    			t26 = space();
    			td9 = element("td");
    			td9.textContent = "string";
    			t28 = space();
    			td10 = element("td");
    			t29 = space();
    			td11 = element("td");
    			add_location(th0, file$t, 23, 8, 577);
    			add_location(th1, file$t, 24, 8, 604);
    			add_location(th2, file$t, 25, 8, 626);
    			add_location(th3, file$t, 26, 8, 657);
    			add_location(tr0, file$t, 22, 6, 564);
    			add_location(thead, file$t, 21, 4, 550);
    			add_location(td0, file$t, 31, 8, 734);
    			add_location(td1, file$t, 32, 8, 756);
    			add_location(td2, file$t, 33, 8, 787);
    			add_location(td3, file$t, 34, 8, 802);
    			add_location(tr1, file$t, 30, 6, 721);
    			attr_dev(th4, "colspan", "4");
    			add_location(th4, file$t, 37, 8, 943);
    			add_location(tr2, file$t, 36, 6, 930);
    			add_location(td4, file$t, 40, 8, 999);
    			add_location(td5, file$t, 41, 8, 1024);
    			add_location(td6, file$t, 42, 8, 1055);
    			add_location(td7, file$t, 43, 8, 1070);
    			add_location(tr3, file$t, 39, 6, 986);
    			add_location(td8, file$t, 46, 8, 1108);
    			add_location(td9, file$t, 47, 8, 1131);
    			add_location(td10, file$t, 48, 8, 1155);
    			add_location(td11, file$t, 49, 8, 1170);
    			add_location(tr4, file$t, 45, 6, 1095);
    			add_location(tbody, file$t, 29, 4, 707);
    			attr_dev(table, "class", "table");
    			add_location(table, file$t, 20, 2, 524);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			append_dev(td3, t14);
    			mount_component(badge, td3, null);
    			append_dev(td3, t15);
    			append_dev(tbody, t16);
    			append_dev(tbody, tr2);
    			append_dev(tr2, th4);
    			append_dev(tbody, t18);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td4);
    			append_dev(tr3, t20);
    			append_dev(tr3, td5);
    			append_dev(tr3, t22);
    			append_dev(tr3, td6);
    			append_dev(tr3, t23);
    			append_dev(tr3, td7);
    			append_dev(tbody, t24);
    			append_dev(tbody, tr4);
    			append_dev(tr4, td8);
    			append_dev(tr4, t26);
    			append_dev(tr4, td9);
    			append_dev(tr4, t28);
    			append_dev(tr4, td10);
    			append_dev(tr4, t29);
    			append_dev(tr4, td11);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			transition_in(badge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			transition_out(badge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    			destroy_component(badge);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(16:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (17:2) <Prism language="js">
    function create_default_slot_4$g(ctx) {
    	let t_value = `import { Accordion } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$g.name,
    		type: "slot",
    		source: "(17:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (35:35) <Badge type="secondary" extension="small">
    function create_default_slot_3$h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Tab");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$h.name,
    		type: "slot",
    		source: "(35:35) <Badge type=\\\"secondary\\\" extension=\\\"small\\\">",
    		ctx
    	});

    	return block;
    }

    // (62:0) {:else}
    function create_else_block$c(ctx) {
    	let prism0;
    	let t;
    	let prism1;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_1$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism0.$$.fragment);
    			t = space();
    			create_component(prism1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(prism1, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(prism1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$c.name,
    		type: "else",
    		source: "(62:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (58:0) {#if $sourceType === 'svelte'}
    function create_if_block$c(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(58:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (63:2) <Prism language="html">
    function create_default_slot_2$m(ctx) {
    	let t_value = `<div class="accordion card-mode padding-l ff-secondary width-1of1">
  <div class="accordion-tab margin-m--b">
    <div class="accordion-header flex flex-justify--between flex-align--center padding-m">
      <span class="fontweight-bold fontsize-medium">Tab 1</span>
      <i class="fas fa-chevron-down" />
    </div>
    <div class="accordion-body padding-m padding-l--rl fontsize-small">
      Content 1
    </div>
  </div>
  <div class="accordion-tab margin-m--b">
    <div class="accordion-header flex flex-justify--between flex-align--center padding-m">
      <span class="fontweight-bold fontsize-medium">Tab 2</span>
      <i class="fas fa-chevron-down" />
    </div>
    <div class="accordion-body padding-m padding-l--rl fontsize-small">
      Content 2
    </div>
  </div>
  <div class="accordion-tab margin-m--b">
    <div class="accordion-header flex flex-justify--between flex-align--center padding-m">
      <span class="fontweight-bold fontsize-medium">Tab 3</span>
      <i class="fas fa-chevron-down" />
    </div>
    <div class="accordion-body padding-m padding-l--rl fontsize-small">
      Content 3
    </div>
  </div>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$m.name,
    		type: "slot",
    		source: "(63:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (95:2) <Prism language="js">
    function create_default_slot_1$n(ctx) {
    	let t_value = `const accordions = document.querySelectorAll(".accordion");
for (const accordion of accordions) {
  const tabs = accordion.querySelectorAll(".accordion-tab");
  for (const tab of tabs) {
    const head = tab.querySelector(".accordion-header");
    head.addEventListener('click', () => {
      for (const othertab of tabs) {
        if (othertab !== tab) {
          othertab.classList.remove('accordion-expanded');
        }
      }
      tab.classList.toggle('accordion-expanded');
    });
  }
}` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$n.name,
    		type: "slot",
    		source: "(95:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (59:2) <Prism language="html">
    function create_default_slot$o(ctx) {
    	let t_value = `<Accordion {tabs} />` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$o.name,
    		type: "slot",
    		source: "(59:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let h1;
    	let t1;
    	let t2;
    	let accordion;
    	let t3;
    	let current_block_type_index;
    	let if_block1;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*$sourceType*/ ctx[0] === 'svelte' && create_if_block_1$a(ctx);

    	accordion = new Accordion({
    			props: { tabs: /*tabs*/ ctx[1] },
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block$c, create_else_block$c];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Accordion";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			create_component(accordion.$$.fragment);
    			t3 = space();
    			if_block1.c();
    			if_block1_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$t, 13, 0, 352);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(accordion, target, anchor);
    			insert_dev(target, t3, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$sourceType*/ ctx[0] === 'svelte') {
    				if (if_block0) {
    					if (dirty & /*$sourceType*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$a(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(accordion.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(accordion.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(accordion, detaching);
    			if (detaching) detach_dev(t3);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Accordion', slots, []);
    	const tabs = [];

    	for (let i = 0; i < 3; i++) {
    		tabs.push({
    			title: `Tab ${i + 1}`,
    			content: '<h2>Test af h2</h2>' + rdmParagraphs()
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Accordion> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		rdmParagraphs,
    		sourceType,
    		Accordion,
    		Badge,
    		tabs,
    		$sourceType
    	});

    	return [$sourceType, tabs];
    }

    class Accordion_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Accordion_1",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    /* docs_src/components/ArticleCard.svelte generated by Svelte v3.42.6 */
    const file$s = "docs_src/components/ArticleCard.svelte";

    // (165:0) {:else}
    function create_else_block$b(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "ArticleCard er en ren Svelte component.";
    			add_location(p, file$s, 165, 2, 4011);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(165:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (9:0) {#if $sourceType === 'svelte'}
    function create_if_block$b(ctx) {
    	let prism0;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t13;
    	let td3;
    	let t14;
    	let tr2;
    	let td4;
    	let t16;
    	let td5;
    	let t18;
    	let td6;
    	let t19;
    	let td7;
    	let t20;
    	let em;
    	let t22;
    	let tr3;
    	let td8;
    	let t24;
    	let td9;
    	let t26;
    	let td10;
    	let t27;
    	let td11;
    	let t29;
    	let tr4;
    	let td12;
    	let t31;
    	let td13;
    	let t33;
    	let td14;
    	let t35;
    	let td15;
    	let t37;
    	let tr5;
    	let td16;
    	let t39;
    	let td17;
    	let t41;
    	let td18;
    	let t43;
    	let td19;
    	let t45;
    	let tr6;
    	let td20;
    	let t47;
    	let td21;
    	let t49;
    	let td22;
    	let t51;
    	let td23;
    	let t52;
    	let tr7;
    	let td24;
    	let t54;
    	let td25;
    	let t56;
    	let td26;
    	let t58;
    	let td27;
    	let t60;
    	let tr8;
    	let td28;
    	let t62;
    	let td29;
    	let t64;
    	let td30;
    	let t66;
    	let td31;
    	let t67;
    	let code;
    	let t69;
    	let t70;
    	let tr9;
    	let td32;
    	let t72;
    	let td33;
    	let t74;
    	let td34;
    	let t75;
    	let td35;
    	let t76;
    	let badge0;
    	let t77;
    	let t78;
    	let tr10;
    	let td36;
    	let t80;
    	let td37;
    	let t82;
    	let td38;
    	let t83;
    	let td39;
    	let t85;
    	let tr11;
    	let td40;
    	let t87;
    	let td41;
    	let t89;
    	let td42;
    	let t90;
    	let td43;
    	let t91;
    	let tr12;
    	let td44;
    	let t93;
    	let td45;
    	let t95;
    	let td46;
    	let t96;
    	let td47;
    	let t98;
    	let tr13;
    	let td48;
    	let t100;
    	let td49;
    	let t102;
    	let td50;
    	let t104;
    	let td51;
    	let t105;
    	let tr14;
    	let td52;
    	let t107;
    	let td53;
    	let t109;
    	let td54;
    	let t110;
    	let td55;
    	let t112;
    	let tr15;
    	let th4;
    	let t114;
    	let tr16;
    	let td56;
    	let t116;
    	let td57;
    	let t118;
    	let td58;
    	let t119;
    	let td59;
    	let t120;
    	let tr17;
    	let td60;
    	let t122;
    	let td61;
    	let t124;
    	let td62;
    	let t125;
    	let td63;
    	let t126;
    	let tr18;
    	let td64;
    	let t127;
    	let badge1;
    	let t128;
    	let td65;
    	let t130;
    	let td66;
    	let t131;
    	let td67;
    	let t132;
    	let tr19;
    	let td68;
    	let t134;
    	let td69;
    	let t136;
    	let td70;
    	let t137;
    	let td71;
    	let t138;
    	let articlecard0;
    	let t139;
    	let prism1;
    	let t140;
    	let h30;
    	let t142;
    	let articlecard1;
    	let t143;
    	let articlecard2;
    	let t144;
    	let prism2;
    	let t145;
    	let h31;
    	let t147;
    	let articlecard3;
    	let t148;
    	let articlecard4;
    	let t149;
    	let articlecard5;
    	let t150;
    	let prism3;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_5$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	badge0 = new Badge({
    			props: {
    				type: "secondary",
    				extension: "small",
    				$$slots: { default: [create_default_slot_4$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	badge1 = new Badge({
    			props: {
    				type: "primary",
    				extension: "small",
    				$$slots: { default: [create_default_slot_3$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const articlecard0_spread_levels = [rdmArticleData()];
    	let articlecard0_props = {};

    	for (let i = 0; i < articlecard0_spread_levels.length; i += 1) {
    		articlecard0_props = assign(articlecard0_props, articlecard0_spread_levels[i]);
    	}

    	articlecard0 = new ArticleCard({
    			props: articlecard0_props,
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const articlecard1_spread_levels = [
    		{ className: "margin-m--b" },
    		{ cardType: "small-media" },
    		rdmArticleData(250, 120)
    	];

    	let articlecard1_props = {};

    	for (let i = 0; i < articlecard1_spread_levels.length; i += 1) {
    		articlecard1_props = assign(articlecard1_props, articlecard1_spread_levels[i]);
    	}

    	articlecard1 = new ArticleCard({
    			props: articlecard1_props,
    			$$inline: true
    		});

    	const articlecard2_spread_levels = [{ cardType: "small-media--reverse" }, rdmArticleData(250, 120)];
    	let articlecard2_props = {};

    	for (let i = 0; i < articlecard2_spread_levels.length; i += 1) {
    		articlecard2_props = assign(articlecard2_props, articlecard2_spread_levels[i]);
    	}

    	articlecard2 = new ArticleCard({
    			props: articlecard2_props,
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	articlecard3 = new ArticleCard({
    			props: { loading: true, title: "" },
    			$$inline: true
    		});

    	articlecard4 = new ArticleCard({
    			props: {
    				loading: true,
    				cardType: "small-media",
    				title: ""
    			},
    			$$inline: true
    		});

    	articlecard5 = new ArticleCard({
    			props: {
    				loading: true,
    				cardType: "small-media--reverse",
    				title: ""
    			},
    			$$inline: true
    		});

    	prism3 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism0.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "className";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "string";
    			t12 = space();
    			td2 = element("td");
    			t13 = space();
    			td3 = element("td");
    			t14 = space();
    			tr2 = element("tr");
    			td4 = element("td");
    			td4.textContent = "colorClass";
    			t16 = space();
    			td5 = element("td");
    			td5.textContent = "string";
    			t18 = space();
    			td6 = element("td");
    			t19 = space();
    			td7 = element("td");
    			t20 = text("EB color ");
    			em = element("em");
    			em.textContent = "(e.g. sport)";
    			t22 = space();
    			tr3 = element("tr");
    			td8 = element("td");
    			td8.textContent = "src";
    			t24 = space();
    			td9 = element("td");
    			td9.textContent = "string";
    			t26 = space();
    			td10 = element("td");
    			t27 = space();
    			td11 = element("td");
    			td11.textContent = "Converts the ArticleCard into a clickable link";
    			t29 = space();
    			tr4 = element("tr");
    			td12 = element("td");
    			td12.textContent = "breaking";
    			t31 = space();
    			td13 = element("td");
    			td13.textContent = "boolean";
    			t33 = space();
    			td14 = element("td");
    			td14.textContent = "false";
    			t35 = space();
    			td15 = element("td");
    			td15.textContent = "Force breaking color";
    			t37 = space();
    			tr5 = element("tr");
    			td16 = element("td");
    			td16.textContent = "update";
    			t39 = space();
    			td17 = element("td");
    			td17.textContent = "boolean";
    			t41 = space();
    			td18 = element("td");
    			td18.textContent = "false";
    			t43 = space();
    			td19 = element("td");
    			td19.textContent = "Add update icon to media";
    			t45 = space();
    			tr6 = element("tr");
    			td20 = element("td");
    			td20.textContent = "premium";
    			t47 = space();
    			td21 = element("td");
    			td21.textContent = "boolean";
    			t49 = space();
    			td22 = element("td");
    			td22.textContent = "false";
    			t51 = space();
    			td23 = element("td");
    			t52 = space();
    			tr7 = element("tr");
    			td24 = element("td");
    			td24.textContent = "loading";
    			t54 = space();
    			td25 = element("td");
    			td25.textContent = "boolean";
    			t56 = space();
    			td26 = element("td");
    			td26.textContent = "false";
    			t58 = space();
    			td27 = element("td");
    			td27.textContent = "Converts the ArticleCard into a loading placeholder";
    			t60 = space();
    			tr8 = element("tr");
    			td28 = element("td");
    			td28.textContent = "maxLines";
    			t62 = space();
    			td29 = element("td");
    			td29.textContent = "number";
    			t64 = space();
    			td30 = element("td");
    			td30.textContent = "4";
    			t66 = space();
    			td31 = element("td");
    			t67 = text("Sets the value of ");
    			code = element("code");
    			code.textContent = "--max-lines";
    			t69 = text(" if truncate is enabled");
    			t70 = space();
    			tr9 = element("tr");
    			td32 = element("td");
    			td32.textContent = "media";
    			t72 = space();
    			td33 = element("td");
    			td33.textContent = "IMediaOptions";
    			t74 = space();
    			td34 = element("td");
    			t75 = space();
    			td35 = element("td");
    			t76 = text("Adds a image, see ");
    			create_component(badge0.$$.fragment);
    			t77 = text(" props below for details");
    			t78 = space();
    			tr10 = element("tr");
    			td36 = element("td");
    			td36.textContent = "section";
    			t80 = space();
    			td37 = element("td");
    			td37.textContent = "string";
    			t82 = space();
    			td38 = element("td");
    			t83 = space();
    			td39 = element("td");
    			td39.textContent = "Displays the section meta with a tag icon";
    			t85 = space();
    			tr11 = element("tr");
    			td40 = element("td");
    			td40.textContent = "style";
    			t87 = space();
    			td41 = element("td");
    			td41.textContent = "string";
    			t89 = space();
    			td42 = element("td");
    			t90 = space();
    			td43 = element("td");
    			t91 = space();
    			tr12 = element("tr");
    			td44 = element("td");
    			td44.textContent = "published";
    			t93 = space();
    			td45 = element("td");
    			td45.textContent = "date string";
    			t95 = space();
    			td46 = element("td");
    			t96 = space();
    			td47 = element("td");
    			td47.textContent = "Displays relative time meta with a icon";
    			t98 = space();
    			tr13 = element("tr");
    			td48 = element("td");
    			td48.textContent = "truncateTitle";
    			t100 = space();
    			td49 = element("td");
    			td49.textContent = "boolean";
    			t102 = space();
    			td50 = element("td");
    			td50.textContent = "false";
    			t104 = space();
    			td51 = element("td");
    			t105 = space();
    			tr14 = element("tr");
    			td52 = element("td");
    			td52.textContent = "cardType";
    			t107 = space();
    			td53 = element("td");
    			td53.textContent = "'mode' | 'small-media' | 'small-media--reverse'";
    			t109 = space();
    			td54 = element("td");
    			t110 = space();
    			td55 = element("td");
    			td55.textContent = "Display types. See examples below";
    			t112 = space();
    			tr15 = element("tr");
    			th4 = element("th");
    			th4.textContent = "Media";
    			t114 = space();
    			tr16 = element("tr");
    			td56 = element("td");
    			td56.textContent = "className";
    			t116 = space();
    			td57 = element("td");
    			td57.textContent = "string";
    			t118 = space();
    			td58 = element("td");
    			t119 = space();
    			td59 = element("td");
    			t120 = space();
    			tr17 = element("tr");
    			td60 = element("td");
    			td60.textContent = "height";
    			t122 = space();
    			td61 = element("td");
    			td61.textContent = "string";
    			t124 = space();
    			td62 = element("td");
    			t125 = space();
    			td63 = element("td");
    			t126 = space();
    			tr18 = element("tr");
    			td64 = element("td");
    			t127 = text("src ");
    			create_component(badge1.$$.fragment);
    			t128 = space();
    			td65 = element("td");
    			td65.textContent = "string";
    			t130 = space();
    			td66 = element("td");
    			t131 = space();
    			td67 = element("td");
    			t132 = space();
    			tr19 = element("tr");
    			td68 = element("td");
    			td68.textContent = "width";
    			t134 = space();
    			td69 = element("td");
    			td69.textContent = "string";
    			t136 = space();
    			td70 = element("td");
    			t137 = space();
    			td71 = element("td");
    			t138 = space();
    			create_component(articlecard0.$$.fragment);
    			t139 = space();
    			create_component(prism1.$$.fragment);
    			t140 = space();
    			h30 = element("h3");
    			h30.textContent = "Small-media";
    			t142 = space();
    			create_component(articlecard1.$$.fragment);
    			t143 = space();
    			create_component(articlecard2.$$.fragment);
    			t144 = space();
    			create_component(prism2.$$.fragment);
    			t145 = space();
    			h31 = element("h3");
    			h31.textContent = "Loading placeholder";
    			t147 = space();
    			create_component(articlecard3.$$.fragment);
    			t148 = space();
    			create_component(articlecard4.$$.fragment);
    			t149 = space();
    			create_component(articlecard5.$$.fragment);
    			t150 = space();
    			create_component(prism3.$$.fragment);
    			add_location(th0, file$s, 16, 8, 423);
    			add_location(th1, file$s, 17, 8, 450);
    			add_location(th2, file$s, 18, 8, 472);
    			add_location(th3, file$s, 19, 8, 503);
    			add_location(tr0, file$s, 15, 6, 410);
    			add_location(thead, file$s, 14, 4, 396);
    			add_location(td0, file$s, 24, 8, 580);
    			add_location(td1, file$s, 25, 8, 607);
    			add_location(td2, file$s, 26, 8, 631);
    			add_location(td3, file$s, 27, 8, 646);
    			add_location(tr1, file$s, 23, 6, 567);
    			add_location(td4, file$s, 30, 8, 684);
    			add_location(td5, file$s, 31, 8, 712);
    			add_location(td6, file$s, 32, 8, 736);
    			add_location(em, file$s, 33, 21, 764);
    			add_location(td7, file$s, 33, 8, 751);
    			add_location(tr2, file$s, 29, 6, 671);
    			add_location(td8, file$s, 36, 8, 822);
    			add_location(td9, file$s, 37, 8, 843);
    			add_location(td10, file$s, 38, 8, 867);
    			add_location(td11, file$s, 39, 8, 882);
    			add_location(tr3, file$s, 35, 6, 809);
    			add_location(td12, file$s, 42, 8, 969);
    			add_location(td13, file$s, 43, 8, 995);
    			add_location(td14, file$s, 44, 8, 1020);
    			add_location(td15, file$s, 45, 8, 1043);
    			add_location(tr4, file$s, 41, 6, 956);
    			add_location(td16, file$s, 48, 8, 1104);
    			add_location(td17, file$s, 49, 8, 1128);
    			add_location(td18, file$s, 50, 8, 1153);
    			add_location(td19, file$s, 51, 8, 1176);
    			add_location(tr5, file$s, 47, 6, 1091);
    			add_location(td20, file$s, 54, 8, 1241);
    			add_location(td21, file$s, 55, 8, 1266);
    			add_location(td22, file$s, 56, 8, 1291);
    			add_location(td23, file$s, 57, 8, 1314);
    			add_location(tr6, file$s, 53, 6, 1228);
    			add_location(td24, file$s, 60, 8, 1352);
    			add_location(td25, file$s, 61, 8, 1377);
    			add_location(td26, file$s, 62, 8, 1402);
    			add_location(td27, file$s, 63, 8, 1425);
    			add_location(tr7, file$s, 59, 6, 1339);
    			add_location(td28, file$s, 66, 8, 1517);
    			add_location(td29, file$s, 67, 8, 1543);
    			add_location(td30, file$s, 68, 8, 1567);
    			add_location(code, file$s, 69, 30, 1608);
    			add_location(td31, file$s, 69, 8, 1586);
    			add_location(tr8, file$s, 65, 6, 1504);
    			add_location(td32, file$s, 72, 8, 1692);
    			add_location(td33, file$s, 73, 8, 1715);
    			add_location(td34, file$s, 74, 8, 1746);
    			add_location(td35, file$s, 75, 8, 1761);
    			add_location(tr9, file$s, 71, 6, 1679);
    			add_location(td36, file$s, 78, 8, 1899);
    			add_location(td37, file$s, 79, 8, 1924);
    			add_location(td38, file$s, 80, 8, 1948);
    			add_location(td39, file$s, 81, 8, 1963);
    			add_location(tr10, file$s, 77, 6, 1886);
    			add_location(td40, file$s, 84, 8, 2045);
    			add_location(td41, file$s, 85, 8, 2068);
    			add_location(td42, file$s, 86, 8, 2092);
    			add_location(td43, file$s, 87, 8, 2107);
    			add_location(tr11, file$s, 83, 6, 2032);
    			add_location(td44, file$s, 90, 8, 2145);
    			add_location(td45, file$s, 91, 8, 2172);
    			add_location(td46, file$s, 92, 8, 2201);
    			add_location(td47, file$s, 93, 8, 2216);
    			add_location(tr12, file$s, 89, 6, 2132);
    			add_location(td48, file$s, 96, 8, 2296);
    			add_location(td49, file$s, 97, 8, 2327);
    			add_location(td50, file$s, 98, 8, 2352);
    			add_location(td51, file$s, 99, 8, 2375);
    			add_location(tr13, file$s, 95, 6, 2283);
    			add_location(td52, file$s, 102, 8, 2413);
    			add_location(td53, file$s, 103, 8, 2439);
    			add_location(td54, file$s, 104, 8, 2504);
    			add_location(td55, file$s, 105, 8, 2519);
    			add_location(tr14, file$s, 101, 6, 2400);
    			attr_dev(th4, "colspan", "4");
    			add_location(th4, file$s, 108, 8, 2593);
    			add_location(tr15, file$s, 107, 6, 2580);
    			add_location(td56, file$s, 111, 8, 2651);
    			add_location(td57, file$s, 112, 8, 2678);
    			add_location(td58, file$s, 113, 8, 2702);
    			add_location(td59, file$s, 114, 8, 2717);
    			add_location(tr16, file$s, 110, 6, 2638);
    			add_location(td60, file$s, 117, 8, 2755);
    			add_location(td61, file$s, 118, 8, 2779);
    			add_location(td62, file$s, 119, 8, 2803);
    			add_location(td63, file$s, 120, 8, 2818);
    			add_location(tr17, file$s, 116, 6, 2742);
    			add_location(td64, file$s, 123, 8, 2856);
    			add_location(td65, file$s, 124, 8, 2934);
    			add_location(td66, file$s, 125, 8, 2958);
    			add_location(td67, file$s, 126, 8, 2973);
    			add_location(tr18, file$s, 122, 6, 2843);
    			add_location(td68, file$s, 129, 8, 3011);
    			add_location(td69, file$s, 130, 8, 3034);
    			add_location(td70, file$s, 131, 8, 3058);
    			add_location(td71, file$s, 132, 8, 3073);
    			add_location(tr19, file$s, 128, 6, 2998);
    			add_location(tbody, file$s, 22, 4, 553);
    			attr_dev(table, "class", "table");
    			add_location(table, file$s, 13, 2, 370);
    			add_location(h30, file$s, 143, 2, 3235);
    			add_location(h31, file$s, 153, 2, 3596);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			append_dev(tbody, t14);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td4);
    			append_dev(tr2, t16);
    			append_dev(tr2, td5);
    			append_dev(tr2, t18);
    			append_dev(tr2, td6);
    			append_dev(tr2, t19);
    			append_dev(tr2, td7);
    			append_dev(td7, t20);
    			append_dev(td7, em);
    			append_dev(tbody, t22);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td8);
    			append_dev(tr3, t24);
    			append_dev(tr3, td9);
    			append_dev(tr3, t26);
    			append_dev(tr3, td10);
    			append_dev(tr3, t27);
    			append_dev(tr3, td11);
    			append_dev(tbody, t29);
    			append_dev(tbody, tr4);
    			append_dev(tr4, td12);
    			append_dev(tr4, t31);
    			append_dev(tr4, td13);
    			append_dev(tr4, t33);
    			append_dev(tr4, td14);
    			append_dev(tr4, t35);
    			append_dev(tr4, td15);
    			append_dev(tbody, t37);
    			append_dev(tbody, tr5);
    			append_dev(tr5, td16);
    			append_dev(tr5, t39);
    			append_dev(tr5, td17);
    			append_dev(tr5, t41);
    			append_dev(tr5, td18);
    			append_dev(tr5, t43);
    			append_dev(tr5, td19);
    			append_dev(tbody, t45);
    			append_dev(tbody, tr6);
    			append_dev(tr6, td20);
    			append_dev(tr6, t47);
    			append_dev(tr6, td21);
    			append_dev(tr6, t49);
    			append_dev(tr6, td22);
    			append_dev(tr6, t51);
    			append_dev(tr6, td23);
    			append_dev(tbody, t52);
    			append_dev(tbody, tr7);
    			append_dev(tr7, td24);
    			append_dev(tr7, t54);
    			append_dev(tr7, td25);
    			append_dev(tr7, t56);
    			append_dev(tr7, td26);
    			append_dev(tr7, t58);
    			append_dev(tr7, td27);
    			append_dev(tbody, t60);
    			append_dev(tbody, tr8);
    			append_dev(tr8, td28);
    			append_dev(tr8, t62);
    			append_dev(tr8, td29);
    			append_dev(tr8, t64);
    			append_dev(tr8, td30);
    			append_dev(tr8, t66);
    			append_dev(tr8, td31);
    			append_dev(td31, t67);
    			append_dev(td31, code);
    			append_dev(td31, t69);
    			append_dev(tbody, t70);
    			append_dev(tbody, tr9);
    			append_dev(tr9, td32);
    			append_dev(tr9, t72);
    			append_dev(tr9, td33);
    			append_dev(tr9, t74);
    			append_dev(tr9, td34);
    			append_dev(tr9, t75);
    			append_dev(tr9, td35);
    			append_dev(td35, t76);
    			mount_component(badge0, td35, null);
    			append_dev(td35, t77);
    			append_dev(tbody, t78);
    			append_dev(tbody, tr10);
    			append_dev(tr10, td36);
    			append_dev(tr10, t80);
    			append_dev(tr10, td37);
    			append_dev(tr10, t82);
    			append_dev(tr10, td38);
    			append_dev(tr10, t83);
    			append_dev(tr10, td39);
    			append_dev(tbody, t85);
    			append_dev(tbody, tr11);
    			append_dev(tr11, td40);
    			append_dev(tr11, t87);
    			append_dev(tr11, td41);
    			append_dev(tr11, t89);
    			append_dev(tr11, td42);
    			append_dev(tr11, t90);
    			append_dev(tr11, td43);
    			append_dev(tbody, t91);
    			append_dev(tbody, tr12);
    			append_dev(tr12, td44);
    			append_dev(tr12, t93);
    			append_dev(tr12, td45);
    			append_dev(tr12, t95);
    			append_dev(tr12, td46);
    			append_dev(tr12, t96);
    			append_dev(tr12, td47);
    			append_dev(tbody, t98);
    			append_dev(tbody, tr13);
    			append_dev(tr13, td48);
    			append_dev(tr13, t100);
    			append_dev(tr13, td49);
    			append_dev(tr13, t102);
    			append_dev(tr13, td50);
    			append_dev(tr13, t104);
    			append_dev(tr13, td51);
    			append_dev(tbody, t105);
    			append_dev(tbody, tr14);
    			append_dev(tr14, td52);
    			append_dev(tr14, t107);
    			append_dev(tr14, td53);
    			append_dev(tr14, t109);
    			append_dev(tr14, td54);
    			append_dev(tr14, t110);
    			append_dev(tr14, td55);
    			append_dev(tbody, t112);
    			append_dev(tbody, tr15);
    			append_dev(tr15, th4);
    			append_dev(tbody, t114);
    			append_dev(tbody, tr16);
    			append_dev(tr16, td56);
    			append_dev(tr16, t116);
    			append_dev(tr16, td57);
    			append_dev(tr16, t118);
    			append_dev(tr16, td58);
    			append_dev(tr16, t119);
    			append_dev(tr16, td59);
    			append_dev(tbody, t120);
    			append_dev(tbody, tr17);
    			append_dev(tr17, td60);
    			append_dev(tr17, t122);
    			append_dev(tr17, td61);
    			append_dev(tr17, t124);
    			append_dev(tr17, td62);
    			append_dev(tr17, t125);
    			append_dev(tr17, td63);
    			append_dev(tbody, t126);
    			append_dev(tbody, tr18);
    			append_dev(tr18, td64);
    			append_dev(td64, t127);
    			mount_component(badge1, td64, null);
    			append_dev(tr18, t128);
    			append_dev(tr18, td65);
    			append_dev(tr18, t130);
    			append_dev(tr18, td66);
    			append_dev(tr18, t131);
    			append_dev(tr18, td67);
    			append_dev(tbody, t132);
    			append_dev(tbody, tr19);
    			append_dev(tr19, td68);
    			append_dev(tr19, t134);
    			append_dev(tr19, td69);
    			append_dev(tr19, t136);
    			append_dev(tr19, td70);
    			append_dev(tr19, t137);
    			append_dev(tr19, td71);
    			insert_dev(target, t138, anchor);
    			mount_component(articlecard0, target, anchor);
    			insert_dev(target, t139, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t140, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t142, anchor);
    			mount_component(articlecard1, target, anchor);
    			insert_dev(target, t143, anchor);
    			mount_component(articlecard2, target, anchor);
    			insert_dev(target, t144, anchor);
    			mount_component(prism2, target, anchor);
    			insert_dev(target, t145, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t147, anchor);
    			mount_component(articlecard3, target, anchor);
    			insert_dev(target, t148, anchor);
    			mount_component(articlecard4, target, anchor);
    			insert_dev(target, t149, anchor);
    			mount_component(articlecard5, target, anchor);
    			insert_dev(target, t150, anchor);
    			mount_component(prism3, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const badge0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				badge0_changes.$$scope = { dirty, ctx };
    			}

    			badge0.$set(badge0_changes);
    			const badge1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				badge1_changes.$$scope = { dirty, ctx };
    			}

    			badge1.$set(badge1_changes);

    			const articlecard0_changes = (dirty & /*rdmArticleData*/ 0)
    			? get_spread_update(articlecard0_spread_levels, [get_spread_object(rdmArticleData())])
    			: {};

    			articlecard0.$set(articlecard0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);

    			const articlecard1_changes = (dirty & /*rdmArticleData*/ 0)
    			? get_spread_update(articlecard1_spread_levels, [
    					articlecard1_spread_levels[0],
    					articlecard1_spread_levels[1],
    					get_spread_object(rdmArticleData(250, 120))
    				])
    			: {};

    			articlecard1.$set(articlecard1_changes);

    			const articlecard2_changes = (dirty & /*rdmArticleData*/ 0)
    			? get_spread_update(articlecard2_spread_levels, [
    					articlecard2_spread_levels[0],
    					get_spread_object(rdmArticleData(250, 120))
    				])
    			: {};

    			articlecard2.$set(articlecard2_changes);
    			const prism2_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				prism2_changes.$$scope = { dirty, ctx };
    			}

    			prism2.$set(prism2_changes);
    			const prism3_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				prism3_changes.$$scope = { dirty, ctx };
    			}

    			prism3.$set(prism3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(badge0.$$.fragment, local);
    			transition_in(badge1.$$.fragment, local);
    			transition_in(articlecard0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(articlecard1.$$.fragment, local);
    			transition_in(articlecard2.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			transition_in(articlecard3.$$.fragment, local);
    			transition_in(articlecard4.$$.fragment, local);
    			transition_in(articlecard5.$$.fragment, local);
    			transition_in(prism3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(badge0.$$.fragment, local);
    			transition_out(badge1.$$.fragment, local);
    			transition_out(articlecard0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(articlecard1.$$.fragment, local);
    			transition_out(articlecard2.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			transition_out(articlecard3.$$.fragment, local);
    			transition_out(articlecard4.$$.fragment, local);
    			transition_out(articlecard5.$$.fragment, local);
    			transition_out(prism3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    			destroy_component(badge0);
    			destroy_component(badge1);
    			if (detaching) detach_dev(t138);
    			destroy_component(articlecard0, detaching);
    			if (detaching) detach_dev(t139);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t140);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t142);
    			destroy_component(articlecard1, detaching);
    			if (detaching) detach_dev(t143);
    			destroy_component(articlecard2, detaching);
    			if (detaching) detach_dev(t144);
    			destroy_component(prism2, detaching);
    			if (detaching) detach_dev(t145);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t147);
    			destroy_component(articlecard3, detaching);
    			if (detaching) detach_dev(t148);
    			destroy_component(articlecard4, detaching);
    			if (detaching) detach_dev(t149);
    			destroy_component(articlecard5, detaching);
    			if (detaching) detach_dev(t150);
    			destroy_component(prism3, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(9:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (10:2) <Prism language="js">
    function create_default_slot_5$d(ctx) {
    	let t_value = `import { ArticleCard } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$d.name,
    		type: "slot",
    		source: "(10:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (76:30) <Badge type="secondary" extension="small">
    function create_default_slot_4$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Media");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$f.name,
    		type: "slot",
    		source: "(76:30) <Badge type=\\\"secondary\\\" extension=\\\"small\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:16) <Badge type="primary" extension="small">
    function create_default_slot_3$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("required");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$g.name,
    		type: "slot",
    		source: "(124:16) <Badge type=\\\"primary\\\" extension=\\\"small\\\">",
    		ctx
    	});

    	return block;
    }

    // (140:2) <Prism language="html">
    function create_default_slot_2$l(ctx) {
    	let t_value = `<ArticleCard {...article} />` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$l.name,
    		type: "slot",
    		source: "(140:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (149:2) <Prism language="html">
    function create_default_slot_1$m(ctx) {
    	let t_value = `<ArticleCard className="small-media" {...article} />
<ArticleCard className="small-media--reverse" {...article} />` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$m.name,
    		type: "slot",
    		source: "(149:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (160:2) <Prism language="html">
    function create_default_slot$n(ctx) {
    	let t_value = `<ArticleCard loading={true} />
<ArticleCard loading={true} cardType="small-media" />
<ArticleCard loading={true} cardType="small-media--reverse" />` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$n.name,
    		type: "slot",
    		source: "(160:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let h1;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$b, create_else_block$b];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Article Card";
    			t1 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$s, 6, 0, 193);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ArticleCard', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArticleCard> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		rdmArticleData,
    		sourceType,
    		ArticleCard,
    		Badge,
    		$sourceType
    	});

    	return [$sourceType];
    }

    class ArticleCard_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ArticleCard_1",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* docs_src/components/Badge.svelte generated by Svelte v3.42.6 */
    const file$r = "docs_src/components/Badge.svelte";

    // (11:0) {#if $sourceType === 'svelte'}
    function create_if_block_4$4(ctx) {
    	let prism;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t13;
    	let td3;
    	let t14;
    	let tr2;
    	let td4;
    	let t16;
    	let td5;
    	let t18;
    	let td6;
    	let t19;
    	let td7;
    	let t21;
    	let tr3;
    	let td8;
    	let t23;
    	let td9;
    	let t25;
    	let td10;
    	let t26;
    	let td11;
    	let t28;
    	let tr4;
    	let td12;
    	let t30;
    	let td13;
    	let t32;
    	let td14;
    	let t33;
    	let td15;
    	let t34;
    	let tr5;
    	let td16;
    	let t36;
    	let td17;
    	let t38;
    	let td18;
    	let t39;
    	let td19;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_17$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "className";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "string";
    			t12 = space();
    			td2 = element("td");
    			t13 = space();
    			td3 = element("td");
    			t14 = space();
    			tr2 = element("tr");
    			td4 = element("td");
    			td4.textContent = "extension";
    			t16 = space();
    			td5 = element("td");
    			td5.textContent = "'small'";
    			t18 = space();
    			td6 = element("td");
    			t19 = space();
    			td7 = element("td");
    			td7.textContent = "Make a smaller version of the badge";
    			t21 = space();
    			tr3 = element("tr");
    			td8 = element("td");
    			td8.textContent = "href";
    			t23 = space();
    			td9 = element("td");
    			td9.textContent = "string";
    			t25 = space();
    			td10 = element("td");
    			t26 = space();
    			td11 = element("td");
    			td11.textContent = "Coverts the Badge into a clickable link";
    			t28 = space();
    			tr4 = element("tr");
    			td12 = element("td");
    			td12.textContent = "style";
    			t30 = space();
    			td13 = element("td");
    			td13.textContent = "string";
    			t32 = space();
    			td14 = element("td");
    			t33 = space();
    			td15 = element("td");
    			t34 = space();
    			tr5 = element("tr");
    			td16 = element("td");
    			td16.textContent = "type";
    			t36 = space();
    			td17 = element("td");
    			td17.textContent = "'danger' | 'primary' | 'secondary' | 'success'";
    			t38 = space();
    			td18 = element("td");
    			t39 = space();
    			td19 = element("td");
    			add_location(th0, file$r, 18, 8, 575);
    			add_location(th1, file$r, 19, 8, 602);
    			add_location(th2, file$r, 20, 8, 624);
    			add_location(th3, file$r, 21, 8, 655);
    			add_location(tr0, file$r, 17, 6, 562);
    			add_location(thead, file$r, 16, 4, 548);
    			add_location(td0, file$r, 26, 8, 732);
    			add_location(td1, file$r, 27, 8, 759);
    			add_location(td2, file$r, 28, 8, 783);
    			add_location(td3, file$r, 29, 8, 798);
    			add_location(tr1, file$r, 25, 6, 719);
    			add_location(td4, file$r, 32, 8, 836);
    			add_location(td5, file$r, 33, 8, 863);
    			add_location(td6, file$r, 34, 8, 888);
    			add_location(td7, file$r, 35, 8, 903);
    			add_location(tr2, file$r, 31, 6, 823);
    			add_location(td8, file$r, 38, 8, 979);
    			add_location(td9, file$r, 39, 8, 1001);
    			add_location(td10, file$r, 40, 8, 1025);
    			add_location(td11, file$r, 41, 8, 1040);
    			add_location(tr3, file$r, 37, 6, 966);
    			add_location(td12, file$r, 44, 8, 1120);
    			add_location(td13, file$r, 45, 8, 1143);
    			add_location(td14, file$r, 46, 8, 1167);
    			add_location(td15, file$r, 47, 8, 1182);
    			add_location(tr4, file$r, 43, 6, 1107);
    			add_location(td16, file$r, 50, 8, 1220);
    			add_location(td17, file$r, 51, 8, 1242);
    			add_location(td18, file$r, 52, 8, 1306);
    			add_location(td19, file$r, 53, 8, 1321);
    			add_location(tr5, file$r, 49, 6, 1207);
    			add_location(tbody, file$r, 24, 4, 705);
    			attr_dev(table, "class", "table");
    			add_location(table, file$r, 15, 2, 522);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			append_dev(tbody, t14);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td4);
    			append_dev(tr2, t16);
    			append_dev(tr2, td5);
    			append_dev(tr2, t18);
    			append_dev(tr2, td6);
    			append_dev(tr2, t19);
    			append_dev(tr2, td7);
    			append_dev(tbody, t21);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td8);
    			append_dev(tr3, t23);
    			append_dev(tr3, td9);
    			append_dev(tr3, t25);
    			append_dev(tr3, td10);
    			append_dev(tr3, t26);
    			append_dev(tr3, td11);
    			append_dev(tbody, t28);
    			append_dev(tbody, tr4);
    			append_dev(tr4, td12);
    			append_dev(tr4, t30);
    			append_dev(tr4, td13);
    			append_dev(tr4, t32);
    			append_dev(tr4, td14);
    			append_dev(tr4, t33);
    			append_dev(tr4, td15);
    			append_dev(tbody, t34);
    			append_dev(tbody, tr5);
    			append_dev(tr5, td16);
    			append_dev(tr5, t36);
    			append_dev(tr5, td17);
    			append_dev(tr5, t38);
    			append_dev(tr5, td18);
    			append_dev(tr5, t39);
    			append_dev(tr5, td19);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(11:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (12:2) <Prism language="js">
    function create_default_slot_17$3(ctx) {
    	let t_value = `import { Badge } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$3.name,
    		type: "slot",
    		source: "(12:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (63:2) <Badge>
    function create_default_slot_16$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Badge");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$3.name,
    		type: "slot",
    		source: "(63:2) <Badge>",
    		ctx
    	});

    	return block;
    }

    // (70:0) {:else}
    function create_else_block_3$4(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_15$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3$4.name,
    		type: "else",
    		source: "(70:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (66:0) {#if $sourceType === 'svelte'}
    function create_if_block_3$5(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_14$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(66:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (71:2) <Prism language="html">
    function create_default_slot_15$3(ctx) {
    	let t_value = `<span class="badge"></span>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$3.name,
    		type: "slot",
    		source: "(71:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (67:2) <Prism language="html">
    function create_default_slot_14$4(ctx) {
    	let t_value = `<Badge></Badge>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$4.name,
    		type: "slot",
    		source: "(67:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (79:2) <Badge className="margin-s" type="primary">
    function create_default_slot_13$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Primary");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$4.name,
    		type: "slot",
    		source: "(79:2) <Badge className=\\\"margin-s\\\" type=\\\"primary\\\">",
    		ctx
    	});

    	return block;
    }

    // (80:2) <Badge className="margin-s" type="secondary">
    function create_default_slot_12$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Secondary");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$4.name,
    		type: "slot",
    		source: "(80:2) <Badge className=\\\"margin-s\\\" type=\\\"secondary\\\">",
    		ctx
    	});

    	return block;
    }

    // (81:2) <Badge className="margin-s" type="success">
    function create_default_slot_11$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Success");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$5.name,
    		type: "slot",
    		source: "(81:2) <Badge className=\\\"margin-s\\\" type=\\\"success\\\">",
    		ctx
    	});

    	return block;
    }

    // (82:2) <Badge className="margin-s" type="danger">
    function create_default_slot_10$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Danger");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$6.name,
    		type: "slot",
    		source: "(82:2) <Badge className=\\\"margin-s\\\" type=\\\"danger\\\">",
    		ctx
    	});

    	return block;
    }

    // (92:0) {:else}
    function create_else_block_2$5(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_9$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$5.name,
    		type: "else",
    		source: "(92:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (85:0) {#if $sourceType === 'svelte'}
    function create_if_block_2$7(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_8$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(85:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (93:2) <Prism language="html">
    function create_default_slot_9$7(ctx) {
    	let t_value = `<span class="badge" data-type="primary"></span>
<span class="badge" data-type="secondary"></span>
<span class="badge" data-type="success"></span>
<span class="badge" data-type="danger"></span>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$7.name,
    		type: "slot",
    		source: "(93:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (86:2) <Prism language="html">
    function create_default_slot_8$a(ctx) {
    	let t_value = `<Badge type="primary"></Badge>
<Badge type="secondary"></Badge>
<Badge type="success"></Badge>
<Badge type="danger"></Badge>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$a.name,
    		type: "slot",
    		source: "(86:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (104:2) <Badge className="margin-s {bluedarkBGClass}">
    function create_default_slot_7$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("bluedarkBGClass");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$a.name,
    		type: "slot",
    		source: "(104:2) <Badge className=\\\"margin-s {bluedarkBGClass}\\\">",
    		ctx
    	});

    	return block;
    }

    // (105:2) <Badge className="margin-s {greenBGClass}">
    function create_default_slot_6$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("greenBGClass");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$c.name,
    		type: "slot",
    		source: "(105:2) <Badge className=\\\"margin-s {greenBGClass}\\\">",
    		ctx
    	});

    	return block;
    }

    // (106:2) <Badge className="margin-s {greendarkBGClass}">
    function create_default_slot_5$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("greendarkBGClass");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$c.name,
    		type: "slot",
    		source: "(106:2) <Badge className=\\\"margin-s {greendarkBGClass}\\\">",
    		ctx
    	});

    	return block;
    }

    // (117:0) {:else}
    function create_else_block_1$8(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_4$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$8.name,
    		type: "else",
    		source: "(117:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (109:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$9(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_3$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(109:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (118:2) <Prism language="html">
    function create_default_slot_4$e(ctx) {
    	let t_value = `<span class="badge bg--bluedark"></span>
<span class="badge bg--green"></span>
<span class="badge bg--greendark"></span>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$e.name,
    		type: "slot",
    		source: "(118:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (110:2) <Prism language="html">
    function create_default_slot_3$f(ctx) {
    	let t_value = `import { bluedarkBGClass, greenBGClass, greendarkBGClass } from '@ekstra-bladet/eb-colors';

<Badge className="margin-s {bluedarkBGClass}">bluedarkBGClass</Badge>
<Badge className="margin-s {greenBGClass}">greenBGClass</Badge>
<Badge className="margin-s {greendarkBGClass}">greendarkBGClass</Badge>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$f.name,
    		type: "slot",
    		source: "(110:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (128:2) <Badge className="margin-s padding-none padding-s--r card--shadow bg--black fontsize-small">
    function create_default_slot_2$k(ctx) {
    	let icon;
    	let t;
    	let current;

    	icon = new Icon({
    			props: {
    				name: "lightning",
    				className: "bg--white color--flash border-radius-s padding-s margin-s--r",
    				style: "margin-left: -1px;",
    				width: "15"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    			t = text("\n    UPDATE");
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$k.name,
    		type: "slot",
    		source: "(128:2) <Badge className=\\\"margin-s padding-none padding-s--r card--shadow bg--black fontsize-small\\\">",
    		ctx
    	});

    	return block;
    }

    // (150:0) {:else}
    function create_else_block$a(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(150:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (139:0) {#if $sourceType === 'svelte'}
    function create_if_block$a(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(139:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (151:2) <Prism language="html">
    function create_default_slot_1$l(ctx) {
    	let t_value = `<span class="badge margin-s padding-none padding-s--r card--shadow bg--black fontsize-small">
  <svg viewBox="0 0 10 16"
    className="icon-svg bg--white color--flash border-radius-s padding-s margin-s--r"
    style="margin-left: -1px; width: 15px; height: 15px;"/>
    <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#lightning"></use>
  </svg>
  UPDATE
</span>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$l.name,
    		type: "slot",
    		source: "(151:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (140:2) <Prism language="html">
    function create_default_slot$m(ctx) {
    	let t_value = `<Badge className="margin-s padding-none padding-s--r card--shadow bg--black fontsize-small">
  <Icon
    name="lightning"
    className="icon-svg bg--white color--flash border-radius-s padding-s margin-s--r"
    style="margin-left: -1px;"
    width="15"/>
  UPDATE
</Badge>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$m.name,
    		type: "slot",
    		source: "(140:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let h1;
    	let t1;
    	let p;
    	let t3;
    	let t4;
    	let h30;
    	let t6;
    	let div0;
    	let badge0;
    	let t7;
    	let current_block_type_index;
    	let if_block1;
    	let t8;
    	let h31;
    	let t10;
    	let div1;
    	let badge1;
    	let t11;
    	let badge2;
    	let t12;
    	let badge3;
    	let t13;
    	let badge4;
    	let t14;
    	let current_block_type_index_1;
    	let if_block2;
    	let t15;
    	let h32;
    	let t17;
    	let div2;
    	let badge5;
    	let t18;
    	let badge6;
    	let t19;
    	let badge7;
    	let t20;
    	let current_block_type_index_2;
    	let if_block3;
    	let t21;
    	let h33;
    	let t23;
    	let div3;
    	let badge8;
    	let t24;
    	let current_block_type_index_3;
    	let if_block4;
    	let if_block4_anchor;
    	let current;
    	let if_block0 = /*$sourceType*/ ctx[0] === 'svelte' && create_if_block_4$4(ctx);

    	badge0 = new Badge({
    			props: {
    				$$slots: { default: [create_default_slot_16$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block_3$5, create_else_block_3$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	badge1 = new Badge({
    			props: {
    				className: "margin-s",
    				type: "primary",
    				$$slots: { default: [create_default_slot_13$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	badge2 = new Badge({
    			props: {
    				className: "margin-s",
    				type: "secondary",
    				$$slots: { default: [create_default_slot_12$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	badge3 = new Badge({
    			props: {
    				className: "margin-s",
    				type: "success",
    				$$slots: { default: [create_default_slot_11$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	badge4 = new Badge({
    			props: {
    				className: "margin-s",
    				type: "danger",
    				$$slots: { default: [create_default_slot_10$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_1 = [create_if_block_2$7, create_else_block_2$5];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	badge5 = new Badge({
    			props: {
    				className: "margin-s " + bluedarkBGClass,
    				$$slots: { default: [create_default_slot_7$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	badge6 = new Badge({
    			props: {
    				className: "margin-s " + greenBGClass,
    				$$slots: { default: [create_default_slot_6$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	badge7 = new Badge({
    			props: {
    				className: "margin-s " + greendarkBGClass,
    				$$slots: { default: [create_default_slot_5$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_2 = [create_if_block_1$9, create_else_block_1$8];
    	const if_blocks_2 = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_2 = select_block_type_2(ctx);
    	if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

    	badge8 = new Badge({
    			props: {
    				className: "margin-s padding-none padding-s--r card--shadow bg--black fontsize-small",
    				$$slots: { default: [create_default_slot_2$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_3 = [create_if_block$a, create_else_block$a];
    	const if_blocks_3 = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_3 = select_block_type_3(ctx);
    	if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Badge";
    			t1 = space();
    			p = element("p");
    			p.textContent = "Badges kan benyttes som mærkater eller som indikation af tags. Størrelsen af et badge kan styres vha. font-sizes.";
    			t3 = space();
    			if (if_block0) if_block0.c();
    			t4 = space();
    			h30 = element("h3");
    			h30.textContent = "Default";
    			t6 = space();
    			div0 = element("div");
    			create_component(badge0.$$.fragment);
    			t7 = space();
    			if_block1.c();
    			t8 = space();
    			h31 = element("h3");
    			h31.textContent = "Variations";
    			t10 = space();
    			div1 = element("div");
    			create_component(badge1.$$.fragment);
    			t11 = space();
    			create_component(badge2.$$.fragment);
    			t12 = space();
    			create_component(badge3.$$.fragment);
    			t13 = space();
    			create_component(badge4.$$.fragment);
    			t14 = space();
    			if_block2.c();
    			t15 = space();
    			h32 = element("h3");
    			h32.textContent = "Farve muligheder fra eb-colors";
    			t17 = space();
    			div2 = element("div");
    			create_component(badge5.$$.fragment);
    			t18 = space();
    			create_component(badge6.$$.fragment);
    			t19 = space();
    			create_component(badge7.$$.fragment);
    			t20 = space();
    			if_block3.c();
    			t21 = space();
    			h33 = element("h3");
    			h33.textContent = "Advanced examples";
    			t23 = space();
    			div3 = element("div");
    			create_component(badge8.$$.fragment);
    			t24 = space();
    			if_block4.c();
    			if_block4_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$r, 6, 0, 236);
    			add_location(p, file$r, 8, 0, 270);
    			add_location(h30, file$r, 59, 0, 1371);
    			attr_dev(div0, "class", "flex");
    			add_location(div0, file$r, 61, 0, 1389);
    			add_location(h31, file$r, 75, 0, 1619);
    			attr_dev(div1, "class", "flex");
    			add_location(div1, file$r, 77, 0, 1640);
    			add_location(h32, file$r, 100, 0, 2367);
    			attr_dev(div2, "class", "flex");
    			add_location(div2, file$r, 102, 0, 2408);
    			add_location(h33, file$r, 124, 0, 3203);
    			attr_dev(div3, "class", "flex");
    			add_location(div3, file$r, 126, 0, 3231);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, div0, anchor);
    			mount_component(badge0, div0, null);
    			insert_dev(target, t7, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(badge1, div1, null);
    			append_dev(div1, t11);
    			mount_component(badge2, div1, null);
    			append_dev(div1, t12);
    			mount_component(badge3, div1, null);
    			append_dev(div1, t13);
    			mount_component(badge4, div1, null);
    			insert_dev(target, t14, anchor);
    			if_blocks_1[current_block_type_index_1].m(target, anchor);
    			insert_dev(target, t15, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(badge5, div2, null);
    			append_dev(div2, t18);
    			mount_component(badge6, div2, null);
    			append_dev(div2, t19);
    			mount_component(badge7, div2, null);
    			insert_dev(target, t20, anchor);
    			if_blocks_2[current_block_type_index_2].m(target, anchor);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t23, anchor);
    			insert_dev(target, div3, anchor);
    			mount_component(badge8, div3, null);
    			insert_dev(target, t24, anchor);
    			if_blocks_3[current_block_type_index_3].m(target, anchor);
    			insert_dev(target, if_block4_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$sourceType*/ ctx[0] === 'svelte') {
    				if (if_block0) {
    					if (dirty & /*$sourceType*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t4.parentNode, t4);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const badge0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				badge0_changes.$$scope = { dirty, ctx };
    			}

    			badge0.$set(badge0_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(t8.parentNode, t8);
    			}

    			const badge1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				badge1_changes.$$scope = { dirty, ctx };
    			}

    			badge1.$set(badge1_changes);
    			const badge2_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				badge2_changes.$$scope = { dirty, ctx };
    			}

    			badge2.$set(badge2_changes);
    			const badge3_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				badge3_changes.$$scope = { dirty, ctx };
    			}

    			badge3.$set(badge3_changes);
    			const badge4_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				badge4_changes.$$scope = { dirty, ctx };
    			}

    			badge4.$set(badge4_changes);
    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks_1[current_block_type_index_1];

    				if (!if_block2) {
    					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(t15.parentNode, t15);
    			}

    			const badge5_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				badge5_changes.$$scope = { dirty, ctx };
    			}

    			badge5.$set(badge5_changes);
    			const badge6_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				badge6_changes.$$scope = { dirty, ctx };
    			}

    			badge6.$set(badge6_changes);
    			const badge7_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				badge7_changes.$$scope = { dirty, ctx };
    			}

    			badge7.$set(badge7_changes);
    			let previous_block_index_2 = current_block_type_index_2;
    			current_block_type_index_2 = select_block_type_2(ctx);

    			if (current_block_type_index_2 !== previous_block_index_2) {
    				group_outros();

    				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
    					if_blocks_2[previous_block_index_2] = null;
    				});

    				check_outros();
    				if_block3 = if_blocks_2[current_block_type_index_2];

    				if (!if_block3) {
    					if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
    					if_block3.c();
    				}

    				transition_in(if_block3, 1);
    				if_block3.m(t21.parentNode, t21);
    			}

    			const badge8_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				badge8_changes.$$scope = { dirty, ctx };
    			}

    			badge8.$set(badge8_changes);
    			let previous_block_index_3 = current_block_type_index_3;
    			current_block_type_index_3 = select_block_type_3(ctx);

    			if (current_block_type_index_3 !== previous_block_index_3) {
    				group_outros();

    				transition_out(if_blocks_3[previous_block_index_3], 1, 1, () => {
    					if_blocks_3[previous_block_index_3] = null;
    				});

    				check_outros();
    				if_block4 = if_blocks_3[current_block_type_index_3];

    				if (!if_block4) {
    					if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);
    					if_block4.c();
    				}

    				transition_in(if_block4, 1);
    				if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(badge0.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(badge1.$$.fragment, local);
    			transition_in(badge2.$$.fragment, local);
    			transition_in(badge3.$$.fragment, local);
    			transition_in(badge4.$$.fragment, local);
    			transition_in(if_block2);
    			transition_in(badge5.$$.fragment, local);
    			transition_in(badge6.$$.fragment, local);
    			transition_in(badge7.$$.fragment, local);
    			transition_in(if_block3);
    			transition_in(badge8.$$.fragment, local);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(badge0.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(badge1.$$.fragment, local);
    			transition_out(badge2.$$.fragment, local);
    			transition_out(badge3.$$.fragment, local);
    			transition_out(badge4.$$.fragment, local);
    			transition_out(if_block2);
    			transition_out(badge5.$$.fragment, local);
    			transition_out(badge6.$$.fragment, local);
    			transition_out(badge7.$$.fragment, local);
    			transition_out(if_block3);
    			transition_out(badge8.$$.fragment, local);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t3);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(div0);
    			destroy_component(badge0);
    			if (detaching) detach_dev(t7);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(div1);
    			destroy_component(badge1);
    			destroy_component(badge2);
    			destroy_component(badge3);
    			destroy_component(badge4);
    			if (detaching) detach_dev(t14);
    			if_blocks_1[current_block_type_index_1].d(detaching);
    			if (detaching) detach_dev(t15);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(div2);
    			destroy_component(badge5);
    			destroy_component(badge6);
    			destroy_component(badge7);
    			if (detaching) detach_dev(t20);
    			if_blocks_2[current_block_type_index_2].d(detaching);
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t23);
    			if (detaching) detach_dev(div3);
    			destroy_component(badge8);
    			if (detaching) detach_dev(t24);
    			if_blocks_3[current_block_type_index_3].d(detaching);
    			if (detaching) detach_dev(if_block4_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Badge', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Badge> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		sourceType,
    		bluedarkBGClass,
    		greenBGClass,
    		greendarkBGClass,
    		Badge,
    		Icon,
    		$sourceType
    	});

    	return [$sourceType];
    }

    class Badge_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Badge_1",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    /* docs_src/components/Button.svelte generated by Svelte v3.42.6 */
    const file$q = "docs_src/components/Button.svelte";

    // (8:0) {#if $sourceType === 'svelte'}
    function create_if_block_5$1(ctx) {
    	let prism;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t13;
    	let td3;
    	let t14;
    	let tr2;
    	let td4;
    	let t16;
    	let td5;
    	let t18;
    	let td6;
    	let t20;
    	let td7;
    	let t21;
    	let tr3;
    	let td8;
    	let t23;
    	let td9;
    	let t25;
    	let td10;
    	let t26;
    	let td11;
    	let t27;
    	let tr4;
    	let td12;
    	let t29;
    	let td13;
    	let t31;
    	let td14;
    	let t32;
    	let td15;
    	let t34;
    	let tr5;
    	let td16;
    	let t36;
    	let td17;
    	let t38;
    	let td18;
    	let t39;
    	let td19;
    	let t40;
    	let tr6;
    	let td20;
    	let t42;
    	let td21;
    	let t44;
    	let td22;
    	let t45;
    	let td23;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_22$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "className";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "string";
    			t12 = space();
    			td2 = element("td");
    			t13 = space();
    			td3 = element("td");
    			t14 = space();
    			tr2 = element("tr");
    			td4 = element("td");
    			td4.textContent = "disabled";
    			t16 = space();
    			td5 = element("td");
    			td5.textContent = "boolean";
    			t18 = space();
    			td6 = element("td");
    			td6.textContent = "false";
    			t20 = space();
    			td7 = element("td");
    			t21 = space();
    			tr3 = element("tr");
    			td8 = element("td");
    			td8.textContent = "extension";
    			t23 = space();
    			td9 = element("td");
    			td9.textContent = "'icon' | 'link' | 'solid' | 'icon link' | 'icon solid'";
    			t25 = space();
    			td10 = element("td");
    			t26 = space();
    			td11 = element("td");
    			t27 = space();
    			tr4 = element("tr");
    			td12 = element("td");
    			td12.textContent = "href";
    			t29 = space();
    			td13 = element("td");
    			td13.textContent = "string";
    			t31 = space();
    			td14 = element("td");
    			t32 = space();
    			td15 = element("td");
    			td15.textContent = "Coverts the Button into a clickable link";
    			t34 = space();
    			tr5 = element("tr");
    			td16 = element("td");
    			td16.textContent = "size";
    			t36 = space();
    			td17 = element("td");
    			td17.textContent = "'big' | 'small'";
    			t38 = space();
    			td18 = element("td");
    			t39 = space();
    			td19 = element("td");
    			t40 = space();
    			tr6 = element("tr");
    			td20 = element("td");
    			td20.textContent = "type";
    			t42 = space();
    			td21 = element("td");
    			td21.textContent = "'accept' | 'cancel' | 'primary' | 'secondary'";
    			t44 = space();
    			td22 = element("td");
    			t45 = space();
    			td23 = element("td");
    			add_location(th0, file$q, 15, 8, 365);
    			add_location(th1, file$q, 16, 8, 392);
    			add_location(th2, file$q, 17, 8, 414);
    			add_location(th3, file$q, 18, 8, 445);
    			add_location(tr0, file$q, 14, 6, 352);
    			add_location(thead, file$q, 13, 4, 338);
    			add_location(td0, file$q, 23, 8, 522);
    			add_location(td1, file$q, 24, 8, 549);
    			add_location(td2, file$q, 25, 8, 573);
    			add_location(td3, file$q, 26, 8, 588);
    			add_location(tr1, file$q, 22, 6, 509);
    			add_location(td4, file$q, 29, 8, 626);
    			add_location(td5, file$q, 30, 8, 652);
    			add_location(td6, file$q, 31, 8, 677);
    			add_location(td7, file$q, 32, 8, 700);
    			add_location(tr2, file$q, 28, 6, 613);
    			add_location(td8, file$q, 35, 8, 738);
    			add_location(td9, file$q, 36, 8, 765);
    			add_location(td10, file$q, 37, 8, 837);
    			add_location(td11, file$q, 38, 8, 852);
    			add_location(tr3, file$q, 34, 6, 725);
    			add_location(td12, file$q, 41, 8, 890);
    			add_location(td13, file$q, 42, 8, 912);
    			add_location(td14, file$q, 43, 8, 936);
    			add_location(td15, file$q, 44, 8, 951);
    			add_location(tr4, file$q, 40, 6, 877);
    			add_location(td16, file$q, 47, 8, 1032);
    			add_location(td17, file$q, 48, 8, 1054);
    			add_location(td18, file$q, 49, 8, 1087);
    			add_location(td19, file$q, 50, 8, 1102);
    			add_location(tr5, file$q, 46, 6, 1019);
    			add_location(td20, file$q, 53, 8, 1140);
    			add_location(td21, file$q, 54, 8, 1162);
    			add_location(td22, file$q, 55, 8, 1225);
    			add_location(td23, file$q, 56, 8, 1240);
    			add_location(tr6, file$q, 52, 6, 1127);
    			add_location(tbody, file$q, 21, 4, 495);
    			attr_dev(table, "class", "table");
    			add_location(table, file$q, 12, 2, 312);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			append_dev(tbody, t14);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td4);
    			append_dev(tr2, t16);
    			append_dev(tr2, td5);
    			append_dev(tr2, t18);
    			append_dev(tr2, td6);
    			append_dev(tr2, t20);
    			append_dev(tr2, td7);
    			append_dev(tbody, t21);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td8);
    			append_dev(tr3, t23);
    			append_dev(tr3, td9);
    			append_dev(tr3, t25);
    			append_dev(tr3, td10);
    			append_dev(tr3, t26);
    			append_dev(tr3, td11);
    			append_dev(tbody, t27);
    			append_dev(tbody, tr4);
    			append_dev(tr4, td12);
    			append_dev(tr4, t29);
    			append_dev(tr4, td13);
    			append_dev(tr4, t31);
    			append_dev(tr4, td14);
    			append_dev(tr4, t32);
    			append_dev(tr4, td15);
    			append_dev(tbody, t34);
    			append_dev(tbody, tr5);
    			append_dev(tr5, td16);
    			append_dev(tr5, t36);
    			append_dev(tr5, td17);
    			append_dev(tr5, t38);
    			append_dev(tr5, td18);
    			append_dev(tr5, t39);
    			append_dev(tr5, td19);
    			append_dev(tbody, t40);
    			append_dev(tbody, tr6);
    			append_dev(tr6, td20);
    			append_dev(tr6, t42);
    			append_dev(tr6, td21);
    			append_dev(tr6, t44);
    			append_dev(tr6, td22);
    			append_dev(tr6, t45);
    			append_dev(tr6, td23);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(8:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (9:2) <Prism language="js">
    function create_default_slot_22$1(ctx) {
    	let t_value = `import { Button } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22$1.name,
    		type: "slot",
    		source: "(9:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (65:0) <Button>
    function create_default_slot_21$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$2.name,
    		type: "slot",
    		source: "(65:0) <Button>",
    		ctx
    	});

    	return block;
    }

    // (71:0) {:else}
    function create_else_block_4$1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_20$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4$1.name,
    		type: "else",
    		source: "(71:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (67:0) {#if $sourceType === 'svelte'}
    function create_if_block_4$3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_19$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(67:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (72:2) <Prism language="html">
    function create_default_slot_20$2(ctx) {
    	let t_value = `<button class="button"></button>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$2.name,
    		type: "slot",
    		source: "(72:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (68:2) <Prism language="html">
    function create_default_slot_19$2(ctx) {
    	let t_value = `<Button></Button>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$2.name,
    		type: "slot",
    		source: "(68:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (79:0) <Button className="margin-m" extension="solid">
    function create_default_slot_18$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Solid");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$2.name,
    		type: "slot",
    		source: "(79:0) <Button className=\\\"margin-m\\\" extension=\\\"solid\\\">",
    		ctx
    	});

    	return block;
    }

    // (80:0) <Button className="margin-m" extension="link">
    function create_default_slot_17$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Link");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$2.name,
    		type: "slot",
    		source: "(80:0) <Button className=\\\"margin-m\\\" extension=\\\"link\\\">",
    		ctx
    	});

    	return block;
    }

    // (81:0) <Button className="margin-m" extension="icon">
    function create_default_slot_16$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "×";
    			set_style(span, "font-size", "30px");
    			add_location(span, file$q, 81, 2, 1721);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$2.name,
    		type: "slot",
    		source: "(81:0) <Button className=\\\"margin-m\\\" extension=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (93:0) {:else}
    function create_else_block_3$3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_15$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3$3.name,
    		type: "else",
    		source: "(93:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (85:0) {#if $sourceType === 'svelte'}
    function create_if_block_3$4(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_14$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(85:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (94:2) <Prism language="html">
    function create_default_slot_15$2(ctx) {
    	let t_value = `<button class="button button--solid"></button>
<button class="button button--link"></button>
<button class="button button--icon">
  <span style="font-size: 30px;">&times;</span>
</button>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$2.name,
    		type: "slot",
    		source: "(94:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (86:2) <Prism language="html">
    function create_default_slot_14$3(ctx) {
    	let t_value = `<Button extension="solid"></Button>
<Button extension="link"></Button>
<Button extension="icon">
  <span style="font-size: 30px">&times;</span>
</Button>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$3.name,
    		type: "slot",
    		source: "(86:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (106:0) <Button className="margin-m" size="big">
    function create_default_slot_13$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Big");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$3.name,
    		type: "slot",
    		source: "(106:0) <Button className=\\\"margin-m\\\" size=\\\"big\\\">",
    		ctx
    	});

    	return block;
    }

    // (107:0) <Button className="margin-m" size="small">
    function create_default_slot_12$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Small");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$3.name,
    		type: "slot",
    		source: "(107:0) <Button className=\\\"margin-m\\\" size=\\\"small\\\">",
    		ctx
    	});

    	return block;
    }

    // (114:0) {:else}
    function create_else_block_2$4(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_11$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$4.name,
    		type: "else",
    		source: "(114:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (109:0) {#if $sourceType === 'svelte'}
    function create_if_block_2$6(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_10$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(109:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (115:2) <Prism language="html">
    function create_default_slot_11$4(ctx) {
    	let t_value = `<button class="button button--big"></button>
<button class="button button--small"></button>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$4.name,
    		type: "slot",
    		source: "(115:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (110:2) <Prism language="html">
    function create_default_slot_10$5(ctx) {
    	let t_value = `<Button size="big"></Button>
<Button size="small"></Button>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$5.name,
    		type: "slot",
    		source: "(110:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (123:0) <Button className="margin-m" type="primary">
    function create_default_slot_9$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Primary");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$6.name,
    		type: "slot",
    		source: "(123:0) <Button className=\\\"margin-m\\\" type=\\\"primary\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:0) <Button className="margin-m" type="secondary">
    function create_default_slot_8$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Secondary");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$9.name,
    		type: "slot",
    		source: "(124:0) <Button className=\\\"margin-m\\\" type=\\\"secondary\\\">",
    		ctx
    	});

    	return block;
    }

    // (125:0) <Button className="margin-m" type="accept">
    function create_default_slot_7$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Accept");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$9.name,
    		type: "slot",
    		source: "(125:0) <Button className=\\\"margin-m\\\" type=\\\"accept\\\">",
    		ctx
    	});

    	return block;
    }

    // (126:0) <Button className="margin-m" type="cancel">
    function create_default_slot_6$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Cancel");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$b.name,
    		type: "slot",
    		source: "(126:0) <Button className=\\\"margin-m\\\" type=\\\"cancel\\\">",
    		ctx
    	});

    	return block;
    }

    // (135:0) {:else}
    function create_else_block_1$7(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_5$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$7.name,
    		type: "else",
    		source: "(135:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (128:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$8(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_4$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(128:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (136:2) <Prism language="html">
    function create_default_slot_5$b(ctx) {
    	let t_value = `<button class="button button--primary"></button>
<button class="button button--secondary"></button>
<button class="button button--accept"></button>
<button class="button button--cancel"></button>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$b.name,
    		type: "slot",
    		source: "(136:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (129:2) <Prism language="html">
    function create_default_slot_4$d(ctx) {
    	let t_value = `<Button type="primary"></Button>
<Button type="secondary"></Button>
<Button type="accept"></Button>
<Button type="cancel"></Button>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$d.name,
    		type: "slot",
    		source: "(129:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (146:0) <Button className="margin-m">
    function create_default_slot_3$e(ctx) {
    	let span;
    	let t1;
    	let icon;
    	let current;

    	icon = new Icon({
    			props: {
    				className: "icon",
    				name: "angleright",
    				width: "20"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Icon to the right";
    			t1 = space();
    			create_component(icon.$$.fragment);
    			add_location(span, file$q, 146, 2, 3544);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t1);
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$e.name,
    		type: "slot",
    		source: "(146:0) <Button className=\\\"margin-m\\\">",
    		ctx
    	});

    	return block;
    }

    // (150:0) <Button className="margin-m">
    function create_default_slot_2$j(ctx) {
    	let icon;
    	let t0;
    	let span;
    	let current;

    	icon = new Icon({
    			props: {
    				className: "icon",
    				name: "angleleft",
    				width: "20"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    			t0 = space();
    			span = element("span");
    			span.textContent = "Icon to the left";
    			add_location(span, file$q, 151, 2, 3730);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$j.name,
    		type: "slot",
    		source: "(150:0) <Button className=\\\"margin-m\\\">",
    		ctx
    	});

    	return block;
    }

    // (166:0) {:else}
    function create_else_block$9(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(166:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (155:0) {#if $sourceType === 'svelte'}
    function create_if_block$9(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(155:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (167:2) <Prism language="html">
    function create_default_slot_1$k(ctx) {
    	let t_value = `<button class="button">
  <span></span>
  <svg viewBox="0 0 50 50">
    <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#angle_right"></use>
  </svg>
</button>
<button class="button">
  <svg viewBox="0 0 50 50">
    <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#angle_left"></use>
  </svg>
  <span></span>
</button>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$k.name,
    		type: "slot",
    		source: "(167:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (156:2) <Prism language="html">
    function create_default_slot$l(ctx) {
    	let t_value = `<Button>
  <span></span>
  <Icon className="icon" name="angleright" width="20" />
</Button>
<Button>
  <Icon className="icon" name="angleleft" width="20" />
  <span></span>
</Button>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$l.name,
    		type: "slot",
    		source: "(156:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let h1;
    	let t1;
    	let t2;
    	let h30;
    	let t4;
    	let button0;
    	let t5;
    	let current_block_type_index;
    	let if_block1;
    	let t6;
    	let h31;
    	let t8;
    	let button1;
    	let t9;
    	let button2;
    	let t10;
    	let button3;
    	let t11;
    	let current_block_type_index_1;
    	let if_block2;
    	let t12;
    	let h32;
    	let t14;
    	let p;
    	let b0;
    	let t16;
    	let b1;
    	let t18;
    	let t19;
    	let button4;
    	let t20;
    	let button5;
    	let t21;
    	let current_block_type_index_2;
    	let if_block3;
    	let t22;
    	let h33;
    	let t24;
    	let button6;
    	let t25;
    	let button7;
    	let t26;
    	let button8;
    	let t27;
    	let button9;
    	let t28;
    	let current_block_type_index_3;
    	let if_block4;
    	let t29;
    	let h34;
    	let t31;
    	let button10;
    	let t32;
    	let button11;
    	let t33;
    	let current_block_type_index_4;
    	let if_block5;
    	let if_block5_anchor;
    	let current;
    	let if_block0 = /*$sourceType*/ ctx[0] === 'svelte' && create_if_block_5$1(ctx);

    	button0 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_21$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block_4$3, create_else_block_4$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	button1 = new Button({
    			props: {
    				className: "margin-m",
    				extension: "solid",
    				$$slots: { default: [create_default_slot_18$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new Button({
    			props: {
    				className: "margin-m",
    				extension: "link",
    				$$slots: { default: [create_default_slot_17$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button3 = new Button({
    			props: {
    				className: "margin-m",
    				extension: "icon",
    				$$slots: { default: [create_default_slot_16$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_1 = [create_if_block_3$4, create_else_block_3$3];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	button4 = new Button({
    			props: {
    				className: "margin-m",
    				size: "big",
    				$$slots: { default: [create_default_slot_13$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button5 = new Button({
    			props: {
    				className: "margin-m",
    				size: "small",
    				$$slots: { default: [create_default_slot_12$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_2 = [create_if_block_2$6, create_else_block_2$4];
    	const if_blocks_2 = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_2 = select_block_type_2(ctx);
    	if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

    	button6 = new Button({
    			props: {
    				className: "margin-m",
    				type: "primary",
    				$$slots: { default: [create_default_slot_9$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button7 = new Button({
    			props: {
    				className: "margin-m",
    				type: "secondary",
    				$$slots: { default: [create_default_slot_8$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button8 = new Button({
    			props: {
    				className: "margin-m",
    				type: "accept",
    				$$slots: { default: [create_default_slot_7$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button9 = new Button({
    			props: {
    				className: "margin-m",
    				type: "cancel",
    				$$slots: { default: [create_default_slot_6$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_3 = [create_if_block_1$8, create_else_block_1$7];
    	const if_blocks_3 = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_3 = select_block_type_3(ctx);
    	if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);

    	button10 = new Button({
    			props: {
    				className: "margin-m",
    				$$slots: { default: [create_default_slot_3$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button11 = new Button({
    			props: {
    				className: "margin-m",
    				$$slots: { default: [create_default_slot_2$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_4 = [create_if_block$9, create_else_block$9];
    	const if_blocks_4 = [];

    	function select_block_type_4(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_4 = select_block_type_4(ctx);
    	if_block5 = if_blocks_4[current_block_type_index_4] = if_block_creators_4[current_block_type_index_4](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Buttons";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			h30 = element("h3");
    			h30.textContent = "Default";
    			t4 = space();
    			create_component(button0.$$.fragment);
    			t5 = space();
    			if_block1.c();
    			t6 = space();
    			h31 = element("h3");
    			h31.textContent = "Extension attribute";
    			t8 = space();
    			create_component(button1.$$.fragment);
    			t9 = space();
    			create_component(button2.$$.fragment);
    			t10 = space();
    			create_component(button3.$$.fragment);
    			t11 = space();
    			if_block2.c();
    			t12 = space();
    			h32 = element("h3");
    			h32.textContent = "Size attribute";
    			t14 = space();
    			p = element("p");
    			b0 = element("b");
    			b0.textContent = "big";
    			t16 = text(" and ");
    			b1 = element("b");
    			b1.textContent = "small";
    			t18 = text(" can be combined with the other three extensions");
    			t19 = space();
    			create_component(button4.$$.fragment);
    			t20 = space();
    			create_component(button5.$$.fragment);
    			t21 = space();
    			if_block3.c();
    			t22 = space();
    			h33 = element("h3");
    			h33.textContent = "Variations";
    			t24 = space();
    			create_component(button6.$$.fragment);
    			t25 = space();
    			create_component(button7.$$.fragment);
    			t26 = space();
    			create_component(button8.$$.fragment);
    			t27 = space();
    			create_component(button9.$$.fragment);
    			t28 = space();
    			if_block4.c();
    			t29 = space();
    			h34 = element("h3");
    			h34.textContent = "With Icon";
    			t31 = space();
    			create_component(button10.$$.fragment);
    			t32 = space();
    			create_component(button11.$$.fragment);
    			t33 = space();
    			if_block5.c();
    			if_block5_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$q, 5, 0, 145);
    			add_location(h30, file$q, 62, 0, 1290);
    			add_location(h31, file$q, 76, 0, 1520);
    			add_location(h32, file$q, 102, 0, 2255);
    			add_location(b0, file$q, 103, 3, 2282);
    			add_location(b1, file$q, 103, 18, 2297);
    			add_location(p, file$q, 103, 0, 2279);
    			add_location(h33, file$q, 120, 0, 2762);
    			add_location(h34, file$q, 143, 0, 3492);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(button0, target, anchor);
    			insert_dev(target, t5, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t9, anchor);
    			mount_component(button2, target, anchor);
    			insert_dev(target, t10, anchor);
    			mount_component(button3, target, anchor);
    			insert_dev(target, t11, anchor);
    			if_blocks_1[current_block_type_index_1].m(target, anchor);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, b0);
    			append_dev(p, t16);
    			append_dev(p, b1);
    			append_dev(p, t18);
    			insert_dev(target, t19, anchor);
    			mount_component(button4, target, anchor);
    			insert_dev(target, t20, anchor);
    			mount_component(button5, target, anchor);
    			insert_dev(target, t21, anchor);
    			if_blocks_2[current_block_type_index_2].m(target, anchor);
    			insert_dev(target, t22, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t24, anchor);
    			mount_component(button6, target, anchor);
    			insert_dev(target, t25, anchor);
    			mount_component(button7, target, anchor);
    			insert_dev(target, t26, anchor);
    			mount_component(button8, target, anchor);
    			insert_dev(target, t27, anchor);
    			mount_component(button9, target, anchor);
    			insert_dev(target, t28, anchor);
    			if_blocks_3[current_block_type_index_3].m(target, anchor);
    			insert_dev(target, t29, anchor);
    			insert_dev(target, h34, anchor);
    			insert_dev(target, t31, anchor);
    			mount_component(button10, target, anchor);
    			insert_dev(target, t32, anchor);
    			mount_component(button11, target, anchor);
    			insert_dev(target, t33, anchor);
    			if_blocks_4[current_block_type_index_4].m(target, anchor);
    			insert_dev(target, if_block5_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$sourceType*/ ctx[0] === 'svelte') {
    				if (if_block0) {
    					if (dirty & /*$sourceType*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(t6.parentNode, t6);
    			}

    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    			const button3_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button3_changes.$$scope = { dirty, ctx };
    			}

    			button3.$set(button3_changes);
    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks_1[current_block_type_index_1];

    				if (!if_block2) {
    					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(t12.parentNode, t12);
    			}

    			const button4_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button4_changes.$$scope = { dirty, ctx };
    			}

    			button4.$set(button4_changes);
    			const button5_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button5_changes.$$scope = { dirty, ctx };
    			}

    			button5.$set(button5_changes);
    			let previous_block_index_2 = current_block_type_index_2;
    			current_block_type_index_2 = select_block_type_2(ctx);

    			if (current_block_type_index_2 !== previous_block_index_2) {
    				group_outros();

    				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
    					if_blocks_2[previous_block_index_2] = null;
    				});

    				check_outros();
    				if_block3 = if_blocks_2[current_block_type_index_2];

    				if (!if_block3) {
    					if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
    					if_block3.c();
    				}

    				transition_in(if_block3, 1);
    				if_block3.m(t22.parentNode, t22);
    			}

    			const button6_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button6_changes.$$scope = { dirty, ctx };
    			}

    			button6.$set(button6_changes);
    			const button7_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button7_changes.$$scope = { dirty, ctx };
    			}

    			button7.$set(button7_changes);
    			const button8_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button8_changes.$$scope = { dirty, ctx };
    			}

    			button8.$set(button8_changes);
    			const button9_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button9_changes.$$scope = { dirty, ctx };
    			}

    			button9.$set(button9_changes);
    			let previous_block_index_3 = current_block_type_index_3;
    			current_block_type_index_3 = select_block_type_3(ctx);

    			if (current_block_type_index_3 !== previous_block_index_3) {
    				group_outros();

    				transition_out(if_blocks_3[previous_block_index_3], 1, 1, () => {
    					if_blocks_3[previous_block_index_3] = null;
    				});

    				check_outros();
    				if_block4 = if_blocks_3[current_block_type_index_3];

    				if (!if_block4) {
    					if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);
    					if_block4.c();
    				}

    				transition_in(if_block4, 1);
    				if_block4.m(t29.parentNode, t29);
    			}

    			const button10_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button10_changes.$$scope = { dirty, ctx };
    			}

    			button10.$set(button10_changes);
    			const button11_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button11_changes.$$scope = { dirty, ctx };
    			}

    			button11.$set(button11_changes);
    			let previous_block_index_4 = current_block_type_index_4;
    			current_block_type_index_4 = select_block_type_4(ctx);

    			if (current_block_type_index_4 !== previous_block_index_4) {
    				group_outros();

    				transition_out(if_blocks_4[previous_block_index_4], 1, 1, () => {
    					if_blocks_4[previous_block_index_4] = null;
    				});

    				check_outros();
    				if_block5 = if_blocks_4[current_block_type_index_4];

    				if (!if_block5) {
    					if_block5 = if_blocks_4[current_block_type_index_4] = if_block_creators_4[current_block_type_index_4](ctx);
    					if_block5.c();
    				}

    				transition_in(if_block5, 1);
    				if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(button0.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			transition_in(button3.$$.fragment, local);
    			transition_in(if_block2);
    			transition_in(button4.$$.fragment, local);
    			transition_in(button5.$$.fragment, local);
    			transition_in(if_block3);
    			transition_in(button6.$$.fragment, local);
    			transition_in(button7.$$.fragment, local);
    			transition_in(button8.$$.fragment, local);
    			transition_in(button9.$$.fragment, local);
    			transition_in(if_block4);
    			transition_in(button10.$$.fragment, local);
    			transition_in(button11.$$.fragment, local);
    			transition_in(if_block5);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(button0.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			transition_out(button3.$$.fragment, local);
    			transition_out(if_block2);
    			transition_out(button4.$$.fragment, local);
    			transition_out(button5.$$.fragment, local);
    			transition_out(if_block3);
    			transition_out(button6.$$.fragment, local);
    			transition_out(button7.$$.fragment, local);
    			transition_out(button8.$$.fragment, local);
    			transition_out(button9.$$.fragment, local);
    			transition_out(if_block4);
    			transition_out(button10.$$.fragment, local);
    			transition_out(button11.$$.fragment, local);
    			transition_out(if_block5);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t4);
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t5);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t8);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t9);
    			destroy_component(button2, detaching);
    			if (detaching) detach_dev(t10);
    			destroy_component(button3, detaching);
    			if (detaching) detach_dev(t11);
    			if_blocks_1[current_block_type_index_1].d(detaching);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t19);
    			destroy_component(button4, detaching);
    			if (detaching) detach_dev(t20);
    			destroy_component(button5, detaching);
    			if (detaching) detach_dev(t21);
    			if_blocks_2[current_block_type_index_2].d(detaching);
    			if (detaching) detach_dev(t22);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t24);
    			destroy_component(button6, detaching);
    			if (detaching) detach_dev(t25);
    			destroy_component(button7, detaching);
    			if (detaching) detach_dev(t26);
    			destroy_component(button8, detaching);
    			if (detaching) detach_dev(t27);
    			destroy_component(button9, detaching);
    			if (detaching) detach_dev(t28);
    			if_blocks_3[current_block_type_index_3].d(detaching);
    			if (detaching) detach_dev(t29);
    			if (detaching) detach_dev(h34);
    			if (detaching) detach_dev(t31);
    			destroy_component(button10, detaching);
    			if (detaching) detach_dev(t32);
    			destroy_component(button11, detaching);
    			if (detaching) detach_dev(t33);
    			if_blocks_4[current_block_type_index_4].d(detaching);
    			if (detaching) detach_dev(if_block5_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Button> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		sourceType,
    		Button,
    		Icon,
    		$sourceType
    	});

    	return [$sourceType];
    }

    class Button_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button_1",
    			options,
    			id: create_fragment$q.name
    		});
    	}
    }

    /* docs_src/components/ButtonGroup.svelte generated by Svelte v3.42.6 */
    const file$p = "docs_src/components/ButtonGroup.svelte";

    // (9:0) {#if $sourceType === 'svelte'}
    function create_if_block_4$2(ctx) {
    	let prism;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t13;
    	let td3;
    	let t14;
    	let tr2;
    	let td4;
    	let t16;
    	let td5;
    	let t18;
    	let td6;
    	let t19;
    	let td7;
    	let t20;
    	let tr3;
    	let td8;
    	let t22;
    	let td9;
    	let t24;
    	let td10;
    	let t25;
    	let td11;
    	let t26;
    	let tr4;
    	let td12;
    	let t28;
    	let td13;
    	let t30;
    	let td14;
    	let t31;
    	let td15;
    	let t32;
    	let tr5;
    	let td16;
    	let t34;
    	let td17;
    	let t36;
    	let td18;
    	let t38;
    	let td19;
    	let t39;
    	let tr6;
    	let td20;
    	let t41;
    	let td21;
    	let t43;
    	let td22;
    	let t45;
    	let td23;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_36] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "className";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "string";
    			t12 = space();
    			td2 = element("td");
    			t13 = space();
    			td3 = element("td");
    			t14 = space();
    			tr2 = element("tr");
    			td4 = element("td");
    			td4.textContent = "type";
    			t16 = space();
    			td5 = element("td");
    			td5.textContent = "'accept' | 'cancel' | 'primary' | 'secondary'";
    			t18 = space();
    			td6 = element("td");
    			t19 = space();
    			td7 = element("td");
    			t20 = space();
    			tr3 = element("tr");
    			td8 = element("td");
    			td8.textContent = "color";
    			t22 = space();
    			td9 = element("td");
    			td9.textContent = "EB Background color variable";
    			t24 = space();
    			td10 = element("td");
    			t25 = space();
    			td11 = element("td");
    			t26 = space();
    			tr4 = element("tr");
    			td12 = element("td");
    			td12.textContent = "colorHover";
    			t28 = space();
    			td13 = element("td");
    			td13.textContent = "EB Background color variable";
    			t30 = space();
    			td14 = element("td");
    			t31 = space();
    			td15 = element("td");
    			t32 = space();
    			tr5 = element("tr");
    			td16 = element("td");
    			td16.textContent = "solid";
    			t34 = space();
    			td17 = element("td");
    			td17.textContent = "boolean";
    			t36 = space();
    			td18 = element("td");
    			td18.textContent = "false";
    			t38 = space();
    			td19 = element("td");
    			t39 = space();
    			tr6 = element("tr");
    			td20 = element("td");
    			td20.textContent = "selectedId";
    			t41 = space();
    			td21 = element("td");
    			td21.textContent = "Writable - number";
    			t43 = space();
    			td22 = element("td");
    			td22.textContent = "0 (first button)";
    			t45 = space();
    			td23 = element("td");
    			td23.textContent = "Can be set onMount";
    			add_location(th0, file$p, 16, 8, 407);
    			add_location(th1, file$p, 17, 8, 434);
    			add_location(th2, file$p, 18, 8, 456);
    			add_location(th3, file$p, 19, 8, 487);
    			add_location(tr0, file$p, 15, 6, 394);
    			add_location(thead, file$p, 14, 4, 380);
    			add_location(td0, file$p, 24, 8, 564);
    			add_location(td1, file$p, 25, 8, 591);
    			add_location(td2, file$p, 26, 8, 615);
    			add_location(td3, file$p, 27, 8, 630);
    			add_location(tr1, file$p, 23, 6, 551);
    			add_location(td4, file$p, 30, 8, 668);
    			add_location(td5, file$p, 31, 8, 690);
    			add_location(td6, file$p, 32, 8, 753);
    			add_location(td7, file$p, 33, 8, 768);
    			add_location(tr2, file$p, 29, 6, 655);
    			add_location(td8, file$p, 36, 8, 806);
    			add_location(td9, file$p, 37, 8, 829);
    			add_location(td10, file$p, 38, 8, 875);
    			add_location(td11, file$p, 39, 8, 890);
    			add_location(tr3, file$p, 35, 6, 793);
    			add_location(td12, file$p, 42, 8, 928);
    			add_location(td13, file$p, 43, 8, 956);
    			add_location(td14, file$p, 44, 8, 1002);
    			add_location(td15, file$p, 45, 8, 1017);
    			add_location(tr4, file$p, 41, 6, 915);
    			add_location(td16, file$p, 48, 8, 1055);
    			add_location(td17, file$p, 49, 8, 1078);
    			add_location(td18, file$p, 50, 8, 1103);
    			add_location(td19, file$p, 51, 8, 1126);
    			add_location(tr5, file$p, 47, 6, 1042);
    			add_location(td20, file$p, 54, 8, 1164);
    			add_location(td21, file$p, 55, 8, 1192);
    			add_location(td22, file$p, 56, 8, 1227);
    			add_location(td23, file$p, 57, 8, 1261);
    			add_location(tr6, file$p, 53, 6, 1151);
    			add_location(tbody, file$p, 22, 4, 537);
    			attr_dev(table, "class", "table");
    			add_location(table, file$p, 13, 2, 354);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			append_dev(tbody, t14);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td4);
    			append_dev(tr2, t16);
    			append_dev(tr2, td5);
    			append_dev(tr2, t18);
    			append_dev(tr2, td6);
    			append_dev(tr2, t19);
    			append_dev(tr2, td7);
    			append_dev(tbody, t20);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td8);
    			append_dev(tr3, t22);
    			append_dev(tr3, td9);
    			append_dev(tr3, t24);
    			append_dev(tr3, td10);
    			append_dev(tr3, t25);
    			append_dev(tr3, td11);
    			append_dev(tbody, t26);
    			append_dev(tbody, tr4);
    			append_dev(tr4, td12);
    			append_dev(tr4, t28);
    			append_dev(tr4, td13);
    			append_dev(tr4, t30);
    			append_dev(tr4, td14);
    			append_dev(tr4, t31);
    			append_dev(tr4, td15);
    			append_dev(tbody, t32);
    			append_dev(tbody, tr5);
    			append_dev(tr5, td16);
    			append_dev(tr5, t34);
    			append_dev(tr5, td17);
    			append_dev(tr5, t36);
    			append_dev(tr5, td18);
    			append_dev(tr5, t38);
    			append_dev(tr5, td19);
    			append_dev(tbody, t39);
    			append_dev(tbody, tr6);
    			append_dev(tr6, td20);
    			append_dev(tr6, t41);
    			append_dev(tr6, td21);
    			append_dev(tr6, t43);
    			append_dev(tr6, td22);
    			append_dev(tr6, t45);
    			append_dev(tr6, td23);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(9:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (10:2) <Prism language="js">
    function create_default_slot_36(ctx) {
    	let t_value = `import { Button, ButtonGroup } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_36.name,
    		type: "slot",
    		source: "(10:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (68:2) <Button>
    function create_default_slot_35(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 1");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_35.name,
    		type: "slot",
    		source: "(68:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (69:2) <Button>
    function create_default_slot_34(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_34.name,
    		type: "slot",
    		source: "(69:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (70:2) <Button>
    function create_default_slot_33(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 3");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_33.name,
    		type: "slot",
    		source: "(70:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (67:0) <ButtonGroup className="margin-l--b" bind:selectedId>
    function create_default_slot_32(ctx) {
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let button2;
    	let current;

    	button0 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_35] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_34] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_33] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			create_component(button2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(button2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_32.name,
    		type: "slot",
    		source: "(67:0) <ButtonGroup className=\\\"margin-l--b\\\" bind:selectedId>",
    		ctx
    	});

    	return block;
    }

    // (81:0) {:else}
    function create_else_block_3$2(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_31] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3$2.name,
    		type: "else",
    		source: "(81:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (73:0) {#if $sourceType === 'svelte'}
    function create_if_block_3$3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_30] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(73:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (82:2) <Prism language="html">
    function create_default_slot_31(ctx) {
    	let t_value = `<div class="buttongroup">
  <button class="button"></button>
  <button class="button"></button>
  <button class="button"></button>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_31.name,
    		type: "slot",
    		source: "(82:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (74:2) <Prism language="html">
    function create_default_slot_30(ctx) {
    	let t_value = `<ButtonGroup bind:selectedId>
  <Button></Button>
  <Button></Button>
  <Button></Button>
</ButtonGroup>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_30.name,
    		type: "slot",
    		source: "(74:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (94:2) <Button>
    function create_default_slot_29(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Primary");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_29.name,
    		type: "slot",
    		source: "(94:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (95:2) <Button>
    function create_default_slot_28(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_28.name,
    		type: "slot",
    		source: "(95:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (96:2) <Button>
    function create_default_slot_27(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 3");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_27.name,
    		type: "slot",
    		source: "(96:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (93:0) <ButtonGroup type="primary" className="margin-m--b">
    function create_default_slot_26(ctx) {
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let button2;
    	let current;

    	button0 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_29] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_28] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_27] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			create_component(button2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(button2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_26.name,
    		type: "slot",
    		source: "(93:0) <ButtonGroup type=\\\"primary\\\" className=\\\"margin-m--b\\\">",
    		ctx
    	});

    	return block;
    }

    // (100:2) <Button>
    function create_default_slot_25(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Secondary");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_25.name,
    		type: "slot",
    		source: "(100:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (101:2) <Button>
    function create_default_slot_24(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_24.name,
    		type: "slot",
    		source: "(101:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (102:2) <Button>
    function create_default_slot_23(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 3");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_23.name,
    		type: "slot",
    		source: "(102:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (99:0) <ButtonGroup type="secondary" className="margin-m--b">
    function create_default_slot_22(ctx) {
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let button2;
    	let current;

    	button0 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_25] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_24] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_23] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			create_component(button2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(button2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_22.name,
    		type: "slot",
    		source: "(99:0) <ButtonGroup type=\\\"secondary\\\" className=\\\"margin-m--b\\\">",
    		ctx
    	});

    	return block;
    }

    // (106:2) <Button>
    function create_default_slot_21$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Accept");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21$1.name,
    		type: "slot",
    		source: "(106:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (107:2) <Button>
    function create_default_slot_20$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20$1.name,
    		type: "slot",
    		source: "(107:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (108:2) <Button>
    function create_default_slot_19$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 3");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19$1.name,
    		type: "slot",
    		source: "(108:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (105:0) <ButtonGroup type="accept" className="margin-m--b">
    function create_default_slot_18$1(ctx) {
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let button2;
    	let current;

    	button0 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_21$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_20$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_19$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			create_component(button2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(button2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18$1.name,
    		type: "slot",
    		source: "(105:0) <ButtonGroup type=\\\"accept\\\" className=\\\"margin-m--b\\\">",
    		ctx
    	});

    	return block;
    }

    // (112:2) <Button>
    function create_default_slot_17$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Cancel");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17$1.name,
    		type: "slot",
    		source: "(112:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (113:2) <Button>
    function create_default_slot_16$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$1.name,
    		type: "slot",
    		source: "(113:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (114:2) <Button>
    function create_default_slot_15$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 3");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$1.name,
    		type: "slot",
    		source: "(114:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (111:0) <ButtonGroup type="cancel" className="margin-l--b">
    function create_default_slot_14$2(ctx) {
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let button2;
    	let current;

    	button0 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_17$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_16$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_15$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			create_component(button2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(button2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$2.name,
    		type: "slot",
    		source: "(111:0) <ButtonGroup type=\\\"cancel\\\" className=\\\"margin-l--b\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:0) {:else}
    function create_else_block_2$3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_13$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$3.name,
    		type: "else",
    		source: "(124:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (117:0) {#if $sourceType === 'svelte'}
    function create_if_block_2$5(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_12$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(117:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (125:2) <Prism language="html">
    function create_default_slot_13$2(ctx) {
    	let t_value = `<div class="buttongroup buttongroup--primary">...</div>
<div class="buttongroup buttongroup--secondary">...</div>
<div class="buttongroup buttongroup--accept">...</div>
<div class="buttongroup buttongroup--cancel">...</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$2.name,
    		type: "slot",
    		source: "(125:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (118:2) <Prism language="html">
    function create_default_slot_12$2(ctx) {
    	let t_value = `<ButtonGroup type="primary">...</ButtonGroup>
<ButtonGroup type="secondary">...</ButtonGroup>
<ButtonGroup type="accept">...</ButtonGroup>
<ButtonGroup type="cancel">...</ButtonGroup>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$2.name,
    		type: "slot",
    		source: "(118:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (136:2) <Button>
    function create_default_slot_11$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 1");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$3.name,
    		type: "slot",
    		source: "(136:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (137:2) <Button>
    function create_default_slot_10$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$4.name,
    		type: "slot",
    		source: "(137:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (138:2) <Button>
    function create_default_slot_9$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 3");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$5.name,
    		type: "slot",
    		source: "(138:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (135:0) <ButtonGroup color="Bordeaux" className="margin-l--b">
    function create_default_slot_8$8(ctx) {
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let button2;
    	let current;

    	button0 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_11$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_10$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_9$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			create_component(button2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(button2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$8.name,
    		type: "slot",
    		source: "(135:0) <ButtonGroup color=\\\"Bordeaux\\\" className=\\\"margin-l--b\\\">",
    		ctx
    	});

    	return block;
    }

    // (145:0) {:else}
    function create_else_block_1$6(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_7$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$6.name,
    		type: "else",
    		source: "(145:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (141:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$7(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_6$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(141:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (146:2) <Prism language="html">
    function create_default_slot_7$8(ctx) {
    	let t_value = `<div class="buttongroup" style="
  --buttongroup-color: #8a0c36;
  --buttongroup-fgcolor: #fff;
  --buttongroup-color--hover: #8a0c36;
  --buttongroup-fgcolor--hover: #fff;
">...</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$8.name,
    		type: "slot",
    		source: "(146:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (142:2) <Prism language="html">
    function create_default_slot_6$a(ctx) {
    	let t_value = `<ButtonGroup color="Bordeaux">...</ButtonGroup>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$a.name,
    		type: "slot",
    		source: "(142:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (159:2) <Button>
    function create_default_slot_5$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 1");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$a.name,
    		type: "slot",
    		source: "(159:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (160:2) <Button>
    function create_default_slot_4$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$c.name,
    		type: "slot",
    		source: "(160:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (161:2) <Button>
    function create_default_slot_3$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Button 3");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$d.name,
    		type: "slot",
    		source: "(161:2) <Button>",
    		ctx
    	});

    	return block;
    }

    // (158:0) <ButtonGroup solid={true} color="Black" colorHover="Red" className="margin-l--b">
    function create_default_slot_2$i(ctx) {
    	let button0;
    	let t0;
    	let button1;
    	let t1;
    	let button2;
    	let current;

    	button0 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_5$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_4$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new Button({
    			props: {
    				$$slots: { default: [create_default_slot_3$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			create_component(button2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(button1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(button1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(button2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$i.name,
    		type: "slot",
    		source: "(158:0) <ButtonGroup solid={true} color=\\\"Black\\\" colorHover=\\\"Red\\\" className=\\\"margin-l--b\\\">",
    		ctx
    	});

    	return block;
    }

    // (168:0) {:else}
    function create_else_block$8(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(168:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (164:0) {#if $sourceType === 'svelte'}
    function create_if_block$8(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(164:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (169:2) <Prism language="html">
    function create_default_slot_1$j(ctx) {
    	let t_value = `<div class="buttongroup buttongroup--solid" style="
  --buttongroup-color: #000;
  --buttongroup-fgcolor: #fff;
  --buttongroup-color--hover: #bd1118;
  --buttongroup-fgcolor--hover: #fff;
">...</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$j.name,
    		type: "slot",
    		source: "(169:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (165:2) <Prism language="html">
    function create_default_slot$k(ctx) {
    	let t_value = `<ButtonGroup solid={true} color="Black" colorHover="Red">...</ButtonGroup>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$k.name,
    		type: "slot",
    		source: "(165:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let h1;
    	let t1;
    	let t2;
    	let h30;
    	let t4;
    	let p;
    	let t5;
    	let t6;
    	let t7;
    	let buttongroup0;
    	let updating_selectedId;
    	let t8;
    	let current_block_type_index;
    	let if_block1;
    	let t9;
    	let h31;
    	let t11;
    	let buttongroup1;
    	let t12;
    	let buttongroup2;
    	let t13;
    	let buttongroup3;
    	let t14;
    	let buttongroup4;
    	let t15;
    	let current_block_type_index_1;
    	let if_block2;
    	let t16;
    	let h32;
    	let t18;
    	let buttongroup5;
    	let t19;
    	let current_block_type_index_2;
    	let if_block3;
    	let t20;
    	let h33;
    	let t22;
    	let buttongroup6;
    	let t23;
    	let current_block_type_index_3;
    	let if_block4;
    	let if_block4_anchor;
    	let current;
    	let if_block0 = /*$sourceType*/ ctx[1] === 'svelte' && create_if_block_4$2(ctx);

    	function buttongroup0_selectedId_binding(value) {
    		/*buttongroup0_selectedId_binding*/ ctx[3](value);
    	}

    	let buttongroup0_props = {
    		className: "margin-l--b",
    		$$slots: { default: [create_default_slot_32] },
    		$$scope: { ctx }
    	};

    	if (/*selectedId*/ ctx[0] !== void 0) {
    		buttongroup0_props.selectedId = /*selectedId*/ ctx[0];
    	}

    	buttongroup0 = new ButtonGroup({
    			props: buttongroup0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(buttongroup0, 'selectedId', buttongroup0_selectedId_binding));
    	const if_block_creators = [create_if_block_3$3, create_else_block_3$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[1] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	buttongroup1 = new ButtonGroup({
    			props: {
    				type: "primary",
    				className: "margin-m--b",
    				$$slots: { default: [create_default_slot_26] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	buttongroup2 = new ButtonGroup({
    			props: {
    				type: "secondary",
    				className: "margin-m--b",
    				$$slots: { default: [create_default_slot_22] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	buttongroup3 = new ButtonGroup({
    			props: {
    				type: "accept",
    				className: "margin-m--b",
    				$$slots: { default: [create_default_slot_18$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	buttongroup4 = new ButtonGroup({
    			props: {
    				type: "cancel",
    				className: "margin-l--b",
    				$$slots: { default: [create_default_slot_14$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_1 = [create_if_block_2$5, create_else_block_2$3];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$sourceType*/ ctx[1] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	buttongroup5 = new ButtonGroup({
    			props: {
    				color: "Bordeaux",
    				className: "margin-l--b",
    				$$slots: { default: [create_default_slot_8$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_2 = [create_if_block_1$7, create_else_block_1$6];
    	const if_blocks_2 = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$sourceType*/ ctx[1] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_2 = select_block_type_2(ctx);
    	if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

    	buttongroup6 = new ButtonGroup({
    			props: {
    				solid: true,
    				color: "Black",
    				colorHover: "Red",
    				className: "margin-l--b",
    				$$slots: { default: [create_default_slot_2$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_3 = [create_if_block$8, create_else_block$8];
    	const if_blocks_3 = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*$sourceType*/ ctx[1] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_3 = select_block_type_3(ctx);
    	if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Button groups";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			h30 = element("h3");
    			h30.textContent = "Default";
    			t4 = space();
    			p = element("p");
    			t5 = text("Button-index selected: ");
    			t6 = text(/*$selectedId*/ ctx[2]);
    			t7 = space();
    			create_component(buttongroup0.$$.fragment);
    			t8 = space();
    			if_block1.c();
    			t9 = space();
    			h31 = element("h3");
    			h31.textContent = "Variations";
    			t11 = space();
    			create_component(buttongroup1.$$.fragment);
    			t12 = space();
    			create_component(buttongroup2.$$.fragment);
    			t13 = space();
    			create_component(buttongroup3.$$.fragment);
    			t14 = space();
    			create_component(buttongroup4.$$.fragment);
    			t15 = space();
    			if_block2.c();
    			t16 = space();
    			h32 = element("h3");
    			h32.textContent = "Farve muligheder fra eb-colors";
    			t18 = space();
    			create_component(buttongroup5.$$.fragment);
    			t19 = space();
    			if_block3.c();
    			t20 = space();
    			h33 = element("h3");
    			h33.textContent = "Solid button group";
    			t22 = space();
    			create_component(buttongroup6.$$.fragment);
    			t23 = space();
    			if_block4.c();
    			if_block4_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$p, 6, 0, 168);
    			add_location(h30, file$p, 63, 0, 1332);
    			add_location(p, file$p, 64, 0, 1349);
    			add_location(h31, file$p, 90, 0, 1927);
    			add_location(h32, file$p, 132, 0, 3100);
    			add_location(h33, file$p, 155, 0, 3665);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t5);
    			append_dev(p, t6);
    			insert_dev(target, t7, anchor);
    			mount_component(buttongroup0, target, anchor);
    			insert_dev(target, t8, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t11, anchor);
    			mount_component(buttongroup1, target, anchor);
    			insert_dev(target, t12, anchor);
    			mount_component(buttongroup2, target, anchor);
    			insert_dev(target, t13, anchor);
    			mount_component(buttongroup3, target, anchor);
    			insert_dev(target, t14, anchor);
    			mount_component(buttongroup4, target, anchor);
    			insert_dev(target, t15, anchor);
    			if_blocks_1[current_block_type_index_1].m(target, anchor);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t18, anchor);
    			mount_component(buttongroup5, target, anchor);
    			insert_dev(target, t19, anchor);
    			if_blocks_2[current_block_type_index_2].m(target, anchor);
    			insert_dev(target, t20, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t22, anchor);
    			mount_component(buttongroup6, target, anchor);
    			insert_dev(target, t23, anchor);
    			if_blocks_3[current_block_type_index_3].m(target, anchor);
    			insert_dev(target, if_block4_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$sourceType*/ ctx[1] === 'svelte') {
    				if (if_block0) {
    					if (dirty & /*$sourceType*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*$selectedId*/ 4) set_data_dev(t6, /*$selectedId*/ ctx[2]);
    			const buttongroup0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				buttongroup0_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_selectedId && dirty & /*selectedId*/ 1) {
    				updating_selectedId = true;
    				buttongroup0_changes.selectedId = /*selectedId*/ ctx[0];
    				add_flush_callback(() => updating_selectedId = false);
    			}

    			buttongroup0.$set(buttongroup0_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(t9.parentNode, t9);
    			}

    			const buttongroup1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				buttongroup1_changes.$$scope = { dirty, ctx };
    			}

    			buttongroup1.$set(buttongroup1_changes);
    			const buttongroup2_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				buttongroup2_changes.$$scope = { dirty, ctx };
    			}

    			buttongroup2.$set(buttongroup2_changes);
    			const buttongroup3_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				buttongroup3_changes.$$scope = { dirty, ctx };
    			}

    			buttongroup3.$set(buttongroup3_changes);
    			const buttongroup4_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				buttongroup4_changes.$$scope = { dirty, ctx };
    			}

    			buttongroup4.$set(buttongroup4_changes);
    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks_1[current_block_type_index_1];

    				if (!if_block2) {
    					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(t16.parentNode, t16);
    			}

    			const buttongroup5_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				buttongroup5_changes.$$scope = { dirty, ctx };
    			}

    			buttongroup5.$set(buttongroup5_changes);
    			let previous_block_index_2 = current_block_type_index_2;
    			current_block_type_index_2 = select_block_type_2(ctx);

    			if (current_block_type_index_2 !== previous_block_index_2) {
    				group_outros();

    				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
    					if_blocks_2[previous_block_index_2] = null;
    				});

    				check_outros();
    				if_block3 = if_blocks_2[current_block_type_index_2];

    				if (!if_block3) {
    					if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
    					if_block3.c();
    				}

    				transition_in(if_block3, 1);
    				if_block3.m(t20.parentNode, t20);
    			}

    			const buttongroup6_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				buttongroup6_changes.$$scope = { dirty, ctx };
    			}

    			buttongroup6.$set(buttongroup6_changes);
    			let previous_block_index_3 = current_block_type_index_3;
    			current_block_type_index_3 = select_block_type_3(ctx);

    			if (current_block_type_index_3 !== previous_block_index_3) {
    				group_outros();

    				transition_out(if_blocks_3[previous_block_index_3], 1, 1, () => {
    					if_blocks_3[previous_block_index_3] = null;
    				});

    				check_outros();
    				if_block4 = if_blocks_3[current_block_type_index_3];

    				if (!if_block4) {
    					if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);
    					if_block4.c();
    				}

    				transition_in(if_block4, 1);
    				if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(buttongroup0.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(buttongroup1.$$.fragment, local);
    			transition_in(buttongroup2.$$.fragment, local);
    			transition_in(buttongroup3.$$.fragment, local);
    			transition_in(buttongroup4.$$.fragment, local);
    			transition_in(if_block2);
    			transition_in(buttongroup5.$$.fragment, local);
    			transition_in(if_block3);
    			transition_in(buttongroup6.$$.fragment, local);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(buttongroup0.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(buttongroup1.$$.fragment, local);
    			transition_out(buttongroup2.$$.fragment, local);
    			transition_out(buttongroup3.$$.fragment, local);
    			transition_out(buttongroup4.$$.fragment, local);
    			transition_out(if_block2);
    			transition_out(buttongroup5.$$.fragment, local);
    			transition_out(if_block3);
    			transition_out(buttongroup6.$$.fragment, local);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t7);
    			destroy_component(buttongroup0, detaching);
    			if (detaching) detach_dev(t8);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t11);
    			destroy_component(buttongroup1, detaching);
    			if (detaching) detach_dev(t12);
    			destroy_component(buttongroup2, detaching);
    			if (detaching) detach_dev(t13);
    			destroy_component(buttongroup3, detaching);
    			if (detaching) detach_dev(t14);
    			destroy_component(buttongroup4, detaching);
    			if (detaching) detach_dev(t15);
    			if_blocks_1[current_block_type_index_1].d(detaching);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t18);
    			destroy_component(buttongroup5, detaching);
    			if (detaching) detach_dev(t19);
    			if_blocks_2[current_block_type_index_2].d(detaching);
    			if (detaching) detach_dev(t20);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t22);
    			destroy_component(buttongroup6, detaching);
    			if (detaching) detach_dev(t23);
    			if_blocks_3[current_block_type_index_3].d(detaching);
    			if (detaching) detach_dev(if_block4_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let $sourceType;

    	let $selectedId,
    		$$unsubscribe_selectedId = noop,
    		$$subscribe_selectedId = () => ($$unsubscribe_selectedId(), $$unsubscribe_selectedId = subscribe(selectedId, $$value => $$invalidate(2, $selectedId = $$value)), selectedId);

    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(1, $sourceType = $$value));
    	$$self.$$.on_destroy.push(() => $$unsubscribe_selectedId());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ButtonGroup', slots, []);
    	let selectedId;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ButtonGroup> was created with unknown prop '${key}'`);
    	});

    	function buttongroup0_selectedId_binding(value) {
    		selectedId = value;
    		$$subscribe_selectedId($$invalidate(0, selectedId));
    	}

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		sourceType,
    		Button,
    		ButtonGroup,
    		selectedId,
    		$sourceType,
    		$selectedId
    	});

    	$$self.$inject_state = $$props => {
    		if ('selectedId' in $$props) $$subscribe_selectedId($$invalidate(0, selectedId = $$props.selectedId));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [selectedId, $sourceType, $selectedId, buttongroup0_selectedId_binding];
    }

    class ButtonGroup_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ButtonGroup_1",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    /* docs_src/components/Card.svelte generated by Svelte v3.42.6 */
    const file$o = "docs_src/components/Card.svelte";

    // (8:0) {#if $sourceType === 'svelte'}
    function create_if_block_2$4(ctx) {
    	let prism;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t13;
    	let td3;
    	let t15;
    	let tr2;
    	let td4;
    	let t17;
    	let td5;
    	let t19;
    	let td6;
    	let t20;
    	let td7;
    	let t22;
    	let tr3;
    	let td8;
    	let t24;
    	let td9;
    	let t26;
    	let td10;
    	let t27;
    	let td11;
    	let t28;
    	let tr4;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_4$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "className";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "string";
    			t12 = space();
    			td2 = element("td");
    			t13 = space();
    			td3 = element("td");
    			td3.textContent = "Card specific classes: card--small-media & card--small-media--reverse";
    			t15 = space();
    			tr2 = element("tr");
    			td4 = element("td");
    			td4.textContent = "url";
    			t17 = space();
    			td5 = element("td");
    			td5.textContent = "string";
    			t19 = space();
    			td6 = element("td");
    			t20 = space();
    			td7 = element("td");
    			td7.textContent = "Converts the Card into a clickable link";
    			t22 = space();
    			tr3 = element("tr");
    			td8 = element("td");
    			td8.textContent = "style";
    			t24 = space();
    			td9 = element("td");
    			td9.textContent = "string";
    			t26 = space();
    			td10 = element("td");
    			t27 = space();
    			td11 = element("td");
    			t28 = space();
    			tr4 = element("tr");
    			add_location(th0, file$o, 15, 8, 352);
    			add_location(th1, file$o, 16, 8, 379);
    			add_location(th2, file$o, 17, 8, 401);
    			add_location(th3, file$o, 18, 8, 432);
    			add_location(tr0, file$o, 14, 6, 339);
    			add_location(thead, file$o, 13, 4, 325);
    			add_location(td0, file$o, 23, 8, 509);
    			add_location(td1, file$o, 24, 8, 536);
    			add_location(td2, file$o, 25, 8, 560);
    			add_location(td3, file$o, 26, 8, 575);
    			add_location(tr1, file$o, 22, 6, 496);
    			add_location(td4, file$o, 29, 8, 685);
    			add_location(td5, file$o, 30, 8, 706);
    			add_location(td6, file$o, 31, 8, 730);
    			add_location(td7, file$o, 32, 8, 745);
    			add_location(tr2, file$o, 28, 6, 672);
    			add_location(td8, file$o, 35, 8, 825);
    			add_location(td9, file$o, 36, 8, 848);
    			add_location(td10, file$o, 37, 8, 872);
    			add_location(td11, file$o, 38, 8, 887);
    			add_location(tr3, file$o, 34, 6, 812);
    			add_location(tr4, file$o, 40, 6, 912);
    			add_location(tbody, file$o, 21, 4, 482);
    			attr_dev(table, "class", "table");
    			add_location(table, file$o, 12, 2, 299);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			append_dev(tbody, t15);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td4);
    			append_dev(tr2, t17);
    			append_dev(tr2, td5);
    			append_dev(tr2, t19);
    			append_dev(tr2, td6);
    			append_dev(tr2, t20);
    			append_dev(tr2, td7);
    			append_dev(tbody, t22);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td8);
    			append_dev(tr3, t24);
    			append_dev(tr3, td9);
    			append_dev(tr3, t26);
    			append_dev(tr3, td10);
    			append_dev(tr3, t27);
    			append_dev(tr3, td11);
    			append_dev(tbody, t28);
    			append_dev(tbody, tr4);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(8:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (9:2) <Prism language="js">
    function create_default_slot_4$b(ctx) {
    	let t_value = `import { Card } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$b.name,
    		type: "slot",
    		source: "(9:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (49:2) 
    function create_header_slot$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Header";
    			attr_dev(div, "slot", "header");
    			add_location(div, file$o, 48, 2, 1004);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_header_slot$1.name,
    		type: "slot",
    		source: "(49:2) ",
    		ctx
    	});

    	return block;
    }

    // (50:2) 
    function create_media_slot_1(ctx) {
    	let div;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = "https://loremflickr.com/1280/400/cat")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$o, 50, 4, 1061);
    			attr_dev(div, "slot", "media");
    			add_location(div, file$o, 49, 2, 1038);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_media_slot_1.name,
    		type: "slot",
    		source: "(50:2) ",
    		ctx
    	});

    	return block;
    }

    // (53:2) 
    function create_content_slot_1$3(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Content";
    			attr_dev(div, "slot", "content");
    			add_location(div, file$o, 52, 2, 1130);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot_1$3.name,
    		type: "slot",
    		source: "(53:2) ",
    		ctx
    	});

    	return block;
    }

    // (54:2) 
    function create_footer_slot$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Footer";
    			attr_dev(div, "slot", "footer");
    			add_location(div, file$o, 53, 2, 1166);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_footer_slot$1.name,
    		type: "slot",
    		source: "(54:2) ",
    		ctx
    	});

    	return block;
    }

    // (68:0) {:else}
    function create_else_block_1$5(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_3$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$5.name,
    		type: "else",
    		source: "(68:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (57:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$6(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(57:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (69:2) <Prism language="html">
    function create_default_slot_3$c(ctx) {
    	let t_value = `<div class="card">
  <div class="card-header"></div>
  <div class="card-media">
    <img src="" alt="">
  </div>
  <div class="card-content"></div>
  <div class="card-footer"></div>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$c.name,
    		type: "slot",
    		source: "(69:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (58:2) <Prism language="html">
    function create_default_slot_2$h(ctx) {
    	let t_value = `<Card>
  <div slot="header"></div>
  <div slot="media">
    <img src="" alt="" />
  </div>
  <div slot="content"></div>
  <div slot="footer"></div>
</Card>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$h.name,
    		type: "slot",
    		source: "(58:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (84:2) 
    function create_media_slot(ctx) {
    	let div;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = "https://loremflickr.com/250/120/dog")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$o, 84, 4, 1789);
    			attr_dev(div, "slot", "media");
    			add_location(div, file$o, 83, 2, 1766);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_media_slot.name,
    		type: "slot",
    		source: "(84:2) ",
    		ctx
    	});

    	return block;
    }

    // (87:2) 
    function create_content_slot$5(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Content";
    			attr_dev(div, "slot", "content");
    			add_location(div, file$o, 86, 2, 1857);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot$5.name,
    		type: "slot",
    		source: "(87:2) ",
    		ctx
    	});

    	return block;
    }

    // (99:0) {:else}
    function create_else_block$7(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(99:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (90:0) {#if $sourceType === 'svelte'}
    function create_if_block$7(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(90:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (100:2) <Prism language="html">
    function create_default_slot_1$i(ctx) {
    	let t_value = `<div class="card card--small-media">
  <div class="card-media">
    <img src="" alt="" />
  </div>
  <div class="card-content"></div>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$i.name,
    		type: "slot",
    		source: "(100:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (91:2) <Prism language="html">
    function create_default_slot$j(ctx) {
    	let t_value = `<Card className="card--small-media">
  <div slot="media">
    <img src="" alt="" />
  </div>
  <div slot="content"></div>
</Card>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$j.name,
    		type: "slot",
    		source: "(91:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let h1;
    	let t1;
    	let t2;
    	let h30;
    	let t4;
    	let card0;
    	let t5;
    	let current_block_type_index;
    	let if_block1;
    	let t6;
    	let h31;
    	let t8;
    	let card1;
    	let t9;
    	let current_block_type_index_1;
    	let if_block2;
    	let if_block2_anchor;
    	let current;
    	let if_block0 = /*$sourceType*/ ctx[0] === 'svelte' && create_if_block_2$4(ctx);

    	card0 = new Card({
    			props: {
    				className: "margin-l--b",
    				$$slots: {
    					footer: [create_footer_slot$1],
    					content: [create_content_slot_1$3],
    					media: [create_media_slot_1],
    					header: [create_header_slot$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block_1$6, create_else_block_1$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	card1 = new Card({
    			props: {
    				className: "card--small-media margin-l--b",
    				$$slots: {
    					content: [create_content_slot$5],
    					media: [create_media_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_1 = [create_if_block$7, create_else_block$7];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Card";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			h30 = element("h3");
    			h30.textContent = "Card slots";
    			t4 = space();
    			create_component(card0.$$.fragment);
    			t5 = space();
    			if_block1.c();
    			t6 = space();
    			h31 = element("h3");
    			h31.textContent = "Small media card";
    			t8 = space();
    			create_component(card1.$$.fragment);
    			t9 = space();
    			if_block2.c();
    			if_block2_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$o, 5, 0, 137);
    			add_location(h30, file$o, 45, 0, 950);
    			add_location(h31, file$o, 80, 0, 1688);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(card0, target, anchor);
    			insert_dev(target, t5, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(card1, target, anchor);
    			insert_dev(target, t9, anchor);
    			if_blocks_1[current_block_type_index_1].m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$sourceType*/ ctx[0] === 'svelte') {
    				if (if_block0) {
    					if (dirty & /*$sourceType*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const card0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				card0_changes.$$scope = { dirty, ctx };
    			}

    			card0.$set(card0_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(t6.parentNode, t6);
    			}

    			const card1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				card1_changes.$$scope = { dirty, ctx };
    			}

    			card1.$set(card1_changes);
    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks_1[current_block_type_index_1];

    				if (!if_block2) {
    					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(card0.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(card1.$$.fragment, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(card0.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(card1.$$.fragment, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t4);
    			destroy_component(card0, detaching);
    			if (detaching) detach_dev(t5);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t8);
    			destroy_component(card1, detaching);
    			if (detaching) detach_dev(t9);
    			if_blocks_1[current_block_type_index_1].d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Card', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Card> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1, sourceType, Card, $sourceType });
    	return [$sourceType];
    }

    class Card_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Card_1",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    /* docs_src/components/FormElement.svelte generated by Svelte v3.42.6 */
    const file$n = "docs_src/components/FormElement.svelte";

    // (8:0) {#if $sourceType === 'svelte'}
    function create_if_block_5(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_11$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(8:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (9:2) <Prism language="js">
    function create_default_slot_11$2(ctx) {
    	let t_value = `import { FormElement } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$2.name,
    		type: "slot",
    		source: "(9:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (26:0) {:else}
    function create_else_block_4(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_10$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4.name,
    		type: "else",
    		source: "(26:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (20:0) {#if $sourceType === 'svelte'}
    function create_if_block_4$1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_9$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(20:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (27:2) <Prism language="html">
    function create_default_slot_10$3(ctx) {
    	let t_value = `FormElement er ikke blevet opdateret til HTML endnu` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$3.name,
    		type: "slot",
    		source: "(27:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (21:2) <Prism language="html">
    function create_default_slot_9$4(ctx) {
    	let t_value = `<FormElement inputtype="text" size="small" label="" />
<FormElement inputtype="text" label="" />
<FormElement inputtype="text" size="large" label="" />` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$4.name,
    		type: "slot",
    		source: "(21:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (40:0) {:else}
    function create_else_block_3$1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_8$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3$1.name,
    		type: "else",
    		source: "(40:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (36:0) {#if $sourceType === 'svelte'}
    function create_if_block_3$2(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_7$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(36:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (41:2) <Prism language="html">
    function create_default_slot_8$7(ctx) {
    	let t_value = `FormElement er ikke blevet opdateret til HTML endnu` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$7.name,
    		type: "slot",
    		source: "(41:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (37:2) <Prism language="html">
    function create_default_slot_7$7(ctx) {
    	let t_value = `<FormElement inputtype="number" label="" />` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$7.name,
    		type: "slot",
    		source: "(37:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (48:0) <FormElement inputtype="select" label="Select">
    function create_default_slot_6$9(ctx) {
    	let option0;
    	let t1;
    	let option1;

    	const block = {
    		c: function create() {
    			option0 = element("option");
    			option0.textContent = "Option 1";
    			t1 = space();
    			option1 = element("option");
    			option1.textContent = "Option 2";
    			option0.__value = "option1";
    			option0.value = option0.__value;
    			add_location(option0, file$n, 48, 2, 1287);
    			option1.__value = "option2";
    			option1.value = option1.__value;
    			add_location(option1, file$n, 49, 2, 1331);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, option1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(option1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$9.name,
    		type: "slot",
    		source: "(48:0) <FormElement inputtype=\\\"select\\\" label=\\\"Select\\\">",
    		ctx
    	});

    	return block;
    }

    // (60:0) {:else}
    function create_else_block_2$2(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_5$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$2.name,
    		type: "else",
    		source: "(60:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (53:0) {#if $sourceType === 'svelte'}
    function create_if_block_2$3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_4$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(53:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (61:2) <Prism language="html">
    function create_default_slot_5$9(ctx) {
    	let t_value = `FormElement er ikke blevet opdateret til HTML endnu` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$9.name,
    		type: "slot",
    		source: "(61:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (54:2) <Prism language="html">
    function create_default_slot_4$a(ctx) {
    	let t_value = `<FormElement inputtype="select" label="">
  <option value="option1"></option>
  <option value="option2"></option>
</FormElement>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$a.name,
    		type: "slot",
    		source: "(54:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (76:0) {:else}
    function create_else_block_1$4(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_3$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$4.name,
    		type: "else",
    		source: "(76:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (71:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$5(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(71:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (77:2) <Prism language="html">
    function create_default_slot_3$b(ctx) {
    	let t_value = `FormElement er ikke blevet opdateret til HTML endnu` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$b.name,
    		type: "slot",
    		source: "(77:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (72:2) <Prism language="html">
    function create_default_slot_2$g(ctx) {
    	let t_value = `<FormElement inputtype="checkbox" label="" />
<FormElement inputtype="radio" label="" bind:group={group} value={1} />` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$g.name,
    		type: "slot",
    		source: "(72:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (90:0) {:else}
    function create_else_block$6(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(90:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (86:0) {#if $sourceType === 'svelte'}
    function create_if_block$6(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(86:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (91:2) <Prism language="html">
    function create_default_slot_1$h(ctx) {
    	let t_value = `FormElement er ikke blevet opdateret til HTML endnu` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$h.name,
    		type: "slot",
    		source: "(91:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (87:2) <Prism language="html">
    function create_default_slot$i(ctx) {
    	let t_value = `<FormElement inputtype="textarea" label="" />` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$i.name,
    		type: "slot",
    		source: "(87:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let h1;
    	let t1;
    	let t2;
    	let h30;
    	let t4;
    	let formelement0;
    	let t5;
    	let formelement1;
    	let t6;
    	let formelement2;
    	let t7;
    	let current_block_type_index;
    	let if_block1;
    	let t8;
    	let h31;
    	let t10;
    	let formelement3;
    	let t11;
    	let current_block_type_index_1;
    	let if_block2;
    	let t12;
    	let h32;
    	let t14;
    	let formelement4;
    	let t15;
    	let current_block_type_index_2;
    	let if_block3;
    	let t16;
    	let h33;
    	let t18;
    	let formelement5;
    	let t19;
    	let formelement6;
    	let t20;
    	let current_block_type_index_3;
    	let if_block4;
    	let t21;
    	let h34;
    	let t23;
    	let formelement7;
    	let t24;
    	let current_block_type_index_4;
    	let if_block5;
    	let if_block5_anchor;
    	let current;
    	let if_block0 = /*$sourceType*/ ctx[0] === 'svelte' && create_if_block_5(ctx);

    	formelement0 = new FormElement({
    			props: {
    				inputtype: "text",
    				size: "small",
    				label: "input size small"
    			},
    			$$inline: true
    		});

    	formelement1 = new FormElement({
    			props: {
    				inputtype: "text",
    				label: "input size medium (standard)"
    			},
    			$$inline: true
    		});

    	formelement2 = new FormElement({
    			props: {
    				inputtype: "text",
    				size: "large",
    				label: "input size large"
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block_4$1, create_else_block_4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	formelement3 = new FormElement({
    			props: {
    				inputtype: "number",
    				label: "Noget tal indhold her"
    			},
    			$$inline: true
    		});

    	const if_block_creators_1 = [create_if_block_3$2, create_else_block_3$1];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	formelement4 = new FormElement({
    			props: {
    				inputtype: "select",
    				label: "Select",
    				$$slots: { default: [create_default_slot_6$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_2 = [create_if_block_2$3, create_else_block_2$2];
    	const if_blocks_2 = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_2 = select_block_type_2(ctx);
    	if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

    	formelement5 = new FormElement({
    			props: { inputtype: "checkbox", label: "Checkbox" },
    			$$inline: true
    		});

    	formelement6 = new FormElement({
    			props: {
    				inputtype: "radio",
    				label: "Radio",
    				value: 1
    			},
    			$$inline: true
    		});

    	const if_block_creators_3 = [create_if_block_1$5, create_else_block_1$4];
    	const if_blocks_3 = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_3 = select_block_type_3(ctx);
    	if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);

    	formelement7 = new FormElement({
    			props: { inputtype: "textarea", label: "Textarea" },
    			$$inline: true
    		});

    	const if_block_creators_4 = [create_if_block$6, create_else_block$6];
    	const if_blocks_4 = [];

    	function select_block_type_4(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_4 = select_block_type_4(ctx);
    	if_block5 = if_blocks_4[current_block_type_index_4] = if_block_creators_4[current_block_type_index_4](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Form Element";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			h30 = element("h3");
    			h30.textContent = "Text input";
    			t4 = space();
    			create_component(formelement0.$$.fragment);
    			t5 = space();
    			create_component(formelement1.$$.fragment);
    			t6 = space();
    			create_component(formelement2.$$.fragment);
    			t7 = space();
    			if_block1.c();
    			t8 = space();
    			h31 = element("h3");
    			h31.textContent = "Number input";
    			t10 = space();
    			create_component(formelement3.$$.fragment);
    			t11 = space();
    			if_block2.c();
    			t12 = space();
    			h32 = element("h3");
    			h32.textContent = "Select";
    			t14 = space();
    			create_component(formelement4.$$.fragment);
    			t15 = space();
    			if_block3.c();
    			t16 = space();
    			h33 = element("h3");
    			h33.textContent = "Checkbox and radio";
    			t18 = space();
    			create_component(formelement5.$$.fragment);
    			t19 = space();
    			create_component(formelement6.$$.fragment);
    			t20 = space();
    			if_block4.c();
    			t21 = space();
    			h34 = element("h3");
    			h34.textContent = "Textarea";
    			t23 = space();
    			create_component(formelement7.$$.fragment);
    			t24 = space();
    			if_block5.c();
    			if_block5_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$n, 5, 0, 144);
    			add_location(h30, file$n, 13, 0, 325);
    			add_location(h31, file$n, 31, 0, 899);
    			add_location(h32, file$n, 45, 0, 1220);
    			add_location(h33, file$n, 65, 0, 1706);
    			add_location(h34, file$n, 81, 0, 2154);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(formelement0, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(formelement1, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(formelement2, target, anchor);
    			insert_dev(target, t7, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t10, anchor);
    			mount_component(formelement3, target, anchor);
    			insert_dev(target, t11, anchor);
    			if_blocks_1[current_block_type_index_1].m(target, anchor);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t14, anchor);
    			mount_component(formelement4, target, anchor);
    			insert_dev(target, t15, anchor);
    			if_blocks_2[current_block_type_index_2].m(target, anchor);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t18, anchor);
    			mount_component(formelement5, target, anchor);
    			insert_dev(target, t19, anchor);
    			mount_component(formelement6, target, anchor);
    			insert_dev(target, t20, anchor);
    			if_blocks_3[current_block_type_index_3].m(target, anchor);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, h34, anchor);
    			insert_dev(target, t23, anchor);
    			mount_component(formelement7, target, anchor);
    			insert_dev(target, t24, anchor);
    			if_blocks_4[current_block_type_index_4].m(target, anchor);
    			insert_dev(target, if_block5_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$sourceType*/ ctx[0] === 'svelte') {
    				if (if_block0) {
    					if (dirty & /*$sourceType*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(t8.parentNode, t8);
    			}

    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks_1[current_block_type_index_1];

    				if (!if_block2) {
    					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(t12.parentNode, t12);
    			}

    			const formelement4_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				formelement4_changes.$$scope = { dirty, ctx };
    			}

    			formelement4.$set(formelement4_changes);
    			let previous_block_index_2 = current_block_type_index_2;
    			current_block_type_index_2 = select_block_type_2(ctx);

    			if (current_block_type_index_2 !== previous_block_index_2) {
    				group_outros();

    				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
    					if_blocks_2[previous_block_index_2] = null;
    				});

    				check_outros();
    				if_block3 = if_blocks_2[current_block_type_index_2];

    				if (!if_block3) {
    					if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
    					if_block3.c();
    				}

    				transition_in(if_block3, 1);
    				if_block3.m(t16.parentNode, t16);
    			}

    			let previous_block_index_3 = current_block_type_index_3;
    			current_block_type_index_3 = select_block_type_3(ctx);

    			if (current_block_type_index_3 !== previous_block_index_3) {
    				group_outros();

    				transition_out(if_blocks_3[previous_block_index_3], 1, 1, () => {
    					if_blocks_3[previous_block_index_3] = null;
    				});

    				check_outros();
    				if_block4 = if_blocks_3[current_block_type_index_3];

    				if (!if_block4) {
    					if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);
    					if_block4.c();
    				}

    				transition_in(if_block4, 1);
    				if_block4.m(t21.parentNode, t21);
    			}

    			let previous_block_index_4 = current_block_type_index_4;
    			current_block_type_index_4 = select_block_type_4(ctx);

    			if (current_block_type_index_4 !== previous_block_index_4) {
    				group_outros();

    				transition_out(if_blocks_4[previous_block_index_4], 1, 1, () => {
    					if_blocks_4[previous_block_index_4] = null;
    				});

    				check_outros();
    				if_block5 = if_blocks_4[current_block_type_index_4];

    				if (!if_block5) {
    					if_block5 = if_blocks_4[current_block_type_index_4] = if_block_creators_4[current_block_type_index_4](ctx);
    					if_block5.c();
    				}

    				transition_in(if_block5, 1);
    				if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(formelement0.$$.fragment, local);
    			transition_in(formelement1.$$.fragment, local);
    			transition_in(formelement2.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(formelement3.$$.fragment, local);
    			transition_in(if_block2);
    			transition_in(formelement4.$$.fragment, local);
    			transition_in(if_block3);
    			transition_in(formelement5.$$.fragment, local);
    			transition_in(formelement6.$$.fragment, local);
    			transition_in(if_block4);
    			transition_in(formelement7.$$.fragment, local);
    			transition_in(if_block5);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(formelement0.$$.fragment, local);
    			transition_out(formelement1.$$.fragment, local);
    			transition_out(formelement2.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(formelement3.$$.fragment, local);
    			transition_out(if_block2);
    			transition_out(formelement4.$$.fragment, local);
    			transition_out(if_block3);
    			transition_out(formelement5.$$.fragment, local);
    			transition_out(formelement6.$$.fragment, local);
    			transition_out(if_block4);
    			transition_out(formelement7.$$.fragment, local);
    			transition_out(if_block5);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t4);
    			destroy_component(formelement0, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(formelement1, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(formelement2, detaching);
    			if (detaching) detach_dev(t7);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t10);
    			destroy_component(formelement3, detaching);
    			if (detaching) detach_dev(t11);
    			if_blocks_1[current_block_type_index_1].d(detaching);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t14);
    			destroy_component(formelement4, detaching);
    			if (detaching) detach_dev(t15);
    			if_blocks_2[current_block_type_index_2].d(detaching);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t18);
    			destroy_component(formelement5, detaching);
    			if (detaching) detach_dev(t19);
    			destroy_component(formelement6, detaching);
    			if (detaching) detach_dev(t20);
    			if_blocks_3[current_block_type_index_3].d(detaching);
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(h34);
    			if (detaching) detach_dev(t23);
    			destroy_component(formelement7, detaching);
    			if (detaching) detach_dev(t24);
    			if_blocks_4[current_block_type_index_4].d(detaching);
    			if (detaching) detach_dev(if_block5_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FormElement', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FormElement> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		sourceType,
    		FormElement,
    		$sourceType
    	});

    	return [$sourceType];
    }

    class FormElement_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FormElement_1",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    const iconnames = ['angledown', 'angleleft', 'angleright', 'angleup', 'article', 'at', 'check', 'clock', 'creditcard', 'ebplus_icon', 'ebplus_sort', 'envelope', 'figcaptionpin', 'gallery', 'headphones', 'headset', 'historyregular', 'lightning', 'lock', 'medielogin', 'menubars', 'mitebregular', 'mitebsolid', 'newspaper', 'phone', 'play', 'rss', 'smartphone', 'starregular', 'tagregular', 'tagsolid', 'tagsregular', 'tagssolid', 'toggleoff', 'toggleon', 'video'];

    const graphicnames = ['ekstrabladet'];

    /* docs_src/components/Icon.svelte generated by Svelte v3.42.6 */
    const file$m = "docs_src/components/Icon.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    // (10:0) {#if $sourceType === 'svelte'}
    function create_if_block_3$1(ctx) {
    	let prism;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t13;
    	let td3;
    	let t15;
    	let tr2;
    	let td4;
    	let t16;
    	let badge;
    	let t17;
    	let td5;
    	let t19;
    	let td6;
    	let t20;
    	let td7;
    	let t22;
    	let tr3;
    	let td8;
    	let t24;
    	let td9;
    	let t26;
    	let td10;
    	let t28;
    	let td11;
    	let t30;
    	let tr4;
    	let td12;
    	let t32;
    	let td13;
    	let t34;
    	let td14;
    	let t36;
    	let td15;
    	let t38;
    	let tr5;
    	let td16;
    	let t40;
    	let td17;
    	let t42;
    	let td18;
    	let t43;
    	let td19;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_9$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	badge = new Badge({
    			props: {
    				type: "primary",
    				extension: "small",
    				$$slots: { default: [create_default_slot_8$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "className";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "string";
    			t12 = space();
    			td2 = element("td");
    			t13 = space();
    			td3 = element("td");
    			td3.textContent = "Used to select icon if type is set to 'fa'";
    			t15 = space();
    			tr2 = element("tr");
    			td4 = element("td");
    			t16 = text("name ");
    			create_component(badge.$$.fragment);
    			t17 = space();
    			td5 = element("td");
    			td5.textContent = "IconTypes";
    			t19 = space();
    			td6 = element("td");
    			t20 = space();
    			td7 = element("td");
    			td7.textContent = "Only names listed beneath are valid";
    			t22 = space();
    			tr3 = element("tr");
    			td8 = element("td");
    			td8.textContent = "type";
    			t24 = space();
    			td9 = element("td");
    			td9.textContent = "'svg' | 'fa'";
    			t26 = space();
    			td10 = element("td");
    			td10.textContent = "svg";
    			t28 = space();
    			td11 = element("td");
    			td11.textContent = "Use EB svg icons or FontAwesome icons";
    			t30 = space();
    			tr4 = element("tr");
    			td12 = element("td");
    			td12.textContent = "width";
    			t32 = space();
    			td13 = element("td");
    			td13.textContent = "number";
    			t34 = space();
    			td14 = element("td");
    			td14.textContent = "36";
    			t36 = space();
    			td15 = element("td");
    			td15.textContent = "The widthof the icon in pixels. Only on 'svg' mode";
    			t38 = space();
    			tr5 = element("tr");
    			td16 = element("td");
    			td16.textContent = "style";
    			t40 = space();
    			td17 = element("td");
    			td17.textContent = "string";
    			t42 = space();
    			td18 = element("td");
    			t43 = space();
    			td19 = element("td");
    			td19.textContent = "Custom styling. Only on 'svg' mode";
    			add_location(th0, file$m, 17, 8, 523);
    			add_location(th1, file$m, 18, 8, 550);
    			add_location(th2, file$m, 19, 8, 572);
    			add_location(th3, file$m, 20, 8, 603);
    			add_location(tr0, file$m, 16, 6, 510);
    			add_location(thead, file$m, 15, 4, 496);
    			add_location(td0, file$m, 25, 8, 680);
    			add_location(td1, file$m, 26, 8, 707);
    			add_location(td2, file$m, 27, 8, 731);
    			add_location(td3, file$m, 28, 8, 746);
    			add_location(tr1, file$m, 24, 6, 667);
    			add_location(td4, file$m, 31, 8, 829);
    			add_location(td5, file$m, 32, 8, 908);
    			add_location(td6, file$m, 33, 8, 935);
    			add_location(td7, file$m, 34, 8, 950);
    			add_location(tr2, file$m, 30, 6, 816);
    			add_location(td8, file$m, 37, 8, 1026);
    			add_location(td9, file$m, 38, 8, 1048);
    			add_location(td10, file$m, 39, 8, 1078);
    			add_location(td11, file$m, 40, 8, 1099);
    			add_location(tr3, file$m, 36, 6, 1013);
    			add_location(td12, file$m, 43, 8, 1177);
    			add_location(td13, file$m, 44, 8, 1200);
    			add_location(td14, file$m, 45, 8, 1224);
    			add_location(td15, file$m, 46, 8, 1244);
    			add_location(tr4, file$m, 42, 6, 1164);
    			add_location(td16, file$m, 49, 8, 1335);
    			add_location(td17, file$m, 50, 8, 1358);
    			add_location(td18, file$m, 51, 8, 1382);
    			add_location(td19, file$m, 52, 8, 1397);
    			add_location(tr5, file$m, 48, 6, 1322);
    			add_location(tbody, file$m, 23, 4, 653);
    			attr_dev(table, "class", "table");
    			add_location(table, file$m, 14, 2, 470);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			append_dev(tbody, t15);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td4);
    			append_dev(td4, t16);
    			mount_component(badge, td4, null);
    			append_dev(tr2, t17);
    			append_dev(tr2, td5);
    			append_dev(tr2, t19);
    			append_dev(tr2, td6);
    			append_dev(tr2, t20);
    			append_dev(tr2, td7);
    			append_dev(tbody, t22);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td8);
    			append_dev(tr3, t24);
    			append_dev(tr3, td9);
    			append_dev(tr3, t26);
    			append_dev(tr3, td10);
    			append_dev(tr3, t28);
    			append_dev(tr3, td11);
    			append_dev(tbody, t30);
    			append_dev(tbody, tr4);
    			append_dev(tr4, td12);
    			append_dev(tr4, t32);
    			append_dev(tr4, td13);
    			append_dev(tr4, t34);
    			append_dev(tr4, td14);
    			append_dev(tr4, t36);
    			append_dev(tr4, td15);
    			append_dev(tbody, t38);
    			append_dev(tbody, tr5);
    			append_dev(tr5, td16);
    			append_dev(tr5, t40);
    			append_dev(tr5, td17);
    			append_dev(tr5, t42);
    			append_dev(tr5, td18);
    			append_dev(tr5, t43);
    			append_dev(tr5, td19);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			transition_in(badge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			transition_out(badge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    			destroy_component(badge);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(10:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (11:2) <Prism language="js">
    function create_default_slot_9$3(ctx) {
    	let t_value = `import { Icon } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$3.name,
    		type: "slot",
    		source: "(11:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (32:17) <Badge type="primary" extension="small">
    function create_default_slot_8$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("required");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$6.name,
    		type: "slot",
    		source: "(32:17) <Badge type=\\\"primary\\\" extension=\\\"small\\\">",
    		ctx
    	});

    	return block;
    }

    // (66:4) <Card className="flex-align--center flex-justify--center margin-s padding-m">
    function create_default_slot_7$6(ctx) {
    	let icon;
    	let t0;
    	let small;
    	let t1_value = /*name*/ ctx[1] + "";
    	let t1;
    	let t2;
    	let current;

    	icon = new Icon({
    			props: {
    				name: /*name*/ ctx[1],
    				className: "margin-s",
    				style: "width: 36px; height: 36px;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    			t0 = space();
    			small = element("small");
    			t1 = text(t1_value);
    			t2 = space();
    			add_location(small, file$m, 67, 6, 1883);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, small, anchor);
    			append_dev(small, t1);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(small);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$6.name,
    		type: "slot",
    		source: "(66:4) <Card className=\\\"flex-align--center flex-justify--center margin-s padding-m\\\">",
    		ctx
    	});

    	return block;
    }

    // (65:2) {#each iconnames as name}
    function create_each_block_1$2(ctx) {
    	let card;
    	let current;

    	card = new Card({
    			props: {
    				className: "flex-align--center flex-justify--center margin-s padding-m",
    				$$slots: { default: [create_default_slot_7$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(card.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(card, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const card_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				card_changes.$$scope = { dirty, ctx };
    			}

    			card.$set(card_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(card, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(65:2) {#each iconnames as name}",
    		ctx
    	});

    	return block;
    }

    // (77:0) {:else}
    function create_else_block_2$1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_6$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(77:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (73:0) {#if $sourceType === 'svelte'}
    function create_if_block_2$2(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_5$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(73:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (78:2) <Prism language="html">
    function create_default_slot_6$8(ctx) {
    	let t_value = `<svg viewBox="0 0 50 50">
  <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#icon_name"></use>
</svg>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$8.name,
    		type: "slot",
    		source: "(78:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (74:2) <Prism language="html">
    function create_default_slot_5$8(ctx) {
    	let t_value = `<Icon name="icon_name" />` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$8.name,
    		type: "slot",
    		source: "(74:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (90:4) <Card className="flex-align--center flex-justify--center margin-s padding-m">
    function create_default_slot_4$9(ctx) {
    	let icon;
    	let t0;
    	let small;
    	let t1_value = /*name*/ ctx[1] + "";
    	let t1;
    	let t2;
    	let current;

    	icon = new Icon({
    			props: {
    				name: /*name*/ ctx[1],
    				className: "margin-s",
    				style: "width: 36px; height: 36px;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    			t0 = space();
    			small = element("small");
    			t1 = text(t1_value);
    			t2 = space();
    			add_location(small, file$m, 91, 6, 2554);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, small, anchor);
    			append_dev(small, t1);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(small);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$9.name,
    		type: "slot",
    		source: "(90:4) <Card className=\\\"flex-align--center flex-justify--center margin-s padding-m\\\">",
    		ctx
    	});

    	return block;
    }

    // (89:2) {#each graphicnames as name}
    function create_each_block$5(ctx) {
    	let card;
    	let current;

    	card = new Card({
    			props: {
    				className: "flex-align--center flex-justify--center margin-s padding-m",
    				$$slots: { default: [create_default_slot_4$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(card.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(card, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const card_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				card_changes.$$scope = { dirty, ctx };
    			}

    			card.$set(card_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(card, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(89:2) {#each graphicnames as name}",
    		ctx
    	});

    	return block;
    }

    // (101:0) {:else}
    function create_else_block_1$3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_3$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(101:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (97:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$4(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(97:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (102:2) <Prism language="html">
    function create_default_slot_3$a(ctx) {
    	let t_value = `<svg viewBox="0 0 50 50">
  <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#icon_name"></use>
</svg>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$a.name,
    		type: "slot",
    		source: "(102:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (98:2) <Prism language="html">
    function create_default_slot_2$f(ctx) {
    	let t_value = `<Icon name="icon_name" />` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$f.name,
    		type: "slot",
    		source: "(98:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (116:0) {:else}
    function create_else_block$5(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(116:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (112:0) {#if $sourceType === 'svelte'}
    function create_if_block$5(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(112:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (117:2) <Prism language="html">
    function create_default_slot_1$g(ctx) {
    	let t_value = `<i class="fas fa-snowplow"></i>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$g.name,
    		type: "slot",
    		source: "(117:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (113:2) <Prism language="html">
    function create_default_slot$h(ctx) {
    	let t_value = `<Icon type="fa" className="fas fa-snowplow" />` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$h.name,
    		type: "slot",
    		source: "(113:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let h1;
    	let t1;
    	let t2;
    	let h30;
    	let t4;
    	let p0;
    	let t6;
    	let div0;
    	let t7;
    	let current_block_type_index;
    	let if_block1;
    	let t8;
    	let h31;
    	let t10;
    	let p1;
    	let t12;
    	let div1;
    	let t13;
    	let current_block_type_index_1;
    	let if_block2;
    	let t14;
    	let h32;
    	let a;
    	let t16;
    	let t17;
    	let icon;
    	let t18;
    	let current_block_type_index_2;
    	let if_block3;
    	let if_block3_anchor;
    	let current;
    	let if_block0 = /*$sourceType*/ ctx[0] === 'svelte' && create_if_block_3$1(ctx);
    	let each_value_1 = iconnames;
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	const if_block_creators = [create_if_block_2$2, create_else_block_2$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let each_value = graphicnames;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const if_block_creators_1 = [create_if_block_1$4, create_else_block_1$3];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	icon = new Icon({
    			props: { type: "fa", className: "fas fa-snowplow" },
    			$$inline: true
    		});

    	const if_block_creators_2 = [create_if_block$5, create_else_block$5];
    	const if_blocks_2 = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_2 = select_block_type_2(ctx);
    	if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Icon library";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			h30 = element("h3");
    			h30.textContent = "Icons";
    			t4 = space();
    			p0 = element("p");
    			p0.textContent = "Icons are simple and dynamic only made with fill. Fill has the value currentColor and makes it possible to add the\n  desired color to the icon.";
    			t6 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t7 = space();
    			if_block1.c();
    			t8 = space();
    			h31 = element("h3");
    			h31.textContent = "Graphics";
    			t10 = space();
    			p1 = element("p");
    			p1.textContent = "Graphics are capable of containing more layers i.e static colors on stroke and fill.";
    			t12 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t13 = space();
    			if_block2.c();
    			t14 = space();
    			h32 = element("h3");
    			a = element("a");
    			a.textContent = "Font Awesome";
    			t16 = text(" icons");
    			t17 = space();
    			create_component(icon.$$.fragment);
    			t18 = space();
    			if_block3.c();
    			if_block3_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$m, 7, 0, 300);
    			add_location(h30, file$m, 58, 0, 1484);
    			add_location(p0, file$m, 59, 0, 1499);
    			attr_dev(div0, "class", "flex flex-wrap--wrap");
    			add_location(div0, file$m, 63, 0, 1654);
    			add_location(h31, file$m, 84, 0, 2211);
    			add_location(p1, file$m, 85, 0, 2229);
    			attr_dev(div1, "class", "flex flex-wrap--wrap");
    			add_location(div1, file$m, 87, 0, 2322);
    			attr_dev(a, "href", "https://fontawesome.com/");
    			attr_dev(a, "target", "_blank");
    			add_location(a, file$m, 108, 4, 2886);
    			add_location(h32, file$m, 108, 0, 2882);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, div0, anchor);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div0, null);
    			}

    			insert_dev(target, t7, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, div1, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			insert_dev(target, t13, anchor);
    			if_blocks_1[current_block_type_index_1].m(target, anchor);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, h32, anchor);
    			append_dev(h32, a);
    			append_dev(h32, t16);
    			insert_dev(target, t17, anchor);
    			mount_component(icon, target, anchor);
    			insert_dev(target, t18, anchor);
    			if_blocks_2[current_block_type_index_2].m(target, anchor);
    			insert_dev(target, if_block3_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$sourceType*/ ctx[0] === 'svelte') {
    				if (if_block0) {
    					if (dirty & /*$sourceType*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*iconnames*/ 0) {
    				each_value_1 = iconnames;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_1$2(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(t8.parentNode, t8);
    			}

    			if (dirty & /*graphicnames*/ 0) {
    				each_value = graphicnames;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div1, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}

    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks_1[current_block_type_index_1];

    				if (!if_block2) {
    					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(t14.parentNode, t14);
    			}

    			let previous_block_index_2 = current_block_type_index_2;
    			current_block_type_index_2 = select_block_type_2(ctx);

    			if (current_block_type_index_2 !== previous_block_index_2) {
    				group_outros();

    				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
    					if_blocks_2[previous_block_index_2] = null;
    				});

    				check_outros();
    				if_block3 = if_blocks_2[current_block_type_index_2];

    				if (!if_block3) {
    					if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
    					if_block3.c();
    				}

    				transition_in(if_block3, 1);
    				if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			transition_in(if_block1);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block2);
    			transition_in(icon.$$.fragment, local);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			transition_out(if_block1);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block2);
    			transition_out(icon.$$.fragment, local);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(div0);
    			destroy_each(each_blocks_1, detaching);
    			if (detaching) detach_dev(t7);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t13);
    			if_blocks_1[current_block_type_index_1].d(detaching);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t17);
    			destroy_component(icon, detaching);
    			if (detaching) detach_dev(t18);
    			if_blocks_2[current_block_type_index_2].d(detaching);
    			if (detaching) detach_dev(if_block3_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Icon', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Icon> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		sourceType,
    		Badge,
    		Card,
    		Icon,
    		iconnames,
    		graphicnames,
    		$sourceType
    	});

    	return [$sourceType];
    }

    class Icon_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon_1",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    /* docs_src/components/HorizontalScroll.svelte generated by Svelte v3.42.6 */
    const file$l = "docs_src/components/HorizontalScroll.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (56:0) {:else}
    function create_else_block_1$2(ctx) {
    	let p;
    	let t1;
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_8$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "HorizontalScroll kræver javascript som findes under list-v2 på eb";
    			t1 = space();
    			create_component(prism.$$.fragment);
    			add_location(p, file$l, 56, 2, 1494);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t1);
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(56:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (33:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$3(ctx) {
    	let prism;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t13;
    	let td3;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_7$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "className";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "string";
    			t12 = space();
    			td2 = element("td");
    			t13 = space();
    			td3 = element("td");
    			add_location(th0, file$l, 40, 8, 1218);
    			add_location(th1, file$l, 41, 8, 1245);
    			add_location(th2, file$l, 42, 8, 1267);
    			add_location(th3, file$l, 43, 8, 1298);
    			add_location(tr0, file$l, 39, 6, 1205);
    			add_location(thead, file$l, 38, 4, 1191);
    			add_location(td0, file$l, 48, 8, 1375);
    			add_location(td1, file$l, 49, 8, 1402);
    			add_location(td2, file$l, 50, 8, 1426);
    			add_location(td3, file$l, 51, 8, 1441);
    			add_location(tr1, file$l, 47, 6, 1362);
    			add_location(tbody, file$l, 46, 4, 1348);
    			attr_dev(table, "class", "table");
    			add_location(table, file$l, 37, 2, 1165);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(33:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (58:2) <Prism language="html">
    function create_default_slot_8$5(ctx) {
    	let t_value = `ekstrabladet/ekstrabladet-publication/src/main/webapp/WEB-INF/jsp/components/list-v2/horizontalscroll.ts` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$5.name,
    		type: "slot",
    		source: "(58:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (34:2) <Prism language="js">
    function create_default_slot_7$5(ctx) {
    	let t_value = `import { HorizontalScroll } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$5.name,
    		type: "slot",
    		source: "(34:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (63:0) <HorizontalScroll>
    function create_default_slot_6$7(ctx) {
    	let articlecard;
    	let current;
    	const articlecard_spread_levels = [/*singleArt*/ ctx[3], { className: "margin-s" }, { style: "width: 215px;" }];
    	let articlecard_props = {};

    	for (let i = 0; i < articlecard_spread_levels.length; i += 1) {
    		articlecard_props = assign(articlecard_props, articlecard_spread_levels[i]);
    	}

    	articlecard = new ArticleCard({ props: articlecard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(articlecard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(articlecard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const articlecard_changes = (dirty & /*singleArt*/ 8)
    			? get_spread_update(articlecard_spread_levels, [
    					get_spread_object(/*singleArt*/ ctx[3]),
    					articlecard_spread_levels[1],
    					articlecard_spread_levels[2]
    				])
    			: {};

    			articlecard.$set(articlecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(articlecard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$7.name,
    		type: "slot",
    		source: "(63:0) <HorizontalScroll>",
    		ctx
    	});

    	return block;
    }

    // (68:2) {#each doubleArt as article}
    function create_each_block_3(ctx) {
    	let articlecard;
    	let current;
    	const articlecard_spread_levels = [/*article*/ ctx[9], { className: "margin-s" }, { style: "width: 215px;" }];
    	let articlecard_props = {};

    	for (let i = 0; i < articlecard_spread_levels.length; i += 1) {
    		articlecard_props = assign(articlecard_props, articlecard_spread_levels[i]);
    	}

    	articlecard = new ArticleCard({ props: articlecard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(articlecard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(articlecard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const articlecard_changes = (dirty & /*doubleArt*/ 16)
    			? get_spread_update(articlecard_spread_levels, [
    					get_spread_object(/*article*/ ctx[9]),
    					articlecard_spread_levels[1],
    					articlecard_spread_levels[2]
    				])
    			: {};

    			articlecard.$set(articlecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(articlecard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(68:2) {#each doubleArt as article}",
    		ctx
    	});

    	return block;
    }

    // (67:0) <HorizontalScroll>
    function create_default_slot_5$7(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_3 = /*doubleArt*/ ctx[4];
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*doubleArt*/ 16) {
    				each_value_3 = /*doubleArt*/ ctx[4];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$7.name,
    		type: "slot",
    		source: "(67:0) <HorizontalScroll>",
    		ctx
    	});

    	return block;
    }

    // (74:2) {#each threeArt as article}
    function create_each_block_2(ctx) {
    	let articlecard;
    	let current;
    	const articlecard_spread_levels = [/*article*/ ctx[9], { className: "margin-s" }, { style: "width: 215px;" }];
    	let articlecard_props = {};

    	for (let i = 0; i < articlecard_spread_levels.length; i += 1) {
    		articlecard_props = assign(articlecard_props, articlecard_spread_levels[i]);
    	}

    	articlecard = new ArticleCard({ props: articlecard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(articlecard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(articlecard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const articlecard_changes = (dirty & /*threeArt*/ 32)
    			? get_spread_update(articlecard_spread_levels, [
    					get_spread_object(/*article*/ ctx[9]),
    					articlecard_spread_levels[1],
    					articlecard_spread_levels[2]
    				])
    			: {};

    			articlecard.$set(articlecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(articlecard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(74:2) {#each threeArt as article}",
    		ctx
    	});

    	return block;
    }

    // (73:0) <HorizontalScroll>
    function create_default_slot_4$8(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_2 = /*threeArt*/ ctx[5];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*threeArt*/ 32) {
    				each_value_2 = /*threeArt*/ ctx[5];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$8.name,
    		type: "slot",
    		source: "(73:0) <HorizontalScroll>",
    		ctx
    	});

    	return block;
    }

    // (80:2) {#each fourArt as article}
    function create_each_block_1$1(ctx) {
    	let articlecard;
    	let current;
    	const articlecard_spread_levels = [/*article*/ ctx[9], { className: "margin-s" }, { style: "width: 215px;" }];
    	let articlecard_props = {};

    	for (let i = 0; i < articlecard_spread_levels.length; i += 1) {
    		articlecard_props = assign(articlecard_props, articlecard_spread_levels[i]);
    	}

    	articlecard = new ArticleCard({ props: articlecard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(articlecard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(articlecard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const articlecard_changes = (dirty & /*fourArt*/ 64)
    			? get_spread_update(articlecard_spread_levels, [
    					get_spread_object(/*article*/ ctx[9]),
    					articlecard_spread_levels[1],
    					articlecard_spread_levels[2]
    				])
    			: {};

    			articlecard.$set(articlecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(articlecard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(80:2) {#each fourArt as article}",
    		ctx
    	});

    	return block;
    }

    // (79:0) <HorizontalScroll>
    function create_default_slot_3$9(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*fourArt*/ ctx[6];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fourArt*/ 64) {
    				each_value_1 = /*fourArt*/ ctx[6];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$9.name,
    		type: "slot",
    		source: "(79:0) <HorizontalScroll>",
    		ctx
    	});

    	return block;
    }

    // (86:2) {#each $articles as article}
    function create_each_block$4(ctx) {
    	let articlecard;
    	let current;
    	const articlecard_spread_levels = [/*article*/ ctx[9], { className: "margin-s" }, { style: "width: 215px;" }];
    	let articlecard_props = {};

    	for (let i = 0; i < articlecard_spread_levels.length; i += 1) {
    		articlecard_props = assign(articlecard_props, articlecard_spread_levels[i]);
    	}

    	articlecard = new ArticleCard({ props: articlecard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(articlecard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(articlecard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const articlecard_changes = (dirty & /*$articles*/ 2)
    			? get_spread_update(articlecard_spread_levels, [
    					get_spread_object(/*article*/ ctx[9]),
    					articlecard_spread_levels[1],
    					articlecard_spread_levels[2]
    				])
    			: {};

    			articlecard.$set(articlecard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(articlecard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(86:2) {#each $articles as article}",
    		ctx
    	});

    	return block;
    }

    // (85:0) <HorizontalScroll>
    function create_default_slot_2$e(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*$articles*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$articles*/ 2) {
    				each_value = /*$articles*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$e.name,
    		type: "slot",
    		source: "(85:0) <HorizontalScroll>",
    		ctx
    	});

    	return block;
    }

    // (97:0) {:else}
    function create_else_block$4(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(97:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (91:0) {#if $sourceType === 'svelte'}
    function create_if_block$4(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(91:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (98:2) <Prism language="html">
    function create_default_slot_1$f(ctx) {
    	let t_value = `<div id="example-id" class="horizontal-scroll-container position-relative">
  <button data-horizontallist="button-prev" class="horizontal-scroll-nav">
    <i class="fa fa-chevron-left"></i>
  </button>
  <button data-horizontallist="button-next" class="horizontal-scroll-nav">
    <i class="fa fa-chevron-right"></i>
  </button>
  <div data-horizontallist="itemcontainer" class="horizontal-scroll-items flex">
    ...
  </div>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$f.name,
    		type: "slot",
    		source: "(98:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (92:2) <Prism language="html">
    function create_default_slot$g(ctx) {
    	let t_value = `<HorizontalScroll>
  ...
</HorizontalScroll>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$g.name,
    		type: "slot",
    		source: "(92:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let h1;
    	let t1;
    	let current_block_type_index;
    	let if_block0;
    	let t2;
    	let horizontalscroll0;
    	let t3;
    	let horizontalscroll1;
    	let t4;
    	let horizontalscroll2;
    	let t5;
    	let horizontalscroll3;
    	let t6;
    	let horizontalscroll4;
    	let t7;
    	let current_block_type_index_1;
    	let if_block1;
    	let if_block1_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$3, create_else_block_1$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	horizontalscroll0 = new HorizontalScroll({
    			props: {
    				$$slots: { default: [create_default_slot_6$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	horizontalscroll1 = new HorizontalScroll({
    			props: {
    				$$slots: { default: [create_default_slot_5$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	horizontalscroll2 = new HorizontalScroll({
    			props: {
    				$$slots: { default: [create_default_slot_4$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	horizontalscroll3 = new HorizontalScroll({
    			props: {
    				$$slots: { default: [create_default_slot_3$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	horizontalscroll4 = new HorizontalScroll({
    			props: {
    				$$slots: { default: [create_default_slot_2$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_1 = [create_if_block$4, create_else_block$4];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Horizontal Scroll";
    			t1 = space();
    			if_block0.c();
    			t2 = space();
    			create_component(horizontalscroll0.$$.fragment);
    			t3 = space();
    			create_component(horizontalscroll1.$$.fragment);
    			t4 = space();
    			create_component(horizontalscroll2.$$.fragment);
    			t5 = space();
    			create_component(horizontalscroll3.$$.fragment);
    			t6 = space();
    			create_component(horizontalscroll4.$$.fragment);
    			t7 = space();
    			if_block1.c();
    			if_block1_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$l, 31, 0, 979);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(horizontalscroll0, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(horizontalscroll1, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(horizontalscroll2, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(horizontalscroll3, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(horizontalscroll4, target, anchor);
    			insert_dev(target, t7, anchor);
    			if_blocks_1[current_block_type_index_1].m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(t2.parentNode, t2);
    			}

    			const horizontalscroll0_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				horizontalscroll0_changes.$$scope = { dirty, ctx };
    			}

    			horizontalscroll0.$set(horizontalscroll0_changes);
    			const horizontalscroll1_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				horizontalscroll1_changes.$$scope = { dirty, ctx };
    			}

    			horizontalscroll1.$set(horizontalscroll1_changes);
    			const horizontalscroll2_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				horizontalscroll2_changes.$$scope = { dirty, ctx };
    			}

    			horizontalscroll2.$set(horizontalscroll2_changes);
    			const horizontalscroll3_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				horizontalscroll3_changes.$$scope = { dirty, ctx };
    			}

    			horizontalscroll3.$set(horizontalscroll3_changes);
    			const horizontalscroll4_changes = {};

    			if (dirty & /*$$scope, $articles*/ 262146) {
    				horizontalscroll4_changes.$$scope = { dirty, ctx };
    			}

    			horizontalscroll4.$set(horizontalscroll4_changes);
    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks_1[current_block_type_index_1];

    				if (!if_block1) {
    					if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(horizontalscroll0.$$.fragment, local);
    			transition_in(horizontalscroll1.$$.fragment, local);
    			transition_in(horizontalscroll2.$$.fragment, local);
    			transition_in(horizontalscroll3.$$.fragment, local);
    			transition_in(horizontalscroll4.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(horizontalscroll0.$$.fragment, local);
    			transition_out(horizontalscroll1.$$.fragment, local);
    			transition_out(horizontalscroll2.$$.fragment, local);
    			transition_out(horizontalscroll3.$$.fragment, local);
    			transition_out(horizontalscroll4.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(horizontalscroll0, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(horizontalscroll1, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(horizontalscroll2, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(horizontalscroll3, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(horizontalscroll4, detaching);
    			if (detaching) detach_dev(t7);
    			if_blocks_1[current_block_type_index_1].d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const max = 20;

    function instance$l($$self, $$props, $$invalidate) {
    	let $sourceType;
    	let $articles;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('HorizontalScroll', slots, []);
    	let articles = writable([rdmArticleData(640, 360), rdmArticleData(640, 360)]);
    	validate_store(articles, 'articles');
    	component_subscribe($$self, articles, value => $$invalidate(1, $articles = value));
    	let count = 2;

    	const addingInterval = setInterval(
    		() => {
    			if (count < max) {
    				articles.update(art => {
    					art.push(rdmArticleData(640, 360));
    					return art;
    				});
    			} else {
    				clearInterval(addingInterval);
    			}

    			count++;
    		},
    		3000
    	);

    	const singleArt = rdmArticleData(640, 360);
    	const doubleArt = [rdmArticleData(640, 360), rdmArticleData(640, 360)];
    	const threeArt = [rdmArticleData(640, 360), rdmArticleData(640, 360), rdmArticleData(640, 360)];

    	const fourArt = [
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360),
    		rdmArticleData(640, 360)
    	];

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<HorizontalScroll> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		rdmArticleData,
    		sourceType,
    		ArticleCard,
    		HorizontalScroll,
    		writable,
    		articles,
    		max,
    		count,
    		addingInterval,
    		singleArt,
    		doubleArt,
    		threeArt,
    		fourArt,
    		$sourceType,
    		$articles
    	});

    	$$self.$inject_state = $$props => {
    		if ('articles' in $$props) $$invalidate(2, articles = $$props.articles);
    		if ('count' in $$props) count = $$props.count;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$sourceType, $articles, articles, singleArt, doubleArt, threeArt, fourArt];
    }

    class HorizontalScroll_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HorizontalScroll_1",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* docs_src/components/Spinner.svelte generated by Svelte v3.42.6 */
    const file$k = "docs_src/components/Spinner.svelte";

    // (8:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$2(ctx) {
    	let prism;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t14;
    	let td3;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_2$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "isLoading";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "boolean";
    			t12 = space();
    			td2 = element("td");
    			td2.textContent = "false";
    			t14 = space();
    			td3 = element("td");
    			td3.textContent = "Will only show if set to 'true'";
    			add_location(th0, file$k, 15, 8, 361);
    			add_location(th1, file$k, 16, 8, 388);
    			add_location(th2, file$k, 17, 8, 410);
    			add_location(th3, file$k, 18, 8, 441);
    			add_location(tr0, file$k, 14, 6, 348);
    			add_location(thead, file$k, 13, 4, 334);
    			add_location(td0, file$k, 23, 8, 518);
    			add_location(td1, file$k, 24, 8, 545);
    			add_location(td2, file$k, 25, 8, 570);
    			add_location(td3, file$k, 26, 8, 593);
    			add_location(tr1, file$k, 22, 6, 505);
    			add_location(tbody, file$k, 21, 4, 491);
    			attr_dev(table, "class", "table");
    			add_location(table, file$k, 12, 2, 308);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t14);
    			append_dev(tr1, td3);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(8:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (9:2) <Prism language="js">
    function create_default_slot_2$d(ctx) {
    	let t_value = `import { Spinner } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$d.name,
    		type: "slot",
    		source: "(9:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (41:0) {:else}
    function create_else_block$3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(41:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (37:0) {#if $sourceType === 'svelte'}
    function create_if_block$3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(37:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (42:2) <Prism language="html">
    function create_default_slot_1$e(ctx) {
    	let t_value = `<div class="loader flex flex--center">
  <i class="fas fa-circle bounce bounce1" />
  <i class="fas fa-circle bounce bounce2" />
  <i class="fas fa-circle bounce bounce3" />
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$e.name,
    		type: "slot",
    		source: "(42:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (38:2) <Prism language="html">
    function create_default_slot$f(ctx) {
    	let t_value = `<Spinner isLoading={true}/>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(38:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let h1;
    	let t1;
    	let t2;
    	let div;
    	let spinner;
    	let t3;
    	let current_block_type_index;
    	let if_block1;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*$sourceType*/ ctx[0] === 'svelte' && create_if_block_1$2(ctx);

    	spinner = new Spinner({
    			props: { isLoading: true },
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block$3, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Spinner";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			div = element("div");
    			create_component(spinner.$$.fragment);
    			t3 = space();
    			if_block1.c();
    			if_block1_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$k, 5, 0, 140);
    			attr_dev(div, "class", "padding-l");
    			add_location(div, file$k, 32, 0, 677);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(spinner, div, null);
    			insert_dev(target, t3, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$sourceType*/ ctx[0] === 'svelte') {
    				if (if_block0) {
    					if (dirty & /*$sourceType*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(spinner.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(spinner.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div);
    			destroy_component(spinner);
    			if (detaching) detach_dev(t3);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Spinner', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Spinner> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1, sourceType, Spinner, $sourceType });
    	return [$sourceType];
    }

    class Spinner_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Spinner_1",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    /* docs_src/components/Tabs.svelte generated by Svelte v3.42.6 */
    const file$j = "docs_src/components/Tabs.svelte";

    // (110:0) {:else}
    function create_else_block$2(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Tabs er en ren Svelte component.";
    			add_location(p, file$j, 110, 2, 2586);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(110:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (12:0) {#if $sourceType === 'svelte'}
    function create_if_block$2(ctx) {
    	let prism0;
    	let t0;
    	let h20;
    	let t2;
    	let tabs0;
    	let t3;
    	let prism1;
    	let t4;
    	let h21;
    	let t6;
    	let tabs1;
    	let t7;
    	let prism2;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_21] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabs0 = new Tabs({
    			props: {
    				$$slots: { default: [create_default_slot_10$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_9$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabs1 = new Tabs({
    			props: {
    				$$slots: { default: [create_default_slot_1$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism0.$$.fragment);
    			t0 = space();
    			h20 = element("h2");
    			h20.textContent = "Style: Tabs";
    			t2 = space();
    			create_component(tabs0.$$.fragment);
    			t3 = space();
    			create_component(prism1.$$.fragment);
    			t4 = space();
    			h21 = element("h2");
    			h21.textContent = "Style: Pillnavigation";
    			t6 = space();
    			create_component(tabs1.$$.fragment);
    			t7 = space();
    			create_component(prism2.$$.fragment);
    			attr_dev(h20, "class", "margin-xl--t margin-m--b");
    			add_location(h20, file$j, 16, 2, 494);
    			attr_dev(h21, "class", "margin-xl--t margin-m--b");
    			add_location(h21, file$j, 63, 2, 1445);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, h20, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(tabs0, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, h21, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(tabs1, target, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(prism2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const tabs0_changes = {};

    			if (dirty & /*$$scope, content3, content2, content1*/ 135) {
    				tabs0_changes.$$scope = { dirty, ctx };
    			}

    			tabs0.$set(tabs0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    			const tabs1_changes = {};

    			if (dirty & /*$$scope, content3, content2, content1*/ 135) {
    				tabs1_changes.$$scope = { dirty, ctx };
    			}

    			tabs1.$set(tabs1_changes);
    			const prism2_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				prism2_changes.$$scope = { dirty, ctx };
    			}

    			prism2.$set(prism2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(tabs0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(tabs1.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(tabs0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(tabs1.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(h20);
    			if (detaching) detach_dev(t2);
    			destroy_component(tabs0, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(h21);
    			if (detaching) detach_dev(t6);
    			destroy_component(tabs1, detaching);
    			if (detaching) detach_dev(t7);
    			destroy_component(prism2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(12:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (13:2) <Prism language="js">
    function create_default_slot_21(ctx) {
    	let t_value = `import { Tabs, Tab, TabContent, TabList } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_21.name,
    		type: "slot",
    		source: "(13:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (21:6) <Tab>
    function create_default_slot_20(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Tab 1");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20.name,
    		type: "slot",
    		source: "(21:6) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (22:6) <Tab>
    function create_default_slot_19(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Tab 2 Long Text Bla Bla");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19.name,
    		type: "slot",
    		source: "(22:6) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (23:6) <Tab>
    function create_default_slot_18(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Tab 3 Long Text Bla Bla");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18.name,
    		type: "slot",
    		source: "(23:6) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (20:4) <TabList>
    function create_default_slot_17(ctx) {
    	let tab0;
    	let t0;
    	let tab1;
    	let t1;
    	let tab2;
    	let current;

    	tab0 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_20] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tab1 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_19] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tab2 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_18] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tab0.$$.fragment);
    			t0 = space();
    			create_component(tab1.$$.fragment);
    			t1 = space();
    			create_component(tab2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tab0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tab1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tab2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tab0_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				tab0_changes.$$scope = { dirty, ctx };
    			}

    			tab0.$set(tab0_changes);
    			const tab1_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				tab1_changes.$$scope = { dirty, ctx };
    			}

    			tab1.$set(tab1_changes);
    			const tab2_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				tab2_changes.$$scope = { dirty, ctx };
    			}

    			tab2.$set(tab2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab0.$$.fragment, local);
    			transition_in(tab1.$$.fragment, local);
    			transition_in(tab2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab0.$$.fragment, local);
    			transition_out(tab1.$$.fragment, local);
    			transition_out(tab2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tab0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tab1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tab2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17.name,
    		type: "slot",
    		source: "(20:4) <TabList>",
    		ctx
    	});

    	return block;
    }

    // (26:6) <Card className="margin-m--t">
    function create_default_slot_16(ctx) {
    	let html_tag;
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(/*content1*/ ctx[0], target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content1*/ 1) html_tag.p(/*content1*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16.name,
    		type: "slot",
    		source: "(26:6) <Card className=\\\"margin-m--t\\\">",
    		ctx
    	});

    	return block;
    }

    // (27:8) 
    function create_header_slot_5(ctx) {
    	let h2;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Content 1";
    			attr_dev(h2, "slot", "header");
    			add_location(h2, file$j, 26, 8, 754);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_header_slot_5.name,
    		type: "slot",
    		source: "(27:8) ",
    		ctx
    	});

    	return block;
    }

    // (25:4) <TabContent>
    function create_default_slot_15(ctx) {
    	let card;
    	let current;

    	card = new Card({
    			props: {
    				className: "margin-m--t",
    				$$slots: {
    					header: [create_header_slot_5],
    					default: [create_default_slot_16]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(card.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(card, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const card_changes = {};

    			if (dirty & /*$$scope, content1*/ 129) {
    				card_changes.$$scope = { dirty, ctx };
    			}

    			card.$set(card_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(card, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15.name,
    		type: "slot",
    		source: "(25:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (32:6) <Card className="margin-m--t">
    function create_default_slot_14$1(ctx) {
    	let html_tag;
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(/*content2*/ ctx[1], target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content2*/ 2) html_tag.p(/*content2*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$1.name,
    		type: "slot",
    		source: "(32:6) <Card className=\\\"margin-m--t\\\">",
    		ctx
    	});

    	return block;
    }

    // (33:8) 
    function create_header_slot_4(ctx) {
    	let h2;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Content 2";
    			attr_dev(h2, "slot", "header");
    			add_location(h2, file$j, 32, 8, 906);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_header_slot_4.name,
    		type: "slot",
    		source: "(33:8) ",
    		ctx
    	});

    	return block;
    }

    // (31:4) <TabContent>
    function create_default_slot_13$1(ctx) {
    	let card;
    	let current;

    	card = new Card({
    			props: {
    				className: "margin-m--t",
    				$$slots: {
    					header: [create_header_slot_4],
    					default: [create_default_slot_14$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(card.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(card, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const card_changes = {};

    			if (dirty & /*$$scope, content2*/ 130) {
    				card_changes.$$scope = { dirty, ctx };
    			}

    			card.$set(card_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(card, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$1.name,
    		type: "slot",
    		source: "(31:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (38:6) <Card className="margin-m--t">
    function create_default_slot_12$1(ctx) {
    	let html_tag;
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(/*content3*/ ctx[2], target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content3*/ 4) html_tag.p(/*content3*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$1.name,
    		type: "slot",
    		source: "(38:6) <Card className=\\\"margin-m--t\\\">",
    		ctx
    	});

    	return block;
    }

    // (39:8) 
    function create_header_slot_3(ctx) {
    	let h2;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Content 3";
    			attr_dev(h2, "slot", "header");
    			add_location(h2, file$j, 38, 8, 1058);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_header_slot_3.name,
    		type: "slot",
    		source: "(39:8) ",
    		ctx
    	});

    	return block;
    }

    // (37:4) <TabContent>
    function create_default_slot_11$1(ctx) {
    	let card;
    	let current;

    	card = new Card({
    			props: {
    				className: "margin-m--t",
    				$$slots: {
    					header: [create_header_slot_3],
    					default: [create_default_slot_12$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(card.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(card, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const card_changes = {};

    			if (dirty & /*$$scope, content3*/ 132) {
    				card_changes.$$scope = { dirty, ctx };
    			}

    			card.$set(card_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(card, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$1.name,
    		type: "slot",
    		source: "(37:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (19:2) <Tabs>
    function create_default_slot_10$2(ctx) {
    	let tablist;
    	let t0;
    	let tabcontent0;
    	let t1;
    	let tabcontent1;
    	let t2;
    	let tabcontent2;
    	let current;

    	tablist = new TabList({
    			props: {
    				$$slots: { default: [create_default_slot_17] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent0 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_15] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent1 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_13$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent2 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_11$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tablist.$$.fragment);
    			t0 = space();
    			create_component(tabcontent0.$$.fragment);
    			t1 = space();
    			create_component(tabcontent1.$$.fragment);
    			t2 = space();
    			create_component(tabcontent2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tablist, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tabcontent0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tabcontent1, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(tabcontent2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tablist_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				tablist_changes.$$scope = { dirty, ctx };
    			}

    			tablist.$set(tablist_changes);
    			const tabcontent0_changes = {};

    			if (dirty & /*$$scope, content1*/ 129) {
    				tabcontent0_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent0.$set(tabcontent0_changes);
    			const tabcontent1_changes = {};

    			if (dirty & /*$$scope, content2*/ 130) {
    				tabcontent1_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent1.$set(tabcontent1_changes);
    			const tabcontent2_changes = {};

    			if (dirty & /*$$scope, content3*/ 132) {
    				tabcontent2_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent2.$set(tabcontent2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tablist.$$.fragment, local);
    			transition_in(tabcontent0.$$.fragment, local);
    			transition_in(tabcontent1.$$.fragment, local);
    			transition_in(tabcontent2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tablist.$$.fragment, local);
    			transition_out(tabcontent0.$$.fragment, local);
    			transition_out(tabcontent1.$$.fragment, local);
    			transition_out(tabcontent2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tablist, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tabcontent0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tabcontent1, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(tabcontent2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$2.name,
    		type: "slot",
    		source: "(19:2) <Tabs>",
    		ctx
    	});

    	return block;
    }

    // (45:2) <Prism language="html">
    function create_default_slot_9$2(ctx) {
    	let t_value = `<Tabs>
  <TabList>
    <Tab>Tab 1</Tab>
    <Tab>Tab 2</Tab>
    <Tab>Tab 3</Tab>
  </TabList>
  <TabContent>
    Content 1
  </TabContent>
  <TabContent>
    Content 2
  </TabContent>
  <TabContent>
    Content 3
  </TabContent>
</Tabs>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$2.name,
    		type: "slot",
    		source: "(45:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (68:6) <Tab>
    function create_default_slot_8$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Tab 1");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$4.name,
    		type: "slot",
    		source: "(68:6) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (69:6) <Tab>
    function create_default_slot_7$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Tab 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$4.name,
    		type: "slot",
    		source: "(69:6) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (70:6) <Tab>
    function create_default_slot_6$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Tab 3");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$6.name,
    		type: "slot",
    		source: "(70:6) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (67:4) <TabList type="pillnavigation">
    function create_default_slot_5$6(ctx) {
    	let tab0;
    	let t0;
    	let tab1;
    	let t1;
    	let tab2;
    	let current;

    	tab0 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_8$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tab1 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_7$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tab2 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_6$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tab0.$$.fragment);
    			t0 = space();
    			create_component(tab1.$$.fragment);
    			t1 = space();
    			create_component(tab2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tab0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tab1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tab2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tab0_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				tab0_changes.$$scope = { dirty, ctx };
    			}

    			tab0.$set(tab0_changes);
    			const tab1_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				tab1_changes.$$scope = { dirty, ctx };
    			}

    			tab1.$set(tab1_changes);
    			const tab2_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				tab2_changes.$$scope = { dirty, ctx };
    			}

    			tab2.$set(tab2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab0.$$.fragment, local);
    			transition_in(tab1.$$.fragment, local);
    			transition_in(tab2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab0.$$.fragment, local);
    			transition_out(tab1.$$.fragment, local);
    			transition_out(tab2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tab0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tab1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tab2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$6.name,
    		type: "slot",
    		source: "(67:4) <TabList type=\\\"pillnavigation\\\">",
    		ctx
    	});

    	return block;
    }

    // (74:8) 
    function create_header_slot_2(ctx) {
    	let h2;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Content 1";
    			attr_dev(h2, "slot", "header");
    			add_location(h2, file$j, 73, 8, 1701);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_header_slot_2.name,
    		type: "slot",
    		source: "(74:8) ",
    		ctx
    	});

    	return block;
    }

    // (75:8) 
    function create_content_slot_2$1(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "slot", "content");
    			attr_dev(div, "contenteditable", "true");
    			if (/*content1*/ ctx[0] === void 0) add_render_callback(() => /*div_input_handler*/ ctx[4].call(div));
    			add_location(div, file$j, 74, 8, 1742);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (/*content1*/ ctx[0] !== void 0) {
    				div.innerHTML = /*content1*/ ctx[0];
    			}

    			if (!mounted) {
    				dispose = listen_dev(div, "input", /*div_input_handler*/ ctx[4]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content1*/ 1 && /*content1*/ ctx[0] !== div.innerHTML) {
    				div.innerHTML = /*content1*/ ctx[0];
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot_2$1.name,
    		type: "slot",
    		source: "(75:8) ",
    		ctx
    	});

    	return block;
    }

    // (72:4) <TabContent>
    function create_default_slot_4$7(ctx) {
    	let card;
    	let current;

    	card = new Card({
    			props: {
    				className: "margin-m--t",
    				$$slots: {
    					content: [create_content_slot_2$1],
    					header: [create_header_slot_2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(card.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(card, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const card_changes = {};

    			if (dirty & /*$$scope, content1*/ 129) {
    				card_changes.$$scope = { dirty, ctx };
    			}

    			card.$set(card_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(card, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$7.name,
    		type: "slot",
    		source: "(72:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (80:8) 
    function create_header_slot_1(ctx) {
    	let h2;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Content 2";
    			attr_dev(h2, "slot", "header");
    			add_location(h2, file$j, 79, 8, 1908);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_header_slot_1.name,
    		type: "slot",
    		source: "(80:8) ",
    		ctx
    	});

    	return block;
    }

    // (81:8) 
    function create_content_slot_1$2(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "slot", "content");
    			attr_dev(div, "contenteditable", "true");
    			if (/*content2*/ ctx[1] === void 0) add_render_callback(() => /*div_input_handler_1*/ ctx[5].call(div));
    			add_location(div, file$j, 80, 8, 1949);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (/*content2*/ ctx[1] !== void 0) {
    				div.innerHTML = /*content2*/ ctx[1];
    			}

    			if (!mounted) {
    				dispose = listen_dev(div, "input", /*div_input_handler_1*/ ctx[5]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content2*/ 2 && /*content2*/ ctx[1] !== div.innerHTML) {
    				div.innerHTML = /*content2*/ ctx[1];
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot_1$2.name,
    		type: "slot",
    		source: "(81:8) ",
    		ctx
    	});

    	return block;
    }

    // (78:4) <TabContent>
    function create_default_slot_3$8(ctx) {
    	let card;
    	let current;

    	card = new Card({
    			props: {
    				className: "margin-m--t",
    				$$slots: {
    					content: [create_content_slot_1$2],
    					header: [create_header_slot_1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(card.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(card, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const card_changes = {};

    			if (dirty & /*$$scope, content2*/ 130) {
    				card_changes.$$scope = { dirty, ctx };
    			}

    			card.$set(card_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(card, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$8.name,
    		type: "slot",
    		source: "(78:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (86:8) 
    function create_header_slot(ctx) {
    	let h2;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Content 3";
    			attr_dev(h2, "slot", "header");
    			add_location(h2, file$j, 85, 8, 2115);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_header_slot.name,
    		type: "slot",
    		source: "(86:8) ",
    		ctx
    	});

    	return block;
    }

    // (87:8) 
    function create_content_slot$4(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "slot", "content");
    			attr_dev(div, "contenteditable", "true");
    			if (/*content3*/ ctx[2] === void 0) add_render_callback(() => /*div_input_handler_2*/ ctx[6].call(div));
    			add_location(div, file$j, 86, 8, 2156);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (/*content3*/ ctx[2] !== void 0) {
    				div.innerHTML = /*content3*/ ctx[2];
    			}

    			if (!mounted) {
    				dispose = listen_dev(div, "input", /*div_input_handler_2*/ ctx[6]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*content3*/ 4 && /*content3*/ ctx[2] !== div.innerHTML) {
    				div.innerHTML = /*content3*/ ctx[2];
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot$4.name,
    		type: "slot",
    		source: "(87:8) ",
    		ctx
    	});

    	return block;
    }

    // (84:4) <TabContent>
    function create_default_slot_2$c(ctx) {
    	let card;
    	let current;

    	card = new Card({
    			props: {
    				className: "margin-m--t",
    				$$slots: {
    					content: [create_content_slot$4],
    					header: [create_header_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(card.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(card, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const card_changes = {};

    			if (dirty & /*$$scope, content3*/ 132) {
    				card_changes.$$scope = { dirty, ctx };
    			}

    			card.$set(card_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(card, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$c.name,
    		type: "slot",
    		source: "(84:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (66:2) <Tabs>
    function create_default_slot_1$d(ctx) {
    	let tablist;
    	let t0;
    	let tabcontent0;
    	let t1;
    	let tabcontent1;
    	let t2;
    	let tabcontent2;
    	let current;

    	tablist = new TabList({
    			props: {
    				type: "pillnavigation",
    				$$slots: { default: [create_default_slot_5$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent0 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_4$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent1 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_3$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent2 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_2$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tablist.$$.fragment);
    			t0 = space();
    			create_component(tabcontent0.$$.fragment);
    			t1 = space();
    			create_component(tabcontent1.$$.fragment);
    			t2 = space();
    			create_component(tabcontent2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tablist, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tabcontent0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tabcontent1, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(tabcontent2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tablist_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				tablist_changes.$$scope = { dirty, ctx };
    			}

    			tablist.$set(tablist_changes);
    			const tabcontent0_changes = {};

    			if (dirty & /*$$scope, content1*/ 129) {
    				tabcontent0_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent0.$set(tabcontent0_changes);
    			const tabcontent1_changes = {};

    			if (dirty & /*$$scope, content2*/ 130) {
    				tabcontent1_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent1.$set(tabcontent1_changes);
    			const tabcontent2_changes = {};

    			if (dirty & /*$$scope, content3*/ 132) {
    				tabcontent2_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent2.$set(tabcontent2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tablist.$$.fragment, local);
    			transition_in(tabcontent0.$$.fragment, local);
    			transition_in(tabcontent1.$$.fragment, local);
    			transition_in(tabcontent2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tablist.$$.fragment, local);
    			transition_out(tabcontent0.$$.fragment, local);
    			transition_out(tabcontent1.$$.fragment, local);
    			transition_out(tabcontent2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tablist, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tabcontent0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tabcontent1, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(tabcontent2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$d.name,
    		type: "slot",
    		source: "(66:2) <Tabs>",
    		ctx
    	});

    	return block;
    }

    // (92:2) <Prism language="html">
    function create_default_slot$e(ctx) {
    	let t_value = `<Tabs>
  <TabList type="pillnavigation">
    <Tab>Tab 1</Tab>
    <Tab>Tab 2</Tab>
    <Tab>Tab 3</Tab>
  </TabList>
  <TabContent>
    Content 1
  </TabContent>
  <TabContent>
    Content 2
  </TabContent>
  <TabContent>
    Content 3
  </TabContent>
</Tabs>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(92:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let h1;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$2, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[3] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Tabs";
    			t1 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$j, 9, 0, 306);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(3, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tabs', slots, []);
    	let content1 = rdmParagraphs();
    	let content2 = rdmParagraphs();
    	let content3 = rdmParagraphs();
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tabs> was created with unknown prop '${key}'`);
    	});

    	function div_input_handler() {
    		content1 = this.innerHTML;
    		$$invalidate(0, content1);
    	}

    	function div_input_handler_1() {
    		content2 = this.innerHTML;
    		$$invalidate(1, content2);
    	}

    	function div_input_handler_2() {
    		content3 = this.innerHTML;
    		$$invalidate(2, content3);
    	}

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		rdmParagraphs,
    		sourceType,
    		Card,
    		Tabs,
    		Tab,
    		TabContent,
    		TabList,
    		content1,
    		content2,
    		content3,
    		$sourceType
    	});

    	$$self.$inject_state = $$props => {
    		if ('content1' in $$props) $$invalidate(0, content1 = $$props.content1);
    		if ('content2' in $$props) $$invalidate(1, content2 = $$props.content2);
    		if ('content3' in $$props) $$invalidate(2, content3 = $$props.content3);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		content1,
    		content2,
    		content3,
    		$sourceType,
    		div_input_handler,
    		div_input_handler_1,
    		div_input_handler_2
    	];
    }

    class Tabs_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabs_1",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* docs_src/components/Toggler.svelte generated by Svelte v3.42.6 */
    const file$i = "docs_src/components/Toggler.svelte";
    const get_default_slot_changes_7 = dirty => ({});
    const get_default_slot_context_7 = ctx => ({ slot: "on" });
    const get_default_slot_changes_6 = dirty => ({});
    const get_default_slot_context_6 = ctx => ({ slot: "off" });
    const get_default_slot_changes_5 = dirty => ({});
    const get_default_slot_context_5 = ctx => ({ slot: "on" });
    const get_default_slot_changes_4 = dirty => ({});
    const get_default_slot_context_4 = ctx => ({ slot: "off" });
    const get_default_slot_changes_3 = dirty => ({});
    const get_default_slot_context_3 = ctx => ({ slot: "on" });
    const get_default_slot_changes_2 = dirty => ({});
    const get_default_slot_context_2 = ctx => ({ slot: "off" });
    const get_default_slot_changes_1 = dirty => ({});
    const get_default_slot_context_1 = ctx => ({ slot: "on" });
    const get_default_slot_changes = dirty => ({});
    const get_default_slot_context = ctx => ({ slot: "off" });

    // (8:0) {#if $sourceType === 'svelte'}
    function create_if_block_4(ctx) {
    	let prism;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t13;
    	let td3;
    	let t14;
    	let tr2;
    	let td4;
    	let t16;
    	let td5;
    	let t18;
    	let td6;
    	let t20;
    	let td7;
    	let t22;
    	let tr3;
    	let td8;
    	let t24;
    	let td9;
    	let t26;
    	let td10;
    	let t28;
    	let td11;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_8$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "className";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "string";
    			t12 = space();
    			td2 = element("td");
    			t13 = space();
    			td3 = element("td");
    			t14 = space();
    			tr2 = element("tr");
    			td4 = element("td");
    			td4.textContent = "defaultState";
    			t16 = space();
    			td5 = element("td");
    			td5.textContent = "boolean";
    			t18 = space();
    			td6 = element("td");
    			td6.textContent = "true";
    			t20 = space();
    			td7 = element("td");
    			td7.textContent = "Should the toggler be on or of on mount";
    			t22 = space();
    			tr3 = element("tr");
    			td8 = element("td");
    			td8.textContent = "isSwitch";
    			t24 = space();
    			td9 = element("td");
    			td9.textContent = "boolean";
    			t26 = space();
    			td10 = element("td");
    			td10.textContent = "false";
    			t28 = space();
    			td11 = element("td");
    			td11.textContent = "Convents into a swicth, see example further down";
    			add_location(th0, file$i, 15, 8, 367);
    			add_location(th1, file$i, 16, 8, 394);
    			add_location(th2, file$i, 17, 8, 416);
    			add_location(th3, file$i, 18, 8, 447);
    			add_location(tr0, file$i, 14, 6, 354);
    			add_location(thead, file$i, 13, 4, 340);
    			add_location(td0, file$i, 23, 8, 524);
    			add_location(td1, file$i, 24, 8, 551);
    			add_location(td2, file$i, 25, 8, 575);
    			add_location(td3, file$i, 26, 8, 590);
    			add_location(tr1, file$i, 22, 6, 511);
    			add_location(td4, file$i, 29, 8, 628);
    			add_location(td5, file$i, 30, 8, 658);
    			add_location(td6, file$i, 31, 8, 683);
    			add_location(td7, file$i, 32, 8, 705);
    			add_location(tr2, file$i, 28, 6, 615);
    			add_location(td8, file$i, 35, 8, 785);
    			add_location(td9, file$i, 36, 8, 811);
    			add_location(td10, file$i, 37, 8, 836);
    			add_location(td11, file$i, 38, 8, 859);
    			add_location(tr3, file$i, 34, 6, 772);
    			add_location(tbody, file$i, 21, 4, 497);
    			attr_dev(table, "class", "table");
    			add_location(table, file$i, 12, 2, 314);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			append_dev(tbody, t14);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td4);
    			append_dev(tr2, t16);
    			append_dev(tr2, td5);
    			append_dev(tr2, t18);
    			append_dev(tr2, td6);
    			append_dev(tr2, t20);
    			append_dev(tr2, td7);
    			append_dev(tbody, t22);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td8);
    			append_dev(tr3, t24);
    			append_dev(tr3, td9);
    			append_dev(tr3, t26);
    			append_dev(tr3, td10);
    			append_dev(tr3, t28);
    			append_dev(tr3, td11);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(8:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (9:2) <Prism language="js">
    function create_default_slot_8$3(ctx) {
    	let t_value = `import { Toggler } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$3.name,
    		type: "slot",
    		source: "(9:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (48:18) on
    function fallback_block_7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("on");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_7.name,
    		type: "fallback",
    		source: "(48:18) on",
    		ctx
    	});

    	return block;
    }

    // (48:2) 
    function create_on_slot_3(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context_1);
    	const default_slot_or_fallback = default_slot || fallback_block_7(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, get_default_slot_changes_1),
    						get_default_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_on_slot_3.name,
    		type: "slot",
    		source: "(48:2) ",
    		ctx
    	});

    	return block;
    }

    // (49:19) off
    function fallback_block_6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("off");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_6.name,
    		type: "fallback",
    		source: "(49:19) off",
    		ctx
    	});

    	return block;
    }

    // (49:2) 
    function create_off_slot_3(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context);
    	const default_slot_or_fallback = default_slot || fallback_block_6(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, get_default_slot_changes),
    						get_default_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_off_slot_3.name,
    		type: "slot",
    		source: "(49:2) ",
    		ctx
    	});

    	return block;
    }

    // (59:0) {:else}
    function create_else_block_3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_7$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(59:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (52:0) {#if $sourceType === 'svelte'}
    function create_if_block_3(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_6$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(52:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (60:2) <Prism language="html">
    function create_default_slot_7$3(ctx) {
    	let t_value = `<label class="toggle">
  <input type="checkbox" hidden class="toggle-input" />
  <span class="toggle toggle-on">on</span>
  <span class="toggle toggle-off">off</span>
</label>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$3.name,
    		type: "slot",
    		source: "(60:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (53:2) <Prism language="html">
    function create_default_slot_6$5(ctx) {
    	let t_value = `<Toggler>
  <slot slot="on">on</slot>
  <slot slot="off">off</slot>
</Toggler>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$5.name,
    		type: "slot",
    		source: "(53:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (72:18)      
    function fallback_block_5(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: {
    				name: "angledown",
    				style: "width: 24px; height: 24px;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_5.name,
    		type: "fallback",
    		source: "(72:18)      ",
    		ctx
    	});

    	return block;
    }

    // (72:2) 
    function create_on_slot_2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context_3);
    	const default_slot_or_fallback = default_slot || fallback_block_5(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, get_default_slot_changes_3),
    						get_default_slot_context_3
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_on_slot_2.name,
    		type: "slot",
    		source: "(72:2) ",
    		ctx
    	});

    	return block;
    }

    // (75:19)      
    function fallback_block_4(ctx) {
    	let icon;
    	let current;

    	icon = new Icon({
    			props: {
    				name: "angleup",
    				style: "width: 24px; height: 24px;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_4.name,
    		type: "fallback",
    		source: "(75:19)      ",
    		ctx
    	});

    	return block;
    }

    // (75:2) 
    function create_off_slot_2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context_2);
    	const default_slot_or_fallback = default_slot || fallback_block_4(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, get_default_slot_changes_2),
    						get_default_slot_context_2
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_off_slot_2.name,
    		type: "slot",
    		source: "(75:2) ",
    		ctx
    	});

    	return block;
    }

    // (91:0) {:else}
    function create_else_block_2(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_5$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(91:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (80:0) {#if $sourceType === 'svelte'}
    function create_if_block_2$1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_4$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(80:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (92:2) <Prism language="html">
    function create_default_slot_5$5(ctx) {
    	let t_value = `<label class="toggle">
  <input type="checkbox" hidden class="toggle-input" />
  <i class="toggle toggle-on fas fa-angle-down"></i>
  <i class="toggle toggle-off fas fa-angle-up"></i>
</label>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$5.name,
    		type: "slot",
    		source: "(92:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (81:2) <Prism language="html">
    function create_default_slot_4$6(ctx) {
    	let t_value = `<Toggler>
  <slot slot="on">
    <Icon name="angledown" style="width: 24px; height: 24px;" />
  </slot>
  <slot slot="off">
    <Icon name="angleup" style="width: 24px; height: 24px;" />
  </slot>
</Toggler>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$6.name,
    		type: "slot",
    		source: "(81:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (104:18) on
    function fallback_block_3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("on");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_3.name,
    		type: "fallback",
    		source: "(104:18) on",
    		ctx
    	});

    	return block;
    }

    // (104:2) 
    function create_on_slot_1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context_5);
    	const default_slot_or_fallback = default_slot || fallback_block_3(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, get_default_slot_changes_5),
    						get_default_slot_context_5
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_on_slot_1.name,
    		type: "slot",
    		source: "(104:2) ",
    		ctx
    	});

    	return block;
    }

    // (105:19) off
    function fallback_block_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("off");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_2.name,
    		type: "fallback",
    		source: "(105:19) off",
    		ctx
    	});

    	return block;
    }

    // (105:2) 
    function create_off_slot_1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context_4);
    	const default_slot_or_fallback = default_slot || fallback_block_2(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, get_default_slot_changes_4),
    						get_default_slot_context_4
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_off_slot_1.name,
    		type: "slot",
    		source: "(105:2) ",
    		ctx
    	});

    	return block;
    }

    // (115:0) {:else}
    function create_else_block_1$1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_3$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(115:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (108:0) {#if $sourceType === 'svelte'}
    function create_if_block_1$1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(108:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (116:2) <Prism language="html">
    function create_default_slot_3$7(ctx) {
    	let t_value = `Sadly, Svelte only` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$7.name,
    		type: "slot",
    		source: "(116:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (109:2) <Prism language="html">
    function create_default_slot_2$b(ctx) {
    	let t_value = `<Toggler isSwitch={true}>
  <slot slot="on">on</slot>
  <slot slot="off">off</slot>
</Toggler>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$b.name,
    		type: "slot",
    		source: "(109:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (124:18) on
    function fallback_block_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("on");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1.name,
    		type: "fallback",
    		source: "(124:18) on",
    		ctx
    	});

    	return block;
    }

    // (124:2) 
    function create_on_slot(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context_7);
    	const default_slot_or_fallback = default_slot || fallback_block_1(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, get_default_slot_changes_7),
    						get_default_slot_context_7
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_on_slot.name,
    		type: "slot",
    		source: "(124:2) ",
    		ctx
    	});

    	return block;
    }

    // (125:19) off
    function fallback_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("off");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(125:19) off",
    		ctx
    	});

    	return block;
    }

    // (125:2) 
    function create_off_slot(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context_6);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, get_default_slot_changes_6),
    						get_default_slot_context_6
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_off_slot.name,
    		type: "slot",
    		source: "(125:2) ",
    		ctx
    	});

    	return block;
    }

    // (135:0) {:else}
    function create_else_block$1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(135:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (128:0) {#if $sourceType === 'svelte'}
    function create_if_block$1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(128:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (136:2) <Prism language="html">
    function create_default_slot_1$c(ctx) {
    	let t_value = `Sadly, Svelte only` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$c.name,
    		type: "slot",
    		source: "(136:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (129:2) <Prism language="html">
    function create_default_slot$d(ctx) {
    	let t_value = `<Toggler defaultState={false}>
  <slot slot="on">on</slot>
  <slot slot="off">off</slot>
</Toggler>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(129:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let h1;
    	let t1;
    	let t2;
    	let h30;
    	let t4;
    	let toggler0;
    	let t5;
    	let current_block_type_index;
    	let if_block1;
    	let t6;
    	let h31;
    	let t8;
    	let toggler1;
    	let t9;
    	let current_block_type_index_1;
    	let if_block2;
    	let t10;
    	let h32;
    	let t12;
    	let toggler2;
    	let t13;
    	let current_block_type_index_2;
    	let if_block3;
    	let t14;
    	let h33;
    	let t16;
    	let toggler3;
    	let t17;
    	let current_block_type_index_3;
    	let if_block4;
    	let if_block4_anchor;
    	let current;
    	let if_block0 = /*$sourceType*/ ctx[0] === 'svelte' && create_if_block_4(ctx);

    	toggler0 = new Toggler({
    			props: {
    				$$slots: {
    					off: [create_off_slot_3],
    					on: [create_on_slot_3]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block_3, create_else_block_3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	toggler1 = new Toggler({
    			props: {
    				$$slots: {
    					off: [create_off_slot_2],
    					on: [create_on_slot_2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_1 = [create_if_block_2$1, create_else_block_2];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	toggler2 = new Toggler({
    			props: {
    				isSwitch: true,
    				$$slots: {
    					off: [create_off_slot_1],
    					on: [create_on_slot_1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_2 = [create_if_block_1$1, create_else_block_1$1];
    	const if_blocks_2 = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_2 = select_block_type_2(ctx);
    	if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

    	toggler3 = new Toggler({
    			props: {
    				defaultState: false,
    				$$slots: {
    					off: [create_off_slot],
    					on: [create_on_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_3 = [create_if_block$1, create_else_block$1];
    	const if_blocks_3 = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_3 = select_block_type_3(ctx);
    	if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Toggler";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			h30 = element("h3");
    			h30.textContent = "Toggler with text";
    			t4 = space();
    			create_component(toggler0.$$.fragment);
    			t5 = space();
    			if_block1.c();
    			t6 = space();
    			h31 = element("h3");
    			h31.textContent = "Toggler with icon";
    			t8 = space();
    			create_component(toggler1.$$.fragment);
    			t9 = space();
    			if_block2.c();
    			t10 = space();
    			h32 = element("h3");
    			h32.textContent = "Toggle as switch";
    			t12 = space();
    			create_component(toggler2.$$.fragment);
    			t13 = space();
    			if_block3.c();
    			t14 = space();
    			h33 = element("h3");
    			h33.textContent = "Set default state to off";
    			t16 = space();
    			create_component(toggler3.$$.fragment);
    			t17 = space();
    			if_block4.c();
    			if_block4_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$i, 5, 0, 146);
    			add_location(h30, file$i, 44, 0, 960);
    			add_location(h31, file$i, 68, 0, 1459);
    			add_location(h32, file$i, 100, 0, 2233);
    			add_location(h33, file$i, 120, 0, 2606);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(toggler0, target, anchor);
    			insert_dev(target, t5, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(toggler1, target, anchor);
    			insert_dev(target, t9, anchor);
    			if_blocks_1[current_block_type_index_1].m(target, anchor);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t12, anchor);
    			mount_component(toggler2, target, anchor);
    			insert_dev(target, t13, anchor);
    			if_blocks_2[current_block_type_index_2].m(target, anchor);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t16, anchor);
    			mount_component(toggler3, target, anchor);
    			insert_dev(target, t17, anchor);
    			if_blocks_3[current_block_type_index_3].m(target, anchor);
    			insert_dev(target, if_block4_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$sourceType*/ ctx[0] === 'svelte') {
    				if (if_block0) {
    					if (dirty & /*$sourceType*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const toggler0_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				toggler0_changes.$$scope = { dirty, ctx };
    			}

    			toggler0.$set(toggler0_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(t6.parentNode, t6);
    			}

    			const toggler1_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				toggler1_changes.$$scope = { dirty, ctx };
    			}

    			toggler1.$set(toggler1_changes);
    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks_1[current_block_type_index_1];

    				if (!if_block2) {
    					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(t10.parentNode, t10);
    			}

    			const toggler2_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				toggler2_changes.$$scope = { dirty, ctx };
    			}

    			toggler2.$set(toggler2_changes);
    			let previous_block_index_2 = current_block_type_index_2;
    			current_block_type_index_2 = select_block_type_2(ctx);

    			if (current_block_type_index_2 !== previous_block_index_2) {
    				group_outros();

    				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
    					if_blocks_2[previous_block_index_2] = null;
    				});

    				check_outros();
    				if_block3 = if_blocks_2[current_block_type_index_2];

    				if (!if_block3) {
    					if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
    					if_block3.c();
    				}

    				transition_in(if_block3, 1);
    				if_block3.m(t14.parentNode, t14);
    			}

    			const toggler3_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				toggler3_changes.$$scope = { dirty, ctx };
    			}

    			toggler3.$set(toggler3_changes);
    			let previous_block_index_3 = current_block_type_index_3;
    			current_block_type_index_3 = select_block_type_3(ctx);

    			if (current_block_type_index_3 !== previous_block_index_3) {
    				group_outros();

    				transition_out(if_blocks_3[previous_block_index_3], 1, 1, () => {
    					if_blocks_3[previous_block_index_3] = null;
    				});

    				check_outros();
    				if_block4 = if_blocks_3[current_block_type_index_3];

    				if (!if_block4) {
    					if_block4 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);
    					if_block4.c();
    				}

    				transition_in(if_block4, 1);
    				if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(toggler0.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(toggler1.$$.fragment, local);
    			transition_in(if_block2);
    			transition_in(toggler2.$$.fragment, local);
    			transition_in(if_block3);
    			transition_in(toggler3.$$.fragment, local);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(toggler0.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(toggler1.$$.fragment, local);
    			transition_out(if_block2);
    			transition_out(toggler2.$$.fragment, local);
    			transition_out(if_block3);
    			transition_out(toggler3.$$.fragment, local);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t4);
    			destroy_component(toggler0, detaching);
    			if (detaching) detach_dev(t5);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t8);
    			destroy_component(toggler1, detaching);
    			if (detaching) detach_dev(t9);
    			if_blocks_1[current_block_type_index_1].d(detaching);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t12);
    			destroy_component(toggler2, detaching);
    			if (detaching) detach_dev(t13);
    			if_blocks_2[current_block_type_index_2].d(detaching);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t16);
    			destroy_component(toggler3, detaching);
    			if (detaching) detach_dev(t17);
    			if_blocks_3[current_block_type_index_3].d(detaching);
    			if (detaching) detach_dev(if_block4_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Toggler', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Toggler> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		sourceType,
    		Icon,
    		Toggler,
    		$sourceType
    	});

    	return [$sourceType, slots, $$scope];
    }

    class Toggler_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Toggler_1",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    /* docs_src/components/Tooltip.svelte generated by Svelte v3.42.6 */
    const file$h = "docs_src/components/Tooltip.svelte";

    // (11:0) {#if $sourceType === 'svelte'}
    function create_if_block_2(ctx) {
    	let prism;
    	let t0;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t2;
    	let th1;
    	let t4;
    	let th2;
    	let t6;
    	let th3;
    	let t8;
    	let tbody;
    	let tr1;
    	let td0;
    	let t10;
    	let td1;
    	let t12;
    	let td2;
    	let t13;
    	let td3;
    	let t14;
    	let tr2;
    	let td4;
    	let t16;
    	let td5;
    	let t18;
    	let td6;
    	let t20;
    	let td7;
    	let t22;
    	let tr3;
    	let td8;
    	let t24;
    	let td9;
    	let t26;
    	let td10;
    	let t28;
    	let td11;
    	let t30;
    	let tr4;
    	let td12;
    	let t32;
    	let td13;
    	let t34;
    	let td14;
    	let t36;
    	let td15;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot_6$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    			t0 = space();
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Prop name";
    			t2 = space();
    			th1 = element("th");
    			th1.textContent = "Type";
    			t4 = space();
    			th2 = element("th");
    			th2.textContent = "Default value";
    			t6 = space();
    			th3 = element("th");
    			th3.textContent = "Description";
    			t8 = space();
    			tbody = element("tbody");
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "className";
    			t10 = space();
    			td1 = element("td");
    			td1.textContent = "string";
    			t12 = space();
    			td2 = element("td");
    			t13 = space();
    			td3 = element("td");
    			t14 = space();
    			tr2 = element("tr");
    			td4 = element("td");
    			td4.textContent = "iconOn";
    			t16 = space();
    			td5 = element("td");
    			td5.textContent = "string";
    			t18 = space();
    			td6 = element("td");
    			td6.textContent = "'times'";
    			t20 = space();
    			td7 = element("td");
    			td7.textContent = "FontAwesome icon for when tooltip is open";
    			t22 = space();
    			tr3 = element("tr");
    			td8 = element("td");
    			td8.textContent = "iconOff";
    			t24 = space();
    			td9 = element("td");
    			td9.textContent = "string";
    			t26 = space();
    			td10 = element("td");
    			td10.textContent = "'question'";
    			t28 = space();
    			td11 = element("td");
    			td11.textContent = "FontAwesome icon for when tooltip is closed";
    			t30 = space();
    			tr4 = element("tr");
    			td12 = element("td");
    			td12.textContent = "position";
    			t32 = space();
    			td13 = element("td");
    			td13.textContent = "'left' | 'right'";
    			t34 = space();
    			td14 = element("td");
    			td14.textContent = "'left'";
    			t36 = space();
    			td15 = element("td");
    			add_location(th0, file$h, 18, 8, 468);
    			add_location(th1, file$h, 19, 8, 495);
    			add_location(th2, file$h, 20, 8, 517);
    			add_location(th3, file$h, 21, 8, 548);
    			add_location(tr0, file$h, 17, 6, 455);
    			add_location(thead, file$h, 16, 4, 441);
    			add_location(td0, file$h, 26, 8, 625);
    			add_location(td1, file$h, 27, 8, 652);
    			add_location(td2, file$h, 28, 8, 676);
    			add_location(td3, file$h, 29, 8, 691);
    			add_location(tr1, file$h, 25, 6, 612);
    			add_location(td4, file$h, 32, 8, 729);
    			add_location(td5, file$h, 33, 8, 753);
    			add_location(td6, file$h, 34, 8, 777);
    			add_location(td7, file$h, 35, 8, 802);
    			add_location(tr2, file$h, 31, 6, 716);
    			add_location(td8, file$h, 38, 8, 884);
    			add_location(td9, file$h, 39, 8, 909);
    			add_location(td10, file$h, 40, 8, 933);
    			add_location(td11, file$h, 41, 8, 961);
    			add_location(tr3, file$h, 37, 6, 871);
    			add_location(td12, file$h, 44, 8, 1045);
    			add_location(td13, file$h, 45, 8, 1071);
    			add_location(td14, file$h, 46, 8, 1105);
    			add_location(td15, file$h, 47, 8, 1129);
    			add_location(tr4, file$h, 43, 6, 1032);
    			add_location(tbody, file$h, 24, 4, 598);
    			attr_dev(table, "class", "table");
    			add_location(table, file$h, 15, 2, 415);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t2);
    			append_dev(tr0, th1);
    			append_dev(tr0, t4);
    			append_dev(tr0, th2);
    			append_dev(tr0, t6);
    			append_dev(tr0, th3);
    			append_dev(table, t8);
    			append_dev(table, tbody);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t10);
    			append_dev(tr1, td1);
    			append_dev(tr1, t12);
    			append_dev(tr1, td2);
    			append_dev(tr1, t13);
    			append_dev(tr1, td3);
    			append_dev(tbody, t14);
    			append_dev(tbody, tr2);
    			append_dev(tr2, td4);
    			append_dev(tr2, t16);
    			append_dev(tr2, td5);
    			append_dev(tr2, t18);
    			append_dev(tr2, td6);
    			append_dev(tr2, t20);
    			append_dev(tr2, td7);
    			append_dev(tbody, t22);
    			append_dev(tbody, tr3);
    			append_dev(tr3, td8);
    			append_dev(tr3, t24);
    			append_dev(tr3, td9);
    			append_dev(tr3, t26);
    			append_dev(tr3, td10);
    			append_dev(tr3, t28);
    			append_dev(tr3, td11);
    			append_dev(tbody, t30);
    			append_dev(tbody, tr4);
    			append_dev(tr4, td12);
    			append_dev(tr4, t32);
    			append_dev(tr4, td13);
    			append_dev(tr4, t34);
    			append_dev(tr4, td14);
    			append_dev(tr4, t36);
    			append_dev(tr4, td15);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(11:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (12:2) <Prism language="js">
    function create_default_slot_6$4(ctx) {
    	let t_value = `import { Tooltip } from '@ekstra-bladet/designsystem';` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$4.name,
    		type: "slot",
    		source: "(12:2) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    // (57:2) <Tooltip>
    function create_default_slot_5$4(ctx) {
    	let html_tag;
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(/*Content1*/ ctx[1], target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$4.name,
    		type: "slot",
    		source: "(57:2) <Tooltip>",
    		ctx
    	});

    	return block;
    }

    // (66:0) {:else}
    function create_else_block_1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_4$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(66:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (62:0) {#if $sourceType === 'svelte'}
    function create_if_block_1(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_3$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(62:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (67:2) <Prism language="html">
    function create_default_slot_4$5(ctx) {
    	let t_value = `<label class="tooltip">
  <input type="checkbox" hidden class="tooltip-input"/>
  <div class="tooltip-off">
    <i class="tooltip-toggle fas fa-question"/>
  </div>
  <div class="tooltip-on">
    <i class="tooltip-toggle fas fa-times"/>
    <div class="padding-s">
      Content
    </div>
  </div>
</label>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$5.name,
    		type: "slot",
    		source: "(67:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (63:2) <Prism language="html">
    function create_default_slot_3$6(ctx) {
    	let t_value = `<Tooltip></Tooltip>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$6.name,
    		type: "slot",
    		source: "(63:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (87:2) <Tooltip position="right" className="flex-item--center">
    function create_default_slot_2$a(ctx) {
    	let html_tag;
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(/*Content2*/ ctx[2], target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$a.name,
    		type: "slot",
    		source: "(87:2) <Tooltip position=\\\"right\\\" className=\\\"flex-item--center\\\">",
    		ctx
    	});

    	return block;
    }

    // (99:0) {:else}
    function create_else_block(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(99:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (92:0) {#if $sourceType === 'svelte'}
    function create_if_block(ctx) {
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(92:0) {#if $sourceType === 'svelte'}",
    		ctx
    	});

    	return block;
    }

    // (100:2) <Prism language="html">
    function create_default_slot_1$b(ctx) {
    	let t_value = `<div class="flex flex-justify--between">
  <h3>Header</h3>
  <label class="tooltip tooltip--right flex-item--center">
    <input type="checkbox" hidden class="tooltip-input"/>
    <div class="tooltip-off">
      <i class="tooltip-toggle fas fa-question"/>
    </div>
    <div class="tooltip-on">
      <i class="tooltip-toggle fas fa-times"/>
      <div class="padding-s">
        Content
      </div>
    </div>
  </label>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$b.name,
    		type: "slot",
    		source: "(100:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (93:2) <Prism language="html">
    function create_default_slot$c(ctx) {
    	let t_value = `<div class="flex flex-justify--between">
  <h3>Header</h3>
  <Tooltip position="right" className="flex-item--center"></Tooltip>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(93:2) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let h1;
    	let t1;
    	let t2;
    	let h30;
    	let t4;
    	let div0;
    	let tooltip0;
    	let t5;
    	let current_block_type_index;
    	let if_block1;
    	let t6;
    	let h31;
    	let t8;
    	let div1;
    	let h32;
    	let t10;
    	let tooltip1;
    	let t11;
    	let current_block_type_index_1;
    	let if_block2;
    	let if_block2_anchor;
    	let current;
    	let if_block0 = /*$sourceType*/ ctx[0] === 'svelte' && create_if_block_2(ctx);

    	tooltip0 = new Tooltip({
    			props: {
    				$$slots: { default: [create_default_slot_5$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block_1, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	tooltip1 = new Tooltip({
    			props: {
    				position: "right",
    				className: "flex-item--center",
    				$$slots: { default: [create_default_slot_2$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators_1 = [create_if_block, create_else_block];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$sourceType*/ ctx[0] === 'svelte') return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Tooltip";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			h30 = element("h3");
    			h30.textContent = "Default tooltip";
    			t4 = space();
    			div0 = element("div");
    			create_component(tooltip0.$$.fragment);
    			t5 = space();
    			if_block1.c();
    			t6 = space();
    			h31 = element("h3");
    			h31.textContent = "Tooltip i højre side";
    			t8 = space();
    			div1 = element("div");
    			h32 = element("h3");
    			h32.textContent = "Header";
    			t10 = space();
    			create_component(tooltip1.$$.fragment);
    			t11 = space();
    			if_block2.c();
    			if_block2_anchor = empty();
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$h, 8, 0, 247);
    			add_location(h30, file$h, 53, 0, 1179);
    			attr_dev(div0, "class", "flex margin-l--tb");
    			add_location(div0, file$h, 55, 0, 1205);
    			add_location(h31, file$h, 82, 0, 1755);
    			add_location(h32, file$h, 85, 2, 1860);
    			attr_dev(div1, "class", "flex flex-justify--between grid-width--small margin-l--tb");
    			add_location(div1, file$h, 84, 0, 1786);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div0, anchor);
    			mount_component(tooltip0, div0, null);
    			insert_dev(target, t5, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h32);
    			append_dev(div1, t10);
    			mount_component(tooltip1, div1, null);
    			insert_dev(target, t11, anchor);
    			if_blocks_1[current_block_type_index_1].m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$sourceType*/ ctx[0] === 'svelte') {
    				if (if_block0) {
    					if (dirty & /*$sourceType*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const tooltip0_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				tooltip0_changes.$$scope = { dirty, ctx };
    			}

    			tooltip0.$set(tooltip0_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(t6.parentNode, t6);
    			}

    			const tooltip1_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				tooltip1_changes.$$scope = { dirty, ctx };
    			}

    			tooltip1.$set(tooltip1_changes);
    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks_1[current_block_type_index_1];

    				if (!if_block2) {
    					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(tooltip0.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(tooltip1.$$.fragment, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(tooltip0.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(tooltip1.$$.fragment, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div0);
    			destroy_component(tooltip0);
    			if (detaching) detach_dev(t5);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(div1);
    			destroy_component(tooltip1);
    			if (detaching) detach_dev(t11);
    			if_blocks_1[current_block_type_index_1].d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tooltip', slots, []);
    	let Content1 = rdmParagraphs(2);
    	let Content2 = rdmParagraphs(2);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tooltip> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		rdmParagraphs,
    		sourceType,
    		Tooltip,
    		Content1,
    		Content2,
    		$sourceType
    	});

    	$$self.$inject_state = $$props => {
    		if ('Content1' in $$props) $$invalidate(1, Content1 = $$props.Content1);
    		if ('Content2' in $$props) $$invalidate(2, Content2 = $$props.Content2);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$sourceType, Content1, Content2];
    }

    class Tooltip_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tooltip_1",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    const components = {
        href: '/components',
        routes: [
            { disabled: false, href: '/components/accordion', title: 'Accordion', group: 'components', component: Accordion_1 },
            {
                disabled: false,
                href: '/components/articlecard',
                title: 'Article card',
                group: 'components',
                component: ArticleCard_1,
            },
            { disabled: false, href: '/components/badge', title: 'Badge', group: 'components', component: Badge_1 },
            { disabled: false, href: '/components/button', title: 'Button', group: 'components', component: Button_1 },
            {
                disabled: false,
                href: '/components/buttongroup',
                title: 'Button group',
                group: 'components',
                component: ButtonGroup_1,
            },
            { disabled: false, href: '/components/card', title: 'Card', group: 'components', component: Card_1 },
            {
                disabled: false,
                href: '/components/form-elements',
                title: 'Form elements',
                group: 'components',
                component: FormElement_1,
            },
            { disabled: false, href: '/components/icon', title: 'Icon', group: 'components', component: Icon_1 },
            {
                disabled: false,
                href: '/components/horizontalscroll',
                title: 'Horizontal scroll',
                group: 'components',
                component: HorizontalScroll_1,
            },
            { disabled: false, href: '/components/tabs', title: 'Tabs', group: 'components', component: Tabs_1 },
            { disabled: false, href: '/components/spinner', title: 'Spinner', group: 'components', component: Spinner_1 },
            { disabled: false, href: '/components/toggler', title: 'Toggler', group: 'components', component: Toggler_1 },
            { disabled: false, href: '/components/tooltip', title: 'Tooltip', group: 'components', component: Tooltip_1 },
        ],
        title: 'Components',
    };

    /* docs_src/guidelines/Svelte.svelte generated by Svelte v3.42.6 */
    const file$g = "docs_src/guidelines/Svelte.svelte";

    // (28:0) <Prism language="js">
    function create_default_slot$b(ctx) {
    	let t_value = `npx degit EkstraBladetUdvikling/sveltetemplate my-svelte-project` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(28:0) <Prism language=\\\"js\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let h1;
    	let t1;
    	let h30;
    	let t3;
    	let ol;
    	let li0;
    	let t5;
    	let li1;
    	let t7;
    	let li2;
    	let t9;
    	let li3;
    	let t11;
    	let li4;
    	let t13;
    	let li5;
    	let t15;
    	let li6;
    	let t17;
    	let li7;
    	let t19;
    	let li8;
    	let t21;
    	let h31;
    	let t23;
    	let p;
    	let t25;
    	let prism;
    	let current;

    	prism = new Prism$1({
    			props: {
    				language: "js",
    				$$slots: { default: [create_default_slot$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Svelte";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Rules";
    			t3 = space();
    			ol = element("ol");
    			li0 = element("li");
    			li0.textContent = "There must be a rigorous division of logic (script-part) and views (template, class selection, etc.)";
    			t5 = space();
    			li1 = element("li");
    			li1.textContent = "Component-specific styling should preferably be solved using the designsystem instead of styling within the\n    Svelte-files.";
    			t7 = space();
    			li2 = element("li");
    			li2.textContent = "Svelte functions should (if possible) be used instead of native functions (eg createEventListener).";
    			t9 = space();
    			li3 = element("li");
    			li3.textContent = "Script tag content must be kept to an absolute minimum.";
    			t11 = space();
    			li4 = element("li");
    			li4.textContent = "As a rule, the state must provide all data in the format required by the components. Ie. Filtering takes place in\n    state management and not in the respective components.";
    			t13 = space();
    			li5 = element("li");
    			li5.textContent = "Design system: on:click should exist on all elements of the design system";
    			t15 = space();
    			li6 = element("li");
    			li6.textContent = "The use of Svelte is agreed in the front-end group, so that it is only used where it makes sense.";
    			t17 = space();
    			li7 = element("li");
    			li7.textContent = "Svelte-store is used and each part of the state is divided into several readable / writeable, instead of one object.";
    			t19 = space();
    			li8 = element("li");
    			li8.textContent = "Writables may only be updated using actions (functions) and may not be exported directly.";
    			t21 = space();
    			h31 = element("h3");
    			h31.textContent = "Create Svelte App";
    			t23 = space();
    			p = element("p");
    			p.textContent = "The recommended way to start new apps with Svelte is by using our Svelte Template:";
    			t25 = space();
    			create_component(prism.$$.fragment);
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$g, 3, 0, 63);
    			add_location(h30, file$g, 4, 0, 97);
    			attr_dev(li0, "class", "svelte-9h10az");
    			add_location(li0, file$g, 6, 2, 119);
    			attr_dev(li1, "class", "svelte-9h10az");
    			add_location(li1, file$g, 7, 2, 231);
    			attr_dev(li2, "class", "svelte-9h10az");
    			add_location(li2, file$g, 11, 2, 376);
    			attr_dev(li3, "class", "svelte-9h10az");
    			add_location(li3, file$g, 12, 2, 487);
    			attr_dev(li4, "class", "svelte-9h10az");
    			add_location(li4, file$g, 13, 2, 554);
    			attr_dev(li5, "class", "svelte-9h10az");
    			add_location(li5, file$g, 17, 2, 746);
    			attr_dev(li6, "class", "svelte-9h10az");
    			add_location(li6, file$g, 18, 2, 831);
    			attr_dev(li7, "class", "svelte-9h10az");
    			add_location(li7, file$g, 19, 2, 940);
    			attr_dev(li8, "class", "svelte-9h10az");
    			add_location(li8, file$g, 22, 2, 1076);
    			add_location(ol, file$g, 5, 0, 112);
    			add_location(h31, file$g, 25, 0, 1182);
    			add_location(p, file$g, 26, 0, 1209);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, ol, anchor);
    			append_dev(ol, li0);
    			append_dev(ol, t5);
    			append_dev(ol, li1);
    			append_dev(ol, t7);
    			append_dev(ol, li2);
    			append_dev(ol, t9);
    			append_dev(ol, li3);
    			append_dev(ol, t11);
    			append_dev(ol, li4);
    			append_dev(ol, t13);
    			append_dev(ol, li5);
    			append_dev(ol, t15);
    			append_dev(ol, li6);
    			append_dev(ol, t17);
    			append_dev(ol, li7);
    			append_dev(ol, t19);
    			append_dev(ol, li8);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t23, anchor);
    			insert_dev(target, p, anchor);
    			insert_dev(target, t25, anchor);
    			mount_component(prism, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism_changes.$$scope = { dirty, ctx };
    			}

    			prism.$set(prism_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(ol);
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t23);
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t25);
    			destroy_component(prism, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Svelte', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Svelte> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1 });
    	return [];
    }

    class Svelte extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Svelte",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    const guidelines = {
        href: '/guidelines',
        routes: [{ disabled: false, href: '/guidelines/svelte', title: 'Svelte', group: 'guidelines', component: Svelte }],
        title: 'Guidelines',
    };

    /* docs_src/utilities/Animation.svelte generated by Svelte v3.42.6 */
    const file$f = "docs_src/utilities/Animation.svelte";

    // (27:8) <Tab>
    function create_default_slot_8$2(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fas fa-cubes");
    			add_location(i, file$f, 26, 13, 913);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$2.name,
    		type: "slot",
    		source: "(27:8) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (28:8) <Tab>
    function create_default_slot_7$2(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fas fa-code");
    			add_location(i, file$f, 27, 13, 959);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$2.name,
    		type: "slot",
    		source: "(28:8) <Tab>",
    		ctx
    	});

    	return block;
    }

    // (26:6) <TabList>
    function create_default_slot_6$3(ctx) {
    	let tab0;
    	let t;
    	let tab1;
    	let current;

    	tab0 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_8$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tab1 = new Tab({
    			props: {
    				$$slots: { default: [create_default_slot_7$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tab0.$$.fragment);
    			t = space();
    			create_component(tab1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tab0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(tab1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tab0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				tab0_changes.$$scope = { dirty, ctx };
    			}

    			tab0.$set(tab0_changes);
    			const tab1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				tab1_changes.$$scope = { dirty, ctx };
    			}

    			tab1.$set(tab1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab0.$$.fragment, local);
    			transition_in(tab1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab0.$$.fragment, local);
    			transition_out(tab1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tab0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(tab1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$3.name,
    		type: "slot",
    		source: "(26:6) <TabList>",
    		ctx
    	});

    	return block;
    }

    // (43:8) <Badge href="#" className="margin-s bg--bluedark animation-fogwave">
    function create_default_slot_5$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Bandekriminialitet");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$3.name,
    		type: "slot",
    		source: "(43:8) <Badge href=\\\"#\\\" className=\\\"margin-s bg--bluedark animation-fogwave\\\">",
    		ctx
    	});

    	return block;
    }

    // (44:8) <Badge href="#" className="margin-s bg--green animation-fogwave">
    function create_default_slot_4$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Sport");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$4.name,
    		type: "slot",
    		source: "(44:8) <Badge href=\\\"#\\\" className=\\\"margin-s bg--green animation-fogwave\\\">",
    		ctx
    	});

    	return block;
    }

    // (45:8) <Badge href="#" className="margin-s bg--greendark animation-fogwave">
    function create_default_slot_3$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Nicklas Bendtner");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$5.name,
    		type: "slot",
    		source: "(45:8) <Badge href=\\\"#\\\" className=\\\"margin-s bg--greendark animation-fogwave\\\">",
    		ctx
    	});

    	return block;
    }

    // (31:4) <TabContent>
    function create_default_slot_2$9(ctx) {
    	let div0;
    	let articlecard;
    	let t0;
    	let div1;
    	let badge0;
    	let t1;
    	let badge1;
    	let t2;
    	let badge2;
    	let current;

    	articlecard = new ArticleCard({
    			props: {
    				className: "animation-fogwave",
    				media: {
    					src: 'https://via.placeholder.com/610x343&text=610x343'
    				},
    				published: /*article*/ ctx[0].timestamp,
    				section: /*article*/ ctx[0].section,
    				title: /*article*/ ctx[0].title,
    				url: /*article*/ ctx[0].href
    			},
    			$$inline: true
    		});

    	badge0 = new Badge({
    			props: {
    				href: "#",
    				className: "margin-s bg--bluedark animation-fogwave",
    				$$slots: { default: [create_default_slot_5$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	badge1 = new Badge({
    			props: {
    				href: "#",
    				className: "margin-s bg--green animation-fogwave",
    				$$slots: { default: [create_default_slot_4$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	badge2 = new Badge({
    			props: {
    				href: "#",
    				className: "margin-s bg--greendark animation-fogwave",
    				$$slots: { default: [create_default_slot_3$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(articlecard.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(badge0.$$.fragment);
    			t1 = space();
    			create_component(badge1.$$.fragment);
    			t2 = space();
    			create_component(badge2.$$.fragment);
    			attr_dev(div0, "class", "flex grid-width--small");
    			add_location(div0, file$f, 31, 6, 1042);
    			attr_dev(div1, "class", "flex grid-width--small");
    			add_location(div1, file$f, 41, 6, 1385);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(articlecard, div0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(badge0, div1, null);
    			append_dev(div1, t1);
    			mount_component(badge1, div1, null);
    			append_dev(div1, t2);
    			mount_component(badge2, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const badge0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				badge0_changes.$$scope = { dirty, ctx };
    			}

    			badge0.$set(badge0_changes);
    			const badge1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				badge1_changes.$$scope = { dirty, ctx };
    			}

    			badge1.$set(badge1_changes);
    			const badge2_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				badge2_changes.$$scope = { dirty, ctx };
    			}

    			badge2.$set(badge2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(articlecard.$$.fragment, local);
    			transition_in(badge0.$$.fragment, local);
    			transition_in(badge1.$$.fragment, local);
    			transition_in(badge2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(articlecard.$$.fragment, local);
    			transition_out(badge0.$$.fragment, local);
    			transition_out(badge1.$$.fragment, local);
    			transition_out(badge2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(articlecard);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			destroy_component(badge0);
    			destroy_component(badge1);
    			destroy_component(badge2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$9.name,
    		type: "slot",
    		source: "(31:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (48:4) <TabContent>
    function create_default_slot_1$a(ctx) {
    	let prism0;
    	let t0;
    	let prism1;
    	let t1;
    	let prism2;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				source: `<ArticleCard
          className="animation-fogwave"
          href="{article.href}"
          media="{{src:'https://via.placeholder.com/610x343&text=610x343'}}"
          section="{article.section}"
          timestamp="{article.timestamp}"
          title="{article.title}"
          />`
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				source: `<Badge href="#" className="margin-s bg--greendark animation-fogwave">Nicklas Bendtner</Badge>`
    			},
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				source: `<a href="#" class="badge badge--primary animation-fogwave margin-s--r">Bandekriminialitet</a>`
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prism0.$$.fragment);
    			t0 = space();
    			create_component(prism1.$$.fragment);
    			t1 = space();
    			create_component(prism2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(prism2, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(prism2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$a.name,
    		type: "slot",
    		source: "(48:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (24:2) <Tabs>
    function create_default_slot$a(ctx) {
    	let div;
    	let tablist;
    	let t0;
    	let tabcontent0;
    	let t1;
    	let tabcontent1;
    	let current;

    	tablist = new TabList({
    			props: {
    				$$slots: { default: [create_default_slot_6$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent0 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_2$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent1 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_1$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tablist.$$.fragment);
    			t0 = space();
    			create_component(tabcontent0.$$.fragment);
    			t1 = space();
    			create_component(tabcontent1.$$.fragment);
    			attr_dev(div, "class", "flex flex-justify--end width-1of1");
    			add_location(div, file$f, 24, 4, 836);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tablist, div, null);
    			insert_dev(target, t0, anchor);
    			mount_component(tabcontent0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tabcontent1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tablist_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				tablist_changes.$$scope = { dirty, ctx };
    			}

    			tablist.$set(tablist_changes);
    			const tabcontent0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				tabcontent0_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent0.$set(tabcontent0_changes);
    			const tabcontent1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				tabcontent1_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent1.$set(tabcontent1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tablist.$$.fragment, local);
    			transition_in(tabcontent0.$$.fragment, local);
    			transition_in(tabcontent1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tablist.$$.fragment, local);
    			transition_out(tabcontent0.$$.fragment, local);
    			transition_out(tabcontent1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tablist);
    			if (detaching) detach_dev(t0);
    			destroy_component(tabcontent0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tabcontent1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(24:2) <Tabs>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let div7;
    	let h1;
    	let t1;
    	let h30;
    	let t3;
    	let p0;
    	let t4;
    	let code0;
    	let t6;
    	let p1;
    	let t8;
    	let p2;
    	let b;
    	let t10;
    	let code1;
    	let t12;
    	let h31;
    	let t14;
    	let tabs;
    	let t15;
    	let h32;
    	let t17;
    	let div6;
    	let div2;
    	let div0;
    	let t19;
    	let div1;
    	let t21;
    	let div5;
    	let div3;
    	let t23;
    	let div4;
    	let prism;
    	let current;

    	tabs = new Tabs({
    			props: {
    				$$slots: { default: [create_default_slot$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism = new Prism$1({
    			props: {
    				language: "html",
    				source: `<component className="animation-fogwave"/></component>`
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Animation";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Anvendelse af animationer";
    			t3 = space();
    			p0 = element("p");
    			t4 = text("Animationer anvendes ved tilføjelse af class: ");
    			code0 = element("code");
    			code0.textContent = "className=\"animation-navnPåAnimation\"";
    			t6 = space();
    			p1 = element("p");
    			p1.textContent = "Denne class kan anvendes på tværs af vores komponenter";
    			t8 = space();
    			p2 = element("p");
    			b = element("b");
    			b.textContent = "OBS:";
    			t10 = text(" anvendes en animation direkte på et html-element skal det anvendes på følgende måde:\n    ");
    			code1 = element("code");
    			code1.textContent = "class=\"animation-navnPåAnimation\"";
    			t12 = space();
    			h31 = element("h3");
    			h31.textContent = "Eksempler på animationer";
    			t14 = space();
    			create_component(tabs.$$.fragment);
    			t15 = space();
    			h32 = element("h3");
    			h32.textContent = "Overblik over animationer";
    			t17 = space();
    			div6 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "Class";
    			t19 = space();
    			div1 = element("div");
    			div1.textContent = "Use case";
    			t21 = space();
    			div5 = element("div");
    			div3 = element("div");
    			div3.textContent = "animation-fogwave";
    			t23 = space();
    			div4 = element("div");
    			create_component(prism.$$.fragment);
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$f, 14, 2, 378);
    			add_location(h30, file$f, 15, 2, 417);
    			add_location(code0, file$f, 16, 51, 503);
    			add_location(p0, file$f, 16, 2, 454);
    			add_location(p1, file$f, 17, 2, 560);
    			add_location(b, file$f, 19, 4, 632);
    			add_location(code1, file$f, 20, 4, 733);
    			add_location(p2, file$f, 18, 2, 624);
    			add_location(h31, file$f, 22, 2, 789);
    			add_location(h32, file$f, 70, 2, 2465);
    			attr_dev(div0, "class", "width-1of3 padding-m fontweight-bold");
    			add_location(div0, file$f, 73, 6, 2643);
    			attr_dev(div1, "class", "width-1of3 padding-m fontweight-bold");
    			add_location(div1, file$f, 74, 6, 2711);
    			attr_dev(div2, "class", "flex flex-item--center bg--graa7");
    			set_style(div2, "border-bottom", "1px solid rgba(0, 0, 0, .1)");
    			add_location(div2, file$f, 72, 4, 2538);
    			attr_dev(div3, "class", "flex-item--center width-1of3 padding-m");
    			add_location(div3, file$f, 77, 6, 2878);
    			attr_dev(div4, "class", "flex-item--center width-2of3 padding-m");
    			add_location(div4, file$f, 78, 6, 2960);
    			attr_dev(div5, "class", "flex bg--graa7");
    			set_style(div5, "border-bottom", "1px solid rgba(0, 0, 0, .1)");
    			add_location(div5, file$f, 76, 4, 2791);
    			attr_dev(div6, "class", "grid-width--large");
    			add_location(div6, file$f, 71, 2, 2502);
    			attr_dev(div7, "class", "grid-width--large");
    			add_location(div7, file$f, 13, 0, 344);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, h1);
    			append_dev(div7, t1);
    			append_dev(div7, h30);
    			append_dev(div7, t3);
    			append_dev(div7, p0);
    			append_dev(p0, t4);
    			append_dev(p0, code0);
    			append_dev(div7, t6);
    			append_dev(div7, p1);
    			append_dev(div7, t8);
    			append_dev(div7, p2);
    			append_dev(p2, b);
    			append_dev(p2, t10);
    			append_dev(p2, code1);
    			append_dev(div7, t12);
    			append_dev(div7, h31);
    			append_dev(div7, t14);
    			mount_component(tabs, div7, null);
    			append_dev(div7, t15);
    			append_dev(div7, h32);
    			append_dev(div7, t17);
    			append_dev(div7, div6);
    			append_dev(div6, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t19);
    			append_dev(div2, div1);
    			append_dev(div6, t21);
    			append_dev(div6, div5);
    			append_dev(div5, div3);
    			append_dev(div5, t23);
    			append_dev(div5, div4);
    			mount_component(prism, div4, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tabs_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				tabs_changes.$$scope = { dirty, ctx };
    			}

    			tabs.$set(tabs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabs.$$.fragment, local);
    			transition_in(prism.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabs.$$.fragment, local);
    			transition_out(prism.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_component(tabs);
    			destroy_component(prism);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Animation', slots, []);

    	let article = {
    		href: '#',
    		media: {
    			src: 'https://via.placeholder.com/610x343&text=610x343'
    		},
    		section: 'Sport',
    		timestamp: '2 timer siden',
    		title: 'List element'
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Animation> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Prism: Prism$1,
    		ArticleCard,
    		Badge,
    		Tabs,
    		Tab,
    		TabContent,
    		TabList,
    		article
    	});

    	$$self.$inject_state = $$props => {
    		if ('article' in $$props) $$invalidate(0, article = $$props.article);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [article];
    }

    class Animation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Animation",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    /* docs_src/utilities/Border.svelte generated by Svelte v3.42.6 */
    const file$e = "docs_src/utilities/Border.svelte";

    // (10:2) 
    function create_content_slot_2(ctx) {
    	let div5;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;
    	let t5;
    	let div3;
    	let t7;
    	let div4;

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div0 = element("div");
    			div0.textContent = "border";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "border--t";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "border--b";
    			t5 = space();
    			div3 = element("div");
    			div3.textContent = "border--l";
    			t7 = space();
    			div4 = element("div");
    			div4.textContent = "border--r";
    			attr_dev(div0, "class", "border border--black width-1of3 padding-xl margin-l bg--eb");
    			add_location(div0, file$e, 10, 4, 256);
    			attr_dev(div1, "class", "border--t border--black width-1of3 padding-xl margin-l bg--eb");
    			add_location(div1, file$e, 11, 4, 345);
    			attr_dev(div2, "class", "border--b border--black width-1of3 padding-xl margin-l bg--eb");
    			add_location(div2, file$e, 12, 4, 440);
    			attr_dev(div3, "class", "border--l border--black width-1of3 padding-xl margin-l bg--eb");
    			add_location(div3, file$e, 13, 4, 535);
    			attr_dev(div4, "class", "border--r border--black width-1of3 padding-xl margin-l bg--eb");
    			add_location(div4, file$e, 14, 4, 630);
    			attr_dev(div5, "class", "flex flex-justify--between flex-wrap--wrap");
    			attr_dev(div5, "slot", "content");
    			add_location(div5, file$e, 9, 2, 180);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div0);
    			append_dev(div5, t1);
    			append_dev(div5, div1);
    			append_dev(div5, t3);
    			append_dev(div5, div2);
    			append_dev(div5, t5);
    			append_dev(div5, div3);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot_2.name,
    		type: "slot",
    		source: "(10:2) ",
    		ctx
    	});

    	return block;
    }

    // (19:0) <Prism language="html">
    function create_default_slot_2$8(ctx) {
    	let t_value = `<div class="border"></div>
<div class="border--t"></div>
<div class="border--b"></div>
<div class="border--l"></div>
<div class="border--r"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$8.name,
    		type: "slot",
    		source: "(19:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (30:2) 
    function create_content_slot_1$1(ctx) {
    	let div6;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;
    	let t5;
    	let div3;
    	let t7;
    	let div4;
    	let t9;
    	let div5;

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div0 = element("div");
    			div0.textContent = "border-radius";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "border-radius-s";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "border-radius--t";
    			t5 = space();
    			div3 = element("div");
    			div3.textContent = "border-radius-s--t";
    			t7 = space();
    			div4 = element("div");
    			div4.textContent = "border-radius--b";
    			t9 = space();
    			div5 = element("div");
    			div5.textContent = "border-radius-s--b";
    			attr_dev(div0, "class", "border-radius padding-xl width-1of3 margin-l bg--eb");
    			add_location(div0, file$e, 30, 4, 1057);
    			attr_dev(div1, "class", "border-radius-s padding-xl width-1of3 margin-l bg--eb");
    			add_location(div1, file$e, 31, 4, 1146);
    			attr_dev(div2, "class", "border-radius--t padding-xl width-1of3 margin-l bg--eb");
    			add_location(div2, file$e, 32, 4, 1239);
    			attr_dev(div3, "class", "border-radius-s--t padding-xl width-1of3 margin-l bg--eb");
    			add_location(div3, file$e, 33, 4, 1334);
    			attr_dev(div4, "class", "border-radius--b padding-xl width-1of3 margin-l bg--eb");
    			add_location(div4, file$e, 34, 4, 1433);
    			attr_dev(div5, "class", "border-radius-s--b padding-xl width-1of3 margin-l bg--eb");
    			add_location(div5, file$e, 35, 4, 1528);
    			attr_dev(div6, "class", "flex flex-justify--between flex-wrap--wrap");
    			attr_dev(div6, "slot", "content");
    			add_location(div6, file$e, 29, 2, 981);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div0);
    			append_dev(div6, t1);
    			append_dev(div6, div1);
    			append_dev(div6, t3);
    			append_dev(div6, div2);
    			append_dev(div6, t5);
    			append_dev(div6, div3);
    			append_dev(div6, t7);
    			append_dev(div6, div4);
    			append_dev(div6, t9);
    			append_dev(div6, div5);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot_1$1.name,
    		type: "slot",
    		source: "(30:2) ",
    		ctx
    	});

    	return block;
    }

    // (40:0) <Prism language="html">
    function create_default_slot_1$9(ctx) {
    	let t_value = `<div class="border-radius"></div>
<div class="border-radius-s"></div>
<div class="border-radius--t"></div>
<div class="border-radius-s--t"></div>
<div class="border-radius--b"></div>
<div class="border-radius-s--b"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$9.name,
    		type: "slot",
    		source: "(40:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (53:2) 
    function create_content_slot$3(ctx) {
    	let div9;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;
    	let t5;
    	let div3;
    	let t7;
    	let div4;
    	let t9;
    	let div5;
    	let t11;
    	let div6;
    	let t13;
    	let div7;
    	let t15;
    	let div8;

    	const block = {
    		c: function create() {
    			div9 = element("div");
    			div0 = element("div");
    			div0.textContent = "border--black";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "border--graa1";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "border--graa2";
    			t5 = space();
    			div3 = element("div");
    			div3.textContent = "border--graa3";
    			t7 = space();
    			div4 = element("div");
    			div4.textContent = "border--graa4";
    			t9 = space();
    			div5 = element("div");
    			div5.textContent = "border--graa5";
    			t11 = space();
    			div6 = element("div");
    			div6.textContent = "border--graa6";
    			t13 = space();
    			div7 = element("div");
    			div7.textContent = "border--graa7";
    			t15 = space();
    			div8 = element("div");
    			div8.textContent = "border--white";
    			attr_dev(div0, "class", "flex flex-align--center border border--black padding-xl width-1of3 margin-l");
    			add_location(div0, file$e, 53, 4, 2047);
    			attr_dev(div1, "class", "flex flex-align--center border border--graa1 padding-xl width-1of3 margin-l");
    			add_location(div1, file$e, 54, 4, 2160);
    			attr_dev(div2, "class", "flex flex-align--center border border--graa2 padding-xl width-1of3 margin-l");
    			add_location(div2, file$e, 55, 4, 2273);
    			attr_dev(div3, "class", "flex flex-align--center border border--graa3 padding-xl width-1of3 margin-l");
    			add_location(div3, file$e, 56, 4, 2386);
    			attr_dev(div4, "class", "flex flex-align--center border border--graa4 padding-xl width-1of3 margin-l");
    			add_location(div4, file$e, 57, 4, 2499);
    			attr_dev(div5, "class", "flex flex-align--center border border--graa5 padding-xl width-1of3 margin-l");
    			add_location(div5, file$e, 58, 4, 2612);
    			attr_dev(div6, "class", "flex flex-align--center border border--graa6 padding-xl width-1of3 margin-l");
    			add_location(div6, file$e, 59, 4, 2725);
    			attr_dev(div7, "class", "flex flex-align--center border border--graa7 padding-xl width-1of3 margin-l");
    			add_location(div7, file$e, 60, 4, 2838);
    			attr_dev(div8, "class", "flex flex-align--center border border--white padding-xl width-1of3 margin-l");
    			add_location(div8, file$e, 61, 4, 2951);
    			attr_dev(div9, "class", "flex flex-justify--between flex-wrap--wrap");
    			attr_dev(div9, "slot", "content");
    			add_location(div9, file$e, 52, 2, 1971);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div0);
    			append_dev(div9, t1);
    			append_dev(div9, div1);
    			append_dev(div9, t3);
    			append_dev(div9, div2);
    			append_dev(div9, t5);
    			append_dev(div9, div3);
    			append_dev(div9, t7);
    			append_dev(div9, div4);
    			append_dev(div9, t9);
    			append_dev(div9, div5);
    			append_dev(div9, t11);
    			append_dev(div9, div6);
    			append_dev(div9, t13);
    			append_dev(div9, div7);
    			append_dev(div9, t15);
    			append_dev(div9, div8);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div9);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot$3.name,
    		type: "slot",
    		source: "(53:2) ",
    		ctx
    	});

    	return block;
    }

    // (66:0) <Prism language="html">
    function create_default_slot$9(ctx) {
    	let t_value = `<div class="border border--black"></div>
<div class="border border--graa1"></div>
<div class="border border--graa2"></div>
<div class="border border--graa3"></div>
<div class="border border--graa4"></div>
<div class="border border--graa5"></div>
<div class="border border--graa6"></div>
<div class="border border--graa7"></div>
<div class="border border--white"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(66:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let h1;
    	let t1;
    	let h30;
    	let t3;
    	let card0;
    	let t4;
    	let prism0;
    	let t5;
    	let h31;
    	let t7;
    	let card1;
    	let t8;
    	let prism1;
    	let t9;
    	let h32;
    	let t11;
    	let p;
    	let t13;
    	let card2;
    	let t14;
    	let prism2;
    	let current;

    	card0 = new Card({
    			props: {
    				className: "bg--graa7",
    				$$slots: { content: [create_content_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card1 = new Card({
    			props: {
    				className: "bg--graa7",
    				$$slots: { content: [create_content_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card2 = new Card({
    			props: {
    				$$slots: { content: [create_content_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Border";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Border";
    			t3 = space();
    			create_component(card0.$$.fragment);
    			t4 = space();
    			create_component(prism0.$$.fragment);
    			t5 = space();
    			h31 = element("h3");
    			h31.textContent = "Border-radius";
    			t7 = space();
    			create_component(card1.$$.fragment);
    			t8 = space();
    			create_component(prism1.$$.fragment);
    			t9 = space();
    			h32 = element("h3");
    			h32.textContent = "Border colors";
    			t11 = space();
    			p = element("p");
    			p.textContent = "All border colors available";
    			t13 = space();
    			create_component(card2.$$.fragment);
    			t14 = space();
    			create_component(prism2.$$.fragment);
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$e, 4, 0, 97);
    			add_location(h30, file$e, 6, 0, 132);
    			add_location(h31, file$e, 26, 0, 926);
    			add_location(h32, file$e, 48, 0, 1903);
    			add_location(p, file$e, 49, 0, 1926);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(card0, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(card1, target, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, p, anchor);
    			insert_dev(target, t13, anchor);
    			mount_component(card2, target, anchor);
    			insert_dev(target, t14, anchor);
    			mount_component(prism2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const card0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card0_changes.$$scope = { dirty, ctx };
    			}

    			card0.$set(card0_changes);
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const card1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card1_changes.$$scope = { dirty, ctx };
    			}

    			card1.$set(card1_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    			const card2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card2_changes.$$scope = { dirty, ctx };
    			}

    			card2.$set(card2_changes);
    			const prism2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism2_changes.$$scope = { dirty, ctx };
    			}

    			prism2.$set(prism2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card0.$$.fragment, local);
    			transition_in(prism0.$$.fragment, local);
    			transition_in(card1.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(card2.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card0.$$.fragment, local);
    			transition_out(prism0.$$.fragment, local);
    			transition_out(card1.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(card2.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t3);
    			destroy_component(card0, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t7);
    			destroy_component(card1, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t13);
    			destroy_component(card2, detaching);
    			if (detaching) detach_dev(t14);
    			destroy_component(prism2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Border', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Border> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1, Card });
    	return [];
    }

    class Border extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Border",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* docs_src/utilities/Color.svelte generated by Svelte v3.42.6 */
    const file$d = "docs_src/utilities/Color.svelte";

    // (14:2) 
    function create_content_slot_1(ctx) {
    	let div7;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;
    	let t5;
    	let div3;
    	let t7;
    	let div4;
    	let t9;
    	let div5;
    	let t11;
    	let div6;
    	let t12;
    	let em;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div0 = element("div");
    			div0.textContent = "color--black";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "color--white";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "color--sport";
    			t5 = space();
    			div3 = element("div");
    			div3.textContent = "color--eb";
    			t7 = space();
    			div4 = element("div");
    			div4.textContent = "color--orangedark";
    			t9 = space();
    			div5 = element("div");
    			div5.textContent = "color--nyheder";
    			t11 = space();
    			div6 = element("div");
    			t12 = text("color--section\n      ");
    			em = element("em");
    			em.textContent = "(inherit the color of the section i.e sport)";
    			attr_dev(div0, "class", "flex flex--column padding-xl width-1of3 margin-l bg--white color--black");
    			add_location(div0, file$d, 14, 4, 462);
    			attr_dev(div1, "class", "flex flex--column padding-xl width-1of3 margin-l bg--black color--white");
    			add_location(div1, file$d, 15, 4, 570);
    			attr_dev(div2, "class", "flex flex--column padding-xl width-1of3 margin-l bg--white color--sport");
    			add_location(div2, file$d, 16, 4, 678);
    			attr_dev(div3, "class", "flex flex--column padding-xl width-1of3 margin-l bg--white color--eb");
    			add_location(div3, file$d, 17, 4, 786);
    			attr_dev(div4, "class", "flex flex--column padding-xl width-1of3 margin-l bg--white color--orangedark");
    			add_location(div4, file$d, 18, 4, 888);
    			attr_dev(div5, "class", "flex flex--column padding-xl width-1of3 margin-l bg--white color--nyheder");
    			add_location(div5, file$d, 19, 4, 1006);
    			add_location(em, file$d, 22, 6, 1233);
    			attr_dev(div6, "class", "flex flex--column padding-xl width-1of3 margin-l bg--white color--section");
    			add_location(div6, file$d, 20, 4, 1118);
    			attr_dev(div7, "class", "flex flex-justify--between flex-wrap--wrap");
    			attr_dev(div7, "slot", "content");
    			add_location(div7, file$d, 13, 2, 386);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div0);
    			append_dev(div7, t1);
    			append_dev(div7, div1);
    			append_dev(div7, t3);
    			append_dev(div7, div2);
    			append_dev(div7, t5);
    			append_dev(div7, div3);
    			append_dev(div7, t7);
    			append_dev(div7, div4);
    			append_dev(div7, t9);
    			append_dev(div7, div5);
    			append_dev(div7, t11);
    			append_dev(div7, div6);
    			append_dev(div6, t12);
    			append_dev(div6, em);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot_1.name,
    		type: "slot",
    		source: "(14:2) ",
    		ctx
    	});

    	return block;
    }

    // (28:0) <Prism language="html">
    function create_default_slot_1$8(ctx) {
    	let t_value = `<div class="color--black"></div>
<div class="color--white"></div>
<div class="color--blue"></div>
<div class="color--sport"></div>
<div class="color--orangedark"></div>
<div class="color--nyheder"></div>
<div class="color--section"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(28:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (42:2) 
    function create_content_slot$2(ctx) {
    	let div7;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;
    	let t5;
    	let div3;
    	let t7;
    	let div4;
    	let t9;
    	let div5;
    	let t11;
    	let div6;
    	let t12;
    	let em;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div0 = element("div");
    			div0.textContent = "bg--black";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "bg--white";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "bg--underholdning";
    			t5 = space();
    			div3 = element("div");
    			div3.textContent = "bg--eb";
    			t7 = space();
    			div4 = element("div");
    			div4.textContent = "bg--orangedark";
    			t9 = space();
    			div5 = element("div");
    			div5.textContent = "bg--nyheder";
    			t11 = space();
    			div6 = element("div");
    			t12 = text("bg--section\n      ");
    			em = element("em");
    			em.textContent = "(inherit the color of the section i.e sport)";
    			attr_dev(div0, "class", "flex flex--column padding-xl width-1of3 margin-l bg--black");
    			add_location(div0, file$d, 42, 4, 1833);
    			attr_dev(div1, "class", "flex flex--column padding-xl width-1of3 margin-l bg--white color--black");
    			add_location(div1, file$d, 43, 4, 1925);
    			attr_dev(div2, "class", "flex flex--column padding-xl width-1of3 margin-l bg--underholdning");
    			add_location(div2, file$d, 44, 4, 2030);
    			attr_dev(div3, "class", "flex flex--column padding-xl width-1of3 margin-l bg--eb");
    			add_location(div3, file$d, 45, 4, 2138);
    			attr_dev(div4, "class", "flex flex--column padding-xl width-1of3 margin-l bg--orangedark");
    			add_location(div4, file$d, 46, 4, 2224);
    			attr_dev(div5, "class", "flex flex--column padding-xl width-1of3 margin-l bg--nyheder");
    			add_location(div5, file$d, 47, 4, 2326);
    			add_location(em, file$d, 50, 6, 2534);
    			attr_dev(div6, "class", "flex flex--column padding-xl width-1of3 margin-l bg--white color--section");
    			add_location(div6, file$d, 48, 4, 2422);
    			attr_dev(div7, "class", "flex flex-justify--between flex-wrap--wrap");
    			attr_dev(div7, "slot", "content");
    			add_location(div7, file$d, 41, 2, 1757);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div0);
    			append_dev(div7, t1);
    			append_dev(div7, div1);
    			append_dev(div7, t3);
    			append_dev(div7, div2);
    			append_dev(div7, t5);
    			append_dev(div7, div3);
    			append_dev(div7, t7);
    			append_dev(div7, div4);
    			append_dev(div7, t9);
    			append_dev(div7, div5);
    			append_dev(div7, t11);
    			append_dev(div7, div6);
    			append_dev(div6, t12);
    			append_dev(div6, em);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot$2.name,
    		type: "slot",
    		source: "(42:2) ",
    		ctx
    	});

    	return block;
    }

    // (56:0) <Prism language="html">
    function create_default_slot$8(ctx) {
    	let t_value = `<div class="bg--black"></div>
<div class="bg--white"></div>
<div class="bg--underholdning"></div>
<div class="bg--eb"></div>
<div class="bg--orangedark"></div>
<div class="bg--nyheder"></div>
<div class="bg--section"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(56:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let h1;
    	let t1;
    	let h30;
    	let t3;
    	let p0;
    	let t5;
    	let card0;
    	let t6;
    	let prism0;
    	let t7;
    	let h31;
    	let t9;
    	let p1;
    	let t11;
    	let card1;
    	let t12;
    	let prism1;
    	let t13;
    	let h32;
    	let t15;
    	let object;
    	let t16;
    	let a;
    	let current;
    	let mounted;
    	let dispose;

    	card0 = new Card({
    			props: {
    				className: "bg--graa7",
    				$$slots: { content: [create_content_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card1 = new Card({
    			props: {
    				className: "bg--graa7",
    				$$slots: { content: [create_content_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Color";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Text color";
    			t3 = space();
    			p0 = element("p");
    			p0.textContent = "View all colors available";
    			t5 = space();
    			create_component(card0.$$.fragment);
    			t6 = space();
    			create_component(prism0.$$.fragment);
    			t7 = space();
    			h31 = element("h3");
    			h31.textContent = "Background color";
    			t9 = space();
    			p1 = element("p");
    			p1.textContent = "View all colors available";
    			t11 = space();
    			create_component(card1.$$.fragment);
    			t12 = space();
    			create_component(prism1.$$.fragment);
    			t13 = space();
    			h32 = element("h3");
    			h32.textContent = "All colors available on ekstrabladet";
    			t15 = space();
    			object = element("object");
    			t16 = text("Error: Embedded data could not be displayed. Visit this link instead: ");
    			a = element("a");
    			a.textContent = "eb-colors";
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$d, 7, 0, 196);
    			add_location(h30, file$d, 9, 0, 230);
    			attr_dev(p0, "class", "color--red");
    			set_style(p0, "cursor", "pointer");
    			add_location(p0, file$d, 10, 0, 250);
    			add_location(h31, file$d, 37, 0, 1595);
    			attr_dev(p1, "class", "color--red");
    			set_style(p1, "cursor", "pointer");
    			add_location(p1, file$d, 38, 0, 1621);
    			attr_dev(h32, "id", "all-colors-section");
    			add_location(h32, file$d, 65, 0, 2881);
    			attr_dev(a, "href", "https://ekstrabladetudvikling.github.io/eb-colors/");
    			add_location(a, file$d, 68, 72, 3135);
    			attr_dev(object, "data", "https://ekstrabladetudvikling.github.io/eb-colors/");
    			attr_dev(object, "width", "100%");
    			attr_dev(object, "height", "500");
    			attr_dev(object, "title", "eb-colors");
    			add_location(object, file$d, 67, 0, 2952);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(card0, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t11, anchor);
    			mount_component(card1, target, anchor);
    			insert_dev(target, t12, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t13, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t15, anchor);
    			insert_dev(target, object, anchor);
    			append_dev(object, t16);
    			append_dev(object, a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(p0, "click", moveToAllColors, false, false, false),
    					listen_dev(p1, "click", moveToAllColors, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const card0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card0_changes.$$scope = { dirty, ctx };
    			}

    			card0.$set(card0_changes);
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const card1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card1_changes.$$scope = { dirty, ctx };
    			}

    			card1.$set(card1_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card0.$$.fragment, local);
    			transition_in(prism0.$$.fragment, local);
    			transition_in(card1.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card0.$$.fragment, local);
    			transition_out(prism0.$$.fragment, local);
    			transition_out(card1.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t5);
    			destroy_component(card0, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t11);
    			destroy_component(card1, detaching);
    			if (detaching) detach_dev(t12);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t13);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t15);
    			if (detaching) detach_dev(object);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function moveToAllColors() {
    	document.getElementById('all-colors-section').scrollIntoView();
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Color', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Color> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1, Card, moveToAllColors });
    	return [];
    }

    class Color extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Color",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    /* docs_src/utilities/Flex.svelte generated by Svelte v3.42.6 */
    const file$c = "docs_src/utilities/Flex.svelte";

    // (9:0) <Prism language="html">
    function create_default_slot_14(ctx) {
    	let t_value = `<div class="flex"></div>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14.name,
    		type: "slot",
    		source: "(9:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (16:0) <Card className="bg--graa7">
    function create_default_slot_13(ctx) {
    	let strong0;
    	let t1;
    	let div3;
    	let div0;
    	let t3;
    	let div1;
    	let t5;
    	let div2;
    	let t7;
    	let strong1;
    	let t9;
    	let div7;
    	let div4;
    	let t11;
    	let div5;
    	let t13;
    	let div6;
    	let t15;
    	let strong2;
    	let t17;
    	let div11;
    	let div8;
    	let t19;
    	let div9;
    	let t21;
    	let div10;
    	let t23;
    	let strong3;
    	let t25;
    	let div15;
    	let div12;
    	let t27;
    	let div13;
    	let t29;
    	let div14;
    	let t31;
    	let strong4;
    	let t33;
    	let div19;
    	let div16;
    	let t35;
    	let div17;
    	let t37;
    	let div18;

    	const block = {
    		c: function create() {
    			strong0 = element("strong");
    			strong0.textContent = "flex flex-justify--start";
    			t1 = space();
    			div3 = element("div");
    			div0 = element("div");
    			div0.textContent = "Flex item 1";
    			t3 = space();
    			div1 = element("div");
    			div1.textContent = "Flex item 2";
    			t5 = space();
    			div2 = element("div");
    			div2.textContent = "Flex item 3";
    			t7 = space();
    			strong1 = element("strong");
    			strong1.textContent = "flex flex-justify--end";
    			t9 = space();
    			div7 = element("div");
    			div4 = element("div");
    			div4.textContent = "Flex item 1";
    			t11 = space();
    			div5 = element("div");
    			div5.textContent = "Flex item 2";
    			t13 = space();
    			div6 = element("div");
    			div6.textContent = "Flex item 3";
    			t15 = space();
    			strong2 = element("strong");
    			strong2.textContent = "flex flex-justify--center";
    			t17 = space();
    			div11 = element("div");
    			div8 = element("div");
    			div8.textContent = "Flex item 1";
    			t19 = space();
    			div9 = element("div");
    			div9.textContent = "Flex item 2";
    			t21 = space();
    			div10 = element("div");
    			div10.textContent = "Flex item 3";
    			t23 = space();
    			strong3 = element("strong");
    			strong3.textContent = "flex flex-justify--around";
    			t25 = space();
    			div15 = element("div");
    			div12 = element("div");
    			div12.textContent = "Flex item 1";
    			t27 = space();
    			div13 = element("div");
    			div13.textContent = "Flex item 2";
    			t29 = space();
    			div14 = element("div");
    			div14.textContent = "Flex item 3";
    			t31 = space();
    			strong4 = element("strong");
    			strong4.textContent = "flex flex-justify--between";
    			t33 = space();
    			div19 = element("div");
    			div16 = element("div");
    			div16.textContent = "Flex item 1";
    			t35 = space();
    			div17 = element("div");
    			div17.textContent = "Flex item 2";
    			t37 = space();
    			div18 = element("div");
    			div18.textContent = "Flex item 3";
    			attr_dev(strong0, "class", "margin-m");
    			add_location(strong0, file$c, 16, 2, 361);
    			attr_dev(div0, "class", "bg--graa4 padding-l");
    			add_location(div0, file$c, 18, 4, 472);
    			attr_dev(div1, "class", "bg--graa3 padding-l");
    			add_location(div1, file$c, 19, 4, 527);
    			attr_dev(div2, "class", "bg--graa2 padding-l");
    			add_location(div2, file$c, 20, 4, 582);
    			attr_dev(div3, "class", "flex flex-justify--start bg--eb");
    			add_location(div3, file$c, 17, 2, 422);
    			attr_dev(strong1, "class", "margin-m margin-l--t");
    			add_location(strong1, file$c, 22, 2, 644);
    			attr_dev(div4, "class", "bg--graa4 padding-l");
    			add_location(div4, file$c, 24, 4, 763);
    			attr_dev(div5, "class", "bg--graa3 padding-l");
    			add_location(div5, file$c, 25, 4, 818);
    			attr_dev(div6, "class", "bg--graa2 padding-l");
    			add_location(div6, file$c, 26, 4, 873);
    			attr_dev(div7, "class", "flex flex-justify--end bg--eb");
    			add_location(div7, file$c, 23, 2, 715);
    			attr_dev(strong2, "class", "margin-m margin-l--t");
    			add_location(strong2, file$c, 28, 2, 935);
    			attr_dev(div8, "class", "bg--graa4 padding-l");
    			add_location(div8, file$c, 30, 4, 1060);
    			attr_dev(div9, "class", "bg--graa3 padding-l");
    			add_location(div9, file$c, 31, 4, 1115);
    			attr_dev(div10, "class", "bg--graa2 padding-l");
    			add_location(div10, file$c, 32, 4, 1170);
    			attr_dev(div11, "class", "flex flex-justify--center bg--eb");
    			add_location(div11, file$c, 29, 2, 1009);
    			attr_dev(strong3, "class", "margin-m margin-l--t");
    			add_location(strong3, file$c, 34, 2, 1232);
    			attr_dev(div12, "class", "bg--graa4 padding-l");
    			add_location(div12, file$c, 36, 4, 1357);
    			attr_dev(div13, "class", "bg--graa3 padding-l");
    			add_location(div13, file$c, 37, 4, 1412);
    			attr_dev(div14, "class", "bg--graa2 padding-l");
    			add_location(div14, file$c, 38, 4, 1467);
    			attr_dev(div15, "class", "flex flex-justify--around bg--eb");
    			add_location(div15, file$c, 35, 2, 1306);
    			attr_dev(strong4, "class", "margin-m margin-l--t");
    			add_location(strong4, file$c, 40, 2, 1529);
    			attr_dev(div16, "class", "bg--graa4 padding-l");
    			add_location(div16, file$c, 42, 4, 1656);
    			attr_dev(div17, "class", "bg--graa3 padding-l");
    			add_location(div17, file$c, 43, 4, 1711);
    			attr_dev(div18, "class", "bg--graa2 padding-l");
    			add_location(div18, file$c, 44, 4, 1766);
    			attr_dev(div19, "class", "flex flex-justify--between bg--eb");
    			add_location(div19, file$c, 41, 2, 1604);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, strong0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t3);
    			append_dev(div3, div1);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, strong1, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div4);
    			append_dev(div7, t11);
    			append_dev(div7, div5);
    			append_dev(div7, t13);
    			append_dev(div7, div6);
    			insert_dev(target, t15, anchor);
    			insert_dev(target, strong2, anchor);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, div11, anchor);
    			append_dev(div11, div8);
    			append_dev(div11, t19);
    			append_dev(div11, div9);
    			append_dev(div11, t21);
    			append_dev(div11, div10);
    			insert_dev(target, t23, anchor);
    			insert_dev(target, strong3, anchor);
    			insert_dev(target, t25, anchor);
    			insert_dev(target, div15, anchor);
    			append_dev(div15, div12);
    			append_dev(div15, t27);
    			append_dev(div15, div13);
    			append_dev(div15, t29);
    			append_dev(div15, div14);
    			insert_dev(target, t31, anchor);
    			insert_dev(target, strong4, anchor);
    			insert_dev(target, t33, anchor);
    			insert_dev(target, div19, anchor);
    			append_dev(div19, div16);
    			append_dev(div19, t35);
    			append_dev(div19, div17);
    			append_dev(div19, t37);
    			append_dev(div19, div18);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(strong0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div3);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(strong1);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(div7);
    			if (detaching) detach_dev(t15);
    			if (detaching) detach_dev(strong2);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(div11);
    			if (detaching) detach_dev(t23);
    			if (detaching) detach_dev(strong3);
    			if (detaching) detach_dev(t25);
    			if (detaching) detach_dev(div15);
    			if (detaching) detach_dev(t31);
    			if (detaching) detach_dev(strong4);
    			if (detaching) detach_dev(t33);
    			if (detaching) detach_dev(div19);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13.name,
    		type: "slot",
    		source: "(16:0) <Card className=\\\"bg--graa7\\\">",
    		ctx
    	});

    	return block;
    }

    // (49:0) <Prism language="html">
    function create_default_slot_12(ctx) {
    	let t_value = `<div class="flex flex-justify--start"></div>
<div class="flex flex-justify--end"></div>
<div class="flex flex-justify--center"></div>
<div class="flex flex-justify--around"></div>
<div class="flex flex-justify--between"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12.name,
    		type: "slot",
    		source: "(49:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (60:0) <Card className="bg--graa7">
    function create_default_slot_11(ctx) {
    	let strong0;
    	let t1;
    	let div3;
    	let div0;
    	let t3;
    	let div1;
    	let t5;
    	let div2;
    	let t7;
    	let strong1;
    	let t9;
    	let div7;
    	let div4;
    	let t11;
    	let div5;
    	let t13;
    	let div6;
    	let t15;
    	let strong2;
    	let t17;
    	let div11;
    	let div8;
    	let t19;
    	let div9;
    	let t21;
    	let div10;
    	let t23;
    	let strong3;
    	let t25;
    	let div15;
    	let div12;
    	let t27;
    	let div13;
    	let t29;
    	let div14;

    	const block = {
    		c: function create() {
    			strong0 = element("strong");
    			strong0.textContent = "flex flex-align--start";
    			t1 = space();
    			div3 = element("div");
    			div0 = element("div");
    			div0.textContent = "Flex item 1";
    			t3 = space();
    			div1 = element("div");
    			div1.textContent = "Flex item 2";
    			t5 = space();
    			div2 = element("div");
    			div2.textContent = "Flex item 3";
    			t7 = space();
    			strong1 = element("strong");
    			strong1.textContent = "flex flex-align--end";
    			t9 = space();
    			div7 = element("div");
    			div4 = element("div");
    			div4.textContent = "Flex item 1";
    			t11 = space();
    			div5 = element("div");
    			div5.textContent = "Flex item 2";
    			t13 = space();
    			div6 = element("div");
    			div6.textContent = "Flex item 3";
    			t15 = space();
    			strong2 = element("strong");
    			strong2.textContent = "flex flex-align--center";
    			t17 = space();
    			div11 = element("div");
    			div8 = element("div");
    			div8.textContent = "Flex item 1";
    			t19 = space();
    			div9 = element("div");
    			div9.textContent = "Flex item 2";
    			t21 = space();
    			div10 = element("div");
    			div10.textContent = "Flex item 3";
    			t23 = space();
    			strong3 = element("strong");
    			strong3.textContent = "flex flex-align--stretch";
    			t25 = space();
    			div15 = element("div");
    			div12 = element("div");
    			div12.textContent = "Flex item 1";
    			t27 = space();
    			div13 = element("div");
    			div13.textContent = "Flex item 2";
    			t29 = space();
    			div14 = element("div");
    			div14.textContent = "Flex item 3";
    			attr_dev(strong0, "class", "margin-m");
    			add_location(strong0, file$c, 60, 2, 2233);
    			attr_dev(div0, "class", "bg--graa4 padding-l");
    			add_location(div0, file$c, 62, 4, 2362);
    			attr_dev(div1, "class", "bg--graa3 padding-l");
    			add_location(div1, file$c, 63, 4, 2417);
    			attr_dev(div2, "class", "bg--graa2 padding-l");
    			add_location(div2, file$c, 64, 4, 2472);
    			attr_dev(div3, "class", "flex flex-align--start bg--eb");
    			set_style(div3, "height", "100px");
    			add_location(div3, file$c, 61, 2, 2292);
    			attr_dev(strong1, "class", "margin-m margin-l--t");
    			add_location(strong1, file$c, 66, 2, 2534);
    			attr_dev(div4, "class", "bg--graa4 padding-l");
    			add_location(div4, file$c, 68, 4, 2671);
    			attr_dev(div5, "class", "bg--graa3 padding-l");
    			add_location(div5, file$c, 69, 4, 2726);
    			attr_dev(div6, "class", "bg--graa2 padding-l");
    			add_location(div6, file$c, 70, 4, 2781);
    			attr_dev(div7, "class", "flex flex-align--end bg--eb");
    			set_style(div7, "height", "100px");
    			add_location(div7, file$c, 67, 2, 2603);
    			attr_dev(strong2, "class", "margin-m margin-l--t");
    			add_location(strong2, file$c, 72, 2, 2843);
    			attr_dev(div8, "class", "bg--graa4 padding-l");
    			add_location(div8, file$c, 74, 4, 2986);
    			attr_dev(div9, "class", "bg--graa3 padding-l");
    			add_location(div9, file$c, 75, 4, 3041);
    			attr_dev(div10, "class", "bg--graa2 padding-l");
    			add_location(div10, file$c, 76, 4, 3096);
    			attr_dev(div11, "class", "flex flex-align--center bg--eb");
    			set_style(div11, "height", "100px");
    			add_location(div11, file$c, 73, 2, 2915);
    			attr_dev(strong3, "class", "margin-m margin-l--t");
    			add_location(strong3, file$c, 78, 2, 3158);
    			attr_dev(div12, "class", "bg--graa4 padding-l");
    			add_location(div12, file$c, 80, 4, 3303);
    			attr_dev(div13, "class", "bg--graa3 padding-l");
    			add_location(div13, file$c, 81, 4, 3358);
    			attr_dev(div14, "class", "bg--graa2 padding-l");
    			add_location(div14, file$c, 82, 4, 3413);
    			attr_dev(div15, "class", "flex flex-align--stretch bg--eb");
    			set_style(div15, "height", "100px");
    			add_location(div15, file$c, 79, 2, 3231);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, strong0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t3);
    			append_dev(div3, div1);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, strong1, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div4);
    			append_dev(div7, t11);
    			append_dev(div7, div5);
    			append_dev(div7, t13);
    			append_dev(div7, div6);
    			insert_dev(target, t15, anchor);
    			insert_dev(target, strong2, anchor);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, div11, anchor);
    			append_dev(div11, div8);
    			append_dev(div11, t19);
    			append_dev(div11, div9);
    			append_dev(div11, t21);
    			append_dev(div11, div10);
    			insert_dev(target, t23, anchor);
    			insert_dev(target, strong3, anchor);
    			insert_dev(target, t25, anchor);
    			insert_dev(target, div15, anchor);
    			append_dev(div15, div12);
    			append_dev(div15, t27);
    			append_dev(div15, div13);
    			append_dev(div15, t29);
    			append_dev(div15, div14);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(strong0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div3);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(strong1);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(div7);
    			if (detaching) detach_dev(t15);
    			if (detaching) detach_dev(strong2);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(div11);
    			if (detaching) detach_dev(t23);
    			if (detaching) detach_dev(strong3);
    			if (detaching) detach_dev(t25);
    			if (detaching) detach_dev(div15);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(60:0) <Card className=\\\"bg--graa7\\\">",
    		ctx
    	});

    	return block;
    }

    // (87:0) <Prism language="html">
    function create_default_slot_10$1(ctx) {
    	let t_value = `<div class="flex flex-align--start"></div>
<div class="flex flex-align--end"></div>
<div class="flex flex-align--center"></div>
<div class="flex flex-align--stretch"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$1.name,
    		type: "slot",
    		source: "(87:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (97:0) <Card className="bg--graa7">
    function create_default_slot_9$1(ctx) {
    	let div3;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			div0.textContent = "Flex item 1";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "Flex item 2";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "Flex item 3";
    			attr_dev(div0, "class", "bg--graa4 padding-l");
    			add_location(div0, file$c, 98, 4, 3906);
    			attr_dev(div1, "class", "bg--graa3 padding-l");
    			add_location(div1, file$c, 99, 4, 3961);
    			attr_dev(div2, "class", "bg--graa2 padding-l");
    			add_location(div2, file$c, 100, 4, 4016);
    			attr_dev(div3, "class", "flex flex--center bg--eb");
    			set_style(div3, "height", "100px");
    			add_location(div3, file$c, 97, 2, 3841);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$1.name,
    		type: "slot",
    		source: "(97:0) <Card className=\\\"bg--graa7\\\">",
    		ctx
    	});

    	return block;
    }

    // (105:0) <Prism language="html">
    function create_default_slot_8$1(ctx) {
    	let t_value = `<div class="flex flex--center"></div>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$1.name,
    		type: "slot",
    		source: "(105:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (112:0) <Card className="bg--graa7">
    function create_default_slot_7$1(ctx) {
    	let strong0;
    	let t1;
    	let div3;
    	let div0;
    	let t3;
    	let div1;
    	let t5;
    	let div2;
    	let t7;
    	let strong1;
    	let t9;
    	let div7;
    	let div4;
    	let t11;
    	let div5;
    	let t13;
    	let div6;
    	let t15;
    	let strong2;
    	let t17;
    	let div11;
    	let div8;
    	let t19;
    	let div9;
    	let t21;
    	let div10;
    	let t23;
    	let strong3;
    	let t25;
    	let div15;
    	let div12;
    	let t27;
    	let div13;
    	let t29;
    	let div14;

    	const block = {
    		c: function create() {
    			strong0 = element("strong");
    			strong0.textContent = "flex flex--column";
    			t1 = space();
    			div3 = element("div");
    			div0 = element("div");
    			div0.textContent = "Flex item 1";
    			t3 = space();
    			div1 = element("div");
    			div1.textContent = "Flex item 2";
    			t5 = space();
    			div2 = element("div");
    			div2.textContent = "Flex item 3";
    			t7 = space();
    			strong1 = element("strong");
    			strong1.textContent = "flex flex--column-reverse";
    			t9 = space();
    			div7 = element("div");
    			div4 = element("div");
    			div4.textContent = "Flex item 1";
    			t11 = space();
    			div5 = element("div");
    			div5.textContent = "Flex item 2";
    			t13 = space();
    			div6 = element("div");
    			div6.textContent = "Flex item 3";
    			t15 = space();
    			strong2 = element("strong");
    			strong2.textContent = "flex";
    			t17 = space();
    			div11 = element("div");
    			div8 = element("div");
    			div8.textContent = "Flex item 1";
    			t19 = space();
    			div9 = element("div");
    			div9.textContent = "Flex item 2";
    			t21 = space();
    			div10 = element("div");
    			div10.textContent = "Flex item 3";
    			t23 = space();
    			strong3 = element("strong");
    			strong3.textContent = "flex flex-row--reverse";
    			t25 = space();
    			div15 = element("div");
    			div12 = element("div");
    			div12.textContent = "Flex item 1";
    			t27 = space();
    			div13 = element("div");
    			div13.textContent = "Flex item 2";
    			t29 = space();
    			div14 = element("div");
    			div14.textContent = "Flex item 3";
    			attr_dev(strong0, "class", "margin-m");
    			add_location(strong0, file$c, 112, 2, 4287);
    			attr_dev(div0, "class", "bg--graa4 padding-l");
    			add_location(div0, file$c, 114, 4, 4377);
    			attr_dev(div1, "class", "bg--graa3 padding-l");
    			add_location(div1, file$c, 115, 4, 4432);
    			attr_dev(div2, "class", "bg--graa2 padding-l");
    			add_location(div2, file$c, 116, 4, 4487);
    			attr_dev(div3, "class", "flex flex--column");
    			add_location(div3, file$c, 113, 2, 4341);
    			attr_dev(strong1, "class", "margin-m margin-l--t");
    			add_location(strong1, file$c, 118, 2, 4549);
    			attr_dev(div4, "class", "bg--graa4 padding-l");
    			add_location(div4, file$c, 120, 4, 4667);
    			attr_dev(div5, "class", "bg--graa3 padding-l");
    			add_location(div5, file$c, 121, 4, 4722);
    			attr_dev(div6, "class", "bg--graa2 padding-l");
    			add_location(div6, file$c, 122, 4, 4777);
    			attr_dev(div7, "class", "flex flex--column-reverse");
    			add_location(div7, file$c, 119, 2, 4623);
    			attr_dev(strong2, "class", "margin-m margin-l--t");
    			add_location(strong2, file$c, 124, 2, 4839);
    			attr_dev(div8, "class", "bg--graa4 padding-l");
    			add_location(div8, file$c, 126, 4, 4922);
    			attr_dev(div9, "class", "bg--graa3 padding-l");
    			add_location(div9, file$c, 127, 4, 4977);
    			attr_dev(div10, "class", "bg--graa2 padding-l");
    			add_location(div10, file$c, 128, 4, 5032);
    			attr_dev(div11, "class", "flex bg--eb");
    			add_location(div11, file$c, 125, 2, 4892);
    			attr_dev(strong3, "class", "margin-m margin-l--t");
    			add_location(strong3, file$c, 130, 2, 5094);
    			attr_dev(div12, "class", "bg--graa4 padding-l");
    			add_location(div12, file$c, 132, 4, 5213);
    			attr_dev(div13, "class", "bg--graa3 padding-l");
    			add_location(div13, file$c, 133, 4, 5268);
    			attr_dev(div14, "class", "bg--graa2 padding-l");
    			add_location(div14, file$c, 134, 4, 5323);
    			attr_dev(div15, "class", "flex flex-row--reverse bg--eb");
    			add_location(div15, file$c, 131, 2, 5165);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, strong0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t3);
    			append_dev(div3, div1);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, strong1, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div4);
    			append_dev(div7, t11);
    			append_dev(div7, div5);
    			append_dev(div7, t13);
    			append_dev(div7, div6);
    			insert_dev(target, t15, anchor);
    			insert_dev(target, strong2, anchor);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, div11, anchor);
    			append_dev(div11, div8);
    			append_dev(div11, t19);
    			append_dev(div11, div9);
    			append_dev(div11, t21);
    			append_dev(div11, div10);
    			insert_dev(target, t23, anchor);
    			insert_dev(target, strong3, anchor);
    			insert_dev(target, t25, anchor);
    			insert_dev(target, div15, anchor);
    			append_dev(div15, div12);
    			append_dev(div15, t27);
    			append_dev(div15, div13);
    			append_dev(div15, t29);
    			append_dev(div15, div14);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(strong0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div3);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(strong1);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(div7);
    			if (detaching) detach_dev(t15);
    			if (detaching) detach_dev(strong2);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(div11);
    			if (detaching) detach_dev(t23);
    			if (detaching) detach_dev(strong3);
    			if (detaching) detach_dev(t25);
    			if (detaching) detach_dev(div15);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$1.name,
    		type: "slot",
    		source: "(112:0) <Card className=\\\"bg--graa7\\\">",
    		ctx
    	});

    	return block;
    }

    // (139:0) <Prism language="html">
    function create_default_slot_6$2(ctx) {
    	let t_value = `<div class="flex flex--column"></div>
<div class="flex flex--column--reverse"></div>
<div class="flex"></div>
<div class="flex flex-row--reverse"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$2.name,
    		type: "slot",
    		source: "(139:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (152:0) <Card className="bg--graa7">
    function create_default_slot_5$2(ctx) {
    	let strong0;
    	let t1;
    	let div4;
    	let div0;
    	let t3;
    	let div1;
    	let t5;
    	let div2;
    	let t7;
    	let div3;
    	let t9;
    	let strong1;
    	let t11;
    	let div9;
    	let div5;
    	let t13;
    	let div6;
    	let t15;
    	let div7;
    	let t17;
    	let div8;

    	const block = {
    		c: function create() {
    			strong0 = element("strong");
    			strong0.textContent = "flex";
    			t1 = space();
    			div4 = element("div");
    			div0 = element("div");
    			div0.textContent = "Flex item 1";
    			t3 = space();
    			div1 = element("div");
    			div1.textContent = "Flex item 2";
    			t5 = space();
    			div2 = element("div");
    			div2.textContent = "Flex item 3";
    			t7 = space();
    			div3 = element("div");
    			div3.textContent = "Flex item 4";
    			t9 = space();
    			strong1 = element("strong");
    			strong1.textContent = "flex flex-wrap--wrap";
    			t11 = space();
    			div9 = element("div");
    			div5 = element("div");
    			div5.textContent = "Flex item 1";
    			t13 = space();
    			div6 = element("div");
    			div6.textContent = "Flex item 2";
    			t15 = space();
    			div7 = element("div");
    			div7.textContent = "Flex item 3";
    			t17 = space();
    			div8 = element("div");
    			div8.textContent = "Flex item 4";
    			attr_dev(strong0, "class", "margin-m");
    			add_location(strong0, file$c, 152, 2, 5785);
    			attr_dev(div0, "class", "bg--graa4 width-1of3 padding-l");
    			add_location(div0, file$c, 154, 4, 5849);
    			attr_dev(div1, "class", "bg--graa3 width-1of3 padding-l");
    			add_location(div1, file$c, 155, 4, 5915);
    			attr_dev(div2, "class", "bg--graa2 width-1of3 padding-l");
    			add_location(div2, file$c, 156, 4, 5981);
    			attr_dev(div3, "class", "bg--graa1 width-1of3 padding-l");
    			add_location(div3, file$c, 157, 4, 6047);
    			attr_dev(div4, "class", "flex");
    			add_location(div4, file$c, 153, 2, 5826);
    			attr_dev(strong1, "class", "margin-m margin-l--t");
    			add_location(strong1, file$c, 159, 2, 6120);
    			attr_dev(div5, "class", "bg--graa4 width-1of3 padding-l");
    			add_location(div5, file$c, 161, 4, 6235);
    			attr_dev(div6, "class", "bg--graa3 width-1of3 padding-l");
    			add_location(div6, file$c, 162, 4, 6301);
    			attr_dev(div7, "class", "bg--graa2 width-1of3 padding-l");
    			add_location(div7, file$c, 163, 4, 6367);
    			attr_dev(div8, "class", "bg--graa1 width-1of3 padding-l");
    			add_location(div8, file$c, 164, 4, 6433);
    			attr_dev(div9, "class", "flex flex-wrap--wrap bg--eb");
    			add_location(div9, file$c, 160, 2, 6189);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, strong0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div4, t3);
    			append_dev(div4, div1);
    			append_dev(div4, t5);
    			append_dev(div4, div2);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, strong1, anchor);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div5);
    			append_dev(div9, t13);
    			append_dev(div9, div6);
    			append_dev(div9, t15);
    			append_dev(div9, div7);
    			append_dev(div9, t17);
    			append_dev(div9, div8);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(strong0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div4);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(strong1);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(div9);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(152:0) <Card className=\\\"bg--graa7\\\">",
    		ctx
    	});

    	return block;
    }

    // (169:0) <Prism language="html">
    function create_default_slot_4$3(ctx) {
    	let t_value = `<div class="flex"></div>
<div class="flex flex-wrap--wrap"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$3.name,
    		type: "slot",
    		source: "(169:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (178:0) <Card className="bg--graa7">
    function create_default_slot_3$4(ctx) {
    	let div4;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;
    	let t5;
    	let div3;

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			div0.textContent = "flex-item--start";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "flex-item--end";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "flex-item--center";
    			t5 = space();
    			div3 = element("div");
    			div3.textContent = "flex-item--stretch";
    			attr_dev(div0, "class", "flex-item--start bg--graa4 width-1of3 padding-l");
    			add_location(div0, file$c, 179, 4, 6744);
    			attr_dev(div1, "class", "flex-item--end bg--graa2 width-1of3 padding-l");
    			add_location(div1, file$c, 180, 4, 6832);
    			attr_dev(div2, "class", "flex-item--center bg--graa3 width-1of3 padding-l");
    			add_location(div2, file$c, 181, 4, 6916);
    			attr_dev(div3, "class", "flex-item--stretch bg--graa1 width-1of3 padding-l");
    			add_location(div3, file$c, 182, 4, 7006);
    			attr_dev(div4, "class", "flex bg--eb");
    			set_style(div4, "height", "100px");
    			add_location(div4, file$c, 178, 2, 6692);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div4, t1);
    			append_dev(div4, div1);
    			append_dev(div4, t3);
    			append_dev(div4, div2);
    			append_dev(div4, t5);
    			append_dev(div4, div3);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$4.name,
    		type: "slot",
    		source: "(178:0) <Card className=\\\"bg--graa7\\\">",
    		ctx
    	});

    	return block;
    }

    // (187:0) <Prism language="html">
    function create_default_slot_2$7(ctx) {
    	let t_value = `<div class="flex">
  <div class="flex-item--start"></div>
  <div class="flex-item--end"></div>
  <div class="flex-item--center"></div>
  <div class="flex-item--stretch"></div>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$7.name,
    		type: "slot",
    		source: "(187:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (202:0) <Card className="bg--graa7">
    function create_default_slot_1$7(ctx) {
    	let strong0;
    	let t1;
    	let div3;
    	let div0;
    	let t3;
    	let div1;
    	let t5;
    	let div2;
    	let t7;
    	let strong1;
    	let t9;
    	let div7;
    	let div4;
    	let t11;
    	let div5;
    	let t13;
    	let div6;

    	const block = {
    		c: function create() {
    			strong0 = element("strong");
    			strong0.textContent = "Grow";
    			t1 = space();
    			div3 = element("div");
    			div0 = element("div");
    			div0.textContent = "flex-item--grow";
    			t3 = space();
    			div1 = element("div");
    			div1.textContent = "Flex item 2";
    			t5 = space();
    			div2 = element("div");
    			div2.textContent = "Flex item 3";
    			t7 = space();
    			strong1 = element("strong");
    			strong1.textContent = "No shrink";
    			t9 = space();
    			div7 = element("div");
    			div4 = element("div");
    			div4.textContent = "flex-item--noshrink width-2of3";
    			t11 = space();
    			div5 = element("div");
    			div5.textContent = "width-1of3";
    			t13 = space();
    			div6 = element("div");
    			div6.textContent = "width-1of3";
    			attr_dev(strong0, "class", "margin-m margin-l--t");
    			add_location(strong0, file$c, 202, 2, 7638);
    			attr_dev(div0, "class", "flex-item--grow bg--graa4 padding-l");
    			add_location(div0, file$c, 204, 4, 7721);
    			attr_dev(div1, "class", "bg--graa3 padding-l");
    			add_location(div1, file$c, 205, 4, 7796);
    			attr_dev(div2, "class", "bg--graa2 padding-l");
    			add_location(div2, file$c, 206, 4, 7851);
    			attr_dev(div3, "class", "flex bg--eb");
    			add_location(div3, file$c, 203, 2, 7691);
    			attr_dev(strong1, "class", "margin-m margin-l--t");
    			add_location(strong1, file$c, 208, 2, 7913);
    			attr_dev(div4, "class", "flex-item--noshrink width-2of3 bg--graa4 padding-l");
    			add_location(div4, file$c, 210, 4, 8001);
    			attr_dev(div5, "class", "bg--graa3 width-1of3 padding-l");
    			add_location(div5, file$c, 211, 4, 8106);
    			attr_dev(div6, "class", "bg--graa2 width-1of3 padding-l");
    			add_location(div6, file$c, 212, 4, 8171);
    			attr_dev(div7, "class", "flex bg--eb");
    			add_location(div7, file$c, 209, 2, 7971);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, strong0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t3);
    			append_dev(div3, div1);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, strong1, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div4);
    			append_dev(div7, t11);
    			append_dev(div7, div5);
    			append_dev(div7, t13);
    			append_dev(div7, div6);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(strong0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div3);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(strong1);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(div7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(202:0) <Card className=\\\"bg--graa7\\\">",
    		ctx
    	});

    	return block;
    }

    // (217:0) <Prism language="html">
    function create_default_slot$7(ctx) {
    	let t_value = `<div class="flex">
  <div class="flex-item--grow"></div>
  <div class="flex-item--noshrink"></div>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(217:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let h1;
    	let t1;
    	let h30;
    	let t3;
    	let prism0;
    	let t4;
    	let h31;
    	let t6;
    	let p0;
    	let t7;
    	let i0;
    	let t9;
    	let t10;
    	let card0;
    	let t11;
    	let prism1;
    	let t12;
    	let h32;
    	let t14;
    	let p1;
    	let t15;
    	let i1;
    	let t17;
    	let t18;
    	let card1;
    	let t19;
    	let prism2;
    	let t20;
    	let h33;
    	let t22;
    	let p2;
    	let t23;
    	let i2;
    	let t25;
    	let i3;
    	let t27;
    	let t28;
    	let card2;
    	let t29;
    	let prism3;
    	let t30;
    	let h34;
    	let t32;
    	let p3;
    	let t34;
    	let card3;
    	let t35;
    	let prism4;
    	let t36;
    	let h35;
    	let t38;
    	let p4;
    	let t40;
    	let card4;
    	let t41;
    	let prism5;
    	let t42;
    	let h2;
    	let t44;
    	let h36;
    	let t46;
    	let card5;
    	let t47;
    	let prism6;
    	let t48;
    	let h37;
    	let t50;
    	let p5;
    	let code0;
    	let t52;
    	let t53;
    	let p6;
    	let code1;
    	let t55;
    	let t56;
    	let card6;
    	let t57;
    	let prism7;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_14] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card0 = new Card({
    			props: {
    				className: "bg--graa7",
    				$$slots: { default: [create_default_slot_13] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_12] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card1 = new Card({
    			props: {
    				className: "bg--graa7",
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_10$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card2 = new Card({
    			props: {
    				className: "bg--graa7",
    				$$slots: { default: [create_default_slot_9$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism3 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_8$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card3 = new Card({
    			props: {
    				className: "bg--graa7",
    				$$slots: { default: [create_default_slot_7$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism4 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_6$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card4 = new Card({
    			props: {
    				className: "bg--graa7",
    				$$slots: { default: [create_default_slot_5$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism5 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_4$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card5 = new Card({
    			props: {
    				className: "bg--graa7",
    				$$slots: { default: [create_default_slot_3$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism6 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card6 = new Card({
    			props: {
    				className: "bg--graa7",
    				$$slots: { default: [create_default_slot_1$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism7 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Flex";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Flex container";
    			t3 = space();
    			create_component(prism0.$$.fragment);
    			t4 = space();
    			h31 = element("h3");
    			h31.textContent = "Justify content";
    			t6 = space();
    			p0 = element("p");
    			t7 = text("Justify content anvendes til ");
    			i0 = element("i");
    			i0.textContent = "horizontal";
    			t9 = text(" placering af child elementer.");
    			t10 = space();
    			create_component(card0.$$.fragment);
    			t11 = space();
    			create_component(prism1.$$.fragment);
    			t12 = space();
    			h32 = element("h3");
    			h32.textContent = "Align items";
    			t14 = space();
    			p1 = element("p");
    			t15 = text("Align items anvendes til ");
    			i1 = element("i");
    			i1.textContent = "veritcal";
    			t17 = text(" placering af child elementer.");
    			t18 = space();
    			create_component(card1.$$.fragment);
    			t19 = space();
    			create_component(prism2.$$.fragment);
    			t20 = space();
    			h33 = element("h3");
    			h33.textContent = "Flex center";
    			t22 = space();
    			p2 = element("p");
    			t23 = text("Flex center centrere alle child elementer både ");
    			i2 = element("i");
    			i2.textContent = "horizontalt";
    			t25 = text(" og ");
    			i3 = element("i");
    			i3.textContent = "vertical";
    			t27 = text(".");
    			t28 = space();
    			create_component(card2.$$.fragment);
    			t29 = space();
    			create_component(prism3.$$.fragment);
    			t30 = space();
    			h34 = element("h3");
    			h34.textContent = "Directions";
    			t32 = space();
    			p3 = element("p");
    			p3.textContent = "Directions bestemmer rækkefølgen for visning af child elementer.";
    			t34 = space();
    			create_component(card3.$$.fragment);
    			t35 = space();
    			create_component(prism4.$$.fragment);
    			t36 = space();
    			h35 = element("h3");
    			h35.textContent = "Wrap";
    			t38 = space();
    			p4 = element("p");
    			p4.textContent = "Flex wrap sørger for at alle child elementer beholder deres størrelse og istedet wrapper elementerne på multiple lines\n  istedet for one-line.";
    			t40 = space();
    			create_component(card4.$$.fragment);
    			t41 = space();
    			create_component(prism5.$$.fragment);
    			t42 = space();
    			h2 = element("h2");
    			h2.textContent = "Flex items";
    			t44 = space();
    			h36 = element("h3");
    			h36.textContent = "Align self";
    			t46 = space();
    			create_component(card5.$$.fragment);
    			t47 = space();
    			create_component(prism6.$$.fragment);
    			t48 = space();
    			h37 = element("h3");
    			h37.textContent = "Grow and shrik";
    			t50 = space();
    			p5 = element("p");
    			code0 = element("code");
    			code0.textContent = "flex-item--grow";
    			t52 = text(" sørger for at child element udfylder den tilbageværende plads i flex containeren.");
    			t53 = space();
    			p6 = element("p");
    			code1 = element("code");
    			code1.textContent = "flex-item--noshrink";
    			t55 = text(" sørger for at et child element altid vil have den samme størrelse også på scalering.");
    			t56 = space();
    			create_component(card6.$$.fragment);
    			t57 = space();
    			create_component(prism7.$$.fragment);
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$c, 4, 0, 97);
    			add_location(h30, file$c, 6, 0, 130);
    			add_location(h31, file$c, 12, 0, 220);
    			add_location(i0, file$c, 13, 32, 277);
    			add_location(p0, file$c, 13, 0, 245);
    			add_location(h32, file$c, 56, 0, 2102);
    			add_location(i1, file$c, 57, 28, 2151);
    			add_location(p1, file$c, 57, 0, 2123);
    			add_location(h33, file$c, 93, 0, 3695);
    			add_location(i2, file$c, 94, 50, 3766);
    			add_location(i3, file$c, 94, 72, 3788);
    			add_location(p2, file$c, 94, 0, 3716);
    			add_location(h34, file$c, 108, 0, 4163);
    			add_location(p3, file$c, 109, 0, 4183);
    			add_location(h35, file$c, 145, 0, 5585);
    			add_location(p4, file$c, 146, 0, 5599);
    			add_location(h2, file$c, 173, 0, 6619);
    			add_location(h36, file$c, 175, 0, 6640);
    			add_location(h37, file$c, 195, 0, 7335);
    			add_location(code0, file$c, 196, 3, 7362);
    			add_location(p5, file$c, 196, 0, 7359);
    			add_location(code1, file$c, 198, 2, 7483);
    			add_location(p6, file$c, 197, 0, 7477);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, p0, anchor);
    			append_dev(p0, t7);
    			append_dev(p0, i0);
    			append_dev(p0, t9);
    			insert_dev(target, t10, anchor);
    			mount_component(card0, target, anchor);
    			insert_dev(target, t11, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, p1, anchor);
    			append_dev(p1, t15);
    			append_dev(p1, i1);
    			append_dev(p1, t17);
    			insert_dev(target, t18, anchor);
    			mount_component(card1, target, anchor);
    			insert_dev(target, t19, anchor);
    			mount_component(prism2, target, anchor);
    			insert_dev(target, t20, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t22, anchor);
    			insert_dev(target, p2, anchor);
    			append_dev(p2, t23);
    			append_dev(p2, i2);
    			append_dev(p2, t25);
    			append_dev(p2, i3);
    			append_dev(p2, t27);
    			insert_dev(target, t28, anchor);
    			mount_component(card2, target, anchor);
    			insert_dev(target, t29, anchor);
    			mount_component(prism3, target, anchor);
    			insert_dev(target, t30, anchor);
    			insert_dev(target, h34, anchor);
    			insert_dev(target, t32, anchor);
    			insert_dev(target, p3, anchor);
    			insert_dev(target, t34, anchor);
    			mount_component(card3, target, anchor);
    			insert_dev(target, t35, anchor);
    			mount_component(prism4, target, anchor);
    			insert_dev(target, t36, anchor);
    			insert_dev(target, h35, anchor);
    			insert_dev(target, t38, anchor);
    			insert_dev(target, p4, anchor);
    			insert_dev(target, t40, anchor);
    			mount_component(card4, target, anchor);
    			insert_dev(target, t41, anchor);
    			mount_component(prism5, target, anchor);
    			insert_dev(target, t42, anchor);
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t44, anchor);
    			insert_dev(target, h36, anchor);
    			insert_dev(target, t46, anchor);
    			mount_component(card5, target, anchor);
    			insert_dev(target, t47, anchor);
    			mount_component(prism6, target, anchor);
    			insert_dev(target, t48, anchor);
    			insert_dev(target, h37, anchor);
    			insert_dev(target, t50, anchor);
    			insert_dev(target, p5, anchor);
    			append_dev(p5, code0);
    			append_dev(p5, t52);
    			insert_dev(target, t53, anchor);
    			insert_dev(target, p6, anchor);
    			append_dev(p6, code1);
    			append_dev(p6, t55);
    			insert_dev(target, t56, anchor);
    			mount_component(card6, target, anchor);
    			insert_dev(target, t57, anchor);
    			mount_component(prism7, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const card0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card0_changes.$$scope = { dirty, ctx };
    			}

    			card0.$set(card0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    			const card1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card1_changes.$$scope = { dirty, ctx };
    			}

    			card1.$set(card1_changes);
    			const prism2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism2_changes.$$scope = { dirty, ctx };
    			}

    			prism2.$set(prism2_changes);
    			const card2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card2_changes.$$scope = { dirty, ctx };
    			}

    			card2.$set(card2_changes);
    			const prism3_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism3_changes.$$scope = { dirty, ctx };
    			}

    			prism3.$set(prism3_changes);
    			const card3_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card3_changes.$$scope = { dirty, ctx };
    			}

    			card3.$set(card3_changes);
    			const prism4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism4_changes.$$scope = { dirty, ctx };
    			}

    			prism4.$set(prism4_changes);
    			const card4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card4_changes.$$scope = { dirty, ctx };
    			}

    			card4.$set(card4_changes);
    			const prism5_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism5_changes.$$scope = { dirty, ctx };
    			}

    			prism5.$set(prism5_changes);
    			const card5_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card5_changes.$$scope = { dirty, ctx };
    			}

    			card5.$set(card5_changes);
    			const prism6_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism6_changes.$$scope = { dirty, ctx };
    			}

    			prism6.$set(prism6_changes);
    			const card6_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card6_changes.$$scope = { dirty, ctx };
    			}

    			card6.$set(card6_changes);
    			const prism7_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism7_changes.$$scope = { dirty, ctx };
    			}

    			prism7.$set(prism7_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(card0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(card1.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			transition_in(card2.$$.fragment, local);
    			transition_in(prism3.$$.fragment, local);
    			transition_in(card3.$$.fragment, local);
    			transition_in(prism4.$$.fragment, local);
    			transition_in(card4.$$.fragment, local);
    			transition_in(prism5.$$.fragment, local);
    			transition_in(card5.$$.fragment, local);
    			transition_in(prism6.$$.fragment, local);
    			transition_in(card6.$$.fragment, local);
    			transition_in(prism7.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(card0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(card1.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			transition_out(card2.$$.fragment, local);
    			transition_out(prism3.$$.fragment, local);
    			transition_out(card3.$$.fragment, local);
    			transition_out(prism4.$$.fragment, local);
    			transition_out(card4.$$.fragment, local);
    			transition_out(prism5.$$.fragment, local);
    			transition_out(card5.$$.fragment, local);
    			transition_out(prism6.$$.fragment, local);
    			transition_out(card6.$$.fragment, local);
    			transition_out(prism7.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t3);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t10);
    			destroy_component(card0, detaching);
    			if (detaching) detach_dev(t11);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t18);
    			destroy_component(card1, detaching);
    			if (detaching) detach_dev(t19);
    			destroy_component(prism2, detaching);
    			if (detaching) detach_dev(t20);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t22);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t28);
    			destroy_component(card2, detaching);
    			if (detaching) detach_dev(t29);
    			destroy_component(prism3, detaching);
    			if (detaching) detach_dev(t30);
    			if (detaching) detach_dev(h34);
    			if (detaching) detach_dev(t32);
    			if (detaching) detach_dev(p3);
    			if (detaching) detach_dev(t34);
    			destroy_component(card3, detaching);
    			if (detaching) detach_dev(t35);
    			destroy_component(prism4, detaching);
    			if (detaching) detach_dev(t36);
    			if (detaching) detach_dev(h35);
    			if (detaching) detach_dev(t38);
    			if (detaching) detach_dev(p4);
    			if (detaching) detach_dev(t40);
    			destroy_component(card4, detaching);
    			if (detaching) detach_dev(t41);
    			destroy_component(prism5, detaching);
    			if (detaching) detach_dev(t42);
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t44);
    			if (detaching) detach_dev(h36);
    			if (detaching) detach_dev(t46);
    			destroy_component(card5, detaching);
    			if (detaching) detach_dev(t47);
    			destroy_component(prism6, detaching);
    			if (detaching) detach_dev(t48);
    			if (detaching) detach_dev(h37);
    			if (detaching) detach_dev(t50);
    			if (detaching) detach_dev(p5);
    			if (detaching) detach_dev(t53);
    			if (detaching) detach_dev(p6);
    			if (detaching) detach_dev(t56);
    			destroy_component(card6, detaching);
    			if (detaching) detach_dev(t57);
    			destroy_component(prism7, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Flex', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Flex> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1, Card });
    	return [];
    }

    class Flex extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Flex",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    /* docs_src/utilities/Fonts.svelte generated by Svelte v3.42.6 */
    const file$b = "docs_src/utilities/Fonts.svelte";

    // (9:0) <Card className="bg--graa7 padding-l--rl">
    function create_default_slot_6$1(ctx) {
    	let div0;
    	let strong0;
    	let t1;
    	let p0;
    	let t3;
    	let div1;
    	let strong1;
    	let t5;
    	let p1;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			strong0 = element("strong");
    			strong0.textContent = ".ff-primary:";
    			t1 = space();
    			p0 = element("p");
    			p0.textContent = "Aa Bb Cc Dd Ee Ff Gg Hh Ii Jj Kk Ll Mm Nn Oo Pp Qq Rr Ss Tt Uu Vv Ww Xx Yy Zz Ææ Øø Åå 1234567890";
    			t3 = space();
    			div1 = element("div");
    			strong1 = element("strong");
    			strong1.textContent = ".ff-secondary:";
    			t5 = space();
    			p1 = element("p");
    			p1.textContent = "Aa Bb Cc Dd Ee Ff Gg Hh Ii Jj Kk Ll Mm Nn Oo Pp Qq Rr Ss Tt Uu Vv Ww Xx Yy Zz Ææ Øø Åå 1234567890";
    			add_location(strong0, file$b, 10, 4, 240);
    			add_location(p0, file$b, 11, 4, 274);
    			attr_dev(div0, "class", "ff-primary margin-l--tb");
    			add_location(div0, file$b, 9, 2, 198);
    			add_location(strong1, file$b, 14, 4, 421);
    			add_location(p1, file$b, 15, 4, 457);
    			attr_dev(div1, "class", "ff-secondary");
    			add_location(div1, file$b, 13, 2, 390);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, strong0);
    			append_dev(div0, t1);
    			append_dev(div0, p0);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, strong1);
    			append_dev(div1, t5);
    			append_dev(div1, p1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(9:0) <Card className=\\\"bg--graa7 padding-l--rl\\\">",
    		ctx
    	});

    	return block;
    }

    // (20:0) <Prism language="html">
    function create_default_slot_5$1(ctx) {
    	let t_value = `<div class="ff-primary"></div>
<div class="ff-secondary"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(20:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (27:0) <Card className="bg--graa7 padding-l--rl">
    function create_default_slot_4$2(ctx) {
    	let p0;
    	let t1;
    	let p1;
    	let t3;
    	let p2;

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			p0.textContent = "fontweight-normal";
    			t1 = space();
    			p1 = element("p");
    			p1.textContent = "fontweight-bold";
    			t3 = space();
    			p2 = element("p");
    			p2.textContent = "fontweight-bolder";
    			attr_dev(p0, "class", "fontweight-normal");
    			add_location(p0, file$b, 27, 2, 751);
    			attr_dev(p1, "class", "fontweight-bold");
    			add_location(p1, file$b, 28, 2, 804);
    			attr_dev(p2, "class", "fontweight-bolder");
    			add_location(p2, file$b, 29, 2, 853);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p2, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(27:0) <Card className=\\\"bg--graa7 padding-l--rl\\\">",
    		ctx
    	});

    	return block;
    }

    // (33:0) <Prism language="html">
    function create_default_slot_3$3(ctx) {
    	let t_value = `<p class="fontweight-normal"></p>
<p class="fontweight-bold"></p>
<p class="fontweight-bolder"></p>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(33:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (45:0) <Card className="bg--graa7 padding-l">
    function create_default_slot_2$6(ctx) {
    	let div2;
    	let t0;
    	let div0;
    	let t2;
    	let div1;
    	let t4;
    	let div5;
    	let t5;
    	let div3;
    	let t7;
    	let div4;
    	let t9;
    	let div8;
    	let t10;
    	let div6;
    	let t12;
    	let div7;
    	let t14;
    	let div11;
    	let t15;
    	let div9;
    	let t17;
    	let div10;
    	let t19;
    	let div14;
    	let t20;
    	let div12;
    	let t22;
    	let div13;
    	let t24;
    	let div17;
    	let t25;
    	let div15;
    	let t27;
    	let div16;
    	let t29;
    	let div20;
    	let t30;
    	let div18;
    	let t32;
    	let div19;
    	let t34;
    	let div23;
    	let t35;
    	let div21;
    	let t37;
    	let div22;
    	let t39;
    	let div26;
    	let t40;
    	let div24;
    	let t42;
    	let div25;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			t0 = text("fontsize-xxsmall = .625rem ~ 10px;\n    ");
    			div0 = element("div");
    			div0.textContent = "fontsize-smaller";
    			t2 = space();
    			div1 = element("div");
    			div1.textContent = "fontsize-larger";
    			t4 = space();
    			div5 = element("div");
    			t5 = text("fontsize-xsmall = .75rem ~ 12px;\n    ");
    			div3 = element("div");
    			div3.textContent = "fontsize-smaller";
    			t7 = space();
    			div4 = element("div");
    			div4.textContent = "fontsize-larger";
    			t9 = space();
    			div8 = element("div");
    			t10 = text("fontsize-small = .875rem ~ 14px;\n    ");
    			div6 = element("div");
    			div6.textContent = "fontsize-smaller";
    			t12 = space();
    			div7 = element("div");
    			div7.textContent = "fontsize-larger";
    			t14 = space();
    			div11 = element("div");
    			t15 = text("fontsize-medium = 1rem ~ 16px;\n    ");
    			div9 = element("div");
    			div9.textContent = "fontsize-smaller";
    			t17 = space();
    			div10 = element("div");
    			div10.textContent = "fontsize-larger";
    			t19 = space();
    			div14 = element("div");
    			t20 = text("fontsize-large = 1.125rem ~ 18px;\n    ");
    			div12 = element("div");
    			div12.textContent = "fontsize-smaller";
    			t22 = space();
    			div13 = element("div");
    			div13.textContent = "fontsize-larger";
    			t24 = space();
    			div17 = element("div");
    			t25 = text("fontsize-xlarge = 1.25rem ~ 20px;\n    ");
    			div15 = element("div");
    			div15.textContent = "fontsize-smaller";
    			t27 = space();
    			div16 = element("div");
    			div16.textContent = "fontsize-larger";
    			t29 = space();
    			div20 = element("div");
    			t30 = text("fontsize-xxlarge = 1.875rem ~ 30px;\n    ");
    			div18 = element("div");
    			div18.textContent = "fontsize-smaller";
    			t32 = space();
    			div19 = element("div");
    			div19.textContent = "fontsize-larger";
    			t34 = space();
    			div23 = element("div");
    			t35 = text("fontsize-xxxlarge = 2.25rem ~ 36px;\n    ");
    			div21 = element("div");
    			div21.textContent = "fontsize-smaller";
    			t37 = space();
    			div22 = element("div");
    			div22.textContent = "fontsize-larger";
    			t39 = space();
    			div26 = element("div");
    			t40 = text("fontsize-xxxxlarge = 3.125rem ~ 50px;\n    ");
    			div24 = element("div");
    			div24.textContent = "fontsize-smaller";
    			t42 = space();
    			div25 = element("div");
    			div25.textContent = "fontsize-larger";
    			attr_dev(div0, "class", "fontsize-smaller");
    			add_location(div0, file$b, 47, 4, 1501);
    			attr_dev(div1, "class", "fontsize-larger");
    			add_location(div1, file$b, 48, 4, 1558);
    			attr_dev(div2, "class", "fontsize-xxsmall padding-m--b");
    			add_location(div2, file$b, 45, 2, 1414);
    			attr_dev(div3, "class", "fontsize-smaller");
    			add_location(div3, file$b, 52, 4, 1705);
    			attr_dev(div4, "class", "fontsize-larger");
    			add_location(div4, file$b, 53, 4, 1762);
    			attr_dev(div5, "class", "fontsize-xsmall padding-m--tb");
    			add_location(div5, file$b, 50, 2, 1620);
    			attr_dev(div6, "class", "fontsize-smaller");
    			add_location(div6, file$b, 57, 4, 1908);
    			attr_dev(div7, "class", "fontsize-larger");
    			add_location(div7, file$b, 58, 4, 1965);
    			attr_dev(div8, "class", "fontsize-small padding-m--tb");
    			add_location(div8, file$b, 55, 2, 1824);
    			attr_dev(div9, "class", "fontsize-smaller");
    			add_location(div9, file$b, 62, 4, 2110);
    			attr_dev(div10, "class", "fontsize-larger");
    			add_location(div10, file$b, 63, 4, 2167);
    			attr_dev(div11, "class", "fontsize-medium padding-m--tb");
    			add_location(div11, file$b, 60, 2, 2027);
    			attr_dev(div12, "class", "fontsize-smaller");
    			add_location(div12, file$b, 67, 4, 2314);
    			attr_dev(div13, "class", "fontsize-larger");
    			add_location(div13, file$b, 68, 4, 2371);
    			attr_dev(div14, "class", "fontsize-large padding-m--tb");
    			add_location(div14, file$b, 65, 2, 2229);
    			attr_dev(div15, "class", "fontsize-smaller");
    			add_location(div15, file$b, 72, 4, 2519);
    			attr_dev(div16, "class", "fontsize-larger");
    			add_location(div16, file$b, 73, 4, 2576);
    			attr_dev(div17, "class", "fontsize-xlarge padding-m--tb");
    			add_location(div17, file$b, 70, 2, 2433);
    			attr_dev(div18, "class", "fontsize-smaller");
    			add_location(div18, file$b, 77, 4, 2727);
    			attr_dev(div19, "class", "fontsize-larger");
    			add_location(div19, file$b, 78, 4, 2784);
    			attr_dev(div20, "class", "fontsize-xxlarge padding-m--tb");
    			add_location(div20, file$b, 75, 2, 2638);
    			attr_dev(div21, "class", "fontsize-smaller");
    			add_location(div21, file$b, 82, 4, 2936);
    			attr_dev(div22, "class", "fontsize-larger");
    			add_location(div22, file$b, 83, 4, 2993);
    			attr_dev(div23, "class", "fontsize-xxxlarge padding-m--tb");
    			add_location(div23, file$b, 80, 2, 2846);
    			attr_dev(div24, "class", "fontsize-smaller");
    			add_location(div24, file$b, 87, 4, 3147);
    			attr_dev(div25, "class", "fontsize-larger");
    			add_location(div25, file$b, 88, 4, 3204);
    			attr_dev(div26, "class", "fontsize-xxxxlarge padding-m--t");
    			add_location(div26, file$b, 85, 2, 3055);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, t0);
    			append_dev(div2, div0);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, t5);
    			append_dev(div5, div3);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, div8, anchor);
    			append_dev(div8, t10);
    			append_dev(div8, div6);
    			append_dev(div8, t12);
    			append_dev(div8, div7);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, div11, anchor);
    			append_dev(div11, t15);
    			append_dev(div11, div9);
    			append_dev(div11, t17);
    			append_dev(div11, div10);
    			insert_dev(target, t19, anchor);
    			insert_dev(target, div14, anchor);
    			append_dev(div14, t20);
    			append_dev(div14, div12);
    			append_dev(div14, t22);
    			append_dev(div14, div13);
    			insert_dev(target, t24, anchor);
    			insert_dev(target, div17, anchor);
    			append_dev(div17, t25);
    			append_dev(div17, div15);
    			append_dev(div17, t27);
    			append_dev(div17, div16);
    			insert_dev(target, t29, anchor);
    			insert_dev(target, div20, anchor);
    			append_dev(div20, t30);
    			append_dev(div20, div18);
    			append_dev(div20, t32);
    			append_dev(div20, div19);
    			insert_dev(target, t34, anchor);
    			insert_dev(target, div23, anchor);
    			append_dev(div23, t35);
    			append_dev(div23, div21);
    			append_dev(div23, t37);
    			append_dev(div23, div22);
    			insert_dev(target, t39, anchor);
    			insert_dev(target, div26, anchor);
    			append_dev(div26, t40);
    			append_dev(div26, div24);
    			append_dev(div26, t42);
    			append_dev(div26, div25);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div5);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(div8);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(div11);
    			if (detaching) detach_dev(t19);
    			if (detaching) detach_dev(div14);
    			if (detaching) detach_dev(t24);
    			if (detaching) detach_dev(div17);
    			if (detaching) detach_dev(t29);
    			if (detaching) detach_dev(div20);
    			if (detaching) detach_dev(t34);
    			if (detaching) detach_dev(div23);
    			if (detaching) detach_dev(t39);
    			if (detaching) detach_dev(div26);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$6.name,
    		type: "slot",
    		source: "(45:0) <Card className=\\\"bg--graa7 padding-l\\\">",
    		ctx
    	});

    	return block;
    }

    // (93:0) <Prism language="html">
    function create_default_slot_1$6(ctx) {
    	let t_value = `<div class="fontsize-xxsmall"></div>
<div class="fontsize-xsmall"></div>
<div class="fontsize-small"></div>
<div class="fontsize-medium"></div>
<div class="fontsize-large"></div>
<div class="fontsize-xlarge"></div>
<div class="fontsize-xxlarge"></div>
<div class="fontsize-xxxlarge"></div>
<div class="fontsize-xxxxlarge"></div>

<div class="fontsize-smaller"></div>
<div class="fontsize-larger"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(93:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (110:0) <Card className="bg--graa7 padding-l--rl padding-l--t">
    function create_default_slot$6(ctx) {
    	let h1;
    	let t1;
    	let h2;
    	let t3;
    	let h3;
    	let t5;
    	let h4;
    	let t7;
    	let h5;
    	let t9;
    	let h6;
    	let t11;
    	let p0;
    	let t13;
    	let p1;
    	let t15;
    	let p2;
    	let t17;
    	let p3;
    	let t19;
    	let p4;
    	let t21;
    	let p5;
    	let t23;
    	let p6;
    	let t25;
    	let p7;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "h1";
    			t1 = space();
    			h2 = element("h2");
    			h2.textContent = "h2";
    			t3 = space();
    			h3 = element("h3");
    			h3.textContent = "h3";
    			t5 = space();
    			h4 = element("h4");
    			h4.textContent = "h4";
    			t7 = space();
    			h5 = element("h5");
    			h5.textContent = "h5";
    			t9 = space();
    			h6 = element("h6");
    			h6.textContent = "h6";
    			t11 = space();
    			p0 = element("p");
    			p0.textContent = "fs-ads";
    			t13 = space();
    			p1 = element("p");
    			p1.textContent = "fs-bodytext";
    			t15 = space();
    			p2 = element("p");
    			p2.textContent = "fs-caption";
    			t17 = space();
    			p3 = element("p");
    			p3.textContent = "fs-quote";
    			t19 = space();
    			p4 = element("p");
    			p4.textContent = "fs-showmore";
    			t21 = space();
    			p5 = element("p");
    			p5.textContent = "fs-subtitle";
    			t23 = space();
    			p6 = element("p");
    			p6.textContent = "fs-timestamp";
    			t25 = space();
    			p7 = element("p");
    			p7.textContent = "fs-title";
    			add_location(h1, file$b, 110, 2, 3809);
    			add_location(h2, file$b, 111, 2, 3823);
    			add_location(h3, file$b, 112, 2, 3837);
    			add_location(h4, file$b, 113, 2, 3851);
    			add_location(h5, file$b, 114, 2, 3865);
    			add_location(h6, file$b, 115, 2, 3879);
    			attr_dev(p0, "class", "fs-ads");
    			add_location(p0, file$b, 117, 2, 3894);
    			attr_dev(p1, "class", "fs-bodytext");
    			add_location(p1, file$b, 118, 2, 3925);
    			attr_dev(p2, "class", "fs-caption");
    			add_location(p2, file$b, 119, 2, 3966);
    			attr_dev(p3, "class", "fs-quote");
    			add_location(p3, file$b, 120, 2, 4005);
    			attr_dev(p4, "class", "fs-showmore");
    			add_location(p4, file$b, 121, 2, 4040);
    			attr_dev(p5, "class", "fs-subtitle");
    			add_location(p5, file$b, 122, 2, 4081);
    			attr_dev(p6, "class", "fs-timestamp");
    			add_location(p6, file$b, 123, 2, 4122);
    			attr_dev(p7, "class", "fs-title");
    			add_location(p7, file$b, 124, 2, 4165);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, h3, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, h4, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, h5, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, h6, anchor);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t13, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t15, anchor);
    			insert_dev(target, p2, anchor);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, p3, anchor);
    			insert_dev(target, t19, anchor);
    			insert_dev(target, p4, anchor);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, p5, anchor);
    			insert_dev(target, t23, anchor);
    			insert_dev(target, p6, anchor);
    			insert_dev(target, t25, anchor);
    			insert_dev(target, p7, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(h5);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(h6);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t13);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t15);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(p3);
    			if (detaching) detach_dev(t19);
    			if (detaching) detach_dev(p4);
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(p5);
    			if (detaching) detach_dev(t23);
    			if (detaching) detach_dev(p6);
    			if (detaching) detach_dev(t25);
    			if (detaching) detach_dev(p7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(110:0) <Card className=\\\"bg--graa7 padding-l--rl padding-l--t\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let h1;
    	let t1;
    	let h30;
    	let t3;
    	let card0;
    	let t4;
    	let prism0;
    	let t5;
    	let h31;
    	let t7;
    	let card1;
    	let t8;
    	let prism1;
    	let t9;
    	let h32;
    	let t11;
    	let p0;
    	let t13;
    	let p1;
    	let t15;
    	let p2;
    	let t16;
    	let u0;
    	let t18;
    	let u1;
    	let t20;
    	let t21;
    	let card2;
    	let t22;
    	let prism2;
    	let t23;
    	let h33;
    	let t25;
    	let card3;
    	let current;

    	card0 = new Card({
    			props: {
    				className: "bg--graa7 padding-l--rl",
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card1 = new Card({
    			props: {
    				className: "bg--graa7 padding-l--rl",
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_3$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card2 = new Card({
    			props: {
    				className: "bg--graa7 padding-l",
    				$$slots: { default: [create_default_slot_2$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card3 = new Card({
    			props: {
    				className: "bg--graa7 padding-l--rl padding-l--t",
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Fonts";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Font family";
    			t3 = space();
    			create_component(card0.$$.fragment);
    			t4 = space();
    			create_component(prism0.$$.fragment);
    			t5 = space();
    			h31 = element("h3");
    			h31.textContent = "Font-weight";
    			t7 = space();
    			create_component(card1.$$.fragment);
    			t8 = space();
    			create_component(prism1.$$.fragment);
    			t9 = space();
    			h32 = element("h3");
    			h32.textContent = "Font-size";
    			t11 = space();
    			p0 = element("p");
    			p0.textContent = "Font-size er sat i rem for at understøtte brugerens font-size valg i browseren.";
    			t13 = space();
    			p1 = element("p");
    			p1.textContent = "Rem værdien er udregnet i forhold til en basis font-size på 16px, hvilket er browser-standarden";
    			t15 = space();
    			p2 = element("p");
    			t16 = text("Der er både en ");
    			u0 = element("u");
    			u0.textContent = "larger";
    			t18 = text(" og en ");
    			u1 = element("u");
    			u1.textContent = "smaller";
    			t20 = text(" mulighed, der begge er relative til parent fontsize");
    			t21 = space();
    			create_component(card2.$$.fragment);
    			t22 = space();
    			create_component(prism2.$$.fragment);
    			t23 = space();
    			h33 = element("h3");
    			h33.textContent = "Headers and font aliases";
    			t25 = space();
    			create_component(card3.$$.fragment);
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$b, 4, 0, 97);
    			add_location(h30, file$b, 6, 0, 131);
    			add_location(h31, file$b, 24, 0, 684);
    			add_location(h32, file$b, 38, 0, 1053);
    			add_location(p0, file$b, 40, 0, 1073);
    			add_location(p1, file$b, 41, 0, 1160);
    			add_location(u0, file$b, 42, 18, 1281);
    			add_location(u1, file$b, 42, 38, 1301);
    			add_location(p2, file$b, 42, 0, 1263);
    			add_location(h33, file$b, 107, 0, 3716);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(card0, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(card1, target, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t13, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t15, anchor);
    			insert_dev(target, p2, anchor);
    			append_dev(p2, t16);
    			append_dev(p2, u0);
    			append_dev(p2, t18);
    			append_dev(p2, u1);
    			append_dev(p2, t20);
    			insert_dev(target, t21, anchor);
    			mount_component(card2, target, anchor);
    			insert_dev(target, t22, anchor);
    			mount_component(prism2, target, anchor);
    			insert_dev(target, t23, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t25, anchor);
    			mount_component(card3, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const card0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card0_changes.$$scope = { dirty, ctx };
    			}

    			card0.$set(card0_changes);
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const card1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card1_changes.$$scope = { dirty, ctx };
    			}

    			card1.$set(card1_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    			const card2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card2_changes.$$scope = { dirty, ctx };
    			}

    			card2.$set(card2_changes);
    			const prism2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism2_changes.$$scope = { dirty, ctx };
    			}

    			prism2.$set(prism2_changes);
    			const card3_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card3_changes.$$scope = { dirty, ctx };
    			}

    			card3.$set(card3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card0.$$.fragment, local);
    			transition_in(prism0.$$.fragment, local);
    			transition_in(card1.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(card2.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			transition_in(card3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card0.$$.fragment, local);
    			transition_out(prism0.$$.fragment, local);
    			transition_out(card1.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(card2.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			transition_out(card3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t3);
    			destroy_component(card0, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t7);
    			destroy_component(card1, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t13);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t15);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t21);
    			destroy_component(card2, detaching);
    			if (detaching) detach_dev(t22);
    			destroy_component(prism2, detaching);
    			if (detaching) detach_dev(t23);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t25);
    			destroy_component(card3, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Fonts', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Fonts> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1, Card });
    	return [];
    }

    class Fonts extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Fonts",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* docs_src/utilities/Grid.svelte generated by Svelte v3.42.6 */
    const file$a = "docs_src/utilities/Grid.svelte";

    // (7:0) <Card className="bg--graa7 text-align--center">
    function create_default_slot_2$5(ctx) {
    	let div3;
    	let p0;
    	let t1;
    	let p1;
    	let t3;
    	let div2;
    	let p2;
    	let t5;
    	let p3;
    	let t7;
    	let div1;
    	let p4;
    	let t9;
    	let p5;
    	let t11;
    	let div0;
    	let p6;
    	let t13;
    	let p7;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			p0 = element("p");
    			p0.textContent = "grid-width--xlarge: 930px";
    			t1 = space();
    			p1 = element("p");
    			p1.textContent = "Page content width - frontpage";
    			t3 = space();
    			div2 = element("div");
    			p2 = element("p");
    			p2.textContent = "grid-width--large: 910px";
    			t5 = space();
    			p3 = element("p");
    			p3.textContent = "Page content width";
    			t7 = space();
    			div1 = element("div");
    			p4 = element("p");
    			p4.textContent = "grid-width--medium: 730px";
    			t9 = space();
    			p5 = element("p");
    			p5.textContent = "Bodytext container width";
    			t11 = space();
    			div0 = element("div");
    			p6 = element("p");
    			p6.textContent = "grid-width--small: 610px";
    			t13 = space();
    			p7 = element("p");
    			p7.textContent = "Widget width";
    			add_location(p0, file$a, 8, 4, 277);
    			add_location(p1, file$a, 9, 4, 314);
    			add_location(p2, file$a, 11, 6, 443);
    			add_location(p3, file$a, 12, 6, 481);
    			add_location(p4, file$a, 14, 8, 602);
    			add_location(p5, file$a, 15, 8, 643);
    			add_location(p6, file$a, 17, 10, 774);
    			add_location(p7, file$a, 18, 10, 816);
    			attr_dev(div0, "class", "grid-width--small vertical-center bg--eb2");
    			set_style(div0, "overflow", "hidden");
    			add_location(div0, file$a, 16, 8, 683);
    			attr_dev(div1, "class", "grid-width--medium vertical-center bg--eb");
    			set_style(div1, "overflow", "hidden");
    			add_location(div1, file$a, 13, 6, 513);
    			attr_dev(div2, "class", "grid-width--large vertical-center bg--eb2");
    			set_style(div2, "overflow", "hidden");
    			add_location(div2, file$a, 10, 4, 356);
    			attr_dev(div3, "class", "grid-width--xlarge vertical-center bg--eb");
    			set_style(div3, "overflow", "hidden");
    			add_location(div3, file$a, 7, 2, 192);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, p0);
    			append_dev(div3, t1);
    			append_dev(div3, p1);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, p2);
    			append_dev(div2, t5);
    			append_dev(div2, p3);
    			append_dev(div2, t7);
    			append_dev(div2, div1);
    			append_dev(div1, p4);
    			append_dev(div1, t9);
    			append_dev(div1, p5);
    			append_dev(div1, t11);
    			append_dev(div1, div0);
    			append_dev(div0, p6);
    			append_dev(div0, t13);
    			append_dev(div0, p7);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(7:0) <Card className=\\\"bg--graa7 text-align--center\\\">",
    		ctx
    	});

    	return block;
    }

    // (28:0) <Prism language="html">
    function create_default_slot_1$5(ctx) {
    	let t_value = `<div class="grid-width--xlarge"></div>
<div class="grid-width--large"></div>
<div class="grid-width--medium"></div>
<div class="grid-width--small"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(28:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (37:0) <Prism language="css">
    function create_default_slot$5(ctx) {
    	let t_value = `--grid-small: 610px;
--grid-medium: 730px;
--grid-large: 910px;
--grid-xlarge: 930px;` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(37:0) <Prism language=\\\"css\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let h1;
    	let t1;
    	let card;
    	let t2;
    	let h30;
    	let t4;
    	let prism0;
    	let t5;
    	let h31;
    	let t7;
    	let prism1;
    	let current;

    	card = new Card({
    			props: {
    				className: "bg--graa7 text-align--center",
    				$$slots: { default: [create_default_slot_2$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "css",
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Grid";
    			t1 = space();
    			create_component(card.$$.fragment);
    			t2 = space();
    			h30 = element("h3");
    			h30.textContent = "HTML class names";
    			t4 = space();
    			create_component(prism0.$$.fragment);
    			t5 = space();
    			h31 = element("h3");
    			h31.textContent = "CSS variable names";
    			t7 = space();
    			create_component(prism1.$$.fragment);
    			attr_dev(h1, "class", "color--eb margin-l--b");
    			add_location(h1, file$a, 4, 0, 97);
    			add_location(h30, file$a, 25, 0, 893);
    			add_location(h31, file$a, 34, 0, 1114);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(card, target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(prism1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const card_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card_changes.$$scope = { dirty, ctx };
    			}

    			card.$set(card_changes);
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card.$$.fragment, local);
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card.$$.fragment, local);
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			destroy_component(card, detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t4);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t7);
    			destroy_component(prism1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Grid', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Grid> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1, Card });
    	return [];
    }

    class Grid extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Grid",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    /* docs_src/utilities/Helpers.svelte generated by Svelte v3.42.6 */
    const file$9 = "docs_src/utilities/Helpers.svelte";

    // (9:0) <Prism language="html">
    function create_default_slot_10(ctx) {
    	let t_value = `<div class="hidden"></div>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(9:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (15:0) <Prism language="html">
    function create_default_slot_9(ctx) {
    	let t_value = `<div class="position-absolute"></div>
<div class="position-fixed"></div>
<div class="position-relative"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(15:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (23:0) <Card className="bg--graa7">
    function create_default_slot_8(ctx) {
    	let div2;
    	let div0;
    	let t1;
    	let div1;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "float-left";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "float-right";
    			attr_dev(div0, "class", "bg--eb padding-m float-left");
    			add_location(div0, file$9, 24, 4, 453);
    			attr_dev(div1, "class", "bg--eb padding-m float-right");
    			add_location(div1, file$9, 25, 4, 515);
    			add_location(div2, file$9, 23, 2, 443);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(23:0) <Card className=\\\"bg--graa7\\\">",
    		ctx
    	});

    	return block;
    }

    // (30:0) <Prism language="html">
    function create_default_slot_7(ctx) {
    	let t_value = `<div class="float-left"></div>
<div class="float-right"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(30:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (37:0) <Prism language="html">
    function create_default_slot_6(ctx) {
    	let t_value = `<div class="clear"></div>` + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(37:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (44:0) <Card className="bg--graa7">
    function create_default_slot_5(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "vertical-center";
    			attr_dev(div, "class", "vertical-center width-1of3 padding-l bg--eb");
    			add_location(div, file$9, 44, 2, 880);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(44:0) <Card className=\\\"bg--graa7\\\">",
    		ctx
    	});

    	return block;
    }

    // (48:0) <Prism language="html">
    function create_default_slot_4$1(ctx) {
    	let t_value = `<div class="vertical-center"></div>
<div class="vertical-auto"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(48:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (61:0) <Prism language="html">
    function create_default_slot_3$2(ctx) {
    	let t_value = `<div class="margin-none padding-none"></div>
<div class="margin-s padding-s"></div>
<div class="margin-m padding-m"></div>
<div class="margin-l padding-l"></div>
<div class="margin-xl padding-xl"></div>
<div class="margin-xxl padding-xxl"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(61:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (75:0) <Prism language="html">
    function create_default_slot_2$4(ctx) {
    	let t_value = `<div class="margin-l--t padding-l--t"></div>
<div class="margin-l--r padding-l--r"></div>
<div class="margin-l--b padding-l--b"></div>
<div class="margin-l--l padding-l--l"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(75:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (84:0) <Prism language="html">
    function create_default_slot_1$4(ctx) {
    	let t_value = `<div class="margin-l--tb padding-l--tb"></div>
<div class="margin-l--rl padding-l--rl"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(84:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (92:2) 
    function create_content_slot$1(ctx) {
    	let div3;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			div0.textContent = "box-shadow--small";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "box-shadow";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "box-shadow--large";
    			attr_dev(div0, "class", "border-radius box-shadow--small padding-xl margin-l bg--eb");
    			add_location(div0, file$9, 92, 4, 2242);
    			attr_dev(div1, "class", "border-radius box-shadow padding-xl margin-l bg--eb");
    			add_location(div1, file$9, 93, 4, 2342);
    			attr_dev(div2, "class", "border-radius box-shadow--large padding-xl margin-l bg--eb");
    			add_location(div2, file$9, 94, 4, 2428);
    			attr_dev(div3, "slot", "content");
    			add_location(div3, file$9, 91, 2, 2217);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot$1.name,
    		type: "slot",
    		source: "(92:2) ",
    		ctx
    	});

    	return block;
    }

    // (99:0) <Prism language="html">
    function create_default_slot$4(ctx) {
    	let t_value = `<div class="box-shadow--small"></div>
<div class="box-shadow"></div>
<div class="box-shadow--large"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(99:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let h1;
    	let t1;
    	let h30;
    	let t3;
    	let prism0;
    	let t4;
    	let h31;
    	let t6;
    	let prism1;
    	let t7;
    	let h32;
    	let t9;
    	let card0;
    	let t10;
    	let prism2;
    	let t11;
    	let h33;
    	let t13;
    	let prism3;
    	let t14;
    	let h34;
    	let t16;
    	let p0;
    	let t18;
    	let card1;
    	let t19;
    	let prism4;
    	let t20;
    	let h35;
    	let t22;
    	let p1;
    	let t23;
    	let strong0;
    	let t25;
    	let strong1;
    	let t27;
    	let em0;
    	let t29;
    	let em1;
    	let t31;
    	let t32;
    	let prism5;
    	let t33;
    	let p2;
    	let t34;
    	let strong2;
    	let t36;
    	let strong3;
    	let t38;
    	let t39;
    	let prism6;
    	let t40;
    	let p3;
    	let t41;
    	let em2;
    	let t43;
    	let em3;
    	let t45;
    	let t46;
    	let prism7;
    	let t47;
    	let h36;
    	let t49;
    	let card2;
    	let t50;
    	let prism8;
    	let current;

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card0 = new Card({
    			props: {
    				className: "bg--graa7",
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism3 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card1 = new Card({
    			props: {
    				className: "bg--graa7",
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism4 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism5 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism6 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism7 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card2 = new Card({
    			props: {
    				className: "bg--graa7",
    				$$slots: { content: [create_content_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism8 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Helpers";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Skjult element";
    			t3 = space();
    			create_component(prism0.$$.fragment);
    			t4 = space();
    			h31 = element("h3");
    			h31.textContent = "Position";
    			t6 = space();
    			create_component(prism1.$$.fragment);
    			t7 = space();
    			h32 = element("h3");
    			h32.textContent = "Floats";
    			t9 = space();
    			create_component(card0.$$.fragment);
    			t10 = space();
    			create_component(prism2.$$.fragment);
    			t11 = space();
    			h33 = element("h3");
    			h33.textContent = "Clear";
    			t13 = space();
    			create_component(prism3.$$.fragment);
    			t14 = space();
    			h34 = element("h3");
    			h34.textContent = "Centrér vertikalt";
    			t16 = space();
    			p0 = element("p");
    			p0.textContent = "Kræver en fast bredde på elementet.";
    			t18 = space();
    			create_component(card1.$$.fragment);
    			t19 = space();
    			create_component(prism4.$$.fragment);
    			t20 = space();
    			h35 = element("h3");
    			h35.textContent = "Margin & padding";
    			t22 = space();
    			p1 = element("p");
    			t23 = text("For både ");
    			strong0 = element("strong");
    			strong0.textContent = "margin";
    			t25 = text(" og ");
    			strong1 = element("strong");
    			strong1.textContent = "padding";
    			t27 = text(" klassen har vi fem størrelser\n  ");
    			em0 = element("em");
    			em0.textContent = "(s, m, l, xl og xxl)";
    			t29 = text("\n  og så\n  ");
    			em1 = element("em");
    			em1.textContent = "none";
    			t31 = text(" som sættes på med bindesteg.");
    			t32 = space();
    			create_component(prism5.$$.fragment);
    			t33 = space();
    			p2 = element("p");
    			t34 = text("Ønskes der derimod kun at have ");
    			strong2 = element("strong");
    			strong2.textContent = "margin";
    			t36 = text(" og ");
    			strong3 = element("strong");
    			strong3.textContent = "padding";
    			t38 = text(" i en retning tilføjes dette med double\n  bindestreg.");
    			t39 = space();
    			create_component(prism6.$$.fragment);
    			t40 = space();
    			p3 = element("p");
    			t41 = text("Vi har også to samle klasser for ");
    			em2 = element("em");
    			em2.textContent = "top-bottom";
    			t43 = text(" og ");
    			em3 = element("em");
    			em3.textContent = "right-left";
    			t45 = text(".");
    			t46 = space();
    			create_component(prism7.$$.fragment);
    			t47 = space();
    			h36 = element("h3");
    			h36.textContent = "Box-shadow";
    			t49 = space();
    			create_component(card2.$$.fragment);
    			t50 = space();
    			create_component(prism8.$$.fragment);
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$9, 4, 0, 97);
    			add_location(h30, file$9, 6, 0, 133);
    			add_location(h31, file$9, 12, 0, 225);
    			add_location(h32, file$9, 20, 0, 395);
    			add_location(h33, file$9, 34, 0, 696);
    			add_location(h34, file$9, 40, 0, 778);
    			add_location(p0, file$9, 41, 0, 805);
    			add_location(h35, file$9, 52, 0, 1078);
    			add_location(strong0, file$9, 54, 11, 1119);
    			add_location(strong1, file$9, 54, 38, 1146);
    			add_location(em0, file$9, 55, 2, 1203);
    			add_location(em1, file$9, 57, 2, 1243);
    			add_location(p1, file$9, 53, 0, 1104);
    			add_location(strong2, file$9, 70, 33, 1615);
    			add_location(strong3, file$9, 70, 60, 1642);
    			add_location(p2, file$9, 69, 0, 1578);
    			add_location(em2, file$9, 81, 36, 1982);
    			add_location(em3, file$9, 81, 59, 2005);
    			add_location(p3, file$9, 81, 0, 1946);
    			add_location(h36, file$9, 88, 0, 2165);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t9, anchor);
    			mount_component(card0, target, anchor);
    			insert_dev(target, t10, anchor);
    			mount_component(prism2, target, anchor);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, h33, anchor);
    			insert_dev(target, t13, anchor);
    			mount_component(prism3, target, anchor);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, h34, anchor);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t18, anchor);
    			mount_component(card1, target, anchor);
    			insert_dev(target, t19, anchor);
    			mount_component(prism4, target, anchor);
    			insert_dev(target, t20, anchor);
    			insert_dev(target, h35, anchor);
    			insert_dev(target, t22, anchor);
    			insert_dev(target, p1, anchor);
    			append_dev(p1, t23);
    			append_dev(p1, strong0);
    			append_dev(p1, t25);
    			append_dev(p1, strong1);
    			append_dev(p1, t27);
    			append_dev(p1, em0);
    			append_dev(p1, t29);
    			append_dev(p1, em1);
    			append_dev(p1, t31);
    			insert_dev(target, t32, anchor);
    			mount_component(prism5, target, anchor);
    			insert_dev(target, t33, anchor);
    			insert_dev(target, p2, anchor);
    			append_dev(p2, t34);
    			append_dev(p2, strong2);
    			append_dev(p2, t36);
    			append_dev(p2, strong3);
    			append_dev(p2, t38);
    			insert_dev(target, t39, anchor);
    			mount_component(prism6, target, anchor);
    			insert_dev(target, t40, anchor);
    			insert_dev(target, p3, anchor);
    			append_dev(p3, t41);
    			append_dev(p3, em2);
    			append_dev(p3, t43);
    			append_dev(p3, em3);
    			append_dev(p3, t45);
    			insert_dev(target, t46, anchor);
    			mount_component(prism7, target, anchor);
    			insert_dev(target, t47, anchor);
    			insert_dev(target, h36, anchor);
    			insert_dev(target, t49, anchor);
    			mount_component(card2, target, anchor);
    			insert_dev(target, t50, anchor);
    			mount_component(prism8, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    			const card0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card0_changes.$$scope = { dirty, ctx };
    			}

    			card0.$set(card0_changes);
    			const prism2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism2_changes.$$scope = { dirty, ctx };
    			}

    			prism2.$set(prism2_changes);
    			const prism3_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism3_changes.$$scope = { dirty, ctx };
    			}

    			prism3.$set(prism3_changes);
    			const card1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card1_changes.$$scope = { dirty, ctx };
    			}

    			card1.$set(card1_changes);
    			const prism4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism4_changes.$$scope = { dirty, ctx };
    			}

    			prism4.$set(prism4_changes);
    			const prism5_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism5_changes.$$scope = { dirty, ctx };
    			}

    			prism5.$set(prism5_changes);
    			const prism6_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism6_changes.$$scope = { dirty, ctx };
    			}

    			prism6.$set(prism6_changes);
    			const prism7_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism7_changes.$$scope = { dirty, ctx };
    			}

    			prism7.$set(prism7_changes);
    			const card2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card2_changes.$$scope = { dirty, ctx };
    			}

    			card2.$set(card2_changes);
    			const prism8_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism8_changes.$$scope = { dirty, ctx };
    			}

    			prism8.$set(prism8_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prism0.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(card0.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			transition_in(prism3.$$.fragment, local);
    			transition_in(card1.$$.fragment, local);
    			transition_in(prism4.$$.fragment, local);
    			transition_in(prism5.$$.fragment, local);
    			transition_in(prism6.$$.fragment, local);
    			transition_in(prism7.$$.fragment, local);
    			transition_in(card2.$$.fragment, local);
    			transition_in(prism8.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prism0.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(card0.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			transition_out(prism3.$$.fragment, local);
    			transition_out(card1.$$.fragment, local);
    			transition_out(prism4.$$.fragment, local);
    			transition_out(prism5.$$.fragment, local);
    			transition_out(prism6.$$.fragment, local);
    			transition_out(prism7.$$.fragment, local);
    			transition_out(card2.$$.fragment, local);
    			transition_out(prism8.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t3);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t6);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t9);
    			destroy_component(card0, detaching);
    			if (detaching) detach_dev(t10);
    			destroy_component(prism2, detaching);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(h33);
    			if (detaching) detach_dev(t13);
    			destroy_component(prism3, detaching);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(h34);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t18);
    			destroy_component(card1, detaching);
    			if (detaching) detach_dev(t19);
    			destroy_component(prism4, detaching);
    			if (detaching) detach_dev(t20);
    			if (detaching) detach_dev(h35);
    			if (detaching) detach_dev(t22);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t32);
    			destroy_component(prism5, detaching);
    			if (detaching) detach_dev(t33);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t39);
    			destroy_component(prism6, detaching);
    			if (detaching) detach_dev(t40);
    			if (detaching) detach_dev(p3);
    			if (detaching) detach_dev(t46);
    			destroy_component(prism7, detaching);
    			if (detaching) detach_dev(t47);
    			if (detaching) detach_dev(h36);
    			if (detaching) detach_dev(t49);
    			destroy_component(card2, detaching);
    			if (detaching) detach_dev(t50);
    			destroy_component(prism8, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Helpers', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Helpers> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1, Card });
    	return [];
    }

    class Helpers extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Helpers",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    /* docs_src/utilities/Sizing.svelte generated by Svelte v3.42.6 */
    const file$8 = "docs_src/utilities/Sizing.svelte";

    // (9:0) <Card className="bg--graa7">
    function create_default_slot_3$1(ctx) {
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;
    	let t5;
    	let div3;
    	let t7;
    	let div4;
    	let t9;
    	let div5;
    	let t11;
    	let div6;
    	let t13;
    	let div7;
    	let t15;
    	let div8;
    	let t17;
    	let div9;
    	let t19;
    	let div10;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "width-100vw";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "width-auto";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "width-1of1";
    			t5 = space();
    			div3 = element("div");
    			div3.textContent = "width-5of6";
    			t7 = space();
    			div4 = element("div");
    			div4.textContent = "width-3of4";
    			t9 = space();
    			div5 = element("div");
    			div5.textContent = "width-2of3";
    			t11 = space();
    			div6 = element("div");
    			div6.textContent = "width-1of2";
    			t13 = space();
    			div7 = element("div");
    			div7.textContent = "width-1of3";
    			t15 = space();
    			div8 = element("div");
    			div8.textContent = "width-1of4";
    			t17 = space();
    			div9 = element("div");
    			div9.textContent = "width-1of5";
    			t19 = space();
    			div10 = element("div");
    			div10.textContent = "width-1of6";
    			attr_dev(div0, "class", "bg--eb padding-m width-100vw");
    			add_location(div0, file$8, 9, 2, 181);
    			attr_dev(div1, "class", "bg--eb padding-m width-auto");
    			add_location(div1, file$8, 10, 2, 243);
    			attr_dev(div2, "class", "bg--eb padding-m width-1of1");
    			add_location(div2, file$8, 11, 2, 303);
    			attr_dev(div3, "class", "bg--eb padding-m width-5of6");
    			add_location(div3, file$8, 12, 2, 363);
    			attr_dev(div4, "class", "bg--eb padding-m width-3of4");
    			add_location(div4, file$8, 13, 2, 423);
    			attr_dev(div5, "class", "bg--eb padding-m width-2of3");
    			add_location(div5, file$8, 14, 2, 483);
    			attr_dev(div6, "class", "bg--eb padding-m width-1of2");
    			add_location(div6, file$8, 15, 2, 543);
    			attr_dev(div7, "class", "bg--eb padding-m width-1of3");
    			add_location(div7, file$8, 16, 2, 603);
    			attr_dev(div8, "class", "bg--eb padding-m width-1of4");
    			add_location(div8, file$8, 17, 2, 663);
    			attr_dev(div9, "class", "bg--eb padding-m width-1of5");
    			add_location(div9, file$8, 18, 2, 723);
    			attr_dev(div10, "class", "bg--eb padding-m width-1of6");
    			add_location(div10, file$8, 19, 2, 783);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div2, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div3, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div4, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, div5, anchor);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, div6, anchor);
    			insert_dev(target, t13, anchor);
    			insert_dev(target, div7, anchor);
    			insert_dev(target, t15, anchor);
    			insert_dev(target, div8, anchor);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, div9, anchor);
    			insert_dev(target, t19, anchor);
    			insert_dev(target, div10, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div3);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div4);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(div5);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(div6);
    			if (detaching) detach_dev(t13);
    			if (detaching) detach_dev(div7);
    			if (detaching) detach_dev(t15);
    			if (detaching) detach_dev(div8);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(div9);
    			if (detaching) detach_dev(t19);
    			if (detaching) detach_dev(div10);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(9:0) <Card className=\\\"bg--graa7\\\">",
    		ctx
    	});

    	return block;
    }

    // (23:0) <Prism language="html">
    function create_default_slot_2$3(ctx) {
    	let t_value = `<div class="width-100vw"></div>
<div class="width-auto"></div>
<div class="width-1of1"></div>
<div class="width-5of6"></div>
<div class="width-3of4"></div>
<div class="width-2of3"></div>
<div class="width-1of2"></div>
<div class="width-1of3"></div>
<div class="width-1of4"></div>
<div class="width-1of5"></div>
<div class="width-1of6"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(23:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (39:0) <Card>
    function create_default_slot_1$3(ctx) {
    	let div3;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			div0.textContent = "height-100vh*";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "height-auto";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "height-1of1";
    			attr_dev(div0, "class", "bg--eb padding-m width-1of4 height-100vh");
    			set_style(div0, "display", "inline-block");
    			add_location(div0, file$8, 40, 4, 1345);
    			attr_dev(div1, "class", "bg--eb padding-m width-1of4 height-auto");
    			set_style(div1, "display", "inline-block");
    			add_location(div1, file$8, 41, 4, 1453);
    			attr_dev(div2, "class", "bg--eb padding-m width-1of4 height-1of1");
    			set_style(div2, "display", "inline-block");
    			add_location(div2, file$8, 42, 4, 1558);
    			attr_dev(div3, "class", "text-align--center bg--graa7");
    			set_style(div3, "height", "200px");
    			set_style(div3, "overflow", "hidden");
    			add_location(div3, file$8, 39, 2, 1258);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(39:0) <Card>",
    		ctx
    	});

    	return block;
    }

    // (45:2) 
    function create_footer_slot(ctx) {
    	let div;
    	let p;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			p.textContent = "* Viewport height - Vær opmærksom på at disse opfører sig meget forskelligt på forskellige devices html";
    			attr_dev(p, "class", "fontsize-small");
    			add_location(p, file$8, 45, 4, 1694);
    			attr_dev(div, "slot", "footer");
    			add_location(div, file$8, 44, 2, 1670);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_footer_slot.name,
    		type: "slot",
    		source: "(45:2) ",
    		ctx
    	});

    	return block;
    }

    // (52:0) <Prism language="html">
    function create_default_slot$3(ctx) {
    	let t_value = `<div class="height-100vh"></div>
<div class="height-auto"></div>
<div class="height-1of1"></div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(52:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let h1;
    	let t1;
    	let h30;
    	let t3;
    	let card0;
    	let t4;
    	let prism0;
    	let t5;
    	let h31;
    	let t7;
    	let card1;
    	let t8;
    	let prism1;
    	let current;

    	card0 = new Card({
    			props: {
    				className: "bg--graa7",
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card1 = new Card({
    			props: {
    				$$slots: {
    					footer: [create_footer_slot],
    					default: [create_default_slot_1$3]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Sizing";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Bredder";
    			t3 = space();
    			create_component(card0.$$.fragment);
    			t4 = space();
    			create_component(prism0.$$.fragment);
    			t5 = space();
    			h31 = element("h3");
    			h31.textContent = "Højder";
    			t7 = space();
    			create_component(card1.$$.fragment);
    			t8 = space();
    			create_component(prism1.$$.fragment);
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$8, 4, 0, 97);
    			add_location(h30, file$8, 6, 0, 132);
    			add_location(h31, file$8, 36, 0, 1232);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(card0, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(card1, target, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(prism1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const card0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card0_changes.$$scope = { dirty, ctx };
    			}

    			card0.$set(card0_changes);
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const card1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card1_changes.$$scope = { dirty, ctx };
    			}

    			card1.$set(card1_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card0.$$.fragment, local);
    			transition_in(prism0.$$.fragment, local);
    			transition_in(card1.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card0.$$.fragment, local);
    			transition_out(prism0.$$.fragment, local);
    			transition_out(card1.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t3);
    			destroy_component(card0, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t7);
    			destroy_component(card1, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(prism1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Sizing', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sizing> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1, Card });
    	return [];
    }

    class Sizing extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Sizing",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    /* docs_src/utilities/Text.svelte generated by Svelte v3.42.6 */
    const file$7 = "docs_src/utilities/Text.svelte";

    // (9:0) <Card className="bg--graa7 padding-m">
    function create_default_slot_4(ctx) {
    	let p0;
    	let t1;
    	let p1;
    	let t3;
    	let p2;

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			p0.textContent = "Centreret tekst";
    			t1 = space();
    			p1 = element("p");
    			p1.textContent = "Venstrestillet tekst";
    			t3 = space();
    			p2 = element("p");
    			p2.textContent = "Højrestillet tekst";
    			attr_dev(p0, "class", "text-align--center");
    			add_location(p0, file$7, 9, 2, 196);
    			attr_dev(p1, "class", "text-align--left");
    			add_location(p1, file$7, 10, 2, 248);
    			attr_dev(p2, "class", "text-align--right");
    			add_location(p2, file$7, 11, 2, 303);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p2, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(9:0) <Card className=\\\"bg--graa7 padding-m\\\">",
    		ctx
    	});

    	return block;
    }

    // (15:0) <Prism language="html">
    function create_default_slot_3(ctx) {
    	let t_value = `<p class="text-align--center"></p>
<p class="text-align--left"></p>
<p class="text-align--right"></p>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(15:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (23:0) <Card className="bg--graa7 padding-m">
    function create_default_slot_2$2(ctx) {
    	let p0;
    	let t1;
    	let p1;

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			p0.textContent = "SMÅ BOGSTAVER";
    			t1 = space();
    			p1 = element("p");
    			p1.textContent = "store bogstaver";
    			attr_dev(p0, "class", "text-transform--lowercase");
    			add_location(p0, file$7, 23, 2, 572);
    			attr_dev(p1, "class", "text-transform--uppercase");
    			add_location(p1, file$7, 24, 2, 629);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(23:0) <Card className=\\\"bg--graa7 padding-m\\\">",
    		ctx
    	});

    	return block;
    }

    // (28:0) <Prism language="html">
    function create_default_slot_1$2(ctx) {
    	let t_value = `<p class="text-transform--lowercase"></p>
<p class="text-transform--uppercase"></p>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(28:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    // (36:2) 
    function create_content_slot(ctx) {
    	let div2;
    	let div0;
    	let p0;
    	let t1;
    	let p1;
    	let t3;
    	let p2;
    	let t5;
    	let div1;
    	let p3;
    	let t7;
    	let p4;
    	let t9;
    	let p5;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			p0 = element("p");
    			p0.textContent = "normal line-height";
    			t1 = space();
    			p1 = element("p");
    			p1.textContent = "normal line-height";
    			t3 = space();
    			p2 = element("p");
    			p2.textContent = "normal line-height";
    			t5 = space();
    			div1 = element("div");
    			p3 = element("p");
    			p3.textContent = "lineheight-m";
    			t7 = space();
    			p4 = element("p");
    			p4.textContent = "lineheight-m";
    			t9 = space();
    			p5 = element("p");
    			p5.textContent = "lineheight-m";
    			add_location(p0, file$7, 37, 6, 1046);
    			add_location(p1, file$7, 38, 6, 1078);
    			add_location(p2, file$7, 39, 6, 1110);
    			attr_dev(div0, "class", "width-1of3 margin-m");
    			add_location(div0, file$7, 36, 4, 1006);
    			add_location(p3, file$7, 42, 6, 1204);
    			add_location(p4, file$7, 43, 6, 1230);
    			add_location(p5, file$7, 44, 6, 1256);
    			attr_dev(div1, "class", "width-1of3 margin-m lineheight-m");
    			add_location(div1, file$7, 41, 4, 1151);
    			attr_dev(div2, "class", "flex flex-justify--between");
    			attr_dev(div2, "slot", "content");
    			add_location(div2, file$7, 35, 2, 946);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, p0);
    			append_dev(div0, t1);
    			append_dev(div0, p1);
    			append_dev(div0, t3);
    			append_dev(div0, p2);
    			append_dev(div2, t5);
    			append_dev(div2, div1);
    			append_dev(div1, p3);
    			append_dev(div1, t7);
    			append_dev(div1, p4);
    			append_dev(div1, t9);
    			append_dev(div1, p5);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot.name,
    		type: "slot",
    		source: "(36:2) ",
    		ctx
    	});

    	return block;
    }

    // (50:0) <Prism language="html">
    function create_default_slot$2(ctx) {
    	let t_value = `<div class="lineheight-m">
  <p>line-height: 1.5em</p>
</div>` + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(50:0) <Prism language=\\\"html\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let h1;
    	let t1;
    	let h30;
    	let t3;
    	let card0;
    	let t4;
    	let prism0;
    	let t5;
    	let h31;
    	let t7;
    	let card1;
    	let t8;
    	let prism1;
    	let t9;
    	let h32;
    	let t11;
    	let p;
    	let t13;
    	let card2;
    	let t14;
    	let prism2;
    	let current;

    	card0 = new Card({
    			props: {
    				className: "bg--graa7 padding-m",
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism0 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card1 = new Card({
    			props: {
    				className: "bg--graa7 padding-m",
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism1 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card2 = new Card({
    			props: {
    				className: "bg--graa7",
    				$$slots: { content: [create_content_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	prism2 = new Prism$1({
    			props: {
    				language: "html",
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Text";
    			t1 = space();
    			h30 = element("h3");
    			h30.textContent = "Text alignment";
    			t3 = space();
    			create_component(card0.$$.fragment);
    			t4 = space();
    			create_component(prism0.$$.fragment);
    			t5 = space();
    			h31 = element("h3");
    			h31.textContent = "Text transform";
    			t7 = space();
    			create_component(card1.$$.fragment);
    			t8 = space();
    			create_component(prism1.$$.fragment);
    			t9 = space();
    			h32 = element("h3");
    			h32.textContent = "Line height";
    			t11 = space();
    			p = element("p");
    			p.textContent = "Default line-height will be based on the browser usually around 1.2";
    			t13 = space();
    			create_component(card2.$$.fragment);
    			t14 = space();
    			create_component(prism2.$$.fragment);
    			attr_dev(h1, "class", "color--eb");
    			add_location(h1, file$7, 4, 0, 97);
    			add_location(h30, file$7, 6, 0, 130);
    			add_location(h31, file$7, 20, 0, 506);
    			add_location(h32, file$7, 32, 0, 819);
    			add_location(p, file$7, 33, 0, 840);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h30, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(card0, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(prism0, target, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, h31, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(card1, target, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(prism1, target, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, h32, anchor);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, p, anchor);
    			insert_dev(target, t13, anchor);
    			mount_component(card2, target, anchor);
    			insert_dev(target, t14, anchor);
    			mount_component(prism2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const card0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card0_changes.$$scope = { dirty, ctx };
    			}

    			card0.$set(card0_changes);
    			const prism0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism0_changes.$$scope = { dirty, ctx };
    			}

    			prism0.$set(prism0_changes);
    			const card1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card1_changes.$$scope = { dirty, ctx };
    			}

    			card1.$set(card1_changes);
    			const prism1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism1_changes.$$scope = { dirty, ctx };
    			}

    			prism1.$set(prism1_changes);
    			const card2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				card2_changes.$$scope = { dirty, ctx };
    			}

    			card2.$set(card2_changes);
    			const prism2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				prism2_changes.$$scope = { dirty, ctx };
    			}

    			prism2.$set(prism2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card0.$$.fragment, local);
    			transition_in(prism0.$$.fragment, local);
    			transition_in(card1.$$.fragment, local);
    			transition_in(prism1.$$.fragment, local);
    			transition_in(card2.$$.fragment, local);
    			transition_in(prism2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card0.$$.fragment, local);
    			transition_out(prism0.$$.fragment, local);
    			transition_out(card1.$$.fragment, local);
    			transition_out(prism1.$$.fragment, local);
    			transition_out(card2.$$.fragment, local);
    			transition_out(prism2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h30);
    			if (detaching) detach_dev(t3);
    			destroy_component(card0, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(prism0, detaching);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(h31);
    			if (detaching) detach_dev(t7);
    			destroy_component(card1, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(prism1, detaching);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(h32);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t13);
    			destroy_component(card2, detaching);
    			if (detaching) detach_dev(t14);
    			destroy_component(prism2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Prism: Prism$1, Card });
    	return [];
    }

    class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    const utilities = {
        href: '/utilities',
        routes: [
            { disabled: false, href: '/utilities/animation', title: 'Animation', group: 'utilities', component: Animation },
            { disabled: false, href: '/utilities/border', title: 'Border', group: 'utilities', component: Border },
            { disabled: false, href: '/utilities/color', title: 'Color', group: 'utilities', component: Color },
            { disabled: false, href: '/utilities/flex', title: 'Flex', group: 'utilities', component: Flex },
            { disabled: false, href: '/utilities/fonts', title: 'Fonts', group: 'utilities', component: Fonts },
            { disabled: false, href: '/utilities/grid', title: 'Grid', group: 'utilities', component: Grid },
            { disabled: false, href: '/utilities/helpers', title: 'Helpers', group: 'utilities', component: Helpers },
            { disabled: false, href: '/utilities/sizing', title: 'Sizing', group: 'utilities', component: Sizing },
            { disabled: false, href: '/utilities/text', title: 'Text', group: 'utilities', component: Text },
        ],
        title: 'Utilities',
    };

    /* docs_src/main/Home.svelte generated by Svelte v3.42.6 */
    const file$6 = "docs_src/main/Home.svelte";

    // (18:8) <Card className="padding-m" url={componentsLink}>
    function create_default_slot_2$1(ctx) {
    	let div;
    	let h2;
    	let t1;
    	let i;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h2 = element("h2");
    			h2.textContent = "Components";
    			t1 = space();
    			i = element("i");
    			attr_dev(h2, "class", "color--graa1");
    			add_location(h2, file$6, 19, 12, 801);
    			attr_dev(i, "class", "home-section-icon fas fa-cubes svelte-pq6zsy");
    			add_location(i, file$6, 20, 12, 854);
    			attr_dev(div, "class", "flex-item flex-item--center text-align--center");
    			add_location(div, file$6, 18, 10, 728);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h2);
    			append_dev(div, t1);
    			append_dev(div, i);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(18:8) <Card className=\\\"padding-m\\\" url={componentsLink}>",
    		ctx
    	});

    	return block;
    }

    // (26:8) <Card className="padding-m" url={utilityLink}>
    function create_default_slot_1$1(ctx) {
    	let div;
    	let h2;
    	let t1;
    	let i;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h2 = element("h2");
    			h2.textContent = "Utilities";
    			t1 = space();
    			i = element("i");
    			attr_dev(h2, "class", "color--graa1");
    			add_location(h2, file$6, 27, 12, 1136);
    			attr_dev(i, "class", "home-section-icon fab fa-connectdevelop svelte-pq6zsy");
    			add_location(i, file$6, 28, 12, 1188);
    			attr_dev(div, "class", "flex-item flex-item--center text-align--center");
    			add_location(div, file$6, 26, 10, 1063);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h2);
    			append_dev(div, t1);
    			append_dev(div, i);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(26:8) <Card className=\\\"padding-m\\\" url={utilityLink}>",
    		ctx
    	});

    	return block;
    }

    // (34:8) <Card className="padding-m" url={guidelineLink}>
    function create_default_slot$1(ctx) {
    	let div;
    	let h2;
    	let t1;
    	let i;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h2 = element("h2");
    			h2.textContent = "Guidelines";
    			t1 = space();
    			i = element("i");
    			attr_dev(h2, "class", "color--graa1");
    			add_location(h2, file$6, 35, 12, 1481);
    			attr_dev(i, "class", "home-section-icon fas fa-quran svelte-pq6zsy");
    			add_location(i, file$6, 36, 12, 1534);
    			attr_dev(div, "class", "flex-item flex-item--center text-align--center");
    			add_location(div, file$6, 34, 10, 1408);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h2);
    			append_dev(div, t1);
    			append_dev(div, i);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(34:8) <Card className=\\\"padding-m\\\" url={guidelineLink}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let div8;
    	let div7;
    	let div0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div1;
    	let h1;
    	let t2;
    	let div2;
    	let t4;
    	let div6;
    	let div3;
    	let card0;
    	let t5;
    	let div4;
    	let card1;
    	let t6;
    	let div5;
    	let card2;
    	let current;

    	card0 = new Card({
    			props: {
    				className: "padding-m",
    				url: /*componentsLink*/ ctx[0],
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card1 = new Card({
    			props: {
    				className: "padding-m",
    				url: /*utilityLink*/ ctx[1],
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	card2 = new Card({
    			props: {
    				className: "padding-m",
    				url: /*guidelineLink*/ ctx[2],
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div7 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div1 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Design system";
    			t2 = space();
    			div2 = element("div");
    			div2.textContent = "yarn add @ekstra-bladet/designsystem";
    			t4 = space();
    			div6 = element("div");
    			div3 = element("div");
    			create_component(card0.$$.fragment);
    			t5 = space();
    			div4 = element("div");
    			create_component(card1.$$.fragment);
    			t6 = space();
    			div5 = element("div");
    			create_component(card2.$$.fragment);
    			attr_dev(img, "alt", "");
    			if (!src_url_equal(img.src, img_src_value = "ekstrabladet.svg")) attr_dev(img, "src", img_src_value);
    			set_style(img, "height", "70px");
    			add_location(img, file$6, 9, 6, 305);
    			attr_dev(div0, "class", "flex flex-justify--center");
    			add_location(div0, file$6, 8, 4, 259);
    			add_location(h1, file$6, 12, 6, 438);
    			attr_dev(div1, "class", "flex flex-justify--center margin-l--b");
    			add_location(div1, file$6, 11, 4, 379);
    			attr_dev(div2, "class", "text-align--center margin-m--tb padding-m bg--graa7");
    			add_location(div2, file$6, 14, 4, 476);
    			attr_dev(div3, "class", "home-section width-1of1 margin-m svelte-pq6zsy");
    			add_location(div3, file$6, 16, 6, 613);
    			attr_dev(div4, "class", "home-section width-1of1 margin-m svelte-pq6zsy");
    			add_location(div4, file$6, 24, 6, 951);
    			attr_dev(div5, "class", "home-section width-1of1 margin-m svelte-pq6zsy");
    			add_location(div5, file$6, 32, 6, 1294);
    			attr_dev(div6, "class", "flex");
    			add_location(div6, file$6, 15, 4, 588);
    			attr_dev(div7, "class", "grid-width--medium");
    			add_location(div7, file$6, 7, 2, 222);
    			attr_dev(div8, "class", "flex flex-justify--around width-1of1");
    			add_location(div8, file$6, 6, 0, 169);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div7);
    			append_dev(div7, div0);
    			append_dev(div0, img);
    			append_dev(div7, t0);
    			append_dev(div7, div1);
    			append_dev(div1, h1);
    			append_dev(div7, t2);
    			append_dev(div7, div2);
    			append_dev(div7, t4);
    			append_dev(div7, div6);
    			append_dev(div6, div3);
    			mount_component(card0, div3, null);
    			append_dev(div6, t5);
    			append_dev(div6, div4);
    			mount_component(card1, div4, null);
    			append_dev(div6, t6);
    			append_dev(div6, div5);
    			mount_component(card2, div5, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const card0_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				card0_changes.$$scope = { dirty, ctx };
    			}

    			card0.$set(card0_changes);
    			const card1_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				card1_changes.$$scope = { dirty, ctx };
    			}

    			card1.$set(card1_changes);
    			const card2_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				card2_changes.$$scope = { dirty, ctx };
    			}

    			card2.$set(card2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card0.$$.fragment, local);
    			transition_in(card1.$$.fragment, local);
    			transition_in(card2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card0.$$.fragment, local);
    			transition_out(card1.$$.fragment, local);
    			transition_out(card2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			destroy_component(card0);
    			destroy_component(card1);
    			destroy_component(card2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Home', slots, []);
    	let componentsLink = '#/components';
    	let utilityLink = '#/utilities';
    	let guidelineLink = '#/guidelines';
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Card,
    		componentsLink,
    		utilityLink,
    		guidelineLink
    	});

    	$$self.$inject_state = $$props => {
    		if ('componentsLink' in $$props) $$invalidate(0, componentsLink = $$props.componentsLink);
    		if ('utilityLink' in $$props) $$invalidate(1, utilityLink = $$props.utilityLink);
    		if ('guidelineLink' in $$props) $$invalidate(2, guidelineLink = $$props.guidelineLink);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [componentsLink, utilityLink, guidelineLink];
    }

    class Home$3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* docs_src/components/Home.svelte generated by Svelte v3.42.6 */
    const file$5 = "docs_src/components/Home.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[0] = list[i];
    	return child_ctx;
    }

    // (12:2) {#each components.routes as route}
    function create_each_block$3(ctx) {
    	let li;
    	let a;
    	let t_value = /*route*/ ctx[0].title + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "href", "#a11y");
    			add_location(a, file$5, 12, 8, 340);
    			add_location(li, file$5, 12, 4, 336);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, t);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a, {
    					disabled: false,
    					href: /*route*/ ctx[0].href
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(12:2) {#each components.routes as route}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let h1;
    	let t1;
    	let div;
    	let p;
    	let t3;
    	let ul;
    	let each_value = components.routes;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Components";
    			t1 = space();
    			div = element("div");
    			p = element("p");
    			p.textContent = "Components mainly consists of svelte components, but must can be used as straight HTML components";
    			t3 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h1, file$5, 4, 0, 122);
    			add_location(p, file$5, 7, 2, 177);
    			attr_dev(div, "class", "grid-width--small");
    			add_location(div, file$5, 6, 0, 143);
    			add_location(ul, file$5, 10, 0, 290);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*components*/ 0) {
    				each_value = components.routes;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Home', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ link, components });
    	return [];
    }

    class Home$2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    /* docs_src/utilities/Home.svelte generated by Svelte v3.42.6 */
    const file$4 = "docs_src/utilities/Home.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[0] = list[i];
    	return child_ctx;
    }

    // (14:2) {#each utilities.routes as route}
    function create_each_block$2(ctx) {
    	let li;
    	let a;
    	let t_value = /*route*/ ctx[0].title + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "href", "#a11y");
    			add_location(a, file$4, 14, 8, 284);
    			add_location(li, file$4, 14, 4, 280);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, t);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a, {
    					disabled: false,
    					href: /*route*/ ctx[0].href
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(14:2) {#each utilities.routes as route}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let h1;
    	let t1;
    	let div;
    	let p;
    	let t3;
    	let ul;
    	let each_value = utilities.routes;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Utilities";
    			t1 = space();
    			div = element("div");
    			p = element("p");
    			p.textContent = "Utilities exposed from Ekstra Bladet designsystem";
    			t3 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h1, file$4, 6, 0, 116);
    			add_location(p, file$4, 9, 2, 170);
    			attr_dev(div, "class", "grid-width--small");
    			add_location(div, file$4, 8, 0, 136);
    			add_location(ul, file$4, 12, 0, 235);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*utilities*/ 0) {
    				each_value = utilities.routes;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Home', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ link, utilities });
    	return [];
    }

    class Home$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* docs_src/guidelines/Home.svelte generated by Svelte v3.42.6 */
    const file$3 = "docs_src/guidelines/Home.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[0] = list[i];
    	return child_ctx;
    }

    // (14:2) {#each guidelines.routes as route}
    function create_each_block$1(ctx) {
    	let li;
    	let a;
    	let t_value = /*route*/ ctx[0].title + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "href", "#a11y");
    			add_location(a, file$3, 14, 8, 373);
    			add_location(li, file$3, 14, 4, 369);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, t);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a, {
    					disabled: false,
    					href: /*route*/ ctx[0].href
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(14:2) {#each guidelines.routes as route}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let h1;
    	let t1;
    	let div;
    	let p;
    	let t3;
    	let ul;
    	let each_value = guidelines.routes;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Guidelines";
    			t1 = space();
    			div = element("div");
    			p = element("p");
    			p.textContent = "Guidelines on how to implements languages or frameworks when working with frontend code in the context of Ekstra\n    Bladet";
    			t3 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h1, file$3, 4, 0, 122);
    			add_location(p, file$3, 7, 2, 177);
    			attr_dev(div, "class", "grid-width--small");
    			add_location(div, file$3, 6, 0, 143);
    			add_location(ul, file$3, 12, 0, 323);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*guidelines*/ 0) {
    				each_value = guidelines.routes;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Home', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ link, guidelines });
    	return [];
    }

    class Home extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    // Fills the object to create a SPA routing
    let spaRoutes = {
        '/': Home$3,
        [components.href]: Home$2,
        [utilities.href]: Home$1,
        [guidelines.href]: Home,
    };
    [...components.routes, ...utilities.routes, ...guidelines.routes].forEach((route) => {
        spaRoutes[route.href] = route.component;
    });
    const routes = spaRoutes;
    const menuItems = [components, utilities, guidelines];

    /* docs_src/main/Sidebar.svelte generated by Svelte v3.42.6 */
    const file$2 = "docs_src/main/Sidebar.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (37:8) {#each group.routes as menuItem}
    function create_each_block_1(ctx) {
    	let a;
    	let t0_value = /*menuItem*/ ctx[4].title + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(a, "class", "sidebar-item width-1of1 padding-m--t padding-m--rl svelte-2rfg6s");
    			attr_dev(a, "href", "#a11y");
    			toggle_class(a, "active-item", /*menuItem*/ ctx[4].href === /*$location*/ ctx[0]);
    			add_location(a, file$2, 37, 10, 1308);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t0);
    			append_dev(a, t1);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a, {
    					disabled: /*menuItem*/ ctx[4].disabled,
    					href: /*menuItem*/ ctx[4].href
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*menuItems, $location*/ 1) {
    				toggle_class(a, "active-item", /*menuItem*/ ctx[4].href === /*$location*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(37:8) {#each group.routes as menuItem}",
    		ctx
    	});

    	return block;
    }

    // (28:2) {#each menuItems as group}
    function create_each_block(ctx) {
    	let div2;
    	let div0;
    	let a;
    	let t0_value = /*group*/ ctx[1].title + "";
    	let t0;
    	let t1;
    	let div1;
    	let t2;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*group*/ ctx[1].routes;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			attr_dev(a, "href", "#a11y");
    			attr_dev(a, "class", "svelte-2rfg6s");
    			toggle_class(a, "active-item", /*group*/ ctx[1].href === /*$location*/ ctx[0]);
    			add_location(a, file$2, 30, 8, 1053);
    			attr_dev(div0, "class", "sidebar-submenu-title fontsize-small svelte-2rfg6s");
    			add_location(div0, file$2, 29, 6, 994);
    			attr_dev(div1, "class", "sidebar-submenu-items");
    			add_location(div1, file$2, 35, 6, 1221);
    			attr_dev(div2, "class", "sidebar-menuitem-container padding-l svelte-2rfg6s");
    			add_location(div2, file$2, 28, 4, 937);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, a);
    			append_dev(a, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div2, t2);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a, {
    					disabled: false,
    					href: /*group*/ ctx[1].href
    				}));

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*menuItems, $location*/ 1) {
    				toggle_class(a, "active-item", /*group*/ ctx[1].href === /*$location*/ ctx[0]);
    			}

    			if (dirty & /*menuItems, $location*/ 1) {
    				each_value_1 = /*group*/ ctx[1].routes;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(28:2) {#each menuItems as group}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let div5;
    	let div2;
    	let div0;
    	let a0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div1;
    	let p;
    	let t2;
    	let div4;
    	let div3;
    	let a1;
    	let t4;
    	let mounted;
    	let dispose;
    	let each_value = menuItems;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			a0 = element("a");
    			img = element("img");
    			t0 = space();
    			div1 = element("div");
    			p = element("p");
    			p.textContent = "Design system";
    			t2 = space();
    			div4 = element("div");
    			div3 = element("div");
    			a1 = element("a");
    			a1.textContent = "Overview";
    			t4 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(img, "alt", "");
    			if (!src_url_equal(img.src, img_src_value = "ekstrabladet.svg")) attr_dev(img, "src", img_src_value);
    			set_style(img, "height", "70px");
    			add_location(img, file$2, 8, 8, 329);
    			attr_dev(a0, "href", "#/");
    			attr_dev(a0, "class", "svelte-2rfg6s");
    			add_location(a0, file$2, 7, 6, 307);
    			add_location(div0, file$2, 6, 4, 295);
    			attr_dev(p, "class", "flex--grow width-1of1 color--graa1 fontweight-bold");
    			add_location(p, file$2, 12, 6, 462);
    			attr_dev(div1, "class", "flex-item flex-item--center");
    			add_location(div1, file$2, 11, 4, 414);
    			attr_dev(div2, "class", "flex flex-justify--around sidebar-logo-container padding-m--rl svelte-2rfg6s");
    			add_location(div2, file$2, 5, 2, 214);
    			attr_dev(a1, "class", "sidebar-item width-1of1 padding-m--t padding-m--rl svelte-2rfg6s");
    			attr_dev(a1, "href", "#a11y");
    			toggle_class(a1, "active-item", '/' === /*$location*/ ctx[0]);
    			add_location(a1, file$2, 17, 6, 661);
    			attr_dev(div3, "class", "sidebar-submenu-items");
    			add_location(div3, file$2, 16, 4, 619);
    			attr_dev(div4, "class", "sidebar-menuitem-container padding-l svelte-2rfg6s");
    			add_location(div4, file$2, 15, 2, 564);
    			attr_dev(div5, "id", "sidebar-menu");
    			attr_dev(div5, "class", "sidebar-container height-100vh bg--white margin-l--r svelte-2rfg6s");
    			add_location(div5, file$2, 4, 0, 127);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div2);
    			append_dev(div2, div0);
    			append_dev(div0, a0);
    			append_dev(a0, img);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, p);
    			append_dev(div5, t2);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, a1);
    			append_dev(div5, t4);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div5, null);
    			}

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a1, { disabled: false, href: '/' }));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$location*/ 1) {
    				toggle_class(a1, "active-item", '/' === /*$location*/ ctx[0]);
    			}

    			if (dirty & /*menuItems, $location*/ 1) {
    				each_value = menuItems;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div5, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $location;
    	validate_store(location, 'location');
    	component_subscribe($$self, location, $$value => $$invalidate(0, $location = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Sidebar', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sidebar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ link, location, menuItems, $location });
    	return [$location];
    }

    class Sidebar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Sidebar",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* docs_src/main/Navbar.svelte generated by Svelte v3.42.6 */
    const file$1 = "docs_src/main/Navbar.svelte";

    // (14:6) <Button size="small" initial={$sourceType === 'svelte'} on:click={() => changeSourceType('svelte')}>
    function create_default_slot_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Svelte");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(14:6) <Button size=\\\"small\\\" initial={$sourceType === 'svelte'} on:click={() => changeSourceType('svelte')}>",
    		ctx
    	});

    	return block;
    }

    // (16:6) <Button size="small" initial={$sourceType === 'html'} on:click={() => changeSourceType('html')}>
    function create_default_slot_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("HTML");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(16:6) <Button size=\\\"small\\\" initial={$sourceType === 'html'} on:click={() => changeSourceType('html')}>",
    		ctx
    	});

    	return block;
    }

    // (13:4) <ButtonGroup type="secondary">
    function create_default_slot(ctx) {
    	let button0;
    	let t;
    	let button1;
    	let current;

    	button0 = new Button({
    			props: {
    				size: "small",
    				initial: /*$sourceType*/ ctx[0] === 'svelte',
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler*/ ctx[2]);

    	button1 = new Button({
    			props: {
    				size: "small",
    				initial: /*$sourceType*/ ctx[0] === 'html',
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_1*/ ctx[3]);

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t = space();
    			create_component(button1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(button1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};
    			if (dirty & /*$sourceType*/ 1) button0_changes.initial = /*$sourceType*/ ctx[0] === 'svelte';

    			if (dirty & /*$$scope*/ 16) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};
    			if (dirty & /*$sourceType*/ 1) button1_changes.initial = /*$sourceType*/ ctx[0] === 'html';

    			if (dirty & /*$$scope*/ 16) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(button1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(13:4) <ButtonGroup type=\\\"secondary\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let div;
    	let nav;
    	let a;
    	let i;
    	let t0;
    	let t1;
    	let buttongroup;
    	let current;

    	buttongroup = new ButtonGroup({
    			props: {
    				type: "secondary",
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			nav = element("nav");
    			a = element("a");
    			i = element("i");
    			t0 = text("Github");
    			t1 = space();
    			create_component(buttongroup.$$.fragment);
    			attr_dev(i, "class", "fab fa-github margin-s--r");
    			add_location(i, file$1, 10, 7, 443);
    			attr_dev(a, "href", "https://github.com/EkstraBladetUdvikling/eb-designsystem");
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "class", "flex svelte-1offyji");
    			add_location(a, file$1, 9, 4, 340);
    			attr_dev(nav, "class", "navmenu flex flex-justify--between flex-align--center padding-xl--rl svelte-1offyji");
    			add_location(nav, file$1, 8, 2, 253);
    			attr_dev(div, "class", "navmenu-container position-fixed margin-xl--b bg-red svelte-1offyji");
    			add_location(div, file$1, 7, 0, 184);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, nav);
    			append_dev(nav, a);
    			append_dev(a, i);
    			append_dev(a, t0);
    			append_dev(nav, t1);
    			mount_component(buttongroup, nav, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const buttongroup_changes = {};

    			if (dirty & /*$$scope, $sourceType*/ 17) {
    				buttongroup_changes.$$scope = { dirty, ctx };
    			}

    			buttongroup.$set(buttongroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(buttongroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(buttongroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(buttongroup);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $sourceType;
    	validate_store(sourceType, 'sourceType');
    	component_subscribe($$self, sourceType, $$value => $$invalidate(0, $sourceType = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Navbar', slots, []);

    	function changeSourceType(source) {
    		sourceType.set(source);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Navbar> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => changeSourceType('svelte');
    	const click_handler_1 = () => changeSourceType('html');

    	$$self.$capture_state = () => ({
    		Button,
    		ButtonGroup,
    		sourceType,
    		changeSourceType,
    		$sourceType
    	});

    	return [$sourceType, changeSourceType, click_handler, click_handler_1];
    }

    class Navbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navbar",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* docs_src/App.svelte generated by Svelte v3.42.6 */
    const file = "docs_src/App.svelte";

    function create_fragment(ctx) {
    	let navbar;
    	let t0;
    	let sidebar;
    	let t1;
    	let div;
    	let router;
    	let current;
    	navbar = new Navbar({ $$inline: true });
    	sidebar = new Sidebar({ $$inline: true });
    	router = new Router({ props: { routes }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			create_component(sidebar.$$.fragment);
    			t1 = space();
    			div = element("div");
    			create_component(router.$$.fragment);
    			attr_dev(div, "class", "content-container padding-xl svelte-ftylog");
    			add_location(div, file, 9, 0, 258);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(sidebar, target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(router, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(sidebar.$$.fragment, local);
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(sidebar.$$.fragment, local);
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(sidebar, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(router);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Router, routes, Sidebar, Navbar });
    	return [];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
        target: document.body,
        props: {
            name: 'world',
        },
    });

    return app;

}());
